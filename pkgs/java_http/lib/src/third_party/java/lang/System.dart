// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../io/InputStream.dart" as inputstream_;

/// from: java.lang.System
class System extends jni.JObject {
  @override
  late final jni.JObjType<System> $type = type;

  System.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class = jni.Jni.findJClass(r"java/lang/System");

  /// The type which includes information such as the signature of this class.
  static const type = $SystemType();
  static final _id_in0 = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"in",
    r"Ljava/io/InputStream;",
  );

  /// from: static public final java.io.InputStream in
  /// The returned object must be deleted after use, by calling the `delete` method.
  static inputstream_.InputStream get in0 =>
      const inputstream_.$InputStreamType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_in0, jni.JniCallType.objectType)
          .object);

  static final _id_out = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"out",
    r"Ljava/io/PrintStream;",
  );

  /// from: static public final java.io.PrintStream out
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject get out =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_out, jni.JniCallType.objectType)
          .object);

  static final _id_err = jni.Jni.accessors.getStaticFieldIDOf(
    _class.reference,
    r"err",
    r"Ljava/io/PrintStream;",
  );

  /// from: static public final java.io.PrintStream err
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject get err =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getStaticField(_class.reference, _id_err, jni.JniCallType.objectType)
          .object);

  static final _id_setIn = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"setIn", r"(Ljava/io/InputStream;)V");

  /// from: static public void setIn(java.io.InputStream inputStream)
  static void setIn(
    inputstream_.InputStream inputStream,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_setIn, jni.JniCallType.voidType, [inputStream.reference]).check();
  }

  static final _id_setOut = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"setOut", r"(Ljava/io/PrintStream;)V");

  /// from: static public void setOut(java.io.PrintStream printStream)
  static void setOut(
    jni.JObject printStream,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_setOut, jni.JniCallType.voidType, [printStream.reference]).check();
  }

  static final _id_setErr = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"setErr", r"(Ljava/io/PrintStream;)V");

  /// from: static public void setErr(java.io.PrintStream printStream)
  static void setErr(
    jni.JObject printStream,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_setErr, jni.JniCallType.voidType, [printStream.reference]).check();
  }

  static final _id_console = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"console", r"()Ljava/io/Console;");

  /// from: static public java.io.Console console()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject console() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_console,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_inheritedChannel = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"inheritedChannel", r"()Ljava/nio/channels/Channel;");

  /// from: static public java.nio.channels.Channel inheritedChannel()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject inheritedChannel() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_inheritedChannel,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_setSecurityManager = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"setSecurityManager",
      r"(Ljava/lang/SecurityManager;)V");

  /// from: static public void setSecurityManager(java.lang.SecurityManager securityManager)
  static void setSecurityManager(
    jni.JObject securityManager,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_setSecurityManager,
        jni.JniCallType.voidType,
        [securityManager.reference]).check();
  }

  static final _id_getSecurityManager = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"getSecurityManager",
      r"()Ljava/lang/SecurityManager;");

  /// from: static public java.lang.SecurityManager getSecurityManager()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject getSecurityManager() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getSecurityManager,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_currentTimeMillis = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"currentTimeMillis", r"()J");

  /// from: static public native long currentTimeMillis()
  static int currentTimeMillis() {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_currentTimeMillis, jni.JniCallType.longType, []).long;
  }

  static final _id_nanoTime = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"nanoTime", r"()J");

  /// from: static public native long nanoTime()
  static int nanoTime() {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference, _id_nanoTime, jni.JniCallType.longType, []).long;
  }

  static final _id_arraycopy = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"arraycopy",
      r"(Ljava/lang/Object;ILjava/lang/Object;II)V");

  /// from: static public native void arraycopy(java.lang.Object object, int i, java.lang.Object object1, int i1, int i2)
  static void arraycopy(
    jni.JObject object,
    int i,
    jni.JObject object1,
    int i1,
    int i2,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference, _id_arraycopy, jni.JniCallType.voidType, [
      object.reference,
      jni.JValueInt(i),
      object1.reference,
      jni.JValueInt(i1),
      jni.JValueInt(i2)
    ]).check();
  }

  static final _id_identityHashCode = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"identityHashCode", r"(Ljava/lang/Object;)I");

  /// from: static public native int identityHashCode(java.lang.Object object)
  static int identityHashCode(
    jni.JObject object,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_identityHashCode,
        jni.JniCallType.intType,
        [object.reference]).integer;
  }

  static final _id_getProperties = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"getProperties", r"()Ljava/util/Properties;");

  /// from: static public java.util.Properties getProperties()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject getProperties() {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getProperties,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_lineSeparator = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"lineSeparator", r"()Ljava/lang/String;");

  /// from: static public java.lang.String lineSeparator()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString lineSeparator() {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_lineSeparator,
            jni.JniCallType.objectType, []).object);
  }

  static final _id_setProperties = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"setProperties", r"(Ljava/util/Properties;)V");

  /// from: static public void setProperties(java.util.Properties properties)
  static void setProperties(
    jni.JObject properties,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_setProperties,
        jni.JniCallType.voidType,
        [properties.reference]).check();
  }

  static final _id_getProperty = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"getProperty",
      r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getProperty(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString getProperty(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getProperty,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_getProperty1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"getProperty",
      r"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getProperty(java.lang.String string, java.lang.String string1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString getProperty1(
    jni.JString string,
    jni.JString string1,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_getProperty1,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_setProperty = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"setProperty",
      r"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String setProperty(java.lang.String string, java.lang.String string1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString setProperty(
    jni.JString string,
    jni.JString string1,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_setProperty,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);
  }

  static final _id_clearProperty = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"clearProperty",
      r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String clearProperty(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString clearProperty(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_clearProperty,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_getenv = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"getenv", r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public java.lang.String getenv(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString getenv(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getenv,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_getenv1 = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"getenv", r"()Ljava/util/Map;");

  /// from: static public java.util.Map getenv()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JMap<jni.JString, jni.JString> getenv1() {
    return const jni.JMapType(jni.JStringType(), jni.JStringType()).fromRef(
        jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
            _id_getenv1, jni.JniCallType.objectType, []).object);
  }

  static final _id_getLogger = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"getLogger",
      r"(Ljava/lang/String;)Ljava/lang/System$Logger;");

  /// from: static public java.lang.System$Logger getLogger(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject getLogger(
    jni.JString string,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_getLogger,
            jni.JniCallType.objectType, [string.reference]).object);
  }

  static final _id_getLogger1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"getLogger",
      r"(Ljava/lang/String;Ljava/util/ResourceBundle;)Ljava/lang/System$Logger;");

  /// from: static public java.lang.System$Logger getLogger(java.lang.String string, java.util.ResourceBundle resourceBundle)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject getLogger1(
    jni.JString string,
    jni.JObject resourceBundle,
  ) {
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_getLogger1,
            jni.JniCallType.objectType,
            [string.reference, resourceBundle.reference]).object);
  }

  static final _id_exit =
      jni.Jni.accessors.getStaticMethodIDOf(_class.reference, r"exit", r"(I)V");

  /// from: static public void exit(int i)
  static void exit(
    int i,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_exit, jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
  }

  static final _id_gc =
      jni.Jni.accessors.getStaticMethodIDOf(_class.reference, r"gc", r"()V");

  /// from: static public void gc()
  static void gc() {
    return jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference, _id_gc, jni.JniCallType.voidType, []).check();
  }

  static final _id_runFinalization = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"runFinalization", r"()V");

  /// from: static public void runFinalization()
  static void runFinalization() {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_runFinalization, jni.JniCallType.voidType, []).check();
  }

  static final _id_load = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r"load", r"(Ljava/lang/String;)V");

  /// from: static public void load(java.lang.String string)
  static void load(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_load, jni.JniCallType.voidType, [string.reference]).check();
  }

  static final _id_loadLibrary = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r"loadLibrary", r"(Ljava/lang/String;)V");

  /// from: static public void loadLibrary(java.lang.String string)
  static void loadLibrary(
    jni.JString string,
  ) {
    return jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
        _id_loadLibrary, jni.JniCallType.voidType, [string.reference]).check();
  }

  static final _id_mapLibraryName = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r"mapLibraryName",
      r"(Ljava/lang/String;)Ljava/lang/String;");

  /// from: static public native java.lang.String mapLibraryName(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JString mapLibraryName(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_mapLibraryName,
            jni.JniCallType.objectType, [string.reference]).object);
  }
}

class $SystemType extends jni.JObjType<System> {
  const $SystemType();

  @override
  String get signature => r"Ljava/lang/System;";

  @override
  System fromRef(jni.JObjectPtr ref) => System.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($SystemType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($SystemType) && other is $SystemType;
  }
}
