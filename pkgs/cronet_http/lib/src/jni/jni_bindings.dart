// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface`
class UrlRequestCallbackProxy$UrlRequestCallbackInterface
    extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UrlRequestCallbackProxy$UrlRequestCallbackInterface> $type;

  @jni$_.internal
  UrlRequestCallbackProxy$UrlRequestCallbackInterface.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequestCallbackProxy$UrlRequestCallbackInterface?>
      nullableType =
      $UrlRequestCallbackProxy$UrlRequestCallbackInterface$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequestCallbackProxy$UrlRequestCallbackInterface>
      type = $UrlRequestCallbackProxy$UrlRequestCallbackInterface$Type$();
  static final _id_onRedirectReceived = _class.instanceMethodId(
    r'onRedirectReceived',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V',
  );

  static final _onRedirectReceived = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onRedirectReceived(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?, newLocationUrl: kotlin.String?): kotlin.Unit`
  void onRedirectReceived(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
    jni$_.JString? string,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onRedirectReceived(
            reference.pointer,
            _id_onRedirectReceived as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer,
            _$string.pointer)
        .check();
  }

  static final _id_onResponseStarted = _class.instanceMethodId(
    r'onResponseStarted',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
  );

  static final _onResponseStarted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onResponseStarted(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?): kotlin.Unit`
  void onResponseStarted(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    _onResponseStarted(
            reference.pointer,
            _id_onResponseStarted as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer)
        .check();
  }

  static final _id_onReadCompleted = _class.instanceMethodId(
    r'onReadCompleted',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V',
  );

  static final _onReadCompleted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onReadCompleted(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?, byteBuffer: java.nio.ByteBuffer?): kotlin.Unit`
  void onReadCompleted(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
    jni$_.JByteBuffer? byteBuffer,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    final _$byteBuffer = byteBuffer?.reference ?? jni$_.jNullReference;
    _onReadCompleted(
            reference.pointer,
            _id_onReadCompleted as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer,
            _$byteBuffer.pointer)
        .check();
  }

  static final _id_onSucceeded = _class.instanceMethodId(
    r'onSucceeded',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
  );

  static final _onSucceeded = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onSucceeded(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?): kotlin.Unit`
  void onSucceeded(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    _onSucceeded(reference.pointer, _id_onSucceeded as jni$_.JMethodIDPtr,
            _$urlRequest.pointer, _$urlResponseInfo.pointer)
        .check();
  }

  static final _id_onCanceled = _class.instanceMethodId(
    r'onCanceled',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
  );

  static final _onCanceled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onCanceled(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?): kotlin.Unit`
  void onCanceled(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    _onCanceled(reference.pointer, _id_onCanceled as jni$_.JMethodIDPtr,
            _$urlRequest.pointer, _$urlResponseInfo.pointer)
        .check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V',
  );

  static final _onFailed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onFailed(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?, error: org.chromium.net.CronetException?): kotlin.Unit`
  void onFailed(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
    CronetException? cronetException,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    final _$cronetException =
        cronetException?.reference ?? jni$_.jNullReference;
    _onFailed(
            reference.pointer,
            _id_onFailed as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer,
            _$cronetException.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final core$_
      .Map<int, $UrlRequestCallbackProxy$UrlRequestCallbackInterface>
      _$impls = {};
  static jni$_.JObjectPtr _$invoke(
    int port,
    jni$_.JObjectPtr descriptor,
    jni$_.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      jni$_.MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final jni$_.Pointer<
          jni$_.NativeFunction<
              jni$_.JObjectPtr Function(
                  jni$_.Int64, jni$_.JObjectPtr, jni$_.JObjectPtr)>>
      _$invokePointer = jni$_.Pointer.fromFunction(_$invoke);

  static jni$_.Pointer<jni$_.Void> _$invokeMethod(
    int $p,
    jni$_.MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onRedirectReceived(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V') {
        _$impls[$p]!.onRedirectReceived(
          $a![0]?.as(const $UrlRequest$Type$(), releaseOriginal: true),
          $a![1]?.as(const $UrlResponseInfo$Type$(), releaseOriginal: true),
          $a![2]?.as(const jni$_.$JString$Type$(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onResponseStarted(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V') {
        _$impls[$p]!.onResponseStarted(
          $a![0]?.as(const $UrlRequest$Type$(), releaseOriginal: true),
          $a![1]?.as(const $UrlResponseInfo$Type$(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onReadCompleted(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V') {
        _$impls[$p]!.onReadCompleted(
          $a![0]?.as(const $UrlRequest$Type$(), releaseOriginal: true),
          $a![1]?.as(const $UrlResponseInfo$Type$(), releaseOriginal: true),
          $a![2]?.as(const jni$_.$JByteBuffer$Type$(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onSucceeded(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V') {
        _$impls[$p]!.onSucceeded(
          $a![0]?.as(const $UrlRequest$Type$(), releaseOriginal: true),
          $a![1]?.as(const $UrlResponseInfo$Type$(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onCanceled(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V') {
        _$impls[$p]!.onCanceled(
          $a![0]?.as(const $UrlRequest$Type$(), releaseOriginal: true),
          $a![1]?.as(const $UrlResponseInfo$Type$(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
      if ($d ==
          r'onFailed(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V') {
        _$impls[$p]!.onFailed(
          $a![0]?.as(const $UrlRequest$Type$(), releaseOriginal: true),
          $a![1]?.as(const $UrlResponseInfo$Type$(), releaseOriginal: true),
          $a![2]?.as(const $CronetException$Type$(), releaseOriginal: true),
        );
        return jni$_.nullptr;
      }
    } catch (e) {
      return jni$_.ProtectedJniExtensions.newDartException(e);
    }
    return jni$_.nullptr;
  }

  static void implementIn(
    jni$_.JImplementer implementer,
    $UrlRequestCallbackProxy$UrlRequestCallbackInterface $impl,
  ) {
    late final jni$_.RawReceivePort $p;
    $p = jni$_.RawReceivePort(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = jni$_.MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      jni$_.ProtectedJniExtensions.returnResult($i.result, $r);
    });
    implementer.add(
      r'io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface',
      $p,
      _$invokePointer,
      [
        if ($impl.onRedirectReceived$async)
          r'onRedirectReceived(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V',
        if ($impl.onResponseStarted$async)
          r'onResponseStarted(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
        if ($impl.onReadCompleted$async)
          r'onReadCompleted(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V',
        if ($impl.onSucceeded$async)
          r'onSucceeded(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
        if ($impl.onCanceled$async)
          r'onCanceled(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
        if ($impl.onFailed$async)
          r'onFailed(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V',
      ],
    );
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
  }

  factory UrlRequestCallbackProxy$UrlRequestCallbackInterface.implement(
    $UrlRequestCallbackProxy$UrlRequestCallbackInterface $impl,
  ) {
    final $i = jni$_.JImplementer();
    implementIn($i, $impl);
    return UrlRequestCallbackProxy$UrlRequestCallbackInterface.fromReference(
      $i.implementReference(),
    );
  }
}

abstract base mixin class $UrlRequestCallbackProxy$UrlRequestCallbackInterface {
  factory $UrlRequestCallbackProxy$UrlRequestCallbackInterface({
    required void Function(UrlRequest? urlRequest,
            UrlResponseInfo? urlResponseInfo, jni$_.JString? string)
        onRedirectReceived,
    bool onRedirectReceived$async,
    required void Function(
            UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo)
        onResponseStarted,
    bool onResponseStarted$async,
    required void Function(UrlRequest? urlRequest,
            UrlResponseInfo? urlResponseInfo, jni$_.JByteBuffer? byteBuffer)
        onReadCompleted,
    bool onReadCompleted$async,
    required void Function(
            UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo)
        onSucceeded,
    bool onSucceeded$async,
    required void Function(
            UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo)
        onCanceled,
    bool onCanceled$async,
    required void Function(UrlRequest? urlRequest,
            UrlResponseInfo? urlResponseInfo, CronetException? cronetException)
        onFailed,
    bool onFailed$async,
  }) = _$UrlRequestCallbackProxy$UrlRequestCallbackInterface;

  void onRedirectReceived(UrlRequest? urlRequest,
      UrlResponseInfo? urlResponseInfo, jni$_.JString? string);
  bool get onRedirectReceived$async => false;
  void onResponseStarted(
      UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo);
  bool get onResponseStarted$async => false;
  void onReadCompleted(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo,
      jni$_.JByteBuffer? byteBuffer);
  bool get onReadCompleted$async => false;
  void onSucceeded(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo);
  bool get onSucceeded$async => false;
  void onCanceled(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo);
  bool get onCanceled$async => false;
  void onFailed(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo,
      CronetException? cronetException);
  bool get onFailed$async => false;
}

final class _$UrlRequestCallbackProxy$UrlRequestCallbackInterface
    with $UrlRequestCallbackProxy$UrlRequestCallbackInterface {
  _$UrlRequestCallbackProxy$UrlRequestCallbackInterface({
    required void Function(UrlRequest? urlRequest,
            UrlResponseInfo? urlResponseInfo, jni$_.JString? string)
        onRedirectReceived,
    this.onRedirectReceived$async = false,
    required void Function(
            UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo)
        onResponseStarted,
    this.onResponseStarted$async = false,
    required void Function(UrlRequest? urlRequest,
            UrlResponseInfo? urlResponseInfo, jni$_.JByteBuffer? byteBuffer)
        onReadCompleted,
    this.onReadCompleted$async = false,
    required void Function(
            UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo)
        onSucceeded,
    this.onSucceeded$async = false,
    required void Function(
            UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo)
        onCanceled,
    this.onCanceled$async = false,
    required void Function(UrlRequest? urlRequest,
            UrlResponseInfo? urlResponseInfo, CronetException? cronetException)
        onFailed,
    this.onFailed$async = false,
  })  : _onRedirectReceived = onRedirectReceived,
        _onResponseStarted = onResponseStarted,
        _onReadCompleted = onReadCompleted,
        _onSucceeded = onSucceeded,
        _onCanceled = onCanceled,
        _onFailed = onFailed;

  final void Function(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo,
      jni$_.JString? string) _onRedirectReceived;
  final bool onRedirectReceived$async;
  final void Function(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo)
      _onResponseStarted;
  final bool onResponseStarted$async;
  final void Function(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo,
      jni$_.JByteBuffer? byteBuffer) _onReadCompleted;
  final bool onReadCompleted$async;
  final void Function(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo)
      _onSucceeded;
  final bool onSucceeded$async;
  final void Function(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo)
      _onCanceled;
  final bool onCanceled$async;
  final void Function(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo,
      CronetException? cronetException) _onFailed;
  final bool onFailed$async;

  void onRedirectReceived(UrlRequest? urlRequest,
      UrlResponseInfo? urlResponseInfo, jni$_.JString? string) {
    return _onRedirectReceived(urlRequest, urlResponseInfo, string);
  }

  void onResponseStarted(
      UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo) {
    return _onResponseStarted(urlRequest, urlResponseInfo);
  }

  void onReadCompleted(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo,
      jni$_.JByteBuffer? byteBuffer) {
    return _onReadCompleted(urlRequest, urlResponseInfo, byteBuffer);
  }

  void onSucceeded(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo) {
    return _onSucceeded(urlRequest, urlResponseInfo);
  }

  void onCanceled(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo) {
    return _onCanceled(urlRequest, urlResponseInfo);
  }

  void onFailed(UrlRequest? urlRequest, UrlResponseInfo? urlResponseInfo,
      CronetException? cronetException) {
    return _onFailed(urlRequest, urlResponseInfo, cronetException);
  }
}

final class $UrlRequestCallbackProxy$UrlRequestCallbackInterface$NullableType$
    extends jni$_.JType<UrlRequestCallbackProxy$UrlRequestCallbackInterface?> {
  @jni$_.internal
  const $UrlRequestCallbackProxy$UrlRequestCallbackInterface$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface;';

  @jni$_.internal
  @core$_.override
  UrlRequestCallbackProxy$UrlRequestCallbackInterface? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UrlRequestCallbackProxy$UrlRequestCallbackInterface.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequestCallbackProxy$UrlRequestCallbackInterface?>
      get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($UrlRequestCallbackProxy$UrlRequestCallbackInterface$NullableType$)
          .hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($UrlRequestCallbackProxy$UrlRequestCallbackInterface$NullableType$) &&
        other
            is $UrlRequestCallbackProxy$UrlRequestCallbackInterface$NullableType$;
  }
}

final class $UrlRequestCallbackProxy$UrlRequestCallbackInterface$Type$
    extends jni$_.JType<UrlRequestCallbackProxy$UrlRequestCallbackInterface> {
  @jni$_.internal
  const $UrlRequestCallbackProxy$UrlRequestCallbackInterface$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface;';

  @jni$_.internal
  @core$_.override
  UrlRequestCallbackProxy$UrlRequestCallbackInterface fromReference(
          jni$_.JReference reference) =>
      UrlRequestCallbackProxy$UrlRequestCallbackInterface.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequestCallbackProxy$UrlRequestCallbackInterface?>
      get nullableType =>
          const $UrlRequestCallbackProxy$UrlRequestCallbackInterface$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($UrlRequestCallbackProxy$UrlRequestCallbackInterface$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($UrlRequestCallbackProxy$UrlRequestCallbackInterface$Type$) &&
        other is $UrlRequestCallbackProxy$UrlRequestCallbackInterface$Type$;
  }
}

/// from: `io.flutter.plugins.cronet_http.UrlRequestCallbackProxy`
class UrlRequestCallbackProxy extends UrlRequest$Callback {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UrlRequestCallbackProxy> $type;

  @jni$_.internal
  UrlRequestCallbackProxy.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'io/flutter/plugins/cronet_http/UrlRequestCallbackProxy');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequestCallbackProxy?> nullableType =
      $UrlRequestCallbackProxy$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequestCallbackProxy> type =
      $UrlRequestCallbackProxy$Type$();
  static final _id_new$ = _class.constructorId(
    r'(Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface urlRequestCallbackInterface)`
  /// The returned object must be released after use, by calling the [release] method.
  factory UrlRequestCallbackProxy(
    UrlRequestCallbackProxy$UrlRequestCallbackInterface
        urlRequestCallbackInterface,
  ) {
    final _$urlRequestCallbackInterface = urlRequestCallbackInterface.reference;
    return UrlRequestCallbackProxy.fromReference(_new$(
            _class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr,
            _$urlRequestCallbackInterface.pointer)
        .reference);
  }

  static final _id_getCallback = _class.instanceMethodId(
    r'getCallback',
    r'()Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface;',
  );

  static final _getCallback = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public final io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface getCallback()`
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequestCallbackProxy$UrlRequestCallbackInterface getCallback() {
    return _getCallback(
            reference.pointer, _id_getCallback as jni$_.JMethodIDPtr)
        .object<UrlRequestCallbackProxy$UrlRequestCallbackInterface>(
            const $UrlRequestCallbackProxy$UrlRequestCallbackInterface$Type$());
  }

  static final _id_onRedirectReceived = _class.instanceMethodId(
    r'onRedirectReceived',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V',
  );

  static final _onRedirectReceived = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onRedirectReceived(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?, newLocationUrl: kotlin.String?): kotlin.Unit`
  void onRedirectReceived(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
    jni$_.JString? string,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onRedirectReceived(
            reference.pointer,
            _id_onRedirectReceived as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer,
            _$string.pointer)
        .check();
  }

  static final _id_onResponseStarted = _class.instanceMethodId(
    r'onResponseStarted',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
  );

  static final _onResponseStarted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onResponseStarted(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?): kotlin.Unit`
  void onResponseStarted(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    _onResponseStarted(
            reference.pointer,
            _id_onResponseStarted as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer)
        .check();
  }

  static final _id_onReadCompleted = _class.instanceMethodId(
    r'onReadCompleted',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V',
  );

  static final _onReadCompleted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onReadCompleted(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?, byteBuffer: java.nio.ByteBuffer?): kotlin.Unit`
  void onReadCompleted(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
    jni$_.JByteBuffer? byteBuffer,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    final _$byteBuffer = byteBuffer?.reference ?? jni$_.jNullReference;
    _onReadCompleted(
            reference.pointer,
            _id_onReadCompleted as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer,
            _$byteBuffer.pointer)
        .check();
  }

  static final _id_onSucceeded = _class.instanceMethodId(
    r'onSucceeded',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
  );

  static final _onSucceeded = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onSucceeded(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?): kotlin.Unit`
  void onSucceeded(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    _onSucceeded(reference.pointer, _id_onSucceeded as jni$_.JMethodIDPtr,
            _$urlRequest.pointer, _$urlResponseInfo.pointer)
        .check();
  }

  static final _id_onCanceled = _class.instanceMethodId(
    r'onCanceled',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
  );

  static final _onCanceled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onCanceled(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?): kotlin.Unit`
  void onCanceled(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    _onCanceled(reference.pointer, _id_onCanceled as jni$_.JMethodIDPtr,
            _$urlRequest.pointer, _$urlResponseInfo.pointer)
        .check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V',
  );

  static final _onFailed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public fun onFailed(request: org.chromium.net.UrlRequest?, info: org.chromium.net.UrlResponseInfo?, error: org.chromium.net.CronetException?): kotlin.Unit`
  void onFailed(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
    CronetException? cronetException,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    final _$cronetException =
        cronetException?.reference ?? jni$_.jNullReference;
    _onFailed(
            reference.pointer,
            _id_onFailed as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer,
            _$cronetException.pointer)
        .check();
  }
}

final class $UrlRequestCallbackProxy$NullableType$
    extends jni$_.JType<UrlRequestCallbackProxy?> {
  @jni$_.internal
  const $UrlRequestCallbackProxy$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy;';

  @jni$_.internal
  @core$_.override
  UrlRequestCallbackProxy? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UrlRequestCallbackProxy.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const $UrlRequest$Callback$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequestCallbackProxy?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UrlRequestCallbackProxy$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequestCallbackProxy$NullableType$) &&
        other is $UrlRequestCallbackProxy$NullableType$;
  }
}

final class $UrlRequestCallbackProxy$Type$
    extends jni$_.JType<UrlRequestCallbackProxy> {
  @jni$_.internal
  const $UrlRequestCallbackProxy$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy;';

  @jni$_.internal
  @core$_.override
  UrlRequestCallbackProxy fromReference(jni$_.JReference reference) =>
      UrlRequestCallbackProxy.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const $UrlRequest$Callback$Type$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequestCallbackProxy?> get nullableType =>
      const $UrlRequestCallbackProxy$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($UrlRequestCallbackProxy$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequestCallbackProxy$Type$) &&
        other is $UrlRequestCallbackProxy$Type$;
  }
}

/// from: `java.net.URL`
class URL extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<URL> $type;

  @jni$_.internal
  URL.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/net/URL');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<URL?> nullableType = $URL$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<URL> type = $URL$Type$();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return URL.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$string.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, int i, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new$1(
    jni$_.JString? string,
    jni$_.JString? string1,
    int i,
    jni$_.JString? string2,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return URL.fromReference(_new$1(
            _class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            i,
            _$string2.pointer)
        .reference);
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;Ljava/net/URLStreamHandler;)V',
  );

  static final _new$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, int i, java.lang.String string2, java.net.URLStreamHandler uRLStreamHandler)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new$2(
    jni$_.JString? string,
    jni$_.JString? string1,
    int i,
    jni$_.JString? string2,
    jni$_.JObject? uRLStreamHandler,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    final _$uRLStreamHandler =
        uRLStreamHandler?.reference ?? jni$_.jNullReference;
    return URL.fromReference(_new$2(
            _class.reference.pointer,
            _id_new$2 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            i,
            _$string2.pointer,
            _$uRLStreamHandler.pointer)
        .reference);
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new$3(
    jni$_.JString? string,
    jni$_.JString? string1,
    jni$_.JString? string2,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    final _$string2 = string2?.reference ?? jni$_.jNullReference;
    return URL.fromReference(_new$3(
            _class.reference.pointer,
            _id_new$3 as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$string1.pointer,
            _$string2.pointer)
        .reference);
  }

  static final _id_new$4 = _class.constructorId(
    r'(Ljava/net/URL;Ljava/lang/String;)V',
  );

  static final _new$4 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.net.URL uRL, java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new$4(
    URL? uRL,
    jni$_.JString? string,
  ) {
    final _$uRL = uRL?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    return URL.fromReference(_new$4(_class.reference.pointer,
            _id_new$4 as jni$_.JMethodIDPtr, _$uRL.pointer, _$string.pointer)
        .reference);
  }

  static final _id_new$5 = _class.constructorId(
    r'(Ljava/net/URL;Ljava/lang/String;Ljava/net/URLStreamHandler;)V',
  );

  static final _new$5 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(java.net.URL uRL, java.lang.String string, java.net.URLStreamHandler uRLStreamHandler)`
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new$5(
    URL? uRL,
    jni$_.JString? string,
    jni$_.JObject? uRLStreamHandler,
  ) {
    final _$uRL = uRL?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$uRLStreamHandler =
        uRLStreamHandler?.reference ?? jni$_.jNullReference;
    return URL.fromReference(_new$5(
            _class.reference.pointer,
            _id_new$5 as jni$_.JMethodIDPtr,
            _$uRL.pointer,
            _$string.pointer,
            _$uRLStreamHandler.pointer)
        .reference);
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni$_.JObject? object,
  ) {
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$object.pointer)
        .boolean;
  }

  static final _id_getAuthority = _class.instanceMethodId(
    r'getAuthority',
    r'()Ljava/lang/String;',
  );

  static final _getAuthority = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getAuthority()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getAuthority() {
    return _getAuthority(
            reference.pointer, _id_getAuthority as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getContent = _class.instanceMethodId(
    r'getContent',
    r'()Ljava/lang/Object;',
  );

  static final _getContent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.Object getContent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContent() {
    return _getContent(reference.pointer, _id_getContent as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getContent$1 = _class.instanceMethodId(
    r'getContent',
    r'([Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _getContent$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.Object getContent(java.lang.Class[] classs)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getContent$1(
    jni$_.JArray<jni$_.JObject?>? classs,
  ) {
    final _$classs = classs?.reference ?? jni$_.jNullReference;
    return _getContent$1(reference.pointer,
            _id_getContent$1 as jni$_.JMethodIDPtr, _$classs.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_getDefaultPort = _class.instanceMethodId(
    r'getDefaultPort',
    r'()I',
  );

  static final _getDefaultPort = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getDefaultPort()`
  int getDefaultPort() {
    return _getDefaultPort(
            reference.pointer, _id_getDefaultPort as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getFile = _class.instanceMethodId(
    r'getFile',
    r'()Ljava/lang/String;',
  );

  static final _getFile = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getFile()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getFile() {
    return _getFile(reference.pointer, _id_getFile as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getHost = _class.instanceMethodId(
    r'getHost',
    r'()Ljava/lang/String;',
  );

  static final _getHost = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getHost()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHost() {
    return _getHost(reference.pointer, _id_getHost as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getPath = _class.instanceMethodId(
    r'getPath',
    r'()Ljava/lang/String;',
  );

  static final _getPath = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getPath()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getPath() {
    return _getPath(reference.pointer, _id_getPath as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getPort = _class.instanceMethodId(
    r'getPort',
    r'()I',
  );

  static final _getPort = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getPort()`
  int getPort() {
    return _getPort(reference.pointer, _id_getPort as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getProtocol = _class.instanceMethodId(
    r'getProtocol',
    r'()Ljava/lang/String;',
  );

  static final _getProtocol = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getProtocol()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getProtocol() {
    return _getProtocol(
            reference.pointer, _id_getProtocol as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getQuery = _class.instanceMethodId(
    r'getQuery',
    r'()Ljava/lang/String;',
  );

  static final _getQuery = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getQuery()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getQuery() {
    return _getQuery(reference.pointer, _id_getQuery as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getRef = _class.instanceMethodId(
    r'getRef',
    r'()Ljava/lang/String;',
  );

  static final _getRef = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getRef()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getRef() {
    return _getRef(reference.pointer, _id_getRef as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getUserInfo = _class.instanceMethodId(
    r'getUserInfo',
    r'()Ljava/lang/String;',
  );

  static final _getUserInfo = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getUserInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUserInfo() {
    return _getUserInfo(
            reference.pointer, _id_getUserInfo as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_openConnection = _class.instanceMethodId(
    r'openConnection',
    r'()Ljava/net/URLConnection;',
  );

  static final _openConnection = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.net.URLConnection openConnection()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openConnection() {
    return _openConnection(
            reference.pointer, _id_openConnection as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_openConnection$1 = _class.instanceMethodId(
    r'openConnection',
    r'(Ljava/net/Proxy;)Ljava/net/URLConnection;',
  );

  static final _openConnection$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.net.URLConnection openConnection(java.net.Proxy proxy)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openConnection$1(
    jni$_.JObject? proxy,
  ) {
    final _$proxy = proxy?.reference ?? jni$_.jNullReference;
    return _openConnection$1(reference.pointer,
            _id_openConnection$1 as jni$_.JMethodIDPtr, _$proxy.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_openStream = _class.instanceMethodId(
    r'openStream',
    r'()Ljava/io/InputStream;',
  );

  static final _openStream = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.io.InputStream openStream()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openStream() {
    return _openStream(reference.pointer, _id_openStream as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_sameFile = _class.instanceMethodId(
    r'sameFile',
    r'(Ljava/net/URL;)Z',
  );

  static final _sameFile = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean sameFile(java.net.URL uRL)`
  bool sameFile(
    URL? uRL,
  ) {
    final _$uRL = uRL?.reference ?? jni$_.jNullReference;
    return _sameFile(reference.pointer, _id_sameFile as jni$_.JMethodIDPtr,
            _$uRL.pointer)
        .boolean;
  }

  static final _id_setURLStreamHandlerFactory = _class.staticMethodId(
    r'setURLStreamHandlerFactory',
    r'(Ljava/net/URLStreamHandlerFactory;)V',
  );

  static final _setURLStreamHandlerFactory =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JThrowablePtr Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticVoidMethod')
          .asFunction<
              jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public void setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory uRLStreamHandlerFactory)`
  static void setURLStreamHandlerFactory(
    jni$_.JObject? uRLStreamHandlerFactory,
  ) {
    final _$uRLStreamHandlerFactory =
        uRLStreamHandlerFactory?.reference ?? jni$_.jNullReference;
    _setURLStreamHandlerFactory(
            _class.reference.pointer,
            _id_setURLStreamHandlerFactory as jni$_.JMethodIDPtr,
            _$uRLStreamHandlerFactory.pointer)
        .check();
  }

  static final _id_toExternalForm = _class.instanceMethodId(
    r'toExternalForm',
    r'()Ljava/lang/String;',
  );

  static final _toExternalForm = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toExternalForm()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toExternalForm() {
    return _toExternalForm(
            reference.pointer, _id_toExternalForm as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_toURI = _class.instanceMethodId(
    r'toURI',
    r'()Ljava/net/URI;',
  );

  static final _toURI = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.net.URI toURI()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? toURI() {
    return _toURI(reference.pointer, _id_toURI as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }
}

final class $URL$NullableType$ extends jni$_.JType<URL?> {
  @jni$_.internal
  const $URL$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URL;';

  @jni$_.internal
  @core$_.override
  URL? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : URL.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<URL?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URL$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($URL$NullableType$) &&
        other is $URL$NullableType$;
  }
}

final class $URL$Type$ extends jni$_.JType<URL> {
  @jni$_.internal
  const $URL$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/net/URL;';

  @jni$_.internal
  @core$_.override
  URL fromReference(jni$_.JReference reference) => URL.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<URL?> get nullableType => const $URL$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($URL$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($URL$Type$) && other is $URL$Type$;
  }
}

/// from: `java.util.concurrent.Executors`
class Executors extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Executors> $type;

  @jni$_.internal
  Executors.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/util/concurrent/Executors');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Executors?> nullableType =
      $Executors$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Executors> type = $Executors$Type$();
  static final _id_callable = _class.staticMethodId(
    r'callable',
    r'(Ljava/lang/Runnable;)Ljava/util/concurrent/Callable;',
  );

  static final _callable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable<java.lang.Object> callable(java.lang.Runnable runnable)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? callable(
    jni$_.JObject? runnable,
  ) {
    final _$runnable = runnable?.reference ?? jni$_.jNullReference;
    return _callable(_class.reference.pointer,
            _id_callable as jni$_.JMethodIDPtr, _$runnable.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_callable$1 = _class.staticMethodId(
    r'callable',
    r'(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Callable;',
  );

  static final _callable$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable<T> callable(java.lang.Runnable runnable, T object)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? callable$1<$T extends jni$_.JObject?>(
    jni$_.JObject? runnable,
    $T? object, {
    required jni$_.JType<$T> T,
  }) {
    final _$runnable = runnable?.reference ?? jni$_.jNullReference;
    final _$object = object?.reference ?? jni$_.jNullReference;
    return _callable$1(
            _class.reference.pointer,
            _id_callable$1 as jni$_.JMethodIDPtr,
            _$runnable.pointer,
            _$object.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_callable$2 = _class.staticMethodId(
    r'callable',
    r'(Ljava/security/PrivilegedAction;)Ljava/util/concurrent/Callable;',
  );

  static final _callable$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable<java.lang.Object> callable(java.security.PrivilegedAction<?> privilegedAction)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? callable$2(
    jni$_.JObject? privilegedAction,
  ) {
    final _$privilegedAction =
        privilegedAction?.reference ?? jni$_.jNullReference;
    return _callable$2(_class.reference.pointer,
            _id_callable$2 as jni$_.JMethodIDPtr, _$privilegedAction.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_callable$3 = _class.staticMethodId(
    r'callable',
    r'(Ljava/security/PrivilegedExceptionAction;)Ljava/util/concurrent/Callable;',
  );

  static final _callable$3 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable<java.lang.Object> callable(java.security.PrivilegedExceptionAction<?> privilegedExceptionAction)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? callable$3(
    jni$_.JObject? privilegedExceptionAction,
  ) {
    final _$privilegedExceptionAction =
        privilegedExceptionAction?.reference ?? jni$_.jNullReference;
    return _callable$3(
            _class.reference.pointer,
            _id_callable$3 as jni$_.JMethodIDPtr,
            _$privilegedExceptionAction.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_defaultThreadFactory = _class.staticMethodId(
    r'defaultThreadFactory',
    r'()Ljava/util/concurrent/ThreadFactory;',
  );

  static final _defaultThreadFactory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.concurrent.ThreadFactory defaultThreadFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? defaultThreadFactory() {
    return _defaultThreadFactory(_class.reference.pointer,
            _id_defaultThreadFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newCachedThreadPool = _class.staticMethodId(
    r'newCachedThreadPool',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _newCachedThreadPool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.concurrent.ExecutorService newCachedThreadPool()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newCachedThreadPool() {
    return _newCachedThreadPool(_class.reference.pointer,
            _id_newCachedThreadPool as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newCachedThreadPool$1 = _class.staticMethodId(
    r'newCachedThreadPool',
    r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newCachedThreadPool$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ExecutorService newCachedThreadPool(java.util.concurrent.ThreadFactory threadFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newCachedThreadPool$1(
    jni$_.JObject? threadFactory,
  ) {
    final _$threadFactory = threadFactory?.reference ?? jni$_.jNullReference;
    return _newCachedThreadPool$1(
            _class.reference.pointer,
            _id_newCachedThreadPool$1 as jni$_.JMethodIDPtr,
            _$threadFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newFixedThreadPool = _class.staticMethodId(
    r'newFixedThreadPool',
    r'(I)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newFixedThreadPool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.util.concurrent.ExecutorService newFixedThreadPool(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newFixedThreadPool(
    int i,
  ) {
    return _newFixedThreadPool(_class.reference.pointer,
            _id_newFixedThreadPool as jni$_.JMethodIDPtr, i)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newFixedThreadPool$1 = _class.staticMethodId(
    r'newFixedThreadPool',
    r'(ILjava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newFixedThreadPool$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ExecutorService newFixedThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newFixedThreadPool$1(
    int i,
    jni$_.JObject? threadFactory,
  ) {
    final _$threadFactory = threadFactory?.reference ?? jni$_.jNullReference;
    return _newFixedThreadPool$1(
            _class.reference.pointer,
            _id_newFixedThreadPool$1 as jni$_.JMethodIDPtr,
            i,
            _$threadFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newScheduledThreadPool = _class.staticMethodId(
    r'newScheduledThreadPool',
    r'(I)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newScheduledThreadPool = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newScheduledThreadPool(
    int i,
  ) {
    return _newScheduledThreadPool(_class.reference.pointer,
            _id_newScheduledThreadPool as jni$_.JMethodIDPtr, i)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newScheduledThreadPool$1 = _class.staticMethodId(
    r'newScheduledThreadPool',
    r'(ILjava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newScheduledThreadPool$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newScheduledThreadPool$1(
    int i,
    jni$_.JObject? threadFactory,
  ) {
    final _$threadFactory = threadFactory?.reference ?? jni$_.jNullReference;
    return _newScheduledThreadPool$1(
            _class.reference.pointer,
            _id_newScheduledThreadPool$1 as jni$_.JMethodIDPtr,
            i,
            _$threadFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newSingleThreadExecutor = _class.staticMethodId(
    r'newSingleThreadExecutor',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _newSingleThreadExecutor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.concurrent.ExecutorService newSingleThreadExecutor()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newSingleThreadExecutor() {
    return _newSingleThreadExecutor(_class.reference.pointer,
            _id_newSingleThreadExecutor as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newSingleThreadExecutor$1 = _class.staticMethodId(
    r'newSingleThreadExecutor',
    r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newSingleThreadExecutor$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ExecutorService newSingleThreadExecutor(java.util.concurrent.ThreadFactory threadFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newSingleThreadExecutor$1(
    jni$_.JObject? threadFactory,
  ) {
    final _$threadFactory = threadFactory?.reference ?? jni$_.jNullReference;
    return _newSingleThreadExecutor$1(
            _class.reference.pointer,
            _id_newSingleThreadExecutor$1 as jni$_.JMethodIDPtr,
            _$threadFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newSingleThreadScheduledExecutor = _class.staticMethodId(
    r'newSingleThreadScheduledExecutor',
    r'()Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newSingleThreadScheduledExecutor =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newSingleThreadScheduledExecutor() {
    return _newSingleThreadScheduledExecutor(_class.reference.pointer,
            _id_newSingleThreadScheduledExecutor as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newSingleThreadScheduledExecutor$1 = _class.staticMethodId(
    r'newSingleThreadScheduledExecutor',
    r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _newSingleThreadScheduledExecutor$1 =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory threadFactory)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newSingleThreadScheduledExecutor$1(
    jni$_.JObject? threadFactory,
  ) {
    final _$threadFactory = threadFactory?.reference ?? jni$_.jNullReference;
    return _newSingleThreadScheduledExecutor$1(
            _class.reference.pointer,
            _id_newSingleThreadScheduledExecutor$1 as jni$_.JMethodIDPtr,
            _$threadFactory.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newWorkStealingPool = _class.staticMethodId(
    r'newWorkStealingPool',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _newWorkStealingPool = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.concurrent.ExecutorService newWorkStealingPool()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newWorkStealingPool() {
    return _newWorkStealingPool(_class.reference.pointer,
            _id_newWorkStealingPool as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newWorkStealingPool$1 = _class.staticMethodId(
    r'newWorkStealingPool',
    r'(I)Ljava/util/concurrent/ExecutorService;',
  );

  static final _newWorkStealingPool$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.util.concurrent.ExecutorService newWorkStealingPool(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? newWorkStealingPool$1(
    int i,
  ) {
    return _newWorkStealingPool$1(_class.reference.pointer,
            _id_newWorkStealingPool$1 as jni$_.JMethodIDPtr, i)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_privilegedCallable = _class.staticMethodId(
    r'privilegedCallable',
    r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Callable;',
  );

  static final _privilegedCallable = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable<T> privilegedCallable(java.util.concurrent.Callable<T> callable)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? privilegedCallable<$T extends jni$_.JObject?>(
    jni$_.JObject? callable, {
    required jni$_.JType<$T> T,
  }) {
    final _$callable = callable?.reference ?? jni$_.jNullReference;
    return _privilegedCallable(_class.reference.pointer,
            _id_privilegedCallable as jni$_.JMethodIDPtr, _$callable.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_privilegedCallableUsingCurrentClassLoader =
      _class.staticMethodId(
    r'privilegedCallableUsingCurrentClassLoader',
    r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Callable;',
  );

  static final _privilegedCallableUsingCurrentClassLoader =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.Callable<T> privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable<T> callable)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject?
      privilegedCallableUsingCurrentClassLoader<$T extends jni$_.JObject?>(
    jni$_.JObject? callable, {
    required jni$_.JType<$T> T,
  }) {
    final _$callable = callable?.reference ?? jni$_.jNullReference;
    return _privilegedCallableUsingCurrentClassLoader(
            _class.reference.pointer,
            _id_privilegedCallableUsingCurrentClassLoader as jni$_.JMethodIDPtr,
            _$callable.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_privilegedThreadFactory = _class.staticMethodId(
    r'privilegedThreadFactory',
    r'()Ljava/util/concurrent/ThreadFactory;',
  );

  static final _privilegedThreadFactory = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.concurrent.ThreadFactory privilegedThreadFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? privilegedThreadFactory() {
    return _privilegedThreadFactory(_class.reference.pointer,
            _id_privilegedThreadFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_unconfigurableExecutorService = _class.staticMethodId(
    r'unconfigurableExecutorService',
    r'(Ljava/util/concurrent/ExecutorService;)Ljava/util/concurrent/ExecutorService;',
  );

  static final _unconfigurableExecutorService =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService executorService)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? unconfigurableExecutorService(
    jni$_.JObject? executorService,
  ) {
    final _$executorService =
        executorService?.reference ?? jni$_.jNullReference;
    return _unconfigurableExecutorService(
            _class.reference.pointer,
            _id_unconfigurableExecutorService as jni$_.JMethodIDPtr,
            _$executorService.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_unconfigurableScheduledExecutorService =
      _class.staticMethodId(
    r'unconfigurableScheduledExecutorService',
    r'(Ljava/util/concurrent/ScheduledExecutorService;)Ljava/util/concurrent/ScheduledExecutorService;',
  );

  static final _unconfigurableScheduledExecutorService =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(
                          jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr,
                          jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
              'globalEnv_CallStaticObjectMethod')
          .asFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService scheduledExecutorService)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? unconfigurableScheduledExecutorService(
    jni$_.JObject? scheduledExecutorService,
  ) {
    final _$scheduledExecutorService =
        scheduledExecutorService?.reference ?? jni$_.jNullReference;
    return _unconfigurableScheduledExecutorService(
            _class.reference.pointer,
            _id_unconfigurableScheduledExecutorService as jni$_.JMethodIDPtr,
            _$scheduledExecutorService.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }
}

final class $Executors$NullableType$ extends jni$_.JType<Executors?> {
  @jni$_.internal
  const $Executors$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/concurrent/Executors;';

  @jni$_.internal
  @core$_.override
  Executors? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Executors.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Executors?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Executors$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Executors$NullableType$) &&
        other is $Executors$NullableType$;
  }
}

final class $Executors$Type$ extends jni$_.JType<Executors> {
  @jni$_.internal
  const $Executors$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/util/concurrent/Executors;';

  @jni$_.internal
  @core$_.override
  Executors fromReference(jni$_.JReference reference) =>
      Executors.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Executors?> get nullableType => const $Executors$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Executors$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Executors$Type$) && other is $Executors$Type$;
  }
}

/// from: `org.chromium.net.CronetEngine$Builder$LibraryLoader`
class CronetEngine$Builder$LibraryLoader extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<CronetEngine$Builder$LibraryLoader> $type;

  @jni$_.internal
  CronetEngine$Builder$LibraryLoader.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
      r'org/chromium/net/CronetEngine$Builder$LibraryLoader');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CronetEngine$Builder$LibraryLoader?> nullableType =
      $CronetEngine$Builder$LibraryLoader$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CronetEngine$Builder$LibraryLoader> type =
      $CronetEngine$Builder$LibraryLoader$Type$();
  static final _id_loadLibrary = _class.instanceMethodId(
    r'loadLibrary',
    r'(Ljava/lang/String;)V',
  );

  static final _loadLibrary = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void loadLibrary(java.lang.String string)`
  void loadLibrary(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _loadLibrary(reference.pointer, _id_loadLibrary as jni$_.JMethodIDPtr,
            _$string.pointer)
        .check();
  }
}

final class $CronetEngine$Builder$LibraryLoader$NullableType$
    extends jni$_.JType<CronetEngine$Builder$LibraryLoader?> {
  @jni$_.internal
  const $CronetEngine$Builder$LibraryLoader$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/chromium/net/CronetEngine$Builder$LibraryLoader;';

  @jni$_.internal
  @core$_.override
  CronetEngine$Builder$LibraryLoader? fromReference(
          jni$_.JReference reference) =>
      reference.isNull
          ? null
          : CronetEngine$Builder$LibraryLoader.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CronetEngine$Builder$LibraryLoader?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode =>
      ($CronetEngine$Builder$LibraryLoader$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($CronetEngine$Builder$LibraryLoader$NullableType$) &&
        other is $CronetEngine$Builder$LibraryLoader$NullableType$;
  }
}

final class $CronetEngine$Builder$LibraryLoader$Type$
    extends jni$_.JType<CronetEngine$Builder$LibraryLoader> {
  @jni$_.internal
  const $CronetEngine$Builder$LibraryLoader$Type$();

  @jni$_.internal
  @core$_.override
  String get signature =>
      r'Lorg/chromium/net/CronetEngine$Builder$LibraryLoader;';

  @jni$_.internal
  @core$_.override
  CronetEngine$Builder$LibraryLoader fromReference(
          jni$_.JReference reference) =>
      CronetEngine$Builder$LibraryLoader.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CronetEngine$Builder$LibraryLoader?> get nullableType =>
      const $CronetEngine$Builder$LibraryLoader$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CronetEngine$Builder$LibraryLoader$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CronetEngine$Builder$LibraryLoader$Type$) &&
        other is $CronetEngine$Builder$LibraryLoader$Type$;
  }
}

/// from: `org.chromium.net.CronetEngine$Builder`
class CronetEngine$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<CronetEngine$Builder> $type;

  @jni$_.internal
  CronetEngine$Builder.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/chromium/net/CronetEngine$Builder');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CronetEngine$Builder?> nullableType =
      $CronetEngine$Builder$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CronetEngine$Builder> type =
      $CronetEngine$Builder$Type$();

  /// from: `static public final int HTTP_CACHE_DISABLED`
  static const HTTP_CACHE_DISABLED = 0;

  /// from: `static public final int HTTP_CACHE_IN_MEMORY`
  static const HTTP_CACHE_IN_MEMORY = 1;

  /// from: `static public final int HTTP_CACHE_DISK_NO_HTTP`
  static const HTTP_CACHE_DISK_NO_HTTP = 2;

  /// from: `static public final int HTTP_CACHE_DISK`
  static const HTTP_CACHE_DISK = 3;
  static final _id_new$ = _class.constructorId(
    r'(Landroid/content/Context;)V',
  );

  static final _new$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(android.content.Context context)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CronetEngine$Builder(
    jni$_.JObject? context,
  ) {
    final _$context = context?.reference ?? jni$_.jNullReference;
    return CronetEngine$Builder.fromReference(_new$(_class.reference.pointer,
            _id_new$ as jni$_.JMethodIDPtr, _$context.pointer)
        .reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(Lorg/chromium/net/ICronetEngineBuilder;)V',
  );

  static final _new$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void <init>(org.chromium.net.ICronetEngineBuilder iCronetEngineBuilder)`
  /// The returned object must be released after use, by calling the [release] method.
  factory CronetEngine$Builder.new$1(
    jni$_.JObject? iCronetEngineBuilder,
  ) {
    final _$iCronetEngineBuilder =
        iCronetEngineBuilder?.reference ?? jni$_.jNullReference;
    return CronetEngine$Builder.fromReference(_new$1(_class.reference.pointer,
            _id_new$1 as jni$_.JMethodIDPtr, _$iCronetEngineBuilder.pointer)
        .reference);
  }

  static final _id_getDefaultUserAgent = _class.instanceMethodId(
    r'getDefaultUserAgent',
    r'()Ljava/lang/String;',
  );

  static final _getDefaultUserAgent = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getDefaultUserAgent()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getDefaultUserAgent() {
    return _getDefaultUserAgent(
            reference.pointer, _id_getDefaultUserAgent as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_setUserAgent = _class.instanceMethodId(
    r'setUserAgent',
    r'(Ljava/lang/String;)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _setUserAgent = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.chromium.net.CronetEngine$Builder setUserAgent(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? setUserAgent(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setUserAgent(reference.pointer,
            _id_setUserAgent as jni$_.JMethodIDPtr, _$string.pointer)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_setStoragePath = _class.instanceMethodId(
    r'setStoragePath',
    r'(Ljava/lang/String;)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _setStoragePath = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.chromium.net.CronetEngine$Builder setStoragePath(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? setStoragePath(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setStoragePath(reference.pointer,
            _id_setStoragePath as jni$_.JMethodIDPtr, _$string.pointer)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_setLibraryLoader = _class.instanceMethodId(
    r'setLibraryLoader',
    r'(Lorg/chromium/net/CronetEngine$Builder$LibraryLoader;)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _setLibraryLoader = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.chromium.net.CronetEngine$Builder setLibraryLoader(org.chromium.net.CronetEngine$Builder$LibraryLoader libraryLoader)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? setLibraryLoader(
    CronetEngine$Builder$LibraryLoader? libraryLoader,
  ) {
    final _$libraryLoader = libraryLoader?.reference ?? jni$_.jNullReference;
    return _setLibraryLoader(reference.pointer,
            _id_setLibraryLoader as jni$_.JMethodIDPtr, _$libraryLoader.pointer)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_enableQuic = _class.instanceMethodId(
    r'enableQuic',
    r'(Z)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _enableQuic = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.chromium.net.CronetEngine$Builder enableQuic(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? enableQuic(
    bool z,
  ) {
    return _enableQuic(
            reference.pointer, _id_enableQuic as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_enableHttp2 = _class.instanceMethodId(
    r'enableHttp2',
    r'(Z)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _enableHttp2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.chromium.net.CronetEngine$Builder enableHttp2(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? enableHttp2(
    bool z,
  ) {
    return _enableHttp2(
            reference.pointer, _id_enableHttp2 as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_enableSdch = _class.instanceMethodId(
    r'enableSdch',
    r'(Z)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _enableSdch = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.chromium.net.CronetEngine$Builder enableSdch(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? enableSdch(
    bool z,
  ) {
    return _enableSdch(
            reference.pointer, _id_enableSdch as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_enableBrotli = _class.instanceMethodId(
    r'enableBrotli',
    r'(Z)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _enableBrotli = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.chromium.net.CronetEngine$Builder enableBrotli(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? enableBrotli(
    bool z,
  ) {
    return _enableBrotli(reference.pointer,
            _id_enableBrotli as jni$_.JMethodIDPtr, z ? 1 : 0)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_enableHttpCache = _class.instanceMethodId(
    r'enableHttpCache',
    r'(IJ)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _enableHttpCache = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int64)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `public org.chromium.net.CronetEngine$Builder enableHttpCache(int i, long j)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? enableHttpCache(
    int i,
    int j,
  ) {
    return _enableHttpCache(
            reference.pointer, _id_enableHttpCache as jni$_.JMethodIDPtr, i, j)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_addQuicHint = _class.instanceMethodId(
    r'addQuicHint',
    r'(Ljava/lang/String;II)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _addQuicHint = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int)>();

  /// from: `public org.chromium.net.CronetEngine$Builder addQuicHint(java.lang.String string, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? addQuicHint(
    jni$_.JString? string,
    int i,
    int i1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _addQuicHint(reference.pointer,
            _id_addQuicHint as jni$_.JMethodIDPtr, _$string.pointer, i, i1)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_addPublicKeyPins = _class.instanceMethodId(
    r'addPublicKeyPins',
    r'(Ljava/lang/String;Ljava/util/Set;ZLjava/util/Date;)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _addPublicKeyPins = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public org.chromium.net.CronetEngine$Builder addPublicKeyPins(java.lang.String string, java.util.Set<byte[]> set, boolean z, java.util.Date date)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? addPublicKeyPins(
    jni$_.JString? string,
    jni$_.JSet<jni$_.JByteArray?>? set,
    bool z,
    jni$_.JObject? date,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$set = set?.reference ?? jni$_.jNullReference;
    final _$date = date?.reference ?? jni$_.jNullReference;
    return _addPublicKeyPins(
            reference.pointer,
            _id_addPublicKeyPins as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$set.pointer,
            z ? 1 : 0,
            _$date.pointer)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_enablePublicKeyPinningBypassForLocalTrustAnchors =
      _class.instanceMethodId(
    r'enablePublicKeyPinningBypassForLocalTrustAnchors',
    r'(Z)Lorg/chromium/net/CronetEngine$Builder;',
  );

  static final _enablePublicKeyPinningBypassForLocalTrustAnchors =
      jni$_.ProtectedJniExtensions.lookup<
                  jni$_.NativeFunction<
                      jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                          jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
              'globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.chromium.net.CronetEngine$Builder enablePublicKeyPinningBypassForLocalTrustAnchors(boolean z)`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine$Builder? enablePublicKeyPinningBypassForLocalTrustAnchors(
    bool z,
  ) {
    return _enablePublicKeyPinningBypassForLocalTrustAnchors(
            reference.pointer,
            _id_enablePublicKeyPinningBypassForLocalTrustAnchors
                as jni$_.JMethodIDPtr,
            z ? 1 : 0)
        .object<CronetEngine$Builder?>(
            const $CronetEngine$Builder$NullableType$());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Lorg/chromium/net/CronetEngine;',
  );

  static final _build = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public org.chromium.net.CronetEngine build()`
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine? build() {
    return _build(reference.pointer, _id_build as jni$_.JMethodIDPtr)
        .object<CronetEngine?>(const $CronetEngine$NullableType$());
  }
}

final class $CronetEngine$Builder$NullableType$
    extends jni$_.JType<CronetEngine$Builder?> {
  @jni$_.internal
  const $CronetEngine$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/CronetEngine$Builder;';

  @jni$_.internal
  @core$_.override
  CronetEngine$Builder? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : CronetEngine$Builder.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CronetEngine$Builder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CronetEngine$Builder$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CronetEngine$Builder$NullableType$) &&
        other is $CronetEngine$Builder$NullableType$;
  }
}

final class $CronetEngine$Builder$Type$
    extends jni$_.JType<CronetEngine$Builder> {
  @jni$_.internal
  const $CronetEngine$Builder$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/CronetEngine$Builder;';

  @jni$_.internal
  @core$_.override
  CronetEngine$Builder fromReference(jni$_.JReference reference) =>
      CronetEngine$Builder.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CronetEngine$Builder?> get nullableType =>
      const $CronetEngine$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CronetEngine$Builder$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CronetEngine$Builder$Type$) &&
        other is $CronetEngine$Builder$Type$;
  }
}

/// from: `org.chromium.net.CronetEngine`
class CronetEngine extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<CronetEngine> $type;

  @jni$_.internal
  CronetEngine.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/chromium/net/CronetEngine');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CronetEngine?> nullableType =
      $CronetEngine$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CronetEngine> type = $CronetEngine$Type$();
  static final _id_getVersionString = _class.instanceMethodId(
    r'getVersionString',
    r'()Ljava/lang/String;',
  );

  static final _getVersionString = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getVersionString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getVersionString() {
    return _getVersionString(
            reference.pointer, _id_getVersionString as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_shutdown = _class.instanceMethodId(
    r'shutdown',
    r'()V',
  );

  static final _shutdown = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void shutdown()`
  void shutdown() {
    _shutdown(reference.pointer, _id_shutdown as jni$_.JMethodIDPtr).check();
  }

  static final _id_startNetLogToFile = _class.instanceMethodId(
    r'startNetLogToFile',
    r'(Ljava/lang/String;Z)V',
  );

  static final _startNetLogToFile = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public abstract void startNetLogToFile(java.lang.String string, boolean z)`
  void startNetLogToFile(
    jni$_.JString? string,
    bool z,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    _startNetLogToFile(
            reference.pointer,
            _id_startNetLogToFile as jni$_.JMethodIDPtr,
            _$string.pointer,
            z ? 1 : 0)
        .check();
  }

  static final _id_stopNetLog = _class.instanceMethodId(
    r'stopNetLog',
    r'()V',
  );

  static final _stopNetLog = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void stopNetLog()`
  void stopNetLog() {
    _stopNetLog(reference.pointer, _id_stopNetLog as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_getGlobalMetricsDeltas = _class.instanceMethodId(
    r'getGlobalMetricsDeltas',
    r'()[B',
  );

  static final _getGlobalMetricsDeltas = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract byte[] getGlobalMetricsDeltas()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? getGlobalMetricsDeltas() {
    return _getGlobalMetricsDeltas(
            reference.pointer, _id_getGlobalMetricsDeltas as jni$_.JMethodIDPtr)
        .object<jni$_.JByteArray?>(const jni$_.$JByteArray$NullableType$());
  }

  static final _id_openConnection = _class.instanceMethodId(
    r'openConnection',
    r'(Ljava/net/URL;)Ljava/net/URLConnection;',
  );

  static final _openConnection = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract java.net.URLConnection openConnection(java.net.URL uRL)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? openConnection(
    URL? uRL,
  ) {
    final _$uRL = uRL?.reference ?? jni$_.jNullReference;
    return _openConnection(reference.pointer,
            _id_openConnection as jni$_.JMethodIDPtr, _$uRL.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_createURLStreamHandlerFactory = _class.instanceMethodId(
    r'createURLStreamHandlerFactory',
    r'()Ljava/net/URLStreamHandlerFactory;',
  );

  static final _createURLStreamHandlerFactory =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public abstract java.net.URLStreamHandlerFactory createURLStreamHandlerFactory()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? createURLStreamHandlerFactory() {
    return _createURLStreamHandlerFactory(reference.pointer,
            _id_createURLStreamHandlerFactory as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newUrlRequestBuilder = _class.instanceMethodId(
    r'newUrlRequestBuilder',
    r'(Ljava/lang/String;Lorg/chromium/net/UrlRequest$Callback;Ljava/util/concurrent/Executor;)Lorg/chromium/net/UrlRequest$Builder;',
  );

  static final _newUrlRequestBuilder = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract org.chromium.net.UrlRequest$Builder newUrlRequestBuilder(java.lang.String string, org.chromium.net.UrlRequest$Callback callback, java.util.concurrent.Executor executor)`
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest$Builder? newUrlRequestBuilder(
    jni$_.JString? string,
    UrlRequest$Callback? callback,
    jni$_.JObject? executor,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$callback = callback?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    return _newUrlRequestBuilder(
            reference.pointer,
            _id_newUrlRequestBuilder as jni$_.JMethodIDPtr,
            _$string.pointer,
            _$callback.pointer,
            _$executor.pointer)
        .object<UrlRequest$Builder?>(const $UrlRequest$Builder$NullableType$());
  }
}

final class $CronetEngine$NullableType$ extends jni$_.JType<CronetEngine?> {
  @jni$_.internal
  const $CronetEngine$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/CronetEngine;';

  @jni$_.internal
  @core$_.override
  CronetEngine? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : CronetEngine.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CronetEngine?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CronetEngine$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CronetEngine$NullableType$) &&
        other is $CronetEngine$NullableType$;
  }
}

final class $CronetEngine$Type$ extends jni$_.JType<CronetEngine> {
  @jni$_.internal
  const $CronetEngine$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/CronetEngine;';

  @jni$_.internal
  @core$_.override
  CronetEngine fromReference(jni$_.JReference reference) =>
      CronetEngine.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CronetEngine?> get nullableType =>
      const $CronetEngine$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CronetEngine$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CronetEngine$Type$) &&
        other is $CronetEngine$Type$;
  }
}

/// from: `org.chromium.net.CronetException`
class CronetException extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<CronetException> $type;

  @jni$_.internal
  CronetException.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/chromium/net/CronetException');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CronetException?> nullableType =
      $CronetException$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<CronetException> type = $CronetException$Type$();
}

final class $CronetException$NullableType$
    extends jni$_.JType<CronetException?> {
  @jni$_.internal
  const $CronetException$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/CronetException;';

  @jni$_.internal
  @core$_.override
  CronetException? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : CronetException.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CronetException?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CronetException$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CronetException$NullableType$) &&
        other is $CronetException$NullableType$;
  }
}

final class $CronetException$Type$ extends jni$_.JType<CronetException> {
  @jni$_.internal
  const $CronetException$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/CronetException;';

  @jni$_.internal
  @core$_.override
  CronetException fromReference(jni$_.JReference reference) =>
      CronetException.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<CronetException?> get nullableType =>
      const $CronetException$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($CronetException$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($CronetException$Type$) &&
        other is $CronetException$Type$;
  }
}

/// from: `org.chromium.net.UploadDataProviders`
class UploadDataProviders extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UploadDataProviders> $type;

  @jni$_.internal
  UploadDataProviders.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/chromium/net/UploadDataProviders');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UploadDataProviders?> nullableType =
      $UploadDataProviders$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UploadDataProviders> type =
      $UploadDataProviders$Type$();
  static final _id_create = _class.staticMethodId(
    r'create',
    r'(Ljava/io/File;)Lorg/chromium/net/UploadDataProvider;',
  );

  static final _create = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.chromium.net.UploadDataProvider create(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? create(
    jni$_.JObject? file,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _create(_class.reference.pointer, _id_create as jni$_.JMethodIDPtr,
            _$file.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_create$1 = _class.staticMethodId(
    r'create',
    r'(Landroid/os/ParcelFileDescriptor;)Lorg/chromium/net/UploadDataProvider;',
  );

  static final _create$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.chromium.net.UploadDataProvider create(android.os.ParcelFileDescriptor parcelFileDescriptor)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? create$1(
    jni$_.JObject? parcelFileDescriptor,
  ) {
    final _$parcelFileDescriptor =
        parcelFileDescriptor?.reference ?? jni$_.jNullReference;
    return _create$1(_class.reference.pointer,
            _id_create$1 as jni$_.JMethodIDPtr, _$parcelFileDescriptor.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_create$2 = _class.staticMethodId(
    r'create',
    r'(Ljava/nio/ByteBuffer;)Lorg/chromium/net/UploadDataProvider;',
  );

  static final _create$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.chromium.net.UploadDataProvider create(java.nio.ByteBuffer byteBuffer)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? create$2(
    jni$_.JByteBuffer? byteBuffer,
  ) {
    final _$byteBuffer = byteBuffer?.reference ?? jni$_.jNullReference;
    return _create$2(_class.reference.pointer,
            _id_create$2 as jni$_.JMethodIDPtr, _$byteBuffer.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_create$3 = _class.staticMethodId(
    r'create',
    r'([BII)Lorg/chromium/net/UploadDataProvider;',
  );

  static final _create$3 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Int32,
                        jni$_.Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int, int)>();

  /// from: `static public org.chromium.net.UploadDataProvider create(byte[] bs, int i, int i1)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? create$3(
    jni$_.JByteArray? bs,
    int i,
    int i1,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _create$3(_class.reference.pointer,
            _id_create$3 as jni$_.JMethodIDPtr, _$bs.pointer, i, i1)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_create$4 = _class.staticMethodId(
    r'create',
    r'([B)Lorg/chromium/net/UploadDataProvider;',
  );

  static final _create$4 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public org.chromium.net.UploadDataProvider create(byte[] bs)`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JObject? create$4(
    jni$_.JByteArray? bs,
  ) {
    final _$bs = bs?.reference ?? jni$_.jNullReference;
    return _create$4(_class.reference.pointer,
            _id_create$4 as jni$_.JMethodIDPtr, _$bs.pointer)
        .object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }
}

final class $UploadDataProviders$NullableType$
    extends jni$_.JType<UploadDataProviders?> {
  @jni$_.internal
  const $UploadDataProviders$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UploadDataProviders;';

  @jni$_.internal
  @core$_.override
  UploadDataProviders? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UploadDataProviders.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UploadDataProviders?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UploadDataProviders$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UploadDataProviders$NullableType$) &&
        other is $UploadDataProviders$NullableType$;
  }
}

final class $UploadDataProviders$Type$
    extends jni$_.JType<UploadDataProviders> {
  @jni$_.internal
  const $UploadDataProviders$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UploadDataProviders;';

  @jni$_.internal
  @core$_.override
  UploadDataProviders fromReference(jni$_.JReference reference) =>
      UploadDataProviders.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UploadDataProviders?> get nullableType =>
      const $UploadDataProviders$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UploadDataProviders$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UploadDataProviders$Type$) &&
        other is $UploadDataProviders$Type$;
  }
}

/// from: `org.chromium.net.UrlRequest$Builder`
class UrlRequest$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UrlRequest$Builder> $type;

  @jni$_.internal
  UrlRequest$Builder.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/chromium/net/UrlRequest$Builder');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequest$Builder?> nullableType =
      $UrlRequest$Builder$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequest$Builder> type =
      $UrlRequest$Builder$Type$();

  /// from: `static public final int REQUEST_PRIORITY_IDLE`
  static const REQUEST_PRIORITY_IDLE = 0;

  /// from: `static public final int REQUEST_PRIORITY_LOWEST`
  static const REQUEST_PRIORITY_LOWEST = 1;

  /// from: `static public final int REQUEST_PRIORITY_LOW`
  static const REQUEST_PRIORITY_LOW = 2;

  /// from: `static public final int REQUEST_PRIORITY_MEDIUM`
  static const REQUEST_PRIORITY_MEDIUM = 3;

  /// from: `static public final int REQUEST_PRIORITY_HIGHEST`
  static const REQUEST_PRIORITY_HIGHEST = 4;
  static final _id_setHttpMethod = _class.instanceMethodId(
    r'setHttpMethod',
    r'(Ljava/lang/String;)Lorg/chromium/net/UrlRequest$Builder;',
  );

  static final _setHttpMethod = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract org.chromium.net.UrlRequest$Builder setHttpMethod(java.lang.String string)`
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest$Builder? setHttpMethod(
    jni$_.JString? string,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    return _setHttpMethod(reference.pointer,
            _id_setHttpMethod as jni$_.JMethodIDPtr, _$string.pointer)
        .object<UrlRequest$Builder?>(const $UrlRequest$Builder$NullableType$());
  }

  static final _id_addHeader = _class.instanceMethodId(
    r'addHeader',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/chromium/net/UrlRequest$Builder;',
  );

  static final _addHeader = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract org.chromium.net.UrlRequest$Builder addHeader(java.lang.String string, java.lang.String string1)`
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest$Builder? addHeader(
    jni$_.JString? string,
    jni$_.JString? string1,
  ) {
    final _$string = string?.reference ?? jni$_.jNullReference;
    final _$string1 = string1?.reference ?? jni$_.jNullReference;
    return _addHeader(reference.pointer, _id_addHeader as jni$_.JMethodIDPtr,
            _$string.pointer, _$string1.pointer)
        .object<UrlRequest$Builder?>(const $UrlRequest$Builder$NullableType$());
  }

  static final _id_disableCache = _class.instanceMethodId(
    r'disableCache',
    r'()Lorg/chromium/net/UrlRequest$Builder;',
  );

  static final _disableCache = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract org.chromium.net.UrlRequest$Builder disableCache()`
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest$Builder? disableCache() {
    return _disableCache(
            reference.pointer, _id_disableCache as jni$_.JMethodIDPtr)
        .object<UrlRequest$Builder?>(const $UrlRequest$Builder$NullableType$());
  }

  static final _id_setPriority = _class.instanceMethodId(
    r'setPriority',
    r'(I)Lorg/chromium/net/UrlRequest$Builder;',
  );

  static final _setPriority = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract org.chromium.net.UrlRequest$Builder setPriority(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest$Builder? setPriority(
    int i,
  ) {
    return _setPriority(
            reference.pointer, _id_setPriority as jni$_.JMethodIDPtr, i)
        .object<UrlRequest$Builder?>(const $UrlRequest$Builder$NullableType$());
  }

  static final _id_setUploadDataProvider = _class.instanceMethodId(
    r'setUploadDataProvider',
    r'(Lorg/chromium/net/UploadDataProvider;Ljava/util/concurrent/Executor;)Lorg/chromium/net/UrlRequest$Builder;',
  );

  static final _setUploadDataProvider = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract org.chromium.net.UrlRequest$Builder setUploadDataProvider(org.chromium.net.UploadDataProvider uploadDataProvider, java.util.concurrent.Executor executor)`
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest$Builder? setUploadDataProvider(
    jni$_.JObject? uploadDataProvider,
    jni$_.JObject? executor,
  ) {
    final _$uploadDataProvider =
        uploadDataProvider?.reference ?? jni$_.jNullReference;
    final _$executor = executor?.reference ?? jni$_.jNullReference;
    return _setUploadDataProvider(
            reference.pointer,
            _id_setUploadDataProvider as jni$_.JMethodIDPtr,
            _$uploadDataProvider.pointer,
            _$executor.pointer)
        .object<UrlRequest$Builder?>(const $UrlRequest$Builder$NullableType$());
  }

  static final _id_allowDirectExecutor = _class.instanceMethodId(
    r'allowDirectExecutor',
    r'()Lorg/chromium/net/UrlRequest$Builder;',
  );

  static final _allowDirectExecutor = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract org.chromium.net.UrlRequest$Builder allowDirectExecutor()`
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest$Builder? allowDirectExecutor() {
    return _allowDirectExecutor(
            reference.pointer, _id_allowDirectExecutor as jni$_.JMethodIDPtr)
        .object<UrlRequest$Builder?>(const $UrlRequest$Builder$NullableType$());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Lorg/chromium/net/UrlRequest;',
  );

  static final _build = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract org.chromium.net.UrlRequest build()`
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest? build() {
    return _build(reference.pointer, _id_build as jni$_.JMethodIDPtr)
        .object<UrlRequest?>(const $UrlRequest$NullableType$());
  }
}

final class $UrlRequest$Builder$NullableType$
    extends jni$_.JType<UrlRequest$Builder?> {
  @jni$_.internal
  const $UrlRequest$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlRequest$Builder;';

  @jni$_.internal
  @core$_.override
  UrlRequest$Builder? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UrlRequest$Builder.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequest$Builder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlRequest$Builder$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequest$Builder$NullableType$) &&
        other is $UrlRequest$Builder$NullableType$;
  }
}

final class $UrlRequest$Builder$Type$ extends jni$_.JType<UrlRequest$Builder> {
  @jni$_.internal
  const $UrlRequest$Builder$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlRequest$Builder;';

  @jni$_.internal
  @core$_.override
  UrlRequest$Builder fromReference(jni$_.JReference reference) =>
      UrlRequest$Builder.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequest$Builder?> get nullableType =>
      const $UrlRequest$Builder$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlRequest$Builder$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequest$Builder$Type$) &&
        other is $UrlRequest$Builder$Type$;
  }
}

/// from: `org.chromium.net.UrlRequest$Callback`
class UrlRequest$Callback extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UrlRequest$Callback> $type;

  @jni$_.internal
  UrlRequest$Callback.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/chromium/net/UrlRequest$Callback');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequest$Callback?> nullableType =
      $UrlRequest$Callback$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequest$Callback> type =
      $UrlRequest$Callback$Type$();
  static final _id_onRedirectReceived = _class.instanceMethodId(
    r'onRedirectReceived',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V',
  );

  static final _onRedirectReceived = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onRedirectReceived(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.lang.String string)`
  void onRedirectReceived(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
    jni$_.JString? string,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    final _$string = string?.reference ?? jni$_.jNullReference;
    _onRedirectReceived(
            reference.pointer,
            _id_onRedirectReceived as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer,
            _$string.pointer)
        .check();
  }

  static final _id_onResponseStarted = _class.instanceMethodId(
    r'onResponseStarted',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
  );

  static final _onResponseStarted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onResponseStarted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)`
  void onResponseStarted(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    _onResponseStarted(
            reference.pointer,
            _id_onResponseStarted as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer)
        .check();
  }

  static final _id_onReadCompleted = _class.instanceMethodId(
    r'onReadCompleted',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V',
  );

  static final _onReadCompleted = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onReadCompleted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.nio.ByteBuffer byteBuffer)`
  void onReadCompleted(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
    jni$_.JByteBuffer? byteBuffer,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    final _$byteBuffer = byteBuffer?.reference ?? jni$_.jNullReference;
    _onReadCompleted(
            reference.pointer,
            _id_onReadCompleted as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer,
            _$byteBuffer.pointer)
        .check();
  }

  static final _id_onSucceeded = _class.instanceMethodId(
    r'onSucceeded',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
  );

  static final _onSucceeded = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onSucceeded(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)`
  void onSucceeded(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    _onSucceeded(reference.pointer, _id_onSucceeded as jni$_.JMethodIDPtr,
            _$urlRequest.pointer, _$urlResponseInfo.pointer)
        .check();
  }

  static final _id_onFailed = _class.instanceMethodId(
    r'onFailed',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V',
  );

  static final _onFailed = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void onFailed(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, org.chromium.net.CronetException cronetException)`
  void onFailed(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
    CronetException? cronetException,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    final _$cronetException =
        cronetException?.reference ?? jni$_.jNullReference;
    _onFailed(
            reference.pointer,
            _id_onFailed as jni$_.JMethodIDPtr,
            _$urlRequest.pointer,
            _$urlResponseInfo.pointer,
            _$cronetException.pointer)
        .check();
  }

  static final _id_onCanceled = _class.instanceMethodId(
    r'onCanceled',
    r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V',
  );

  static final _onCanceled = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public void onCanceled(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)`
  void onCanceled(
    UrlRequest? urlRequest,
    UrlResponseInfo? urlResponseInfo,
  ) {
    final _$urlRequest = urlRequest?.reference ?? jni$_.jNullReference;
    final _$urlResponseInfo =
        urlResponseInfo?.reference ?? jni$_.jNullReference;
    _onCanceled(reference.pointer, _id_onCanceled as jni$_.JMethodIDPtr,
            _$urlRequest.pointer, _$urlResponseInfo.pointer)
        .check();
  }
}

final class $UrlRequest$Callback$NullableType$
    extends jni$_.JType<UrlRequest$Callback?> {
  @jni$_.internal
  const $UrlRequest$Callback$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlRequest$Callback;';

  @jni$_.internal
  @core$_.override
  UrlRequest$Callback? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UrlRequest$Callback.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequest$Callback?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlRequest$Callback$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequest$Callback$NullableType$) &&
        other is $UrlRequest$Callback$NullableType$;
  }
}

final class $UrlRequest$Callback$Type$
    extends jni$_.JType<UrlRequest$Callback> {
  @jni$_.internal
  const $UrlRequest$Callback$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlRequest$Callback;';

  @jni$_.internal
  @core$_.override
  UrlRequest$Callback fromReference(jni$_.JReference reference) =>
      UrlRequest$Callback.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequest$Callback?> get nullableType =>
      const $UrlRequest$Callback$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlRequest$Callback$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequest$Callback$Type$) &&
        other is $UrlRequest$Callback$Type$;
  }
}

/// from: `org.chromium.net.UrlRequest$Status`
class UrlRequest$Status extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UrlRequest$Status> $type;

  @jni$_.internal
  UrlRequest$Status.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/chromium/net/UrlRequest$Status');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequest$Status?> nullableType =
      $UrlRequest$Status$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequest$Status> type = $UrlRequest$Status$Type$();

  /// from: `static public final int INVALID`
  static const INVALID = -1;

  /// from: `static public final int IDLE`
  static const IDLE = 0;

  /// from: `static public final int WAITING_FOR_STALLED_SOCKET_POOL`
  static const WAITING_FOR_STALLED_SOCKET_POOL = 1;

  /// from: `static public final int WAITING_FOR_AVAILABLE_SOCKET`
  static const WAITING_FOR_AVAILABLE_SOCKET = 2;

  /// from: `static public final int WAITING_FOR_DELEGATE`
  static const WAITING_FOR_DELEGATE = 3;

  /// from: `static public final int WAITING_FOR_CACHE`
  static const WAITING_FOR_CACHE = 4;

  /// from: `static public final int DOWNLOADING_PAC_FILE`
  static const DOWNLOADING_PAC_FILE = 5;

  /// from: `static public final int RESOLVING_PROXY_FOR_URL`
  static const RESOLVING_PROXY_FOR_URL = 6;

  /// from: `static public final int RESOLVING_HOST_IN_PAC_FILE`
  static const RESOLVING_HOST_IN_PAC_FILE = 7;

  /// from: `static public final int ESTABLISHING_PROXY_TUNNEL`
  static const ESTABLISHING_PROXY_TUNNEL = 8;

  /// from: `static public final int RESOLVING_HOST`
  static const RESOLVING_HOST = 9;

  /// from: `static public final int CONNECTING`
  static const CONNECTING = 10;

  /// from: `static public final int SSL_HANDSHAKE`
  static const SSL_HANDSHAKE = 11;

  /// from: `static public final int SENDING_REQUEST`
  static const SENDING_REQUEST = 12;

  /// from: `static public final int WAITING_FOR_RESPONSE`
  static const WAITING_FOR_RESPONSE = 13;

  /// from: `static public final int READING_RESPONSE`
  static const READING_RESPONSE = 14;
}

final class $UrlRequest$Status$NullableType$
    extends jni$_.JType<UrlRequest$Status?> {
  @jni$_.internal
  const $UrlRequest$Status$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlRequest$Status;';

  @jni$_.internal
  @core$_.override
  UrlRequest$Status? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UrlRequest$Status.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequest$Status?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlRequest$Status$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequest$Status$NullableType$) &&
        other is $UrlRequest$Status$NullableType$;
  }
}

final class $UrlRequest$Status$Type$ extends jni$_.JType<UrlRequest$Status> {
  @jni$_.internal
  const $UrlRequest$Status$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlRequest$Status;';

  @jni$_.internal
  @core$_.override
  UrlRequest$Status fromReference(jni$_.JReference reference) =>
      UrlRequest$Status.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequest$Status?> get nullableType =>
      const $UrlRequest$Status$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlRequest$Status$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequest$Status$Type$) &&
        other is $UrlRequest$Status$Type$;
  }
}

/// from: `org.chromium.net.UrlRequest$StatusListener`
class UrlRequest$StatusListener extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UrlRequest$StatusListener> $type;

  @jni$_.internal
  UrlRequest$StatusListener.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/chromium/net/UrlRequest$StatusListener');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequest$StatusListener?> nullableType =
      $UrlRequest$StatusListener$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequest$StatusListener> type =
      $UrlRequest$StatusListener$Type$();
  static final _id_onStatus = _class.instanceMethodId(
    r'onStatus',
    r'(I)V',
  );

  static final _onStatus = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public abstract void onStatus(int i)`
  void onStatus(
    int i,
  ) {
    _onStatus(reference.pointer, _id_onStatus as jni$_.JMethodIDPtr, i).check();
  }
}

final class $UrlRequest$StatusListener$NullableType$
    extends jni$_.JType<UrlRequest$StatusListener?> {
  @jni$_.internal
  const $UrlRequest$StatusListener$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlRequest$StatusListener;';

  @jni$_.internal
  @core$_.override
  UrlRequest$StatusListener? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UrlRequest$StatusListener.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequest$StatusListener?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlRequest$StatusListener$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequest$StatusListener$NullableType$) &&
        other is $UrlRequest$StatusListener$NullableType$;
  }
}

final class $UrlRequest$StatusListener$Type$
    extends jni$_.JType<UrlRequest$StatusListener> {
  @jni$_.internal
  const $UrlRequest$StatusListener$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlRequest$StatusListener;';

  @jni$_.internal
  @core$_.override
  UrlRequest$StatusListener fromReference(jni$_.JReference reference) =>
      UrlRequest$StatusListener.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequest$StatusListener?> get nullableType =>
      const $UrlRequest$StatusListener$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlRequest$StatusListener$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequest$StatusListener$Type$) &&
        other is $UrlRequest$StatusListener$Type$;
  }
}

/// from: `org.chromium.net.UrlRequest`
class UrlRequest extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UrlRequest> $type;

  @jni$_.internal
  UrlRequest.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/chromium/net/UrlRequest');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequest?> nullableType =
      $UrlRequest$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlRequest> type = $UrlRequest$Type$();
  static final _id_start = _class.instanceMethodId(
    r'start',
    r'()V',
  );

  static final _start = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void start()`
  void start() {
    _start(reference.pointer, _id_start as jni$_.JMethodIDPtr).check();
  }

  static final _id_followRedirect = _class.instanceMethodId(
    r'followRedirect',
    r'()V',
  );

  static final _followRedirect = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void followRedirect()`
  void followRedirect() {
    _followRedirect(reference.pointer, _id_followRedirect as jni$_.JMethodIDPtr)
        .check();
  }

  static final _id_read = _class.instanceMethodId(
    r'read',
    r'(Ljava/nio/ByteBuffer;)V',
  );

  static final _read = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void read(java.nio.ByteBuffer byteBuffer)`
  void read(
    jni$_.JByteBuffer? byteBuffer,
  ) {
    final _$byteBuffer = byteBuffer?.reference ?? jni$_.jNullReference;
    _read(reference.pointer, _id_read as jni$_.JMethodIDPtr,
            _$byteBuffer.pointer)
        .check();
  }

  static final _id_cancel = _class.instanceMethodId(
    r'cancel',
    r'()V',
  );

  static final _cancel = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract void cancel()`
  void cancel() {
    _cancel(reference.pointer, _id_cancel as jni$_.JMethodIDPtr).check();
  }

  static final _id_isDone = _class.instanceMethodId(
    r'isDone',
    r'()Z',
  );

  static final _isDone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract boolean isDone()`
  bool isDone() {
    return _isDone(reference.pointer, _id_isDone as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_getStatus = _class.instanceMethodId(
    r'getStatus',
    r'(Lorg/chromium/net/UrlRequest$StatusListener;)V',
  );

  static final _getStatus = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JThrowablePtr Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public abstract void getStatus(org.chromium.net.UrlRequest$StatusListener statusListener)`
  void getStatus(
    UrlRequest$StatusListener? statusListener,
  ) {
    final _$statusListener = statusListener?.reference ?? jni$_.jNullReference;
    _getStatus(reference.pointer, _id_getStatus as jni$_.JMethodIDPtr,
            _$statusListener.pointer)
        .check();
  }
}

final class $UrlRequest$NullableType$ extends jni$_.JType<UrlRequest?> {
  @jni$_.internal
  const $UrlRequest$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlRequest;';

  @jni$_.internal
  @core$_.override
  UrlRequest? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : UrlRequest.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequest?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlRequest$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequest$NullableType$) &&
        other is $UrlRequest$NullableType$;
  }
}

final class $UrlRequest$Type$ extends jni$_.JType<UrlRequest> {
  @jni$_.internal
  const $UrlRequest$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlRequest;';

  @jni$_.internal
  @core$_.override
  UrlRequest fromReference(jni$_.JReference reference) =>
      UrlRequest.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlRequest?> get nullableType =>
      const $UrlRequest$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlRequest$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlRequest$Type$) &&
        other is $UrlRequest$Type$;
  }
}

/// from: `org.chromium.net.UrlResponseInfo$HeaderBlock`
class UrlResponseInfo$HeaderBlock extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UrlResponseInfo$HeaderBlock> $type;

  @jni$_.internal
  UrlResponseInfo$HeaderBlock.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/chromium/net/UrlResponseInfo$HeaderBlock');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlResponseInfo$HeaderBlock?> nullableType =
      $UrlResponseInfo$HeaderBlock$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlResponseInfo$HeaderBlock> type =
      $UrlResponseInfo$HeaderBlock$Type$();
  static final _id_getAsList = _class.instanceMethodId(
    r'getAsList',
    r'()Ljava/util/List;',
  );

  static final _getAsList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.util.List<java.util.Map$Entry<java.lang.String, java.lang.String>> getAsList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getAsList() {
    return _getAsList(reference.pointer, _id_getAsList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.$JList$NullableType$<jni$_.JObject?>(
                jni$_.$JObject$NullableType$()));
  }

  static final _id_getAsMap = _class.instanceMethodId(
    r'getAsMap',
    r'()Ljava/util/Map;',
  );

  static final _getAsMap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.util.Map<java.lang.String, java.util.List<java.lang.String>> getAsMap()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? getAsMap() {
    return _getAsMap(reference.pointer, _id_getAsMap as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?>(
            const jni$_.$JMap$NullableType$<jni$_.JString?,
                    jni$_.JList<jni$_.JString?>?>(
                jni$_.$JString$NullableType$(),
                jni$_.$JList$NullableType$<jni$_.JString?>(
                    jni$_.$JString$NullableType$())));
  }
}

final class $UrlResponseInfo$HeaderBlock$NullableType$
    extends jni$_.JType<UrlResponseInfo$HeaderBlock?> {
  @jni$_.internal
  const $UrlResponseInfo$HeaderBlock$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlResponseInfo$HeaderBlock;';

  @jni$_.internal
  @core$_.override
  UrlResponseInfo$HeaderBlock? fromReference(jni$_.JReference reference) =>
      reference.isNull
          ? null
          : UrlResponseInfo$HeaderBlock.fromReference(
              reference,
            );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlResponseInfo$HeaderBlock?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlResponseInfo$HeaderBlock$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlResponseInfo$HeaderBlock$NullableType$) &&
        other is $UrlResponseInfo$HeaderBlock$NullableType$;
  }
}

final class $UrlResponseInfo$HeaderBlock$Type$
    extends jni$_.JType<UrlResponseInfo$HeaderBlock> {
  @jni$_.internal
  const $UrlResponseInfo$HeaderBlock$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlResponseInfo$HeaderBlock;';

  @jni$_.internal
  @core$_.override
  UrlResponseInfo$HeaderBlock fromReference(jni$_.JReference reference) =>
      UrlResponseInfo$HeaderBlock.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlResponseInfo$HeaderBlock?> get nullableType =>
      const $UrlResponseInfo$HeaderBlock$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlResponseInfo$HeaderBlock$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlResponseInfo$HeaderBlock$Type$) &&
        other is $UrlResponseInfo$HeaderBlock$Type$;
  }
}

/// from: `org.chromium.net.UrlResponseInfo`
class UrlResponseInfo extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<UrlResponseInfo> $type;

  @jni$_.internal
  UrlResponseInfo.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class =
      jni$_.JClass.forName(r'org/chromium/net/UrlResponseInfo');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlResponseInfo?> nullableType =
      $UrlResponseInfo$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<UrlResponseInfo> type = $UrlResponseInfo$Type$();
  static final _id_getUrl = _class.instanceMethodId(
    r'getUrl',
    r'()Ljava/lang/String;',
  );

  static final _getUrl = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getUrl()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getUrl() {
    return _getUrl(reference.pointer, _id_getUrl as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getUrlChain = _class.instanceMethodId(
    r'getUrlChain',
    r'()Ljava/util/List;',
  );

  static final _getUrlChain = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.util.List<java.lang.String> getUrlChain()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JString?>? getUrlChain() {
    return _getUrlChain(
            reference.pointer, _id_getUrlChain as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JString?>?>(
            const jni$_.$JList$NullableType$<jni$_.JString?>(
                jni$_.$JString$NullableType$()));
  }

  static final _id_getHttpStatusCode = _class.instanceMethodId(
    r'getHttpStatusCode',
    r'()I',
  );

  static final _getHttpStatusCode = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract int getHttpStatusCode()`
  int getHttpStatusCode() {
    return _getHttpStatusCode(
            reference.pointer, _id_getHttpStatusCode as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getHttpStatusText = _class.instanceMethodId(
    r'getHttpStatusText',
    r'()Ljava/lang/String;',
  );

  static final _getHttpStatusText = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getHttpStatusText()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getHttpStatusText() {
    return _getHttpStatusText(
            reference.pointer, _id_getHttpStatusText as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getAllHeadersAsList = _class.instanceMethodId(
    r'getAllHeadersAsList',
    r'()Ljava/util/List;',
  );

  static final _getAllHeadersAsList = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.util.List<java.util.Map$Entry<java.lang.String, java.lang.String>> getAllHeadersAsList()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JList<jni$_.JObject?>? getAllHeadersAsList() {
    return _getAllHeadersAsList(
            reference.pointer, _id_getAllHeadersAsList as jni$_.JMethodIDPtr)
        .object<jni$_.JList<jni$_.JObject?>?>(
            const jni$_.$JList$NullableType$<jni$_.JObject?>(
                jni$_.$JObject$NullableType$()));
  }

  static final _id_getAllHeaders = _class.instanceMethodId(
    r'getAllHeaders',
    r'()Ljava/util/Map;',
  );

  static final _getAllHeaders = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.util.Map<java.lang.String, java.util.List<java.lang.String>> getAllHeaders()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>? getAllHeaders() {
    return _getAllHeaders(
            reference.pointer, _id_getAllHeaders as jni$_.JMethodIDPtr)
        .object<jni$_.JMap<jni$_.JString?, jni$_.JList<jni$_.JString?>?>?>(
            const jni$_.$JMap$NullableType$<jni$_.JString?,
                    jni$_.JList<jni$_.JString?>?>(
                jni$_.$JString$NullableType$(),
                jni$_.$JList$NullableType$<jni$_.JString?>(
                    jni$_.$JString$NullableType$())));
  }

  static final _id_wasCached = _class.instanceMethodId(
    r'wasCached',
    r'()Z',
  );

  static final _wasCached = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract boolean wasCached()`
  bool wasCached() {
    return _wasCached(reference.pointer, _id_wasCached as jni$_.JMethodIDPtr)
        .boolean;
  }

  static final _id_getNegotiatedProtocol = _class.instanceMethodId(
    r'getNegotiatedProtocol',
    r'()Ljava/lang/String;',
  );

  static final _getNegotiatedProtocol = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getNegotiatedProtocol()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getNegotiatedProtocol() {
    return _getNegotiatedProtocol(
            reference.pointer, _id_getNegotiatedProtocol as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getProxyServer = _class.instanceMethodId(
    r'getProxyServer',
    r'()Ljava/lang/String;',
  );

  static final _getProxyServer = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getProxyServer()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getProxyServer() {
    return _getProxyServer(
            reference.pointer, _id_getProxyServer as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_getReceivedByteCount = _class.instanceMethodId(
    r'getReceivedByteCount',
    r'()J',
  );

  static final _getReceivedByteCount = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract long getReceivedByteCount()`
  int getReceivedByteCount() {
    return _getReceivedByteCount(
            reference.pointer, _id_getReceivedByteCount as jni$_.JMethodIDPtr)
        .long;
  }
}

final class $UrlResponseInfo$NullableType$
    extends jni$_.JType<UrlResponseInfo?> {
  @jni$_.internal
  const $UrlResponseInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlResponseInfo;';

  @jni$_.internal
  @core$_.override
  UrlResponseInfo? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : UrlResponseInfo.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlResponseInfo?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlResponseInfo$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlResponseInfo$NullableType$) &&
        other is $UrlResponseInfo$NullableType$;
  }
}

final class $UrlResponseInfo$Type$ extends jni$_.JType<UrlResponseInfo> {
  @jni$_.internal
  const $UrlResponseInfo$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/chromium/net/UrlResponseInfo;';

  @jni$_.internal
  @core$_.override
  UrlResponseInfo fromReference(jni$_.JReference reference) =>
      UrlResponseInfo.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<UrlResponseInfo?> get nullableType =>
      const $UrlResponseInfo$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($UrlResponseInfo$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($UrlResponseInfo$Type$) &&
        other is $UrlResponseInfo$Type$;
  }
}
