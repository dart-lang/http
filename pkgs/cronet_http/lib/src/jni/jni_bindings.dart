// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;
import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

/// from: io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface
class UrlRequestCallbackProxy_UrlRequestCallbackInterface extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequestCallbackProxy_UrlRequestCallbackInterface>
      $type = type;

  UrlRequestCallbackProxy_UrlRequestCallbackInterface.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(
      r'io/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface');

  /// The type which includes information such as the signature of this class.
  static const type =
      $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType();
  static final _id_onRedirectReceived = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onRedirectReceived',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V');

  /// from: public abstract void onRedirectReceived(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.lang.String string)
  void onRedirectReceived(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    jni.JString string,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference, _id_onRedirectReceived, jni.JniCallType.voidType, [
        urlRequest.reference,
        urlResponseInfo.reference,
        string.reference
      ]).check();

  static final _id_onResponseStarted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onResponseStarted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public abstract void onResponseStarted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onResponseStarted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_onResponseStarted,
          jni.JniCallType.voidType,
          [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onReadCompleted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onReadCompleted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V');

  /// from: public abstract void onReadCompleted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.nio.ByteBuffer byteBuffer)
  void onReadCompleted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    jni.JByteBuffer byteBuffer,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference, _id_onReadCompleted, jni.JniCallType.voidType, [
        urlRequest.reference,
        urlResponseInfo.reference,
        byteBuffer.reference
      ]).check();

  static final _id_onSucceeded = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onSucceeded',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public abstract void onSucceeded(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onSucceeded(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_onSucceeded,
          jni.JniCallType.voidType,
          [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onFailed = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onFailed',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V');

  /// from: public abstract void onFailed(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, org.chromium.net.CronetException cronetException)
  void onFailed(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    CronetException cronetException,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference, _id_onFailed, jni.JniCallType.voidType, [
        urlRequest.reference,
        urlResponseInfo.reference,
        cronetException.reference
      ]).check();

  /// Maps a specific port to the implemented interface.
  static final Map<int,
      $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) =>
      _$invokeMethod(
        port,
        $MethodInvocation.fromAddresses(
          0,
          descriptor.address,
          args.address,
        ),
      );

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onRedirectReceived(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V') {
        _$impls[$p]!.onRedirectReceived(
          $a[0].castTo(const $UrlRequestType(), releaseOriginal: true),
          $a[1].castTo(const $UrlResponseInfoType(), releaseOriginal: true),
          $a[2].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onResponseStarted(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V') {
        _$impls[$p]!.onResponseStarted(
          $a[0].castTo(const $UrlRequestType(), releaseOriginal: true),
          $a[1].castTo(const $UrlResponseInfoType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onReadCompleted(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V') {
        _$impls[$p]!.onReadCompleted(
          $a[0].castTo(const $UrlRequestType(), releaseOriginal: true),
          $a[1].castTo(const $UrlResponseInfoType(), releaseOriginal: true),
          $a[2].castTo(const jni.JByteBufferType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onSucceeded(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V') {
        _$impls[$p]!.onSucceeded(
          $a[0].castTo(const $UrlRequestType(), releaseOriginal: true),
          $a[1].castTo(const $UrlResponseInfoType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onFailed(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V') {
        _$impls[$p]!.onFailed(
          $a[0].castTo(const $UrlRequestType(), releaseOriginal: true),
          $a[1].castTo(const $UrlResponseInfoType(), releaseOriginal: true),
          $a[2].castTo(const $CronetExceptionType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory UrlRequestCallbackProxy_UrlRequestCallbackInterface.implement(
    $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = UrlRequestCallbackProxy_UrlRequestCallbackInterface.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r'io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl {
  factory $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl({
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, jni.JString string)
        onRedirectReceived,
    required void Function(
            UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
        onResponseStarted,
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, jni.JByteBuffer byteBuffer)
        onReadCompleted,
    required void Function(
            UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
        onSucceeded,
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, CronetException cronetException)
        onFailed,
  }) = _$UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl;

  void onRedirectReceived(UrlRequest urlRequest,
      UrlResponseInfo urlResponseInfo, jni.JString string);
  void onResponseStarted(
      UrlRequest urlRequest, UrlResponseInfo urlResponseInfo);
  void onReadCompleted(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      jni.JByteBuffer byteBuffer);
  void onSucceeded(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo);
  void onFailed(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      CronetException cronetException);
}

class _$UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl
    implements $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl {
  _$UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl({
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, jni.JString string)
        onRedirectReceived,
    required void Function(
            UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
        onResponseStarted,
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, jni.JByteBuffer byteBuffer)
        onReadCompleted,
    required void Function(
            UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
        onSucceeded,
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, CronetException cronetException)
        onFailed,
  })  : _onRedirectReceived = onRedirectReceived,
        _onResponseStarted = onResponseStarted,
        _onReadCompleted = onReadCompleted,
        _onSucceeded = onSucceeded,
        _onFailed = onFailed;

  final void Function(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      jni.JString string) _onRedirectReceived;
  final void Function(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
      _onResponseStarted;
  final void Function(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      jni.JByteBuffer byteBuffer) _onReadCompleted;
  final void Function(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
      _onSucceeded;
  final void Function(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      CronetException cronetException) _onFailed;

  void onRedirectReceived(UrlRequest urlRequest,
          UrlResponseInfo urlResponseInfo, jni.JString string) =>
      _onRedirectReceived(urlRequest, urlResponseInfo, string);

  void onResponseStarted(
          UrlRequest urlRequest, UrlResponseInfo urlResponseInfo) =>
      _onResponseStarted(urlRequest, urlResponseInfo);

  void onReadCompleted(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
          jni.JByteBuffer byteBuffer) =>
      _onReadCompleted(urlRequest, urlResponseInfo, byteBuffer);

  void onSucceeded(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo) =>
      _onSucceeded(urlRequest, urlResponseInfo);

  void onFailed(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
          CronetException cronetException) =>
      _onFailed(urlRequest, urlResponseInfo, cronetException);
}

final class $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType
    extends jni.JObjType<UrlRequestCallbackProxy_UrlRequestCallbackInterface> {
  const $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType();

  @override
  String get signature =>
      r'Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface;';

  @override
  UrlRequestCallbackProxy_UrlRequestCallbackInterface fromRef(
          jni.JObjectPtr ref) =>
      UrlRequestCallbackProxy_UrlRequestCallbackInterface.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType ==
          $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType &&
      other is $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType;
}

/// from: io.flutter.plugins.cronet_http.UrlRequestCallbackProxy
class UrlRequestCallbackProxy extends UrlRequest_Callback {
  @override
  late final jni.JObjType<UrlRequestCallbackProxy> $type = type;

  UrlRequestCallbackProxy.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(
      r'io/flutter/plugins/cronet_http/UrlRequestCallbackProxy');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequestCallbackProxyType();
  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'<init>',
      r'(Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface;)V');

  /// from: public void <init>(io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface urlRequestCallbackInterface)
  /// The returned object must be released after use, by calling the [release] method.
  factory UrlRequestCallbackProxy.new1(
    UrlRequestCallbackProxy_UrlRequestCallbackInterface
        urlRequestCallbackInterface,
  ) =>
      UrlRequestCallbackProxy.fromRef(jni.Jni.accessors.newObjectWithArgs(
          _class.reference,
          _id_new1,
          [urlRequestCallbackInterface.reference]).object);

  static final _id_getCallback = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'getCallback',
      r'()Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface;');

  /// from: public final io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface getCallback()
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequestCallbackProxy_UrlRequestCallbackInterface getCallback() =>
      const $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType().fromRef(
          jni.Jni.accessors.callMethodWithArgs(reference, _id_getCallback,
              jni.JniCallType.objectType, []).object);

  static final _id_onRedirectReceived = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onRedirectReceived',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V');

  /// from: public void onRedirectReceived(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.lang.String string)
  void onRedirectReceived(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    jni.JString string,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference, _id_onRedirectReceived, jni.JniCallType.voidType, [
        urlRequest.reference,
        urlResponseInfo.reference,
        string.reference
      ]).check();

  static final _id_onResponseStarted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onResponseStarted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public void onResponseStarted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onResponseStarted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_onResponseStarted,
          jni.JniCallType.voidType,
          [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onReadCompleted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onReadCompleted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V');

  /// from: public void onReadCompleted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.nio.ByteBuffer byteBuffer)
  void onReadCompleted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    jni.JByteBuffer byteBuffer,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference, _id_onReadCompleted, jni.JniCallType.voidType, [
        urlRequest.reference,
        urlResponseInfo.reference,
        byteBuffer.reference
      ]).check();

  static final _id_onSucceeded = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onSucceeded',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public void onSucceeded(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onSucceeded(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_onSucceeded,
          jni.JniCallType.voidType,
          [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onFailed = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onFailed',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V');

  /// from: public void onFailed(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, org.chromium.net.CronetException cronetException)
  void onFailed(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    CronetException cronetException,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference, _id_onFailed, jni.JniCallType.voidType, [
        urlRequest.reference,
        urlResponseInfo.reference,
        cronetException.reference
      ]).check();
}

final class $UrlRequestCallbackProxyType
    extends jni.JObjType<UrlRequestCallbackProxy> {
  const $UrlRequestCallbackProxyType();

  @override
  String get signature =>
      r'Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy;';

  @override
  UrlRequestCallbackProxy fromRef(jni.JObjectPtr ref) =>
      UrlRequestCallbackProxy.fromRef(ref);

  @override
  jni.JObjType get superType => const $UrlRequest_CallbackType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($UrlRequestCallbackProxyType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $UrlRequestCallbackProxyType &&
      other is $UrlRequestCallbackProxyType;
}

/// from: java.net.URL
class URL extends jni.JObject {
  @override
  late final jni.JObjType<URL> $type = type;

  URL.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'java/net/URL');

  /// The type which includes information such as the signature of this class.
  static const type = $URLType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'<init>', r'(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;)V');

  /// from: public void <init>(java.lang.String string, java.lang.String string1, int i, java.lang.String string2)
  /// The returned object must be released after use, by calling the [release] method.
  factory URL(
    jni.JString string,
    jni.JString string1,
    int i,
    jni.JString string2,
  ) =>
      URL.fromRef(jni.Jni.accessors.newObjectWithArgs(
          _class.reference, _id_new0, [
        string.reference,
        string1.reference,
        jni.JValueInt(i),
        string2.reference
      ]).object);

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'<init>', r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V');

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2)
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new1(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) =>
      URL.fromRef(jni.Jni.accessors.newObjectWithArgs(
          _class.reference,
          _id_new1,
          [string.reference, string1.reference, string2.reference]).object);

  static final _id_new2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'<init>',
      r'(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;Ljava/net/URLStreamHandler;)V');

  /// from: public void <init>(java.lang.String string, java.lang.String string1, int i, java.lang.String string2, java.net.URLStreamHandler uRLStreamHandler)
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new2(
    jni.JString string,
    jni.JString string1,
    int i,
    jni.JString string2,
    jni.JObject uRLStreamHandler,
  ) =>
      URL.fromRef(
          jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new2, [
        string.reference,
        string1.reference,
        jni.JValueInt(i),
        string2.reference,
        uRLStreamHandler.reference
      ]).object);

  static final _id_new3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'<init>', r'(Ljava/lang/String;)V');

  /// from: public void <init>(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new3(
    jni.JString string,
  ) =>
      URL.fromRef(jni.Jni.accessors.newObjectWithArgs(
          _class.reference, _id_new3, [string.reference]).object);

  static final _id_new4 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'<init>', r'(Ljava/net/URL;Ljava/lang/String;)V');

  /// from: public void <init>(java.net.URL uRL, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new4(
    URL uRL,
    jni.JString string,
  ) =>
      URL.fromRef(jni.Jni.accessors.newObjectWithArgs(_class.reference,
          _id_new4, [uRL.reference, string.reference]).object);

  static final _id_new5 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'<init>',
      r'(Ljava/net/URL;Ljava/lang/String;Ljava/net/URLStreamHandler;)V');

  /// from: public void <init>(java.net.URL uRL, java.lang.String string, java.net.URLStreamHandler uRLStreamHandler)
  /// The returned object must be released after use, by calling the [release] method.
  factory URL.new5(
    URL uRL,
    jni.JString string,
    jni.JObject uRLStreamHandler,
  ) =>
      URL.fromRef(jni.Jni.accessors.newObjectWithArgs(
          _class.reference, _id_new5, [
        uRL.reference,
        string.reference,
        uRLStreamHandler.reference
      ]).object);

  static final _id_getQuery = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getQuery', r'()Ljava/lang/String;');

  /// from: public java.lang.String getQuery()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getQuery() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getQuery, jni.JniCallType.objectType, []).object);

  static final _id_getPath = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getPath', r'()Ljava/lang/String;');

  /// from: public java.lang.String getPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPath() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getPath, jni.JniCallType.objectType, []).object);

  static final _id_getUserInfo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getUserInfo', r'()Ljava/lang/String;');

  /// from: public java.lang.String getUserInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUserInfo() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getUserInfo, jni.JniCallType.objectType, []).object);

  static final _id_getAuthority = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getAuthority', r'()Ljava/lang/String;');

  /// from: public java.lang.String getAuthority()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAuthority() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getAuthority, jni.JniCallType.objectType, []).object);

  static final _id_getPort =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getPort', r'()I');

  /// from: public int getPort()
  int getPort() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_getPort, jni.JniCallType.intType, []).integer;

  static final _id_getDefaultPort = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getDefaultPort', r'()I');

  /// from: public int getDefaultPort()
  int getDefaultPort() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_getDefaultPort, jni.JniCallType.intType, []).integer;

  static final _id_getProtocol = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getProtocol', r'()Ljava/lang/String;');

  /// from: public java.lang.String getProtocol()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getProtocol() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getProtocol, jni.JniCallType.objectType, []).object);

  static final _id_getHost = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getHost', r'()Ljava/lang/String;');

  /// from: public java.lang.String getHost()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getHost() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getHost, jni.JniCallType.objectType, []).object);

  static final _id_getFile = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getFile', r'()Ljava/lang/String;');

  /// from: public java.lang.String getFile()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFile() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getFile, jni.JniCallType.objectType, []).object);

  static final _id_getRef = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getRef', r'()Ljava/lang/String;');

  /// from: public java.lang.String getRef()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRef() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getRef, jni.JniCallType.objectType, []).object);

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'equals', r'(Ljava/lang/Object;)Z');

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
          jni.JniCallType.booleanType, [object.reference]).boolean;

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'hashCode', r'()I');

  /// from: public int hashCode()
  int hashCode1() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_hashCode1, jni.JniCallType.intType, []).integer;

  static final _id_sameFile = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'sameFile', r'(Ljava/net/URL;)Z');

  /// from: public boolean sameFile(java.net.URL uRL)
  bool sameFile(
    URL uRL,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(reference, _id_sameFile,
          jni.JniCallType.booleanType, [uRL.reference]).boolean;

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'toString', r'()Ljava/lang/String;');

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_toString1, jni.JniCallType.objectType, []).object);

  static final _id_toExternalForm = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'toExternalForm', r'()Ljava/lang/String;');

  /// from: public java.lang.String toExternalForm()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toExternalForm() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_toExternalForm,
          jni.JniCallType.objectType, []).object);

  static final _id_toURI = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'toURI', r'()Ljava/net/URI;');

  /// from: public java.net.URI toURI()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject toURI() =>
      const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_toURI, jni.JniCallType.objectType, []).object);

  static final _id_openConnection = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'openConnection', r'()Ljava/net/URLConnection;');

  /// from: public java.net.URLConnection openConnection()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openConnection() =>
      const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_openConnection,
          jni.JniCallType.objectType, []).object);

  static final _id_openConnection1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'openConnection',
      r'(Ljava/net/Proxy;)Ljava/net/URLConnection;');

  /// from: public java.net.URLConnection openConnection(java.net.Proxy proxy)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openConnection1(
    jni.JObject proxy,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_openConnection1,
          jni.JniCallType.objectType,
          [proxy.reference]).object);

  static final _id_openStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'openStream', r'()Ljava/io/InputStream;');

  /// from: public java.io.InputStream openStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openStream() =>
      const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_openStream, jni.JniCallType.objectType, []).object);

  static final _id_getContent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getContent', r'()Ljava/lang/Object;');

  /// from: public java.lang.Object getContent()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContent() =>
      const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getContent, jni.JniCallType.objectType, []).object);

  static final _id_getContent1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'getContent',
      r'([Ljava/lang/Class;)Ljava/lang/Object;');

  /// from: public java.lang.Object getContent(java.lang.Class[] classs)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getContent1(
    jni.JArray<jni.JObject> classs,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_getContent1,
          jni.JniCallType.objectType,
          [classs.reference]).object);

  static final _id_setURLStreamHandlerFactory = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r'setURLStreamHandlerFactory',
          r'(Ljava/net/URLStreamHandlerFactory;)V');

  /// from: static public void setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory uRLStreamHandlerFactory)
  static void setURLStreamHandlerFactory(
    jni.JObject uRLStreamHandlerFactory,
  ) =>
      jni.Jni.accessors.callStaticMethodWithArgs(
          _class.reference,
          _id_setURLStreamHandlerFactory,
          jni.JniCallType.voidType,
          [uRLStreamHandlerFactory.reference]).check();
}

final class $URLType extends jni.JObjType<URL> {
  const $URLType();

  @override
  String get signature => r'Ljava/net/URL;';

  @override
  URL fromRef(jni.JObjectPtr ref) => URL.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($URLType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $URLType && other is $URLType;
}

/// from: java.util.concurrent.Executors
class Executors extends jni.JObject {
  @override
  late final jni.JObjType<Executors> $type = type;

  Executors.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'java/util/concurrent/Executors');

  /// The type which includes information such as the signature of this class.
  static const type = $ExecutorsType();
  static final _id_newFixedThreadPool = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newFixedThreadPool',
      r'(I)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newFixedThreadPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newFixedThreadPool(
    int i,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(_class.reference, _id_newFixedThreadPool,
              jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_newWorkStealingPool = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newWorkStealingPool',
      r'(I)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newWorkStealingPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newWorkStealingPool(
    int i,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(_class.reference, _id_newWorkStealingPool,
              jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_newWorkStealingPool1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newWorkStealingPool',
      r'()Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newWorkStealingPool()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newWorkStealingPool1() => const jni.JObjectType().fromRef(
      jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
          _id_newWorkStealingPool1, jni.JniCallType.objectType, []).object);

  static final _id_newFixedThreadPool1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newFixedThreadPool',
      r'(ILjava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newFixedThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newFixedThreadPool1(
    int i,
    jni.JObject threadFactory,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_newFixedThreadPool1,
              jni.JniCallType.objectType,
              [jni.JValueInt(i), threadFactory.reference]).object);

  static final _id_newSingleThreadExecutor = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r'newSingleThreadExecutor',
          r'()Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newSingleThreadExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadExecutor() => const jni.JObjectType()
      .fromRef(jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
          _id_newSingleThreadExecutor, jni.JniCallType.objectType, []).object);

  static final _id_newSingleThreadExecutor1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newSingleThreadExecutor',
      r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newSingleThreadExecutor(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadExecutor1(
    jni.JObject threadFactory,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_newSingleThreadExecutor1,
              jni.JniCallType.objectType,
              [threadFactory.reference]).object);

  static final _id_newCachedThreadPool = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newCachedThreadPool',
      r'()Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newCachedThreadPool()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newCachedThreadPool() => const jni.JObjectType().fromRef(
      jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
          _id_newCachedThreadPool, jni.JniCallType.objectType, []).object);

  static final _id_newCachedThreadPool1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newCachedThreadPool',
      r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newCachedThreadPool(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newCachedThreadPool1(
    jni.JObject threadFactory,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(_class.reference, _id_newCachedThreadPool1,
              jni.JniCallType.objectType, [threadFactory.reference]).object);

  static final _id_newSingleThreadScheduledExecutor = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference,
          r'newSingleThreadScheduledExecutor',
          r'()Ljava/util/concurrent/ScheduledExecutorService;');

  /// from: static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadScheduledExecutor() =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_newSingleThreadScheduledExecutor,
              jni.JniCallType.objectType, []).object);

  static final _id_newSingleThreadScheduledExecutor1 = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference,
          r'newSingleThreadScheduledExecutor',
          r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ScheduledExecutorService;');

  /// from: static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadScheduledExecutor1(
    jni.JObject threadFactory,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_newSingleThreadScheduledExecutor1,
              jni.JniCallType.objectType,
              [threadFactory.reference]).object);

  static final _id_newScheduledThreadPool = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r'newScheduledThreadPool',
          r'(I)Ljava/util/concurrent/ScheduledExecutorService;');

  /// from: static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newScheduledThreadPool(
    int i,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_newScheduledThreadPool,
              jni.JniCallType.objectType,
              [jni.JValueInt(i)]).object);

  static final _id_newScheduledThreadPool1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newScheduledThreadPool',
      r'(ILjava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ScheduledExecutorService;');

  /// from: static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newScheduledThreadPool1(
    int i,
    jni.JObject threadFactory,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_newScheduledThreadPool1,
              jni.JniCallType.objectType,
              [jni.JValueInt(i), threadFactory.reference]).object);

  static final _id_unconfigurableExecutorService = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r'unconfigurableExecutorService',
          r'(Ljava/util/concurrent/ExecutorService;)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService executorService)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject unconfigurableExecutorService(
    jni.JObject executorService,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_unconfigurableExecutorService,
              jni.JniCallType.objectType,
              [executorService.reference]).object);

  static final _id_unconfigurableScheduledExecutorService = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference,
          r'unconfigurableScheduledExecutorService',
          r'(Ljava/util/concurrent/ScheduledExecutorService;)Ljava/util/concurrent/ScheduledExecutorService;');

  /// from: static public java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService scheduledExecutorService)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject unconfigurableScheduledExecutorService(
    jni.JObject scheduledExecutorService,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_unconfigurableScheduledExecutorService,
              jni.JniCallType.objectType,
              [scheduledExecutorService.reference]).object);

  static final _id_defaultThreadFactory = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'defaultThreadFactory',
      r'()Ljava/util/concurrent/ThreadFactory;');

  /// from: static public java.util.concurrent.ThreadFactory defaultThreadFactory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject defaultThreadFactory() => const jni.JObjectType().fromRef(
      jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
          _id_defaultThreadFactory, jni.JniCallType.objectType, []).object);

  static final _id_privilegedThreadFactory = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r'privilegedThreadFactory',
          r'()Ljava/util/concurrent/ThreadFactory;');

  /// from: static public java.util.concurrent.ThreadFactory privilegedThreadFactory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject privilegedThreadFactory() => const jni.JObjectType()
      .fromRef(jni.Jni.accessors.callStaticMethodWithArgs(_class.reference,
          _id_privilegedThreadFactory, jni.JniCallType.objectType, []).object);

  static final _id_callable = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'callable',
      r'(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable callable(java.lang.Runnable runnable, T object)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable<$T extends jni.JObject>(
    jni.JObject runnable,
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_callable,
            jni.JniCallType.objectType,
            [runnable.reference, object.reference]).object);
  }

  static final _id_callable1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'callable',
      r'(Ljava/lang/Runnable;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable callable(java.lang.Runnable runnable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable1(
    jni.JObject runnable,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(_class.reference, _id_callable1,
              jni.JniCallType.objectType, [runnable.reference]).object);

  static final _id_callable2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'callable',
      r'(Ljava/security/PrivilegedAction;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable callable(java.security.PrivilegedAction privilegedAction)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable2(
    jni.JObject privilegedAction,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(_class.reference, _id_callable2,
              jni.JniCallType.objectType, [privilegedAction.reference]).object);

  static final _id_callable3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'callable',
      r'(Ljava/security/PrivilegedExceptionAction;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable callable(java.security.PrivilegedExceptionAction privilegedExceptionAction)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable3(
    jni.JObject privilegedExceptionAction,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_callable3,
              jni.JniCallType.objectType,
              [privilegedExceptionAction.reference]).object);

  static final _id_privilegedCallable = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'privilegedCallable',
      r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable privilegedCallable(java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject privilegedCallable<$T extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$T> T,
  }) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(_class.reference, _id_privilegedCallable,
              jni.JniCallType.objectType, [callable.reference]).object);

  static final _id_privilegedCallableUsingCurrentClassLoader = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference,
          r'privilegedCallableUsingCurrentClassLoader',
          r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject
      privilegedCallableUsingCurrentClassLoader<$T extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$T> T,
  }) =>
          const jni.JObjectType().fromRef(jni.Jni.accessors
              .callStaticMethodWithArgs(
                  _class.reference,
                  _id_privilegedCallableUsingCurrentClassLoader,
                  jni.JniCallType.objectType,
                  [callable.reference]).object);
}

final class $ExecutorsType extends jni.JObjType<Executors> {
  const $ExecutorsType();

  @override
  String get signature => r'Ljava/util/concurrent/Executors;';

  @override
  Executors fromRef(jni.JObjectPtr ref) => Executors.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExecutorsType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $ExecutorsType && other is $ExecutorsType;
}

/// from: org.chromium.net.CronetEngine$Builder$LibraryLoader
class CronetEngine_Builder_LibraryLoader extends jni.JObject {
  @override
  late final jni.JObjType<CronetEngine_Builder_LibraryLoader> $type = type;

  CronetEngine_Builder_LibraryLoader.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(
      r'org/chromium/net/CronetEngine$Builder$LibraryLoader');

  /// The type which includes information such as the signature of this class.
  static const type = $CronetEngine_Builder_LibraryLoaderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory CronetEngine_Builder_LibraryLoader() =>
      CronetEngine_Builder_LibraryLoader.fromRef(jni.Jni.accessors
          .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_loadLibrary = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'loadLibrary', r'(Ljava/lang/String;)V');

  /// from: public abstract void loadLibrary(java.lang.String string)
  void loadLibrary(
    jni.JString string,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(reference, _id_loadLibrary,
          jni.JniCallType.voidType, [string.reference]).check();
}

final class $CronetEngine_Builder_LibraryLoaderType
    extends jni.JObjType<CronetEngine_Builder_LibraryLoader> {
  const $CronetEngine_Builder_LibraryLoaderType();

  @override
  String get signature =>
      r'Lorg/chromium/net/CronetEngine$Builder$LibraryLoader;';

  @override
  CronetEngine_Builder_LibraryLoader fromRef(jni.JObjectPtr ref) =>
      CronetEngine_Builder_LibraryLoader.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CronetEngine_Builder_LibraryLoaderType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $CronetEngine_Builder_LibraryLoaderType &&
      other is $CronetEngine_Builder_LibraryLoaderType;
}

/// from: org.chromium.net.CronetEngine$Builder
class CronetEngine_Builder extends jni.JObject {
  @override
  late final jni.JObjType<CronetEngine_Builder> $type = type;

  CronetEngine_Builder.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/CronetEngine$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $CronetEngine_BuilderType();
  static final _id_mBuilderDelegate = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r'mBuilderDelegate',
    r'Lorg/chromium/net/ICronetEngineBuilder;',
  );

  /// from: protected final org.chromium.net.ICronetEngineBuilder mBuilderDelegate
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get mBuilderDelegate =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getField(reference, _id_mBuilderDelegate, jni.JniCallType.objectType)
          .object);

  /// from: static public final int HTTP_CACHE_DISABLED
  static const HTTP_CACHE_DISABLED = 0;

  /// from: static public final int HTTP_CACHE_IN_MEMORY
  static const HTTP_CACHE_IN_MEMORY = 1;

  /// from: static public final int HTTP_CACHE_DISK_NO_HTTP
  static const HTTP_CACHE_DISK_NO_HTTP = 2;

  /// from: static public final int HTTP_CACHE_DISK
  static const HTTP_CACHE_DISK = 3;

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'<init>', r'(Landroid/content/Context;)V');

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be released after use, by calling the [release] method.
  factory CronetEngine_Builder(
    jni.JObject context,
  ) =>
      CronetEngine_Builder.fromRef(jni.Jni.accessors.newObjectWithArgs(
          _class.reference, _id_new0, [context.reference]).object);

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'<init>', r'(Lorg/chromium/net/ICronetEngineBuilder;)V');

  /// from: public void <init>(org.chromium.net.ICronetEngineBuilder iCronetEngineBuilder)
  /// The returned object must be released after use, by calling the [release] method.
  factory CronetEngine_Builder.new1(
    jni.JObject iCronetEngineBuilder,
  ) =>
      CronetEngine_Builder.fromRef(jni.Jni.accessors.newObjectWithArgs(
          _class.reference, _id_new1, [iCronetEngineBuilder.reference]).object);

  static final _id_getDefaultUserAgent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getDefaultUserAgent', r'()Ljava/lang/String;');

  /// from: public java.lang.String getDefaultUserAgent()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDefaultUserAgent() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_getDefaultUserAgent,
          jni.JniCallType.objectType, []).object);

  static final _id_setUserAgent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setUserAgent',
      r'(Ljava/lang/String;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setUserAgent(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder setUserAgent(
    jni.JString string,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_setUserAgent,
              jni.JniCallType.objectType, [string.reference]).object);

  static final _id_setStoragePath = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setStoragePath',
      r'(Ljava/lang/String;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setStoragePath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder setStoragePath(
    jni.JString string,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_setStoragePath,
              jni.JniCallType.objectType, [string.reference]).object);

  static final _id_setLibraryLoader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setLibraryLoader',
      r'(Lorg/chromium/net/CronetEngine$Builder$LibraryLoader;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setLibraryLoader(org.chromium.net.CronetEngine$Builder$LibraryLoader libraryLoader)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder setLibraryLoader(
    CronetEngine_Builder_LibraryLoader libraryLoader,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_setLibraryLoader,
              jni.JniCallType.objectType, [libraryLoader.reference]).object);

  static final _id_enableQuic = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'enableQuic',
      r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableQuic(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder enableQuic(
    bool z,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_enableQuic,
              jni.JniCallType.objectType, [z ? 1 : 0]).object);

  static final _id_enableHttp2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'enableHttp2',
      r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableHttp2(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder enableHttp2(
    bool z,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_enableHttp2,
              jni.JniCallType.objectType, [z ? 1 : 0]).object);

  static final _id_enableSdch = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'enableSdch',
      r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableSdch(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder enableSdch(
    bool z,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_enableSdch,
              jni.JniCallType.objectType, [z ? 1 : 0]).object);

  static final _id_enableBrotli = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'enableBrotli',
      r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableBrotli(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder enableBrotli(
    bool z,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_enableBrotli,
              jni.JniCallType.objectType, [z ? 1 : 0]).object);

  static final _id_enableHttpCache = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'enableHttpCache',
      r'(IJ)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableHttpCache(int i, long j)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder enableHttpCache(
    int i,
    int j,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_enableHttpCache,
              jni.JniCallType.objectType, [jni.JValueInt(i), j]).object);

  static final _id_addQuicHint = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'addQuicHint',
      r'(Ljava/lang/String;II)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder addQuicHint(java.lang.String string, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder addQuicHint(
    jni.JString string,
    int i,
    int i1,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(
              reference,
              _id_addQuicHint,
              jni.JniCallType.objectType,
              [string.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);

  static final _id_addPublicKeyPins = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'addPublicKeyPins',
      r'(Ljava/lang/String;Ljava/util/Set;ZLjava/util/Date;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder addPublicKeyPins(java.lang.String string, java.util.Set set, boolean z, java.util.Date date)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder addPublicKeyPins(
    jni.JString string,
    jni.JSet<jni.JArray<jni.jbyte>> set0,
    bool z,
    jni.JObject date,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(
              reference, _id_addPublicKeyPins, jni.JniCallType.objectType, [
        string.reference,
        set0.reference,
        z ? 1 : 0,
        date.reference
      ]).object);

  static final _id_enablePublicKeyPinningBypassForLocalTrustAnchors =
      jni.Jni.accessors.getMethodIDOf(
          _class.reference,
          r'enablePublicKeyPinningBypassForLocalTrustAnchors',
          r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enablePublicKeyPinningBypassForLocalTrustAnchors(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine_Builder enablePublicKeyPinningBypassForLocalTrustAnchors(
    bool z,
  ) =>
      const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(
              reference,
              _id_enablePublicKeyPinningBypassForLocalTrustAnchors,
              jni.JniCallType.objectType,
              [z ? 1 : 0]).object);

  static final _id_build = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'build', r'()Lorg/chromium/net/CronetEngine;');

  /// from: public org.chromium.net.CronetEngine build()
  /// The returned object must be released after use, by calling the [release] method.
  CronetEngine build() =>
      const $CronetEngineType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_build, jni.JniCallType.objectType, []).object);
}

final class $CronetEngine_BuilderType
    extends jni.JObjType<CronetEngine_Builder> {
  const $CronetEngine_BuilderType();

  @override
  String get signature => r'Lorg/chromium/net/CronetEngine$Builder;';

  @override
  CronetEngine_Builder fromRef(jni.JObjectPtr ref) =>
      CronetEngine_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CronetEngine_BuilderType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $CronetEngine_BuilderType &&
      other is $CronetEngine_BuilderType;
}

/// from: org.chromium.net.CronetEngine
class CronetEngine extends jni.JObject {
  @override
  late final jni.JObjType<CronetEngine> $type = type;

  CronetEngine.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'org/chromium/net/CronetEngine');

  /// The type which includes information such as the signature of this class.
  static const type = $CronetEngineType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory CronetEngine() => CronetEngine.fromRef(jni.Jni.accessors
      .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_getVersionString = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getVersionString', r'()Ljava/lang/String;');

  /// from: public abstract java.lang.String getVersionString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getVersionString() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_getVersionString,
          jni.JniCallType.objectType, []).object);

  static final _id_shutdown =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'shutdown', r'()V');

  /// from: public abstract void shutdown()
  void shutdown() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_shutdown, jni.JniCallType.voidType, []).check();

  static final _id_startNetLogToFile = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'startNetLogToFile', r'(Ljava/lang/String;Z)V');

  /// from: public abstract void startNetLogToFile(java.lang.String string, boolean z)
  void startNetLogToFile(
    jni.JString string,
    bool z,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(reference, _id_startNetLogToFile,
          jni.JniCallType.voidType, [string.reference, z ? 1 : 0]).check();

  static final _id_stopNetLog =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'stopNetLog', r'()V');

  /// from: public abstract void stopNetLog()
  void stopNetLog() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_stopNetLog, jni.JniCallType.voidType, []).check();

  static final _id_getGlobalMetricsDeltas = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getGlobalMetricsDeltas', r'()[B');

  /// from: public abstract byte[] getGlobalMetricsDeltas()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getGlobalMetricsDeltas() =>
      const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_getGlobalMetricsDeltas,
              jni.JniCallType.objectType, []).object);

  static final _id_openConnection = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'openConnection',
      r'(Ljava/net/URL;)Ljava/net/URLConnection;');

  /// from: public abstract java.net.URLConnection openConnection(java.net.URL uRL)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject openConnection(
    URL uRL,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_openConnection,
          jni.JniCallType.objectType,
          [uRL.reference]).object);

  static final _id_createURLStreamHandlerFactory = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'createURLStreamHandlerFactory',
          r'()Ljava/net/URLStreamHandlerFactory;');

  /// from: public abstract java.net.URLStreamHandlerFactory createURLStreamHandlerFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject createURLStreamHandlerFactory() =>
      const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_createURLStreamHandlerFactory,
          jni.JniCallType.objectType, []).object);

  static final _id_newUrlRequestBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'newUrlRequestBuilder',
      r'(Ljava/lang/String;Lorg/chromium/net/UrlRequest$Callback;Ljava/util/concurrent/Executor;)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder newUrlRequestBuilder(java.lang.String string, org.chromium.net.UrlRequest$Callback callback, java.util.concurrent.Executor executor)
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest_Builder newUrlRequestBuilder(
    jni.JString string,
    UrlRequest_Callback callback,
    jni.JObject executor,
  ) =>
      const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(
              reference, _id_newUrlRequestBuilder, jni.JniCallType.objectType, [
        string.reference,
        callback.reference,
        executor.reference
      ]).object);
}

final class $CronetEngineType extends jni.JObjType<CronetEngine> {
  const $CronetEngineType();

  @override
  String get signature => r'Lorg/chromium/net/CronetEngine;';

  @override
  CronetEngine fromRef(jni.JObjectPtr ref) => CronetEngine.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CronetEngineType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $CronetEngineType && other is $CronetEngineType;
}

/// from: org.chromium.net.CronetException
class CronetException extends jni.JObject {
  @override
  late final jni.JObjType<CronetException> $type = type;

  CronetException.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'org/chromium/net/CronetException');

  /// The type which includes information such as the signature of this class.
  static const type = $CronetExceptionType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'<init>', r'(Ljava/lang/String;Ljava/lang/Throwable;)V');

  /// from: protected void <init>(java.lang.String string, java.lang.Throwable throwable)
  /// The returned object must be released after use, by calling the [release] method.
  factory CronetException(
    jni.JString string,
    jni.JObject throwable,
  ) =>
      CronetException.fromRef(jni.Jni.accessors.newObjectWithArgs(
          _class.reference,
          _id_new0,
          [string.reference, throwable.reference]).object);
}

final class $CronetExceptionType extends jni.JObjType<CronetException> {
  const $CronetExceptionType();

  @override
  String get signature => r'Lorg/chromium/net/CronetException;';

  @override
  CronetException fromRef(jni.JObjectPtr ref) => CronetException.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CronetExceptionType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $CronetExceptionType &&
      other is $CronetExceptionType;
}

/// from: org.chromium.net.UploadDataProviders
class UploadDataProviders extends jni.JObject {
  @override
  late final jni.JObjType<UploadDataProviders> $type = type;

  UploadDataProviders.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UploadDataProviders');

  /// The type which includes information such as the signature of this class.
  static const type = $UploadDataProvidersType();
  static final _id_create = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'create',
      r'(Ljava/io/File;)Lorg/chromium/net/UploadDataProvider;');

  /// from: static public org.chromium.net.UploadDataProvider create(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject create(
    jni.JObject file,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(_class.reference, _id_create,
              jni.JniCallType.objectType, [file.reference]).object);

  static final _id_create1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'create',
      r'(Landroid/os/ParcelFileDescriptor;)Lorg/chromium/net/UploadDataProvider;');

  /// from: static public org.chromium.net.UploadDataProvider create(android.os.ParcelFileDescriptor parcelFileDescriptor)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject create1(
    jni.JObject parcelFileDescriptor,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_create1,
              jni.JniCallType.objectType,
              [parcelFileDescriptor.reference]).object);

  static final _id_create2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'create',
      r'(Ljava/nio/ByteBuffer;)Lorg/chromium/net/UploadDataProvider;');

  /// from: static public org.chromium.net.UploadDataProvider create(java.nio.ByteBuffer byteBuffer)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject create2(
    jni.JByteBuffer byteBuffer,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(_class.reference, _id_create2,
              jni.JniCallType.objectType, [byteBuffer.reference]).object);

  static final _id_create3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'create',
      r'([BII)Lorg/chromium/net/UploadDataProvider;');

  /// from: static public org.chromium.net.UploadDataProvider create(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject create3(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(
              _class.reference,
              _id_create3,
              jni.JniCallType.objectType,
              [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);

  static final _id_create4 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'create',
      r'([B)Lorg/chromium/net/UploadDataProvider;');

  /// from: static public org.chromium.net.UploadDataProvider create(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject create4(
    jni.JArray<jni.jbyte> bs,
  ) =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .callStaticMethodWithArgs(_class.reference, _id_create4,
              jni.JniCallType.objectType, [bs.reference]).object);
}

final class $UploadDataProvidersType extends jni.JObjType<UploadDataProviders> {
  const $UploadDataProvidersType();

  @override
  String get signature => r'Lorg/chromium/net/UploadDataProviders;';

  @override
  UploadDataProviders fromRef(jni.JObjectPtr ref) =>
      UploadDataProviders.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UploadDataProvidersType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $UploadDataProvidersType &&
      other is $UploadDataProvidersType;
}

/// from: org.chromium.net.UrlRequest$Builder
class UrlRequest_Builder extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequest_Builder> $type = type;

  UrlRequest_Builder.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UrlRequest$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequest_BuilderType();

  /// from: static public final int REQUEST_PRIORITY_IDLE
  static const REQUEST_PRIORITY_IDLE = 0;

  /// from: static public final int REQUEST_PRIORITY_LOWEST
  static const REQUEST_PRIORITY_LOWEST = 1;

  /// from: static public final int REQUEST_PRIORITY_LOW
  static const REQUEST_PRIORITY_LOW = 2;

  /// from: static public final int REQUEST_PRIORITY_MEDIUM
  static const REQUEST_PRIORITY_MEDIUM = 3;

  /// from: static public final int REQUEST_PRIORITY_HIGHEST
  static const REQUEST_PRIORITY_HIGHEST = 4;

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory UrlRequest_Builder() => UrlRequest_Builder.fromRef(jni.Jni.accessors
      .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_setHttpMethod = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setHttpMethod',
      r'(Ljava/lang/String;)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder setHttpMethod(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest_Builder setHttpMethod(
    jni.JString string,
  ) =>
      const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_setHttpMethod,
              jni.JniCallType.objectType, [string.reference]).object);

  static final _id_addHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'addHeader',
      r'(Ljava/lang/String;Ljava/lang/String;)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) =>
      const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(
              reference,
              _id_addHeader,
              jni.JniCallType.objectType,
              [string.reference, string1.reference]).object);

  static final _id_disableCache = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'disableCache',
      r'()Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder disableCache()
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest_Builder disableCache() => const $UrlRequest_BuilderType().fromRef(
      jni.Jni.accessors.callMethodWithArgs(
          reference, _id_disableCache, jni.JniCallType.objectType, []).object);

  static final _id_setPriority = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setPriority',
      r'(I)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder setPriority(int i)
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest_Builder setPriority(
    int i,
  ) =>
      const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_setPriority,
              jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_setUploadDataProvider = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setUploadDataProvider',
      r'(Lorg/chromium/net/UploadDataProvider;Ljava/util/concurrent/Executor;)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder setUploadDataProvider(org.chromium.net.UploadDataProvider uploadDataProvider, java.util.concurrent.Executor executor)
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest_Builder setUploadDataProvider(
    jni.JObject uploadDataProvider,
    jni.JObject executor,
  ) =>
      const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
          .callMethodWithArgs(
              reference,
              _id_setUploadDataProvider,
              jni.JniCallType.objectType,
              [uploadDataProvider.reference, executor.reference]).object);

  static final _id_allowDirectExecutor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'allowDirectExecutor',
      r'()Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder allowDirectExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest_Builder allowDirectExecutor() => const $UrlRequest_BuilderType()
      .fromRef(jni.Jni.accessors.callMethodWithArgs(reference,
          _id_allowDirectExecutor, jni.JniCallType.objectType, []).object);

  static final _id_build = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'build', r'()Lorg/chromium/net/UrlRequest;');

  /// from: public abstract org.chromium.net.UrlRequest build()
  /// The returned object must be released after use, by calling the [release] method.
  UrlRequest build() =>
      const $UrlRequestType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_build, jni.JniCallType.objectType, []).object);
}

final class $UrlRequest_BuilderType extends jni.JObjType<UrlRequest_Builder> {
  const $UrlRequest_BuilderType();

  @override
  String get signature => r'Lorg/chromium/net/UrlRequest$Builder;';

  @override
  UrlRequest_Builder fromRef(jni.JObjectPtr ref) =>
      UrlRequest_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlRequest_BuilderType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $UrlRequest_BuilderType &&
      other is $UrlRequest_BuilderType;
}

/// from: org.chromium.net.UrlRequest$Callback
class UrlRequest_Callback extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequest_Callback> $type = type;

  UrlRequest_Callback.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UrlRequest$Callback');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequest_CallbackType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory UrlRequest_Callback() => UrlRequest_Callback.fromRef(jni.Jni.accessors
      .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_onRedirectReceived = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onRedirectReceived',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V');

  /// from: public abstract void onRedirectReceived(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.lang.String string)
  void onRedirectReceived(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    jni.JString string,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference, _id_onRedirectReceived, jni.JniCallType.voidType, [
        urlRequest.reference,
        urlResponseInfo.reference,
        string.reference
      ]).check();

  static final _id_onResponseStarted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onResponseStarted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public abstract void onResponseStarted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onResponseStarted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_onResponseStarted,
          jni.JniCallType.voidType,
          [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onReadCompleted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onReadCompleted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V');

  /// from: public abstract void onReadCompleted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.nio.ByteBuffer byteBuffer)
  void onReadCompleted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    jni.JByteBuffer byteBuffer,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference, _id_onReadCompleted, jni.JniCallType.voidType, [
        urlRequest.reference,
        urlResponseInfo.reference,
        byteBuffer.reference
      ]).check();

  static final _id_onSucceeded = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onSucceeded',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public abstract void onSucceeded(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onSucceeded(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_onSucceeded,
          jni.JniCallType.voidType,
          [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onFailed = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onFailed',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V');

  /// from: public abstract void onFailed(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, org.chromium.net.CronetException cronetException)
  void onFailed(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    CronetException cronetException,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference, _id_onFailed, jni.JniCallType.voidType, [
        urlRequest.reference,
        urlResponseInfo.reference,
        cronetException.reference
      ]).check();

  static final _id_onCanceled = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onCanceled',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public void onCanceled(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onCanceled(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_onCanceled,
          jni.JniCallType.voidType,
          [urlRequest.reference, urlResponseInfo.reference]).check();
}

final class $UrlRequest_CallbackType extends jni.JObjType<UrlRequest_Callback> {
  const $UrlRequest_CallbackType();

  @override
  String get signature => r'Lorg/chromium/net/UrlRequest$Callback;';

  @override
  UrlRequest_Callback fromRef(jni.JObjectPtr ref) =>
      UrlRequest_Callback.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlRequest_CallbackType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $UrlRequest_CallbackType &&
      other is $UrlRequest_CallbackType;
}

/// from: org.chromium.net.UrlRequest$Status
class UrlRequest_Status extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequest_Status> $type = type;

  UrlRequest_Status.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UrlRequest$Status');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequest_StatusType();

  /// from: static public final int INVALID
  static const INVALID = -1;

  /// from: static public final int IDLE
  static const IDLE = 0;

  /// from: static public final int WAITING_FOR_STALLED_SOCKET_POOL
  static const WAITING_FOR_STALLED_SOCKET_POOL = 1;

  /// from: static public final int WAITING_FOR_AVAILABLE_SOCKET
  static const WAITING_FOR_AVAILABLE_SOCKET = 2;

  /// from: static public final int WAITING_FOR_DELEGATE
  static const WAITING_FOR_DELEGATE = 3;

  /// from: static public final int WAITING_FOR_CACHE
  static const WAITING_FOR_CACHE = 4;

  /// from: static public final int DOWNLOADING_PAC_FILE
  static const DOWNLOADING_PAC_FILE = 5;

  /// from: static public final int RESOLVING_PROXY_FOR_URL
  static const RESOLVING_PROXY_FOR_URL = 6;

  /// from: static public final int RESOLVING_HOST_IN_PAC_FILE
  static const RESOLVING_HOST_IN_PAC_FILE = 7;

  /// from: static public final int ESTABLISHING_PROXY_TUNNEL
  static const ESTABLISHING_PROXY_TUNNEL = 8;

  /// from: static public final int RESOLVING_HOST
  static const RESOLVING_HOST = 9;

  /// from: static public final int CONNECTING
  static const CONNECTING = 10;

  /// from: static public final int SSL_HANDSHAKE
  static const SSL_HANDSHAKE = 11;

  /// from: static public final int SENDING_REQUEST
  static const SENDING_REQUEST = 12;

  /// from: static public final int WAITING_FOR_RESPONSE
  static const WAITING_FOR_RESPONSE = 13;

  /// from: static public final int READING_RESPONSE
  static const READING_RESPONSE = 14;
}

final class $UrlRequest_StatusType extends jni.JObjType<UrlRequest_Status> {
  const $UrlRequest_StatusType();

  @override
  String get signature => r'Lorg/chromium/net/UrlRequest$Status;';

  @override
  UrlRequest_Status fromRef(jni.JObjectPtr ref) =>
      UrlRequest_Status.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlRequest_StatusType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $UrlRequest_StatusType &&
      other is $UrlRequest_StatusType;
}

/// from: org.chromium.net.UrlRequest$StatusListener
class UrlRequest_StatusListener extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequest_StatusListener> $type = type;

  UrlRequest_StatusListener.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UrlRequest$StatusListener');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequest_StatusListenerType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory UrlRequest_StatusListener() =>
      UrlRequest_StatusListener.fromRef(jni.Jni.accessors
          .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_onStatus =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'onStatus', r'(I)V');

  /// from: public abstract void onStatus(int i)
  void onStatus(
    int i,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(reference, _id_onStatus,
          jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
}

final class $UrlRequest_StatusListenerType
    extends jni.JObjType<UrlRequest_StatusListener> {
  const $UrlRequest_StatusListenerType();

  @override
  String get signature => r'Lorg/chromium/net/UrlRequest$StatusListener;';

  @override
  UrlRequest_StatusListener fromRef(jni.JObjectPtr ref) =>
      UrlRequest_StatusListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlRequest_StatusListenerType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $UrlRequest_StatusListenerType &&
      other is $UrlRequest_StatusListenerType;
}

/// from: org.chromium.net.UrlRequest
class UrlRequest extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequest> $type = type;

  UrlRequest.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'org/chromium/net/UrlRequest');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequestType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory UrlRequest() => UrlRequest.fromRef(jni.Jni.accessors
      .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_start =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'start', r'()V');

  /// from: public abstract void start()
  void start() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_start, jni.JniCallType.voidType, []).check();

  static final _id_followRedirect = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'followRedirect', r'()V');

  /// from: public abstract void followRedirect()
  void followRedirect() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_followRedirect, jni.JniCallType.voidType, []).check();

  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'read', r'(Ljava/nio/ByteBuffer;)V');

  /// from: public abstract void read(java.nio.ByteBuffer byteBuffer)
  void read(
    jni.JByteBuffer byteBuffer,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
          jni.JniCallType.voidType, [byteBuffer.reference]).check();

  static final _id_cancel =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'cancel', r'()V');

  /// from: public abstract void cancel()
  void cancel() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_cancel, jni.JniCallType.voidType, []).check();

  static final _id_isDone =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'isDone', r'()Z');

  /// from: public abstract boolean isDone()
  bool isDone() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_isDone, jni.JniCallType.booleanType, []).boolean;

  static final _id_getStatus = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'getStatus', r'(Lorg/chromium/net/UrlRequest$StatusListener;)V');

  /// from: public abstract void getStatus(org.chromium.net.UrlRequest$StatusListener statusListener)
  void getStatus(
    UrlRequest_StatusListener statusListener,
  ) =>
      jni.Jni.accessors.callMethodWithArgs(reference, _id_getStatus,
          jni.JniCallType.voidType, [statusListener.reference]).check();
}

final class $UrlRequestType extends jni.JObjType<UrlRequest> {
  const $UrlRequestType();

  @override
  String get signature => r'Lorg/chromium/net/UrlRequest;';

  @override
  UrlRequest fromRef(jni.JObjectPtr ref) => UrlRequest.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlRequestType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $UrlRequestType && other is $UrlRequestType;
}

/// from: org.chromium.net.UrlResponseInfo$HeaderBlock
class UrlResponseInfo_HeaderBlock extends jni.JObject {
  @override
  late final jni.JObjType<UrlResponseInfo_HeaderBlock> $type = type;

  UrlResponseInfo_HeaderBlock.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UrlResponseInfo$HeaderBlock');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlResponseInfo_HeaderBlockType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory UrlResponseInfo_HeaderBlock() =>
      UrlResponseInfo_HeaderBlock.fromRef(jni.Jni.accessors
          .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_getAsList = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getAsList', r'()Ljava/util/List;');

  /// from: public abstract java.util.List getAsList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getAsList() => const jni.JListType(jni.JObjectType())
      .fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getAsList, jni.JniCallType.objectType, []).object);

  static final _id_getAsMap = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getAsMap', r'()Ljava/util/Map;');

  /// from: public abstract java.util.Map getAsMap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JMap<jni.JString, jni.JList<jni.JString>> getAsMap() =>
      const jni.JMapType(jni.JStringType(), jni.JListType(jni.JStringType()))
          .fromRef(jni.Jni.accessors.callMethodWithArgs(
              reference, _id_getAsMap, jni.JniCallType.objectType, []).object);
}

final class $UrlResponseInfo_HeaderBlockType
    extends jni.JObjType<UrlResponseInfo_HeaderBlock> {
  const $UrlResponseInfo_HeaderBlockType();

  @override
  String get signature => r'Lorg/chromium/net/UrlResponseInfo$HeaderBlock;';

  @override
  UrlResponseInfo_HeaderBlock fromRef(jni.JObjectPtr ref) =>
      UrlResponseInfo_HeaderBlock.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlResponseInfo_HeaderBlockType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $UrlResponseInfo_HeaderBlockType &&
      other is $UrlResponseInfo_HeaderBlockType;
}

/// from: org.chromium.net.UrlResponseInfo
class UrlResponseInfo extends jni.JObject {
  @override
  late final jni.JObjType<UrlResponseInfo> $type = type;

  UrlResponseInfo.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'org/chromium/net/UrlResponseInfo');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlResponseInfoType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory UrlResponseInfo() => UrlResponseInfo.fromRef(jni.Jni.accessors
      .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_getUrl = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getUrl', r'()Ljava/lang/String;');

  /// from: public abstract java.lang.String getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUrl() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getUrl, jni.JniCallType.objectType, []).object);

  static final _id_getUrlChain = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getUrlChain', r'()Ljava/util/List;');

  /// from: public abstract java.util.List getUrlChain()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getUrlChain() => const jni.JListType(jni.JStringType())
      .fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference, _id_getUrlChain, jni.JniCallType.objectType, []).object);

  static final _id_getHttpStatusCode = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getHttpStatusCode', r'()I');

  /// from: public abstract int getHttpStatusCode()
  int getHttpStatusCode() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_getHttpStatusCode, jni.JniCallType.intType, []).integer;

  static final _id_getHttpStatusText = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getHttpStatusText', r'()Ljava/lang/String;');

  /// from: public abstract java.lang.String getHttpStatusText()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getHttpStatusText() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_getHttpStatusText,
          jni.JniCallType.objectType, []).object);

  static final _id_getAllHeadersAsList = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getAllHeadersAsList', r'()Ljava/util/List;');

  /// from: public abstract java.util.List getAllHeadersAsList()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> getAllHeadersAsList() =>
      const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
          .callMethodWithArgs(reference, _id_getAllHeadersAsList,
              jni.JniCallType.objectType, []).object);

  static final _id_getAllHeaders = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getAllHeaders', r'()Ljava/util/Map;');

  /// from: public abstract java.util.Map getAllHeaders()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JMap<jni.JString, jni.JList<jni.JString>> getAllHeaders() =>
      const jni.JMapType(jni.JStringType(), jni.JListType(jni.JStringType()))
          .fromRef(jni.Jni.accessors.callMethodWithArgs(reference,
              _id_getAllHeaders, jni.JniCallType.objectType, []).object);

  static final _id_wasCached =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'wasCached', r'()Z');

  /// from: public abstract boolean wasCached()
  bool wasCached() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_wasCached, jni.JniCallType.booleanType, []).boolean;

  static final _id_getNegotiatedProtocol = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getNegotiatedProtocol', r'()Ljava/lang/String;');

  /// from: public abstract java.lang.String getNegotiatedProtocol()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getNegotiatedProtocol() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_getNegotiatedProtocol,
          jni.JniCallType.objectType, []).object);

  static final _id_getProxyServer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getProxyServer', r'()Ljava/lang/String;');

  /// from: public abstract java.lang.String getProxyServer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getProxyServer() =>
      const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
          reference,
          _id_getProxyServer,
          jni.JniCallType.objectType, []).object);

  static final _id_getReceivedByteCount = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getReceivedByteCount', r'()J');

  /// from: public abstract long getReceivedByteCount()
  int getReceivedByteCount() => jni.Jni.accessors.callMethodWithArgs(
      reference, _id_getReceivedByteCount, jni.JniCallType.longType, []).long;
}

final class $UrlResponseInfoType extends jni.JObjType<UrlResponseInfo> {
  const $UrlResponseInfoType();

  @override
  String get signature => r'Lorg/chromium/net/UrlResponseInfo;';

  @override
  UrlResponseInfo fromRef(jni.JObjectPtr ref) => UrlResponseInfo.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlResponseInfoType).hashCode;

  @override
  bool operator ==(Object other) =>
      other.runtimeType == $UrlResponseInfoType &&
      other is $UrlResponseInfoType;
}
