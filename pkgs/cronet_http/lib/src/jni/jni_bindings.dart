// Autogenerated by jnigen. DO NOT EDIT!

import 'dart:ffi' as ffi;
// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

/// from: io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface
class UrlRequestCallbackProxy_UrlRequestCallbackInterface extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequestCallbackProxy_UrlRequestCallbackInterface>
      $type = type;

  UrlRequestCallbackProxy_UrlRequestCallbackInterface.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(
      r'io/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface');

  /// The type which includes information such as the signature of this class.
  static const type =
      $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType();
  static final _id_onRedirectReceived = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onRedirectReceived',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V');

  /// from: public abstract void onRedirectReceived(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.lang.String string)
  void onRedirectReceived(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    jni.JString string,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onRedirectReceived, jni.JniCallType.voidType, [
      urlRequest.reference,
      urlResponseInfo.reference,
      string.reference
    ]).check();

  static final _id_onResponseStarted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onResponseStarted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public abstract void onResponseStarted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onResponseStarted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onResponseStarted,
        jni.JniCallType.voidType,
        [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onReadCompleted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onReadCompleted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V');

  /// from: public abstract void onReadCompleted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.nio.ByteBuffer byteBuffer)
  void onReadCompleted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    ByteBuffer byteBuffer,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onReadCompleted, jni.JniCallType.voidType, [
      urlRequest.reference,
      urlResponseInfo.reference,
      byteBuffer.reference
    ]).check();

  static final _id_onSucceeded = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onSucceeded',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public abstract void onSucceeded(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onSucceeded(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onSucceeded,
        jni.JniCallType.voidType,
        [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onFailed = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onFailed',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V');

  /// from: public abstract void onFailed(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, org.chromium.net.CronetException cronetException)
  void onFailed(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    CronetException cronetException,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onFailed, jni.JniCallType.voidType, [
      urlRequest.reference,
      urlResponseInfo.reference,
      cronetException.reference
    ]).check();

  /// Maps a specific port to the implemented interface.
  static final Map<int,
      $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) => _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(deleteOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'onRedirectReceived(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V') {
        _$impls[$p]!.onRedirectReceived(
          $a[0].castTo(const $UrlRequestType(), deleteOriginal: true),
          $a[1].castTo(const $UrlResponseInfoType(), deleteOriginal: true),
          $a[2].castTo(const jni.JStringType(), deleteOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onResponseStarted(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V') {
        _$impls[$p]!.onResponseStarted(
          $a[0].castTo(const $UrlRequestType(), deleteOriginal: true),
          $a[1].castTo(const $UrlResponseInfoType(), deleteOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onReadCompleted(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V') {
        _$impls[$p]!.onReadCompleted(
          $a[0].castTo(const $UrlRequestType(), deleteOriginal: true),
          $a[1].castTo(const $UrlResponseInfoType(), deleteOriginal: true),
          $a[2].castTo(const $ByteBufferType(), deleteOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onSucceeded(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V') {
        _$impls[$p]!.onSucceeded(
          $a[0].castTo(const $UrlRequestType(), deleteOriginal: true),
          $a[1].castTo(const $UrlResponseInfoType(), deleteOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onFailed(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V') {
        _$impls[$p]!.onFailed(
          $a[0].castTo(const $UrlRequestType(), deleteOriginal: true),
          $a[1].castTo(const $UrlResponseInfoType(), deleteOriginal: true),
          $a[2].castTo(const $CronetExceptionType(), deleteOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory UrlRequestCallbackProxy_UrlRequestCallbackInterface.implement(
    $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = UrlRequestCallbackProxy_UrlRequestCallbackInterface.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r'io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl {
  factory $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl({
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, jni.JString string)
        onRedirectReceived,
    required void Function(
            UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
        onResponseStarted,
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, ByteBuffer byteBuffer)
        onReadCompleted,
    required void Function(
            UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
        onSucceeded,
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, CronetException cronetException)
        onFailed,
  }) = _$UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl;

  void onRedirectReceived(UrlRequest urlRequest,
      UrlResponseInfo urlResponseInfo, jni.JString string);
  void onResponseStarted(
      UrlRequest urlRequest, UrlResponseInfo urlResponseInfo);
  void onReadCompleted(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      ByteBuffer byteBuffer);
  void onSucceeded(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo);
  void onFailed(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      CronetException cronetException);
}

class _$UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl
    implements $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl {
  _$UrlRequestCallbackProxy_UrlRequestCallbackInterfaceImpl({
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, jni.JString string)
        onRedirectReceived,
    required void Function(
            UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
        onResponseStarted,
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, ByteBuffer byteBuffer)
        onReadCompleted,
    required void Function(
            UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
        onSucceeded,
    required void Function(UrlRequest urlRequest,
            UrlResponseInfo urlResponseInfo, CronetException cronetException)
        onFailed,
  })  : _onRedirectReceived = onRedirectReceived,
        _onResponseStarted = onResponseStarted,
        _onReadCompleted = onReadCompleted,
        _onSucceeded = onSucceeded,
        _onFailed = onFailed;

  final void Function(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      jni.JString string) _onRedirectReceived;
  final void Function(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
      _onResponseStarted;
  final void Function(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      ByteBuffer byteBuffer) _onReadCompleted;
  final void Function(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo)
      _onSucceeded;
  final void Function(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      CronetException cronetException) _onFailed;

  void onRedirectReceived(UrlRequest urlRequest,
      UrlResponseInfo urlResponseInfo, jni.JString string) => _onRedirectReceived(urlRequest, urlResponseInfo, string);

  void onResponseStarted(
      UrlRequest urlRequest, UrlResponseInfo urlResponseInfo) => _onResponseStarted(urlRequest, urlResponseInfo);

  void onReadCompleted(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      ByteBuffer byteBuffer) => _onReadCompleted(urlRequest, urlResponseInfo, byteBuffer);

  void onSucceeded(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo) => _onSucceeded(urlRequest, urlResponseInfo);

  void onFailed(UrlRequest urlRequest, UrlResponseInfo urlResponseInfo,
      CronetException cronetException) => _onFailed(urlRequest, urlResponseInfo, cronetException);
}

class $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType
    extends jni.JObjType<UrlRequestCallbackProxy_UrlRequestCallbackInterface> {
  const $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType();

  @override
  String get signature =>
      r'Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface;';

  @override
  UrlRequestCallbackProxy_UrlRequestCallbackInterface fromRef(
          jni.JObjectPtr ref) =>
      UrlRequestCallbackProxy_UrlRequestCallbackInterface.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode =>
      ($UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType ==
            $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType &&
        other is $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType;
}

/// from: io.flutter.plugins.cronet_http.UrlRequestCallbackProxy
class UrlRequestCallbackProxy extends UrlRequest_Callback {
  @override
  late final jni.JObjType<UrlRequestCallbackProxy> $type = type;

  UrlRequestCallbackProxy.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(
      r'io/flutter/plugins/cronet_http/UrlRequestCallbackProxy');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequestCallbackProxyType();
  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'<init>',
      r'(Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface;)V');

  /// from: public void <init>(io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface urlRequestCallbackInterface)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory UrlRequestCallbackProxy.new1(
    UrlRequestCallbackProxy_UrlRequestCallbackInterface
        urlRequestCallbackInterface,
  ) => UrlRequestCallbackProxy.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new1,
        [urlRequestCallbackInterface.reference]).object);

  static final _id_getCallback = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'getCallback',
      r'()Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy$UrlRequestCallbackInterface;');

  /// from: public final io.flutter.plugins.cronet_http.UrlRequestCallbackProxy$UrlRequestCallbackInterface getCallback()
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequestCallbackProxy_UrlRequestCallbackInterface getCallback() => const $UrlRequestCallbackProxy_UrlRequestCallbackInterfaceType()
        .fromRef(jni.Jni.accessors.callMethodWithArgs(
            reference, _id_getCallback, jni.JniCallType.objectType, []).object);

  static final _id_onRedirectReceived = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onRedirectReceived',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V');

  /// from: public void onRedirectReceived(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.lang.String string)
  void onRedirectReceived(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    jni.JString string,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onRedirectReceived, jni.JniCallType.voidType, [
      urlRequest.reference,
      urlResponseInfo.reference,
      string.reference
    ]).check();

  static final _id_onResponseStarted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onResponseStarted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public void onResponseStarted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onResponseStarted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onResponseStarted,
        jni.JniCallType.voidType,
        [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onReadCompleted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onReadCompleted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V');

  /// from: public void onReadCompleted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.nio.ByteBuffer byteBuffer)
  void onReadCompleted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    ByteBuffer byteBuffer,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onReadCompleted, jni.JniCallType.voidType, [
      urlRequest.reference,
      urlResponseInfo.reference,
      byteBuffer.reference
    ]).check();

  static final _id_onSucceeded = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onSucceeded',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public void onSucceeded(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onSucceeded(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onSucceeded,
        jni.JniCallType.voidType,
        [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onFailed = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onFailed',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V');

  /// from: public void onFailed(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, org.chromium.net.CronetException cronetException)
  void onFailed(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    CronetException cronetException,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onFailed, jni.JniCallType.voidType, [
      urlRequest.reference,
      urlResponseInfo.reference,
      cronetException.reference
    ]).check();
}

class $UrlRequestCallbackProxyType
    extends jni.JObjType<UrlRequestCallbackProxy> {
  const $UrlRequestCallbackProxyType();

  @override
  String get signature =>
      r'Lio/flutter/plugins/cronet_http/UrlRequestCallbackProxy;';

  @override
  UrlRequestCallbackProxy fromRef(jni.JObjectPtr ref) =>
      UrlRequestCallbackProxy.fromRef(ref);

  @override
  jni.JObjType get superType => const $UrlRequest_CallbackType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($UrlRequestCallbackProxyType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $UrlRequestCallbackProxyType &&
        other is $UrlRequestCallbackProxyType;
}

/// from: java.net.URL
class URL extends jni.JObject {
  @override
  late final jni.JObjType<URL> $type = type;

  URL.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'java/net/URL');

  /// The type which includes information such as the signature of this class.
  static const type = $URLType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'<init>', r'(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;)V');

  /// from: public void <init>(java.lang.String string, java.lang.String string1, int i, java.lang.String string2)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory URL(
    jni.JString string,
    jni.JString string1,
    int i,
    jni.JString string2,
  ) => URL.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [
      string.reference,
      string1.reference,
      jni.JValueInt(i),
      string2.reference
    ]).object);

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'<init>', r'(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V');

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory URL.new1(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) => URL.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new1,
        [string.reference, string1.reference, string2.reference]).object);

  static final _id_new2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'<init>',
      r'(Ljava/lang/String;Ljava/lang/String;ILjava/lang/String;Ljava/net/URLStreamHandler;)V');

  /// from: public void <init>(java.lang.String string, java.lang.String string1, int i, java.lang.String string2, java.net.URLStreamHandler uRLStreamHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory URL.new2(
    jni.JString string,
    jni.JString string1,
    int i,
    jni.JString string2,
    jni.JObject uRLStreamHandler,
  ) => URL.fromRef(
        jni.Jni.accessors.newObjectWithArgs(_class.reference, _id_new2, [
      string.reference,
      string1.reference,
      jni.JValueInt(i),
      string2.reference,
      uRLStreamHandler.reference
    ]).object);

  static final _id_new3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'<init>', r'(Ljava/lang/String;)V');

  /// from: public void <init>(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory URL.new3(
    jni.JString string,
  ) => URL.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new3, [string.reference]).object);

  static final _id_new4 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'<init>', r'(Ljava/net/URL;Ljava/lang/String;)V');

  /// from: public void <init>(java.net.URL uRL, java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory URL.new4(
    URL uRL,
    jni.JString string,
  ) => URL.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new4, [uRL.reference, string.reference]).object);

  static final _id_new5 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'<init>',
      r'(Ljava/net/URL;Ljava/lang/String;Ljava/net/URLStreamHandler;)V');

  /// from: public void <init>(java.net.URL uRL, java.lang.String string, java.net.URLStreamHandler uRLStreamHandler)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory URL.new5(
    URL uRL,
    jni.JString string,
    jni.JObject uRLStreamHandler,
  ) => URL.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new5,
        [uRL.reference, string.reference, uRLStreamHandler.reference]).object);

  static final _id_getQuery = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getQuery', r'()Ljava/lang/String;');

  /// from: public java.lang.String getQuery()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getQuery() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getQuery, jni.JniCallType.objectType, []).object);

  static final _id_getPath = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getPath', r'()Ljava/lang/String;');

  /// from: public java.lang.String getPath()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getPath() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPath, jni.JniCallType.objectType, []).object);

  static final _id_getUserInfo = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getUserInfo', r'()Ljava/lang/String;');

  /// from: public java.lang.String getUserInfo()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getUserInfo() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getUserInfo, jni.JniCallType.objectType, []).object);

  static final _id_getAuthority = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getAuthority', r'()Ljava/lang/String;');

  /// from: public java.lang.String getAuthority()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getAuthority() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getAuthority, jni.JniCallType.objectType, []).object);

  static final _id_getPort =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getPort', r'()I');

  /// from: public int getPort()
  int getPort() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getPort, jni.JniCallType.intType, []).integer;

  static final _id_getDefaultPort = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getDefaultPort', r'()I');

  /// from: public int getDefaultPort()
  int getDefaultPort() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getDefaultPort, jni.JniCallType.intType, []).integer;

  static final _id_getProtocol = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getProtocol', r'()Ljava/lang/String;');

  /// from: public java.lang.String getProtocol()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getProtocol() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getProtocol, jni.JniCallType.objectType, []).object);

  static final _id_getHost = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getHost', r'()Ljava/lang/String;');

  /// from: public java.lang.String getHost()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getHost() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getHost, jni.JniCallType.objectType, []).object);

  static final _id_getFile = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getFile', r'()Ljava/lang/String;');

  /// from: public java.lang.String getFile()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getFile() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getFile, jni.JniCallType.objectType, []).object);

  static final _id_getRef = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getRef', r'()Ljava/lang/String;');

  /// from: public java.lang.String getRef()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getRef() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getRef, jni.JniCallType.objectType, []).object);

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'equals', r'(Ljava/lang/Object;)Z');

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'hashCode', r'()I');

  /// from: public int hashCode()
  int hashCode1() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;

  static final _id_sameFile = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'sameFile', r'(Ljava/net/URL;)Z');

  /// from: public boolean sameFile(java.net.URL uRL)
  bool sameFile(
    URL uRL,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_sameFile,
        jni.JniCallType.booleanType, [uRL.reference]).boolean;

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'toString', r'()Ljava/lang/String;');

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString toString1() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);

  static final _id_toExternalForm = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'toExternalForm', r'()Ljava/lang/String;');

  /// from: public java.lang.String toExternalForm()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString toExternalForm() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toExternalForm, jni.JniCallType.objectType, []).object);

  static final _id_toURI = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'toURI', r'()Ljava/net/URI;');

  /// from: public java.net.URI toURI()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject toURI() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toURI, jni.JniCallType.objectType, []).object);

  static final _id_openConnection = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'openConnection', r'()Ljava/net/URLConnection;');

  /// from: public java.net.URLConnection openConnection()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject openConnection() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_openConnection, jni.JniCallType.objectType, []).object);

  static final _id_openConnection1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'openConnection',
      r'(Ljava/net/Proxy;)Ljava/net/URLConnection;');

  /// from: public java.net.URLConnection openConnection(java.net.Proxy proxy)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject openConnection1(
    jni.JObject proxy,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openConnection1,
        jni.JniCallType.objectType,
        [proxy.reference]).object);

  static final _id_openStream = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'openStream', r'()Ljava/io/InputStream;');

  /// from: public java.io.InputStream openStream()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject openStream() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_openStream, jni.JniCallType.objectType, []).object);

  static final _id_getContent = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getContent', r'()Ljava/lang/Object;');

  /// from: public java.lang.Object getContent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject getContent() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getContent, jni.JniCallType.objectType, []).object);

  static final _id_getContent1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'getContent',
      r'([Ljava/lang/Class;)Ljava/lang/Object;');

  /// from: public java.lang.Object getContent(java.lang.Class[] classs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject getContent1(
    jni.JArray<jni.JObject> classs,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getContent1,
        jni.JniCallType.objectType,
        [classs.reference]).object);

  static final _id_setURLStreamHandlerFactory = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r'setURLStreamHandlerFactory',
          r'(Ljava/net/URLStreamHandlerFactory;)V');

  /// from: static public void setURLStreamHandlerFactory(java.net.URLStreamHandlerFactory uRLStreamHandlerFactory)
  static void setURLStreamHandlerFactory(
    jni.JObject uRLStreamHandlerFactory,
  ) => jni.Jni.accessors.callStaticMethodWithArgs(
        _class.reference,
        _id_setURLStreamHandlerFactory,
        jni.JniCallType.voidType,
        [uRLStreamHandlerFactory.reference]).check();
}

class $URLType extends jni.JObjType<URL> {
  const $URLType();

  @override
  String get signature => r'Ljava/net/URL;';

  @override
  URL fromRef(jni.JObjectPtr ref) => URL.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($URLType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $URLType && other is $URLType;
}

/// from: java.nio.Buffer
class Buffer extends jni.JObject {
  @override
  late final jni.JObjType<Buffer> $type = type;

  Buffer.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'java/nio/Buffer');

  /// The type which includes information such as the signature of this class.
  static const type = $BufferType();
  static final _id_capacity =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'capacity', r'()I');

  /// from: public final int capacity()
  int capacity() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_capacity, jni.JniCallType.intType, []).integer;

  static final _id_position =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'position', r'()I');

  /// from: public final int position()
  int position() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_position, jni.JniCallType.intType, []).integer;

  static final _id_position1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'position', r'(I)Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer position(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer position1(
    int i,
  ) => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_position1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);

  static final _id_limit =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'limit', r'()I');

  /// from: public final int limit()
  int limit() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_limit, jni.JniCallType.intType, []).integer;

  static final _id_limit1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'limit', r'(I)Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer limit(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer limit1(
    int i,
  ) => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_limit1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);

  static final _id_mark = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'mark', r'()Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer mark()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer mark() => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_mark, jni.JniCallType.objectType, []).object);

  static final _id_reset = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'reset', r'()Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer reset()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer reset() => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_reset, jni.JniCallType.objectType, []).object);

  static final _id_clear = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'clear', r'()Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer clear()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer clear() => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clear, jni.JniCallType.objectType, []).object);

  static final _id_flip = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'flip', r'()Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer flip()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer flip() => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flip, jni.JniCallType.objectType, []).object);

  static final _id_rewind = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'rewind', r'()Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer rewind()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer rewind() => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_rewind, jni.JniCallType.objectType, []).object);

  static final _id_remaining =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'remaining', r'()I');

  /// from: public final int remaining()
  int remaining() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_remaining, jni.JniCallType.intType, []).integer;

  static final _id_hasRemaining = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'hasRemaining', r'()Z');

  /// from: public final boolean hasRemaining()
  bool hasRemaining() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hasRemaining, jni.JniCallType.booleanType, []).boolean;

  static final _id_isReadOnly =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'isReadOnly', r'()Z');

  /// from: public abstract boolean isReadOnly()
  bool isReadOnly() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isReadOnly, jni.JniCallType.booleanType, []).boolean;

  static final _id_hasArray =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'hasArray', r'()Z');

  /// from: public abstract boolean hasArray()
  bool hasArray() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hasArray, jni.JniCallType.booleanType, []).boolean;

  static final _id_array = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'array', r'()Ljava/lang/Object;');

  /// from: public abstract java.lang.Object array()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject array() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_array, jni.JniCallType.objectType, []).object);

  static final _id_arrayOffset =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'arrayOffset', r'()I');

  /// from: public abstract int arrayOffset()
  int arrayOffset() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_arrayOffset, jni.JniCallType.intType, []).integer;

  static final _id_isDirect =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'isDirect', r'()Z');

  /// from: public abstract boolean isDirect()
  bool isDirect() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isDirect, jni.JniCallType.booleanType, []).boolean;
}

class $BufferType extends jni.JObjType<Buffer> {
  const $BufferType();

  @override
  String get signature => r'Ljava/nio/Buffer;';

  @override
  Buffer fromRef(jni.JObjectPtr ref) => Buffer.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BufferType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $BufferType && other is $BufferType;
}

/// from: java.nio.ByteBuffer
class ByteBuffer extends Buffer {
  @override
  late final jni.JObjType<ByteBuffer> $type = type;

  ByteBuffer.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'java/nio/ByteBuffer');

  /// The type which includes information such as the signature of this class.
  static const type = $ByteBufferType();
  static final _id_allocateDirect = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r'allocateDirect', r'(I)Ljava/nio/ByteBuffer;');

  /// from: static public java.nio.ByteBuffer allocateDirect(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ByteBuffer allocateDirect(
    int i,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_allocateDirect,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_allocate = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r'allocate', r'(I)Ljava/nio/ByteBuffer;');

  /// from: static public java.nio.ByteBuffer allocate(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ByteBuffer allocate(
    int i,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_allocate,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_wrap = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r'wrap', r'([BII)Ljava/nio/ByteBuffer;');

  /// from: static public java.nio.ByteBuffer wrap(byte[] bs, int i, int i1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ByteBuffer wrap(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_wrap,
            jni.JniCallType.objectType,
            [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);

  static final _id_wrap1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference, r'wrap', r'([B)Ljava/nio/ByteBuffer;');

  /// from: static public java.nio.ByteBuffer wrap(byte[] bs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static ByteBuffer wrap1(
    jni.JArray<jni.jbyte> bs,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_wrap1,
            jni.JniCallType.objectType, [bs.reference]).object);

  static final _id_slice = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'slice', r'()Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer slice()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer slice() => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_slice, jni.JniCallType.objectType, []).object);

  static final _id_duplicate = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'duplicate', r'()Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer duplicate()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer duplicate() => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_duplicate, jni.JniCallType.objectType, []).object);

  static final _id_asReadOnlyBuffer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'asReadOnlyBuffer', r'()Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer asReadOnlyBuffer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer asReadOnlyBuffer() => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_asReadOnlyBuffer,
        jni.JniCallType.objectType, []).object);

  static final _id_get0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'get', r'()B');

  /// from: public abstract byte get()
  int get0() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_get0, jni.JniCallType.byteType, []).byte;

  static final _id_put = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'put', r'(B)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer put(byte b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer put(
    int b,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_put,
        jni.JniCallType.objectType,
        [jni.JValueByte(b)]).object);

  static final _id_get1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'get', r'(I)B');

  /// from: public abstract byte get(int i)
  int get1(
    int i,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_get1, jni.JniCallType.byteType, [jni.JValueInt(i)]).byte;

  static final _id_put1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'put', r'(IB)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer put(int i, byte b)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer put1(
    int i,
    int b,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_put1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i), jni.JValueByte(b)]).object);

  static final _id_get2 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'get', r'([BII)Ljava/nio/ByteBuffer;');

  /// from: public java.nio.ByteBuffer get(byte[] bs, int i, int i1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer get2(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get2,
        jni.JniCallType.objectType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);

  static final _id_get3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'get', r'([B)Ljava/nio/ByteBuffer;');

  /// from: public java.nio.ByteBuffer get(byte[] bs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer get3(
    jni.JArray<jni.jbyte> bs,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_get3,
        jni.JniCallType.objectType,
        [bs.reference]).object);

  static final _id_put2 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'put', r'(Ljava/nio/ByteBuffer;)Ljava/nio/ByteBuffer;');

  /// from: public java.nio.ByteBuffer put(java.nio.ByteBuffer byteBuffer)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer put2(
    ByteBuffer byteBuffer,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_put2,
        jni.JniCallType.objectType,
        [byteBuffer.reference]).object);

  static final _id_put3 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'put', r'([BII)Ljava/nio/ByteBuffer;');

  /// from: public java.nio.ByteBuffer put(byte[] bs, int i, int i1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer put3(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_put3,
        jni.JniCallType.objectType,
        [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);

  static final _id_put4 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'put', r'([B)Ljava/nio/ByteBuffer;');

  /// from: public final java.nio.ByteBuffer put(byte[] bs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer put4(
    jni.JArray<jni.jbyte> bs,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_put4,
        jni.JniCallType.objectType,
        [bs.reference]).object);

  static final _id_hasArray =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'hasArray', r'()Z');

  /// from: public final boolean hasArray()
  bool hasArray() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hasArray, jni.JniCallType.booleanType, []).boolean;

  static final _id_array1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'array', r'()[B');

  /// from: public final byte[] array()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JArray<jni.jbyte> array1() => const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_array1, jni.JniCallType.objectType, []).object);

  static final _id_arrayOffset =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'arrayOffset', r'()I');

  /// from: public final int arrayOffset()
  int arrayOffset() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_arrayOffset, jni.JniCallType.intType, []).integer;

  static final _id_position1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'position', r'(I)Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer position(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer position1(
    int i,
  ) => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_position1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);

  static final _id_limit1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'limit', r'(I)Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer limit(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer limit1(
    int i,
  ) => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_limit1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);

  static final _id_mark = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'mark', r'()Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer mark()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer mark() => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_mark, jni.JniCallType.objectType, []).object);

  static final _id_reset = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'reset', r'()Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer reset()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer reset() => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_reset, jni.JniCallType.objectType, []).object);

  static final _id_clear = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'clear', r'()Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer clear()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer clear() => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_clear, jni.JniCallType.objectType, []).object);

  static final _id_flip = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'flip', r'()Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer flip()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer flip() => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_flip, jni.JniCallType.objectType, []).object);

  static final _id_rewind = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'rewind', r'()Ljava/nio/Buffer;');

  /// from: public java.nio.Buffer rewind()
  /// The returned object must be deleted after use, by calling the `delete` method.
  Buffer rewind() => const $BufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_rewind, jni.JniCallType.objectType, []).object);

  static final _id_compact = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'compact', r'()Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer compact()
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer compact() => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_compact, jni.JniCallType.objectType, []).object);

  static final _id_isDirect =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'isDirect', r'()Z');

  /// from: public abstract boolean isDirect()
  bool isDirect() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isDirect, jni.JniCallType.booleanType, []).boolean;

  static final _id_toString1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'toString', r'()Ljava/lang/String;');

  /// from: public java.lang.String toString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString toString1() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_toString1, jni.JniCallType.objectType, []).object);

  static final _id_hashCode1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'hashCode', r'()I');

  /// from: public int hashCode()
  int hashCode1() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_hashCode1, jni.JniCallType.intType, []).integer;

  static final _id_equals1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'equals', r'(Ljava/lang/Object;)Z');

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_equals1,
        jni.JniCallType.booleanType, [object.reference]).boolean;

  static final _id_compareTo = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'compareTo', r'(Ljava/nio/ByteBuffer;)I');

  /// from: public int compareTo(java.nio.ByteBuffer byteBuffer)
  int compareTo(
    ByteBuffer byteBuffer,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_compareTo,
        jni.JniCallType.intType, [byteBuffer.reference]).integer;

  static final _id_order = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'order', r'()Ljava/nio/ByteOrder;');

  /// from: public final java.nio.ByteOrder order()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject order() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_order, jni.JniCallType.objectType, []).object);

  static final _id_order1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'order', r'(Ljava/nio/ByteOrder;)Ljava/nio/ByteBuffer;');

  /// from: public final java.nio.ByteBuffer order(java.nio.ByteOrder byteOrder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer order1(
    jni.JObject byteOrder,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_order1,
        jni.JniCallType.objectType,
        [byteOrder.reference]).object);

  static final _id_alignmentOffset = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'alignmentOffset', r'(II)I');

  /// from: public final int alignmentOffset(int i, int i1)
  int alignmentOffset(
    int i,
    int i1,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_alignmentOffset,
        jni.JniCallType.intType, [jni.JValueInt(i), jni.JValueInt(i1)]).integer;

  static final _id_alignedSlice = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'alignedSlice', r'(I)Ljava/nio/ByteBuffer;');

  /// from: public final java.nio.ByteBuffer alignedSlice(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer alignedSlice(
    int i,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_alignedSlice,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);

  static final _id_getChar =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getChar', r'()C');

  /// from: public abstract char getChar()
  int getChar() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getChar, jni.JniCallType.charType, []).char;

  static final _id_putChar = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'putChar', r'(C)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putChar(char c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putChar(
    int c,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_putChar,
        jni.JniCallType.objectType,
        [jni.JValueChar(c)]).object);

  static final _id_getChar1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getChar', r'(I)C');

  /// from: public abstract char getChar(int i)
  int getChar1(
    int i,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_getChar1,
        jni.JniCallType.charType, [jni.JValueInt(i)]).char;

  static final _id_putChar1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'putChar', r'(IC)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putChar(int i, char c)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putChar1(
    int i,
    int c,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_putChar1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i), jni.JValueChar(c)]).object);

  static final _id_asCharBuffer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'asCharBuffer', r'()Ljava/nio/CharBuffer;');

  /// from: public abstract java.nio.CharBuffer asCharBuffer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject asCharBuffer() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_asCharBuffer, jni.JniCallType.objectType, []).object);

  static final _id_getShort =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getShort', r'()S');

  /// from: public abstract short getShort()
  int getShort() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getShort, jni.JniCallType.shortType, []).short;

  static final _id_putShort = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'putShort', r'(S)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putShort(short s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putShort(
    int s,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_putShort,
        jni.JniCallType.objectType,
        [jni.JValueShort(s)]).object);

  static final _id_getShort1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getShort', r'(I)S');

  /// from: public abstract short getShort(int i)
  int getShort1(
    int i,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_getShort1,
        jni.JniCallType.shortType, [jni.JValueInt(i)]).short;

  static final _id_putShort1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'putShort', r'(IS)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putShort(int i, short s)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putShort1(
    int i,
    int s,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_putShort1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i), jni.JValueShort(s)]).object);

  static final _id_asShortBuffer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'asShortBuffer', r'()Ljava/nio/ShortBuffer;');

  /// from: public abstract java.nio.ShortBuffer asShortBuffer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject asShortBuffer() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_asShortBuffer, jni.JniCallType.objectType, []).object);

  static final _id_getInt =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getInt', r'()I');

  /// from: public abstract int getInt()
  int getInt() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getInt, jni.JniCallType.intType, []).integer;

  static final _id_putInt = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'putInt', r'(I)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putInt(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putInt(
    int i,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_putInt,
        jni.JniCallType.objectType,
        [jni.JValueInt(i)]).object);

  static final _id_getInt1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getInt', r'(I)I');

  /// from: public abstract int getInt(int i)
  int getInt1(
    int i,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_getInt1,
        jni.JniCallType.intType, [jni.JValueInt(i)]).integer;

  static final _id_putInt1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'putInt', r'(II)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putInt(int i, int i1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putInt1(
    int i,
    int i1,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_putInt1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).object);

  static final _id_asIntBuffer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'asIntBuffer', r'()Ljava/nio/IntBuffer;');

  /// from: public abstract java.nio.IntBuffer asIntBuffer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject asIntBuffer() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_asIntBuffer, jni.JniCallType.objectType, []).object);

  static final _id_getLong =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getLong', r'()J');

  /// from: public abstract long getLong()
  int getLong() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getLong, jni.JniCallType.longType, []).long;

  static final _id_putLong = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'putLong', r'(J)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putLong(long j)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putLong(
    int j,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_putLong, jni.JniCallType.objectType, [j]).object);

  static final _id_getLong1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getLong', r'(I)J');

  /// from: public abstract long getLong(int i)
  int getLong1(
    int i,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_getLong1,
        jni.JniCallType.longType, [jni.JValueInt(i)]).long;

  static final _id_putLong1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'putLong', r'(IJ)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putLong(int i, long j)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putLong1(
    int i,
    int j,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_putLong1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i), j]).object);

  static final _id_asLongBuffer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'asLongBuffer', r'()Ljava/nio/LongBuffer;');

  /// from: public abstract java.nio.LongBuffer asLongBuffer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject asLongBuffer() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_asLongBuffer, jni.JniCallType.objectType, []).object);

  static final _id_getFloat =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getFloat', r'()F');

  /// from: public abstract float getFloat()
  double getFloat() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getFloat, jni.JniCallType.floatType, []).float;

  static final _id_putFloat = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'putFloat', r'(F)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putFloat(float f)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putFloat(
    double f,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_putFloat,
        jni.JniCallType.objectType,
        [jni.JValueFloat(f)]).object);

  static final _id_getFloat1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getFloat', r'(I)F');

  /// from: public abstract float getFloat(int i)
  double getFloat1(
    int i,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_getFloat1,
        jni.JniCallType.floatType, [jni.JValueInt(i)]).float;

  static final _id_putFloat1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'putFloat', r'(IF)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putFloat(int i, float f)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putFloat1(
    int i,
    double f,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_putFloat1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i), jni.JValueFloat(f)]).object);

  static final _id_asFloatBuffer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'asFloatBuffer', r'()Ljava/nio/FloatBuffer;');

  /// from: public abstract java.nio.FloatBuffer asFloatBuffer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject asFloatBuffer() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_asFloatBuffer, jni.JniCallType.objectType, []).object);

  static final _id_getDouble =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getDouble', r'()D');

  /// from: public abstract double getDouble()
  double getDouble() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getDouble, jni.JniCallType.doubleType, []).doubleFloat;

  static final _id_putDouble = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'putDouble', r'(D)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putDouble(double d)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putDouble(
    double d,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_putDouble, jni.JniCallType.objectType, [d]).object);

  static final _id_getDouble1 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'getDouble', r'(I)D');

  /// from: public abstract double getDouble(int i)
  double getDouble1(
    int i,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_getDouble1,
        jni.JniCallType.doubleType, [jni.JValueInt(i)]).doubleFloat;

  static final _id_putDouble1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'putDouble', r'(ID)Ljava/nio/ByteBuffer;');

  /// from: public abstract java.nio.ByteBuffer putDouble(int i, double d)
  /// The returned object must be deleted after use, by calling the `delete` method.
  ByteBuffer putDouble1(
    int i,
    double d,
  ) => const $ByteBufferType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_putDouble1,
        jni.JniCallType.objectType,
        [jni.JValueInt(i), d]).object);

  static final _id_asDoubleBuffer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'asDoubleBuffer', r'()Ljava/nio/DoubleBuffer;');

  /// from: public abstract java.nio.DoubleBuffer asDoubleBuffer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject asDoubleBuffer() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_asDoubleBuffer, jni.JniCallType.objectType, []).object);

  static final _id_array = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'array', r'()Ljava/lang/Object;');

  /// from: public java.lang.Object array()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject array() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_array, jni.JniCallType.objectType, []).object);

  static final _id_compareTo1 = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'compareTo', r'(Ljava/lang/Object;)I');

  /// from: public int compareTo(java.lang.Object object)
  int compareTo1(
    jni.JObject object,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_compareTo1,
        jni.JniCallType.intType, [object.reference]).integer;
}

class $ByteBufferType extends jni.JObjType<ByteBuffer> {
  const $ByteBufferType();

  @override
  String get signature => r'Ljava/nio/ByteBuffer;';

  @override
  ByteBuffer fromRef(jni.JObjectPtr ref) => ByteBuffer.fromRef(ref);

  @override
  jni.JObjType get superType => const $BufferType();

  @override
  final superCount = 2;

  @override
  int get hashCode => ($ByteBufferType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $ByteBufferType && other is $ByteBufferType;
}

/// from: java.util.concurrent.Executors
class Executors extends jni.JObject {
  @override
  late final jni.JObjType<Executors> $type = type;

  Executors.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'java/util/concurrent/Executors');

  /// The type which includes information such as the signature of this class.
  static const type = $ExecutorsType();
  static final _id_newFixedThreadPool = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newFixedThreadPool',
      r'(I)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newFixedThreadPool(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newFixedThreadPool(
    int i,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_newFixedThreadPool,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_newWorkStealingPool = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newWorkStealingPool',
      r'(I)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newWorkStealingPool(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newWorkStealingPool(
    int i,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_newWorkStealingPool,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_newWorkStealingPool1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newWorkStealingPool',
      r'()Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newWorkStealingPool()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newWorkStealingPool1() => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_newWorkStealingPool1,
            jni.JniCallType.objectType, []).object);

  static final _id_newFixedThreadPool1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newFixedThreadPool',
      r'(ILjava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newFixedThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newFixedThreadPool1(
    int i,
    jni.JObject threadFactory,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_newFixedThreadPool1,
            jni.JniCallType.objectType,
            [jni.JValueInt(i), threadFactory.reference]).object);

  static final _id_newSingleThreadExecutor = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r'newSingleThreadExecutor',
          r'()Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newSingleThreadExecutor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newSingleThreadExecutor() => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_newSingleThreadExecutor,
            jni.JniCallType.objectType, []).object);

  static final _id_newSingleThreadExecutor1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newSingleThreadExecutor',
      r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newSingleThreadExecutor(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newSingleThreadExecutor1(
    jni.JObject threadFactory,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_newSingleThreadExecutor1,
            jni.JniCallType.objectType,
            [threadFactory.reference]).object);

  static final _id_newCachedThreadPool = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newCachedThreadPool',
      r'()Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newCachedThreadPool()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newCachedThreadPool() => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_newCachedThreadPool,
            jni.JniCallType.objectType, []).object);

  static final _id_newCachedThreadPool1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newCachedThreadPool',
      r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService newCachedThreadPool(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newCachedThreadPool1(
    jni.JObject threadFactory,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_newCachedThreadPool1,
            jni.JniCallType.objectType, [threadFactory.reference]).object);

  static final _id_newSingleThreadScheduledExecutor = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference,
          r'newSingleThreadScheduledExecutor',
          r'()Ljava/util/concurrent/ScheduledExecutorService;');

  /// from: static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newSingleThreadScheduledExecutor() => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_newSingleThreadScheduledExecutor,
            jni.JniCallType.objectType, []).object);

  static final _id_newSingleThreadScheduledExecutor1 = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference,
          r'newSingleThreadScheduledExecutor',
          r'(Ljava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ScheduledExecutorService;');

  /// from: static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newSingleThreadScheduledExecutor1(
    jni.JObject threadFactory,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_newSingleThreadScheduledExecutor1,
            jni.JniCallType.objectType,
            [threadFactory.reference]).object);

  static final _id_newScheduledThreadPool = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r'newScheduledThreadPool',
          r'(I)Ljava/util/concurrent/ScheduledExecutorService;');

  /// from: static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newScheduledThreadPool(
    int i,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_newScheduledThreadPool,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_newScheduledThreadPool1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'newScheduledThreadPool',
      r'(ILjava/util/concurrent/ThreadFactory;)Ljava/util/concurrent/ScheduledExecutorService;');

  /// from: static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject newScheduledThreadPool1(
    int i,
    jni.JObject threadFactory,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_newScheduledThreadPool1,
            jni.JniCallType.objectType,
            [jni.JValueInt(i), threadFactory.reference]).object);

  static final _id_unconfigurableExecutorService = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r'unconfigurableExecutorService',
          r'(Ljava/util/concurrent/ExecutorService;)Ljava/util/concurrent/ExecutorService;');

  /// from: static public java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService executorService)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject unconfigurableExecutorService(
    jni.JObject executorService,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_unconfigurableExecutorService,
            jni.JniCallType.objectType,
            [executorService.reference]).object);

  static final _id_unconfigurableScheduledExecutorService = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference,
          r'unconfigurableScheduledExecutorService',
          r'(Ljava/util/concurrent/ScheduledExecutorService;)Ljava/util/concurrent/ScheduledExecutorService;');

  /// from: static public java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService scheduledExecutorService)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject unconfigurableScheduledExecutorService(
    jni.JObject scheduledExecutorService,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_unconfigurableScheduledExecutorService,
            jni.JniCallType.objectType,
            [scheduledExecutorService.reference]).object);

  static final _id_defaultThreadFactory = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'defaultThreadFactory',
      r'()Ljava/util/concurrent/ThreadFactory;');

  /// from: static public java.util.concurrent.ThreadFactory defaultThreadFactory()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject defaultThreadFactory() => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_defaultThreadFactory,
            jni.JniCallType.objectType, []).object);

  static final _id_privilegedThreadFactory = jni.Jni.accessors
      .getStaticMethodIDOf(_class.reference, r'privilegedThreadFactory',
          r'()Ljava/util/concurrent/ThreadFactory;');

  /// from: static public java.util.concurrent.ThreadFactory privilegedThreadFactory()
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject privilegedThreadFactory() => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_privilegedThreadFactory,
            jni.JniCallType.objectType, []).object);

  static final _id_callable = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'callable',
      r'(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable callable(java.lang.Runnable runnable, T object)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject callable<$T extends jni.JObject>(
    jni.JObject runnable,
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_callable,
            jni.JniCallType.objectType,
            [runnable.reference, object.reference]).object);
  }

  static final _id_callable1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'callable',
      r'(Ljava/lang/Runnable;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable callable(java.lang.Runnable runnable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject callable1(
    jni.JObject runnable,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_callable1,
            jni.JniCallType.objectType, [runnable.reference]).object);

  static final _id_callable2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'callable',
      r'(Ljava/security/PrivilegedAction;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable callable(java.security.PrivilegedAction privilegedAction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject callable2(
    jni.JObject privilegedAction,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_callable2,
            jni.JniCallType.objectType, [privilegedAction.reference]).object);

  static final _id_callable3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'callable',
      r'(Ljava/security/PrivilegedExceptionAction;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable callable(java.security.PrivilegedExceptionAction privilegedExceptionAction)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject callable3(
    jni.JObject privilegedExceptionAction,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_callable3,
            jni.JniCallType.objectType,
            [privilegedExceptionAction.reference]).object);

  static final _id_privilegedCallable = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'privilegedCallable',
      r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable privilegedCallable(java.util.concurrent.Callable callable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject privilegedCallable<$T extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$T> T,
  }) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_privilegedCallable,
            jni.JniCallType.objectType, [callable.reference]).object);

  static final _id_privilegedCallableUsingCurrentClassLoader = jni.Jni.accessors
      .getStaticMethodIDOf(
          _class.reference,
          r'privilegedCallableUsingCurrentClassLoader',
          r'(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Callable;');

  /// from: static public java.util.concurrent.Callable privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable callable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject
      privilegedCallableUsingCurrentClassLoader<$T extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$T> T,
  }) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_privilegedCallableUsingCurrentClassLoader,
            jni.JniCallType.objectType,
            [callable.reference]).object);
}

class $ExecutorsType extends jni.JObjType<Executors> {
  const $ExecutorsType();

  @override
  String get signature => r'Ljava/util/concurrent/Executors;';

  @override
  Executors fromRef(jni.JObjectPtr ref) => Executors.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExecutorsType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $ExecutorsType && other is $ExecutorsType;
}

/// from: org.chromium.net.CronetEngine$Builder$LibraryLoader
class CronetEngine_Builder_LibraryLoader extends jni.JObject {
  @override
  late final jni.JObjType<CronetEngine_Builder_LibraryLoader> $type = type;

  CronetEngine_Builder_LibraryLoader.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(
      r'org/chromium/net/CronetEngine$Builder$LibraryLoader');

  /// The type which includes information such as the signature of this class.
  static const type = $CronetEngine_Builder_LibraryLoaderType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory CronetEngine_Builder_LibraryLoader() => CronetEngine_Builder_LibraryLoader.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_loadLibrary = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'loadLibrary', r'(Ljava/lang/String;)V');

  /// from: public abstract void loadLibrary(java.lang.String string)
  void loadLibrary(
    jni.JString string,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_loadLibrary,
        jni.JniCallType.voidType, [string.reference]).check();
}

class $CronetEngine_Builder_LibraryLoaderType
    extends jni.JObjType<CronetEngine_Builder_LibraryLoader> {
  const $CronetEngine_Builder_LibraryLoaderType();

  @override
  String get signature =>
      r'Lorg/chromium/net/CronetEngine$Builder$LibraryLoader;';

  @override
  CronetEngine_Builder_LibraryLoader fromRef(jni.JObjectPtr ref) =>
      CronetEngine_Builder_LibraryLoader.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CronetEngine_Builder_LibraryLoaderType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $CronetEngine_Builder_LibraryLoaderType &&
        other is $CronetEngine_Builder_LibraryLoaderType;
}

/// from: org.chromium.net.CronetEngine$Builder
class CronetEngine_Builder extends jni.JObject {
  @override
  late final jni.JObjType<CronetEngine_Builder> $type = type;

  CronetEngine_Builder.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/CronetEngine$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $CronetEngine_BuilderType();
  static final _id_mBuilderDelegate = jni.Jni.accessors.getFieldIDOf(
    _class.reference,
    r'mBuilderDelegate',
    r'Lorg/chromium/net/ICronetEngineBuilder;',
  );

  /// from: protected final org.chromium.net.ICronetEngineBuilder mBuilderDelegate
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject get mBuilderDelegate =>
      const jni.JObjectType().fromRef(jni.Jni.accessors
          .getField(reference, _id_mBuilderDelegate, jni.JniCallType.objectType)
          .object);

  /// from: static public final int HTTP_CACHE_DISABLED
  static const HTTP_CACHE_DISABLED = 0;

  /// from: static public final int HTTP_CACHE_IN_MEMORY
  static const HTTP_CACHE_IN_MEMORY = 1;

  /// from: static public final int HTTP_CACHE_DISK_NO_HTTP
  static const HTTP_CACHE_DISK_NO_HTTP = 2;

  /// from: static public final int HTTP_CACHE_DISK
  static const HTTP_CACHE_DISK = 3;

  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'<init>', r'(Landroid/content/Context;)V');

  /// from: public void <init>(android.content.Context context)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory CronetEngine_Builder(
    jni.JObject context,
  ) => CronetEngine_Builder.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new0, [context.reference]).object);

  static final _id_new1 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'<init>', r'(Lorg/chromium/net/ICronetEngineBuilder;)V');

  /// from: public void <init>(org.chromium.net.ICronetEngineBuilder iCronetEngineBuilder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory CronetEngine_Builder.new1(
    jni.JObject iCronetEngineBuilder,
  ) => CronetEngine_Builder.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference, _id_new1, [iCronetEngineBuilder.reference]).object);

  static final _id_getDefaultUserAgent = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getDefaultUserAgent', r'()Ljava/lang/String;');

  /// from: public java.lang.String getDefaultUserAgent()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getDefaultUserAgent() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getDefaultUserAgent,
        jni.JniCallType.objectType, []).object);

  static final _id_setUserAgent = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setUserAgent',
      r'(Ljava/lang/String;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setUserAgent(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder setUserAgent(
    jni.JString string,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setUserAgent,
            jni.JniCallType.objectType, [string.reference]).object);

  static final _id_setStoragePath = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setStoragePath',
      r'(Ljava/lang/String;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setStoragePath(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder setStoragePath(
    jni.JString string,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setStoragePath,
            jni.JniCallType.objectType, [string.reference]).object);

  static final _id_setLibraryLoader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setLibraryLoader',
      r'(Lorg/chromium/net/CronetEngine$Builder$LibraryLoader;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setLibraryLoader(org.chromium.net.CronetEngine$Builder$LibraryLoader libraryLoader)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder setLibraryLoader(
    CronetEngine_Builder_LibraryLoader libraryLoader,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setLibraryLoader,
            jni.JniCallType.objectType, [libraryLoader.reference]).object);

  static final _id_enableQuic = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'enableQuic',
      r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableQuic(boolean z)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder enableQuic(
    bool z,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_enableQuic,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);

  static final _id_enableHttp2 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'enableHttp2',
      r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableHttp2(boolean z)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder enableHttp2(
    bool z,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_enableHttp2,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);

  static final _id_enableSdch = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'enableSdch',
      r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableSdch(boolean z)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder enableSdch(
    bool z,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_enableSdch,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);

  static final _id_enableBrotli = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'enableBrotli',
      r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableBrotli(boolean z)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder enableBrotli(
    bool z,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_enableBrotli,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);

  static final _id_enableHttpCache = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'enableHttpCache',
      r'(IJ)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableHttpCache(int i, long j)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder enableHttpCache(
    int i,
    int j,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_enableHttpCache,
            jni.JniCallType.objectType, [jni.JValueInt(i), j]).object);

  static final _id_addQuicHint = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'addQuicHint',
      r'(Ljava/lang/String;II)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder addQuicHint(java.lang.String string, int i, int i1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder addQuicHint(
    jni.JString string,
    int i,
    int i1,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addQuicHint,
            jni.JniCallType.objectType,
            [string.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);

  static final _id_addPublicKeyPins = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'addPublicKeyPins',
      r'(Ljava/lang/String;Ljava/util/Set;ZLjava/util/Date;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder addPublicKeyPins(java.lang.String string, java.util.Set set, boolean z, java.util.Date date)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder addPublicKeyPins(
    jni.JString string,
    jni.JSet<jni.JArray<jni.jbyte>> set0,
    bool z,
    jni.JObject date,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_addPublicKeyPins, jni.JniCallType.objectType, [
      string.reference,
      set0.reference,
      z ? 1 : 0,
      date.reference
    ]).object);

  static final _id_enablePublicKeyPinningBypassForLocalTrustAnchors =
      jni.Jni.accessors.getMethodIDOf(
          _class.reference,
          r'enablePublicKeyPinningBypassForLocalTrustAnchors',
          r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enablePublicKeyPinningBypassForLocalTrustAnchors(boolean z)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder enablePublicKeyPinningBypassForLocalTrustAnchors(
    bool z,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_enablePublicKeyPinningBypassForLocalTrustAnchors,
            jni.JniCallType.objectType,
            [z ? 1 : 0]).object);

  static final _id_setThreadPriority = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setThreadPriority',
      r'(I)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setThreadPriority(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder setThreadPriority(
    int i,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setThreadPriority,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_enableNetworkQualityEstimator = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'enableNetworkQualityEstimator',
          r'(Z)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder enableNetworkQualityEstimator(boolean z)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder enableNetworkQualityEstimator(
    bool z,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_enableNetworkQualityEstimator,
            jni.JniCallType.objectType, [z ? 1 : 0]).object);

  static final _id_setQuicOptions = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setQuicOptions',
      r'(Lorg/chromium/net/QuicOptions;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setQuicOptions(org.chromium.net.QuicOptions quicOptions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder setQuicOptions(
    jni.JObject quicOptions,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setQuicOptions,
            jni.JniCallType.objectType, [quicOptions.reference]).object);

  static final _id_setQuicOptions1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setQuicOptions',
      r'(Lorg/chromium/net/QuicOptions$Builder;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setQuicOptions(org.chromium.net.QuicOptions$Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder setQuicOptions1(
    jni.JObject builder,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setQuicOptions1,
            jni.JniCallType.objectType, [builder.reference]).object);

  static final _id_setDnsOptions = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setDnsOptions',
      r'(Lorg/chromium/net/DnsOptions;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setDnsOptions(org.chromium.net.DnsOptions dnsOptions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder setDnsOptions(
    jni.JObject dnsOptions,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setDnsOptions,
            jni.JniCallType.objectType, [dnsOptions.reference]).object);

  static final _id_setDnsOptions1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setDnsOptions',
      r'(Lorg/chromium/net/DnsOptions$Builder;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setDnsOptions(org.chromium.net.DnsOptions$Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder setDnsOptions1(
    jni.JObject builder,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setDnsOptions1,
            jni.JniCallType.objectType, [builder.reference]).object);

  static final _id_setConnectionMigrationOptions = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setConnectionMigrationOptions',
      r'(Lorg/chromium/net/ConnectionMigrationOptions;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setConnectionMigrationOptions(org.chromium.net.ConnectionMigrationOptions connectionMigrationOptions)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder setConnectionMigrationOptions(
    jni.JObject connectionMigrationOptions,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_setConnectionMigrationOptions,
            jni.JniCallType.objectType,
            [connectionMigrationOptions.reference]).object);

  static final _id_setConnectionMigrationOptions1 = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setConnectionMigrationOptions',
      r'(Lorg/chromium/net/ConnectionMigrationOptions$Builder;)Lorg/chromium/net/CronetEngine$Builder;');

  /// from: public org.chromium.net.CronetEngine$Builder setConnectionMigrationOptions(org.chromium.net.ConnectionMigrationOptions$Builder builder)
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine_Builder setConnectionMigrationOptions1(
    jni.JObject builder,
  ) => const $CronetEngine_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setConnectionMigrationOptions1,
            jni.JniCallType.objectType, [builder.reference]).object);

  static final _id_build = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'build', r'()Lorg/chromium/net/CronetEngine;');

  /// from: public org.chromium.net.CronetEngine build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  CronetEngine build() => const $CronetEngineType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_build, jni.JniCallType.objectType, []).object);
}

class $CronetEngine_BuilderType extends jni.JObjType<CronetEngine_Builder> {
  const $CronetEngine_BuilderType();

  @override
  String get signature => r'Lorg/chromium/net/CronetEngine$Builder;';

  @override
  CronetEngine_Builder fromRef(jni.JObjectPtr ref) =>
      CronetEngine_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CronetEngine_BuilderType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $CronetEngine_BuilderType &&
        other is $CronetEngine_BuilderType;
}

/// from: org.chromium.net.CronetEngine
class CronetEngine extends jni.JObject {
  @override
  late final jni.JObjType<CronetEngine> $type = type;

  CronetEngine.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'org/chromium/net/CronetEngine');

  /// The type which includes information such as the signature of this class.
  static const type = $CronetEngineType();

  /// from: static public final int ACTIVE_REQUEST_COUNT_UNKNOWN
  static const ACTIVE_REQUEST_COUNT_UNKNOWN = -1;

  /// from: static public final int CONNECTION_METRIC_UNKNOWN
  static const CONNECTION_METRIC_UNKNOWN = -1;

  /// from: static public final int EFFECTIVE_CONNECTION_TYPE_UNKNOWN
  static const EFFECTIVE_CONNECTION_TYPE_UNKNOWN = 0;

  /// from: static public final int EFFECTIVE_CONNECTION_TYPE_OFFLINE
  static const EFFECTIVE_CONNECTION_TYPE_OFFLINE = 1;

  /// from: static public final int EFFECTIVE_CONNECTION_TYPE_SLOW_2G
  static const EFFECTIVE_CONNECTION_TYPE_SLOW_2G = 2;

  /// from: static public final int EFFECTIVE_CONNECTION_TYPE_2G
  static const EFFECTIVE_CONNECTION_TYPE_2G = 3;

  /// from: static public final int EFFECTIVE_CONNECTION_TYPE_3G
  static const EFFECTIVE_CONNECTION_TYPE_3G = 4;

  /// from: static public final int EFFECTIVE_CONNECTION_TYPE_4G
  static const EFFECTIVE_CONNECTION_TYPE_4G = 5;

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory CronetEngine() => CronetEngine.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_getVersionString = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getVersionString', r'()Ljava/lang/String;');

  /// from: public abstract java.lang.String getVersionString()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getVersionString() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getVersionString,
        jni.JniCallType.objectType, []).object);

  static final _id_shutdown =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'shutdown', r'()V');

  /// from: public abstract void shutdown()
  void shutdown() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_shutdown, jni.JniCallType.voidType, []).check();

  static final _id_startNetLogToFile = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'startNetLogToFile', r'(Ljava/lang/String;Z)V');

  /// from: public abstract void startNetLogToFile(java.lang.String string, boolean z)
  void startNetLogToFile(
    jni.JString string,
    bool z,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_startNetLogToFile,
        jni.JniCallType.voidType,
        [string.reference, z ? 1 : 0]).check();

  static final _id_stopNetLog =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'stopNetLog', r'()V');

  /// from: public abstract void stopNetLog()
  void stopNetLog() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_stopNetLog, jni.JniCallType.voidType, []).check();

  static final _id_getGlobalMetricsDeltas = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getGlobalMetricsDeltas', r'()[B');

  /// from: public abstract byte[] getGlobalMetricsDeltas()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JArray<jni.jbyte> getGlobalMetricsDeltas() => const jni.JArrayType(jni.jbyteType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getGlobalMetricsDeltas,
            jni.JniCallType.objectType, []).object);

  static final _id_openConnection = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'openConnection',
      r'(Ljava/net/URL;)Ljava/net/URLConnection;');

  /// from: public abstract java.net.URLConnection openConnection(java.net.URL uRL)
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject openConnection(
    URL uRL,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_openConnection,
        jni.JniCallType.objectType,
        [uRL.reference]).object);

  static final _id_createURLStreamHandlerFactory = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'createURLStreamHandlerFactory',
          r'()Ljava/net/URLStreamHandlerFactory;');

  /// from: public abstract java.net.URLStreamHandlerFactory createURLStreamHandlerFactory()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JObject createURLStreamHandlerFactory() => const jni.JObjectType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_createURLStreamHandlerFactory,
        jni.JniCallType.objectType, []).object);

  static final _id_newUrlRequestBuilder = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'newUrlRequestBuilder',
      r'(Ljava/lang/String;Lorg/chromium/net/UrlRequest$Callback;Ljava/util/concurrent/Executor;)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder newUrlRequestBuilder(java.lang.String string, org.chromium.net.UrlRequest$Callback callback, java.util.concurrent.Executor executor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder newUrlRequestBuilder(
    jni.JString string,
    UrlRequest_Callback callback,
    jni.JObject executor,
  ) => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_newUrlRequestBuilder,
            jni.JniCallType.objectType,
            [string.reference, callback.reference, executor.reference]).object);

  static final _id_getActiveRequestCount = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getActiveRequestCount', r'()I');

  /// from: public int getActiveRequestCount()
  int getActiveRequestCount() => jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getActiveRequestCount, jni.JniCallType.intType, []).integer;

  static final _id_addRequestFinishedListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'addRequestFinishedListener',
      r'(Lorg/chromium/net/RequestFinishedInfo$Listener;)V');

  /// from: public void addRequestFinishedListener(org.chromium.net.RequestFinishedInfo$Listener listener)
  void addRequestFinishedListener(
    jni.JObject listener,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addRequestFinishedListener,
        jni.JniCallType.voidType,
        [listener.reference]).check();

  static final _id_removeRequestFinishedListener = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'removeRequestFinishedListener',
          r'(Lorg/chromium/net/RequestFinishedInfo$Listener;)V');

  /// from: public void removeRequestFinishedListener(org.chromium.net.RequestFinishedInfo$Listener listener)
  void removeRequestFinishedListener(
    jni.JObject listener,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_removeRequestFinishedListener,
        jni.JniCallType.voidType,
        [listener.reference]).check();

  static final _id_getHttpRttMs = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getHttpRttMs', r'()I');

  /// from: public int getHttpRttMs()
  int getHttpRttMs() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getHttpRttMs, jni.JniCallType.intType, []).integer;

  static final _id_getTransportRttMs = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getTransportRttMs', r'()I');

  /// from: public int getTransportRttMs()
  int getTransportRttMs() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getTransportRttMs, jni.JniCallType.intType, []).integer;

  static final _id_getDownstreamThroughputKbps = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getDownstreamThroughputKbps', r'()I');

  /// from: public int getDownstreamThroughputKbps()
  int getDownstreamThroughputKbps() => jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getDownstreamThroughputKbps, jni.JniCallType.intType, []).integer;

  static final _id_startNetLogToDisk = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'startNetLogToDisk', r'(Ljava/lang/String;ZI)V');

  /// from: public void startNetLogToDisk(java.lang.String string, boolean z, int i)
  void startNetLogToDisk(
    jni.JString string,
    bool z,
    int i,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_startNetLogToDisk,
        jni.JniCallType.voidType,
        [string.reference, z ? 1 : 0, jni.JValueInt(i)]).check();

  static final _id_getEffectiveConnectionType = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getEffectiveConnectionType', r'()I');

  /// from: public int getEffectiveConnectionType()
  int getEffectiveConnectionType() => jni.Jni.accessors.callMethodWithArgs(reference,
        _id_getEffectiveConnectionType, jni.JniCallType.intType, []).integer;

  static final _id_configureNetworkQualityEstimatorForTesting =
      jni.Jni.accessors.getMethodIDOf(_class.reference,
          r'configureNetworkQualityEstimatorForTesting', r'(ZZZ)V');

  /// from: public void configureNetworkQualityEstimatorForTesting(boolean z, boolean z1, boolean z2)
  void configureNetworkQualityEstimatorForTesting(
    bool z,
    bool z1,
    bool z2,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_configureNetworkQualityEstimatorForTesting,
        jni.JniCallType.voidType,
        [z ? 1 : 0, z1 ? 1 : 0, z2 ? 1 : 0]).check();

  static final _id_addRttListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'addRttListener',
      r'(Lorg/chromium/net/NetworkQualityRttListener;)V');

  /// from: public void addRttListener(org.chromium.net.NetworkQualityRttListener networkQualityRttListener)
  void addRttListener(
    jni.JObject networkQualityRttListener,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addRttListener,
        jni.JniCallType.voidType,
        [networkQualityRttListener.reference]).check();

  static final _id_removeRttListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'removeRttListener',
      r'(Lorg/chromium/net/NetworkQualityRttListener;)V');

  /// from: public void removeRttListener(org.chromium.net.NetworkQualityRttListener networkQualityRttListener)
  void removeRttListener(
    jni.JObject networkQualityRttListener,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_removeRttListener,
        jni.JniCallType.voidType,
        [networkQualityRttListener.reference]).check();

  static final _id_addThroughputListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'addThroughputListener',
      r'(Lorg/chromium/net/NetworkQualityThroughputListener;)V');

  /// from: public void addThroughputListener(org.chromium.net.NetworkQualityThroughputListener networkQualityThroughputListener)
  void addThroughputListener(
    jni.JObject networkQualityThroughputListener,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_addThroughputListener,
        jni.JniCallType.voidType,
        [networkQualityThroughputListener.reference]).check();

  static final _id_removeThroughputListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'removeThroughputListener',
      r'(Lorg/chromium/net/NetworkQualityThroughputListener;)V');

  /// from: public void removeThroughputListener(org.chromium.net.NetworkQualityThroughputListener networkQualityThroughputListener)
  void removeThroughputListener(
    jni.JObject networkQualityThroughputListener,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_removeThroughputListener,
        jni.JniCallType.voidType,
        [networkQualityThroughputListener.reference]).check();
}

class $CronetEngineType extends jni.JObjType<CronetEngine> {
  const $CronetEngineType();

  @override
  String get signature => r'Lorg/chromium/net/CronetEngine;';

  @override
  CronetEngine fromRef(jni.JObjectPtr ref) => CronetEngine.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CronetEngineType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $CronetEngineType &&
        other is $CronetEngineType;
}

/// from: org.chromium.net.CronetException
class CronetException extends jni.JObject {
  @override
  late final jni.JObjType<CronetException> $type = type;

  CronetException.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'org/chromium/net/CronetException');

  /// The type which includes information such as the signature of this class.
  static const type = $CronetExceptionType();
  static final _id_new0 = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'<init>', r'(Ljava/lang/String;Ljava/lang/Throwable;)V');

  /// from: protected void <init>(java.lang.String string, java.lang.Throwable throwable)
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory CronetException(
    jni.JString string,
    jni.JObject throwable,
  ) => CronetException.fromRef(jni.Jni.accessors.newObjectWithArgs(
        _class.reference,
        _id_new0,
        [string.reference, throwable.reference]).object);
}

class $CronetExceptionType extends jni.JObjType<CronetException> {
  const $CronetExceptionType();

  @override
  String get signature => r'Lorg/chromium/net/CronetException;';

  @override
  CronetException fromRef(jni.JObjectPtr ref) => CronetException.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CronetExceptionType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $CronetExceptionType &&
        other is $CronetExceptionType;
}

/// from: org.chromium.net.UploadDataProviders
class UploadDataProviders extends jni.JObject {
  @override
  late final jni.JObjType<UploadDataProviders> $type = type;

  UploadDataProviders.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UploadDataProviders');

  /// The type which includes information such as the signature of this class.
  static const type = $UploadDataProvidersType();
  static final _id_create = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'create',
      r'(Ljava/io/File;)Lorg/chromium/net/UploadDataProvider;');

  /// from: static public org.chromium.net.UploadDataProvider create(java.io.File file)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject create(
    jni.JObject file,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_create,
            jni.JniCallType.objectType, [file.reference]).object);

  static final _id_create1 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'create',
      r'(Landroid/os/ParcelFileDescriptor;)Lorg/chromium/net/UploadDataProvider;');

  /// from: static public org.chromium.net.UploadDataProvider create(android.os.ParcelFileDescriptor parcelFileDescriptor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject create1(
    jni.JObject parcelFileDescriptor,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create1,
            jni.JniCallType.objectType,
            [parcelFileDescriptor.reference]).object);

  static final _id_create2 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'create',
      r'(Ljava/nio/ByteBuffer;)Lorg/chromium/net/UploadDataProvider;');

  /// from: static public org.chromium.net.UploadDataProvider create(java.nio.ByteBuffer byteBuffer)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject create2(
    ByteBuffer byteBuffer,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_create2,
            jni.JniCallType.objectType, [byteBuffer.reference]).object);

  static final _id_create3 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'create',
      r'([BII)Lorg/chromium/net/UploadDataProvider;');

  /// from: static public org.chromium.net.UploadDataProvider create(byte[] bs, int i, int i1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject create3(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(
            _class.reference,
            _id_create3,
            jni.JniCallType.objectType,
            [bs.reference, jni.JValueInt(i), jni.JValueInt(i1)]).object);

  static final _id_create4 = jni.Jni.accessors.getStaticMethodIDOf(
      _class.reference,
      r'create',
      r'([B)Lorg/chromium/net/UploadDataProvider;');

  /// from: static public org.chromium.net.UploadDataProvider create(byte[] bs)
  /// The returned object must be deleted after use, by calling the `delete` method.
  static jni.JObject create4(
    jni.JArray<jni.jbyte> bs,
  ) => const jni.JObjectType().fromRef(jni.Jni.accessors
        .callStaticMethodWithArgs(_class.reference, _id_create4,
            jni.JniCallType.objectType, [bs.reference]).object);
}

class $UploadDataProvidersType extends jni.JObjType<UploadDataProviders> {
  const $UploadDataProvidersType();

  @override
  String get signature => r'Lorg/chromium/net/UploadDataProviders;';

  @override
  UploadDataProviders fromRef(jni.JObjectPtr ref) =>
      UploadDataProviders.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UploadDataProvidersType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $UploadDataProvidersType &&
        other is $UploadDataProvidersType;
}

/// from: org.chromium.net.UrlRequest$Builder
class UrlRequest_Builder extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequest_Builder> $type = type;

  UrlRequest_Builder.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UrlRequest$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequest_BuilderType();

  /// from: static public final int REQUEST_PRIORITY_IDLE
  static const REQUEST_PRIORITY_IDLE = 0;

  /// from: static public final int REQUEST_PRIORITY_LOWEST
  static const REQUEST_PRIORITY_LOWEST = 1;

  /// from: static public final int REQUEST_PRIORITY_LOW
  static const REQUEST_PRIORITY_LOW = 2;

  /// from: static public final int REQUEST_PRIORITY_MEDIUM
  static const REQUEST_PRIORITY_MEDIUM = 3;

  /// from: static public final int REQUEST_PRIORITY_HIGHEST
  static const REQUEST_PRIORITY_HIGHEST = 4;

  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory UrlRequest_Builder() => UrlRequest_Builder.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_setHttpMethod = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setHttpMethod',
      r'(Ljava/lang/String;)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder setHttpMethod(java.lang.String string)
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder setHttpMethod(
    jni.JString string,
  ) => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setHttpMethod,
            jni.JniCallType.objectType, [string.reference]).object);

  static final _id_addHeader = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'addHeader',
      r'(Ljava/lang/String;Ljava/lang/String;)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_addHeader,
            jni.JniCallType.objectType,
            [string.reference, string1.reference]).object);

  static final _id_disableCache = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'disableCache',
      r'()Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder disableCache()
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder disableCache() => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_disableCache,
            jni.JniCallType.objectType, []).object);

  static final _id_setPriority = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setPriority',
      r'(I)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder setPriority(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder setPriority(
    int i,
  ) => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setPriority,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_setUploadDataProvider = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setUploadDataProvider',
      r'(Lorg/chromium/net/UploadDataProvider;Ljava/util/concurrent/Executor;)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder setUploadDataProvider(org.chromium.net.UploadDataProvider uploadDataProvider, java.util.concurrent.Executor executor)
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder setUploadDataProvider(
    jni.JObject uploadDataProvider,
    jni.JObject executor,
  ) => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference,
            _id_setUploadDataProvider,
            jni.JniCallType.objectType,
            [uploadDataProvider.reference, executor.reference]).object);

  static final _id_allowDirectExecutor = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'allowDirectExecutor',
      r'()Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public abstract org.chromium.net.UrlRequest$Builder allowDirectExecutor()
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder allowDirectExecutor() => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_allowDirectExecutor,
            jni.JniCallType.objectType, []).object);

  static final _id_addRequestAnnotation = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'addRequestAnnotation',
      r'(Ljava/lang/Object;)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public org.chromium.net.UrlRequest$Builder addRequestAnnotation(java.lang.Object object)
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder addRequestAnnotation(
    jni.JObject object,
  ) => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_addRequestAnnotation,
            jni.JniCallType.objectType, [object.reference]).object);

  static final _id_setTrafficStatsTag = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setTrafficStatsTag',
      r'(I)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public org.chromium.net.UrlRequest$Builder setTrafficStatsTag(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder setTrafficStatsTag(
    int i,
  ) => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setTrafficStatsTag,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_setTrafficStatsUid = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setTrafficStatsUid',
      r'(I)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public org.chromium.net.UrlRequest$Builder setTrafficStatsUid(int i)
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder setTrafficStatsUid(
    int i,
  ) => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setTrafficStatsUid,
            jni.JniCallType.objectType, [jni.JValueInt(i)]).object);

  static final _id_setRequestFinishedListener = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'setRequestFinishedListener',
      r'(Lorg/chromium/net/RequestFinishedInfo$Listener;)Lorg/chromium/net/UrlRequest$Builder;');

  /// from: public org.chromium.net.UrlRequest$Builder setRequestFinishedListener(org.chromium.net.RequestFinishedInfo$Listener listener)
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest_Builder setRequestFinishedListener(
    jni.JObject listener,
  ) => const $UrlRequest_BuilderType().fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_setRequestFinishedListener,
            jni.JniCallType.objectType, [listener.reference]).object);

  static final _id_build = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'build', r'()Lorg/chromium/net/UrlRequest;');

  /// from: public abstract org.chromium.net.UrlRequest build()
  /// The returned object must be deleted after use, by calling the `delete` method.
  UrlRequest build() => const $UrlRequestType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_build, jni.JniCallType.objectType, []).object);
}

class $UrlRequest_BuilderType extends jni.JObjType<UrlRequest_Builder> {
  const $UrlRequest_BuilderType();

  @override
  String get signature => r'Lorg/chromium/net/UrlRequest$Builder;';

  @override
  UrlRequest_Builder fromRef(jni.JObjectPtr ref) =>
      UrlRequest_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlRequest_BuilderType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $UrlRequest_BuilderType &&
        other is $UrlRequest_BuilderType;
}

/// from: org.chromium.net.UrlRequest$Callback
class UrlRequest_Callback extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequest_Callback> $type = type;

  UrlRequest_Callback.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UrlRequest$Callback');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequest_CallbackType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory UrlRequest_Callback() => UrlRequest_Callback.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_onRedirectReceived = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onRedirectReceived',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/lang/String;)V');

  /// from: public abstract void onRedirectReceived(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.lang.String string)
  void onRedirectReceived(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    jni.JString string,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onRedirectReceived, jni.JniCallType.voidType, [
      urlRequest.reference,
      urlResponseInfo.reference,
      string.reference
    ]).check();

  static final _id_onResponseStarted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onResponseStarted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public abstract void onResponseStarted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onResponseStarted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onResponseStarted,
        jni.JniCallType.voidType,
        [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onReadCompleted = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onReadCompleted',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Ljava/nio/ByteBuffer;)V');

  /// from: public abstract void onReadCompleted(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, java.nio.ByteBuffer byteBuffer)
  void onReadCompleted(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    ByteBuffer byteBuffer,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onReadCompleted, jni.JniCallType.voidType, [
      urlRequest.reference,
      urlResponseInfo.reference,
      byteBuffer.reference
    ]).check();

  static final _id_onSucceeded = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onSucceeded',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public abstract void onSucceeded(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onSucceeded(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onSucceeded,
        jni.JniCallType.voidType,
        [urlRequest.reference, urlResponseInfo.reference]).check();

  static final _id_onFailed = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onFailed',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;Lorg/chromium/net/CronetException;)V');

  /// from: public abstract void onFailed(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo, org.chromium.net.CronetException cronetException)
  void onFailed(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
    CronetException cronetException,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_onFailed, jni.JniCallType.voidType, [
      urlRequest.reference,
      urlResponseInfo.reference,
      cronetException.reference
    ]).check();

  static final _id_onCanceled = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r'onCanceled',
      r'(Lorg/chromium/net/UrlRequest;Lorg/chromium/net/UrlResponseInfo;)V');

  /// from: public void onCanceled(org.chromium.net.UrlRequest urlRequest, org.chromium.net.UrlResponseInfo urlResponseInfo)
  void onCanceled(
    UrlRequest urlRequest,
    UrlResponseInfo urlResponseInfo,
  ) => jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_onCanceled,
        jni.JniCallType.voidType,
        [urlRequest.reference, urlResponseInfo.reference]).check();
}

class $UrlRequest_CallbackType extends jni.JObjType<UrlRequest_Callback> {
  const $UrlRequest_CallbackType();

  @override
  String get signature => r'Lorg/chromium/net/UrlRequest$Callback;';

  @override
  UrlRequest_Callback fromRef(jni.JObjectPtr ref) =>
      UrlRequest_Callback.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlRequest_CallbackType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $UrlRequest_CallbackType &&
        other is $UrlRequest_CallbackType;
}

/// from: org.chromium.net.UrlRequest$Status
class UrlRequest_Status extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequest_Status> $type = type;

  UrlRequest_Status.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UrlRequest$Status');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequest_StatusType();

  /// from: static public final int INVALID
  static const INVALID = -1;

  /// from: static public final int IDLE
  static const IDLE = 0;

  /// from: static public final int WAITING_FOR_STALLED_SOCKET_POOL
  static const WAITING_FOR_STALLED_SOCKET_POOL = 1;

  /// from: static public final int WAITING_FOR_AVAILABLE_SOCKET
  static const WAITING_FOR_AVAILABLE_SOCKET = 2;

  /// from: static public final int WAITING_FOR_DELEGATE
  static const WAITING_FOR_DELEGATE = 3;

  /// from: static public final int WAITING_FOR_CACHE
  static const WAITING_FOR_CACHE = 4;

  /// from: static public final int DOWNLOADING_PAC_FILE
  static const DOWNLOADING_PAC_FILE = 5;

  /// from: static public final int RESOLVING_PROXY_FOR_URL
  static const RESOLVING_PROXY_FOR_URL = 6;

  /// from: static public final int RESOLVING_HOST_IN_PAC_FILE
  static const RESOLVING_HOST_IN_PAC_FILE = 7;

  /// from: static public final int ESTABLISHING_PROXY_TUNNEL
  static const ESTABLISHING_PROXY_TUNNEL = 8;

  /// from: static public final int RESOLVING_HOST
  static const RESOLVING_HOST = 9;

  /// from: static public final int CONNECTING
  static const CONNECTING = 10;

  /// from: static public final int SSL_HANDSHAKE
  static const SSL_HANDSHAKE = 11;

  /// from: static public final int SENDING_REQUEST
  static const SENDING_REQUEST = 12;

  /// from: static public final int WAITING_FOR_RESPONSE
  static const WAITING_FOR_RESPONSE = 13;

  /// from: static public final int READING_RESPONSE
  static const READING_RESPONSE = 14;
}

class $UrlRequest_StatusType extends jni.JObjType<UrlRequest_Status> {
  const $UrlRequest_StatusType();

  @override
  String get signature => r'Lorg/chromium/net/UrlRequest$Status;';

  @override
  UrlRequest_Status fromRef(jni.JObjectPtr ref) =>
      UrlRequest_Status.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlRequest_StatusType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $UrlRequest_StatusType &&
        other is $UrlRequest_StatusType;
}

/// from: org.chromium.net.UrlRequest$StatusListener
class UrlRequest_StatusListener extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequest_StatusListener> $type = type;

  UrlRequest_StatusListener.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UrlRequest$StatusListener');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequest_StatusListenerType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory UrlRequest_StatusListener() => UrlRequest_StatusListener.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_onStatus =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'onStatus', r'(I)V');

  /// from: public abstract void onStatus(int i)
  void onStatus(
    int i,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_onStatus,
        jni.JniCallType.voidType, [jni.JValueInt(i)]).check();
}

class $UrlRequest_StatusListenerType
    extends jni.JObjType<UrlRequest_StatusListener> {
  const $UrlRequest_StatusListenerType();

  @override
  String get signature => r'Lorg/chromium/net/UrlRequest$StatusListener;';

  @override
  UrlRequest_StatusListener fromRef(jni.JObjectPtr ref) =>
      UrlRequest_StatusListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlRequest_StatusListenerType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $UrlRequest_StatusListenerType &&
        other is $UrlRequest_StatusListenerType;
}

/// from: org.chromium.net.UrlRequest
class UrlRequest extends jni.JObject {
  @override
  late final jni.JObjType<UrlRequest> $type = type;

  UrlRequest.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'org/chromium/net/UrlRequest');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlRequestType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory UrlRequest() => UrlRequest.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_start =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'start', r'()V');

  /// from: public abstract void start()
  void start() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_start, jni.JniCallType.voidType, []).check();

  static final _id_followRedirect = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'followRedirect', r'()V');

  /// from: public abstract void followRedirect()
  void followRedirect() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_followRedirect, jni.JniCallType.voidType, []).check();

  static final _id_read = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'read', r'(Ljava/nio/ByteBuffer;)V');

  /// from: public abstract void read(java.nio.ByteBuffer byteBuffer)
  void read(
    ByteBuffer byteBuffer,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_read,
        jni.JniCallType.voidType, [byteBuffer.reference]).check();

  static final _id_cancel =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'cancel', r'()V');

  /// from: public abstract void cancel()
  void cancel() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_cancel, jni.JniCallType.voidType, []).check();

  static final _id_isDone =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'isDone', r'()Z');

  /// from: public abstract boolean isDone()
  bool isDone() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_isDone, jni.JniCallType.booleanType, []).boolean;

  static final _id_getStatus = jni.Jni.accessors.getMethodIDOf(_class.reference,
      r'getStatus', r'(Lorg/chromium/net/UrlRequest$StatusListener;)V');

  /// from: public abstract void getStatus(org.chromium.net.UrlRequest$StatusListener statusListener)
  void getStatus(
    UrlRequest_StatusListener statusListener,
  ) => jni.Jni.accessors.callMethodWithArgs(reference, _id_getStatus,
        jni.JniCallType.voidType, [statusListener.reference]).check();
}

class $UrlRequestType extends jni.JObjType<UrlRequest> {
  const $UrlRequestType();

  @override
  String get signature => r'Lorg/chromium/net/UrlRequest;';

  @override
  UrlRequest fromRef(jni.JObjectPtr ref) => UrlRequest.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlRequestType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $UrlRequestType && other is $UrlRequestType;
}

/// from: org.chromium.net.UrlResponseInfo$HeaderBlock
class UrlResponseInfo_HeaderBlock extends jni.JObject {
  @override
  late final jni.JObjType<UrlResponseInfo_HeaderBlock> $type = type;

  UrlResponseInfo_HeaderBlock.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class =
      jni.Jni.findJClass(r'org/chromium/net/UrlResponseInfo$HeaderBlock');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlResponseInfo_HeaderBlockType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory UrlResponseInfo_HeaderBlock() => UrlResponseInfo_HeaderBlock.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_getAsList = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getAsList', r'()Ljava/util/List;');

  /// from: public abstract java.util.List getAsList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JList<jni.JObject> getAsList() => const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_getAsList, jni.JniCallType.objectType, []).object);

  static final _id_getAsMap = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getAsMap', r'()Ljava/util/Map;');

  /// from: public abstract java.util.Map getAsMap()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JMap<jni.JString, jni.JList<jni.JString>> getAsMap() => const jni.JMapType(
            jni.JStringType(), jni.JListType(jni.JStringType()))
        .fromRef(jni.Jni.accessors.callMethodWithArgs(
            reference, _id_getAsMap, jni.JniCallType.objectType, []).object);
}

class $UrlResponseInfo_HeaderBlockType
    extends jni.JObjType<UrlResponseInfo_HeaderBlock> {
  const $UrlResponseInfo_HeaderBlockType();

  @override
  String get signature => r'Lorg/chromium/net/UrlResponseInfo$HeaderBlock;';

  @override
  UrlResponseInfo_HeaderBlock fromRef(jni.JObjectPtr ref) =>
      UrlResponseInfo_HeaderBlock.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlResponseInfo_HeaderBlockType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $UrlResponseInfo_HeaderBlockType &&
        other is $UrlResponseInfo_HeaderBlockType;
}

/// from: org.chromium.net.UrlResponseInfo
class UrlResponseInfo extends jni.JObject {
  @override
  late final jni.JObjType<UrlResponseInfo> $type = type;

  UrlResponseInfo.fromRef(
    super.ref,
  ) : super.fromRef();

  static final _class = jni.Jni.findJClass(r'org/chromium/net/UrlResponseInfo');

  /// The type which includes information such as the signature of this class.
  static const type = $UrlResponseInfoType();
  static final _id_new0 =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'<init>', r'()V');

  /// from: public void <init>()
  /// The returned object must be deleted after use, by calling the `delete` method.
  factory UrlResponseInfo() => UrlResponseInfo.fromRef(jni.Jni.accessors
        .newObjectWithArgs(_class.reference, _id_new0, []).object);

  static final _id_getUrl = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getUrl', r'()Ljava/lang/String;');

  /// from: public abstract java.lang.String getUrl()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getUrl() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getUrl, jni.JniCallType.objectType, []).object);

  static final _id_getUrlChain = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getUrlChain', r'()Ljava/util/List;');

  /// from: public abstract java.util.List getUrlChain()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JList<jni.JString> getUrlChain() => const jni.JListType(jni.JStringType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(
            reference, _id_getUrlChain, jni.JniCallType.objectType, []).object);

  static final _id_getHttpStatusCode = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getHttpStatusCode', r'()I');

  /// from: public abstract int getHttpStatusCode()
  int getHttpStatusCode() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getHttpStatusCode, jni.JniCallType.intType, []).integer;

  static final _id_getHttpStatusText = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getHttpStatusText', r'()Ljava/lang/String;');

  /// from: public abstract java.lang.String getHttpStatusText()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getHttpStatusText() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getHttpStatusText,
        jni.JniCallType.objectType, []).object);

  static final _id_getAllHeadersAsList = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getAllHeadersAsList', r'()Ljava/util/List;');

  /// from: public abstract java.util.List getAllHeadersAsList()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JList<jni.JObject> getAllHeadersAsList() => const jni.JListType(jni.JObjectType()).fromRef(jni.Jni.accessors
        .callMethodWithArgs(reference, _id_getAllHeadersAsList,
            jni.JniCallType.objectType, []).object);

  static final _id_getAllHeaders = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getAllHeaders', r'()Ljava/util/Map;');

  /// from: public abstract java.util.Map getAllHeaders()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JMap<jni.JString, jni.JList<jni.JString>> getAllHeaders() => const jni.JMapType(
            jni.JStringType(), jni.JListType(jni.JStringType()))
        .fromRef(jni.Jni.accessors.callMethodWithArgs(reference,
            _id_getAllHeaders, jni.JniCallType.objectType, []).object);

  static final _id_wasCached =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r'wasCached', r'()Z');

  /// from: public abstract boolean wasCached()
  bool wasCached() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_wasCached, jni.JniCallType.booleanType, []).boolean;

  static final _id_getNegotiatedProtocol = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getNegotiatedProtocol', r'()Ljava/lang/String;');

  /// from: public abstract java.lang.String getNegotiatedProtocol()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getNegotiatedProtocol() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_getNegotiatedProtocol,
        jni.JniCallType.objectType, []).object);

  static final _id_getProxyServer = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r'getProxyServer', r'()Ljava/lang/String;');

  /// from: public abstract java.lang.String getProxyServer()
  /// The returned object must be deleted after use, by calling the `delete` method.
  jni.JString getProxyServer() => const jni.JStringType().fromRef(jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getProxyServer, jni.JniCallType.objectType, []).object);

  static final _id_getReceivedByteCount = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r'getReceivedByteCount', r'()J');

  /// from: public abstract long getReceivedByteCount()
  int getReceivedByteCount() => jni.Jni.accessors.callMethodWithArgs(
        reference, _id_getReceivedByteCount, jni.JniCallType.longType, []).long;
}

class $UrlResponseInfoType extends jni.JObjType<UrlResponseInfo> {
  const $UrlResponseInfoType();

  @override
  String get signature => r'Lorg/chromium/net/UrlResponseInfo;';

  @override
  UrlResponseInfo fromRef(jni.JObjectPtr ref) => UrlResponseInfo.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UrlResponseInfoType).hashCode;

  @override
  bool operator ==(Object other) => other.runtimeType == $UrlResponseInfoType &&
        other is $UrlResponseInfoType;
}
