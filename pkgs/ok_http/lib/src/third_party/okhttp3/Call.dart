// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "Request.dart" as request_;

import "Response.dart" as response_;

import "Callback.dart" as callback_;

/// from: okhttp3.Call$Factory
class Call_Factory extends jni.JObject {
  @override
  late final jni.JObjType<Call_Factory> $type = type;

  Call_Factory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Call$Factory");

  /// The type which includes information such as the signature of this class.
  static const type = $Call_FactoryType();
  static final _id_newCall = _class.instanceMethodId(
    r"newCall",
    r"(Lokhttp3/Request;)Lokhttp3/Call;",
  );

  static final _newCall = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    request_.Request request,
  ) {
    return _newCall(reference.pointer, _id_newCall as jni.JMethodIDPtr,
            request.reference.pointer)
        .object(const $CallType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Call_FactoryImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"newCall(Lokhttp3/Request;)Lokhttp3/Call;") {
        final $r = _$impls[$p]!.newCall(
          $a[0].castTo(const request_.$RequestType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Call_Factory.implement(
    $Call_FactoryImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Call_Factory.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"okhttp3.Call$Factory",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Call_FactoryImpl {
  factory $Call_FactoryImpl({
    required Call Function(request_.Request request) newCall,
  }) = _$Call_FactoryImpl;

  Call newCall(request_.Request request);
}

class _$Call_FactoryImpl implements $Call_FactoryImpl {
  _$Call_FactoryImpl({
    required Call Function(request_.Request request) newCall,
  }) : _newCall = newCall;

  final Call Function(request_.Request request) _newCall;

  Call newCall(request_.Request request) {
    return _newCall(request);
  }
}

final class $Call_FactoryType extends jni.JObjType<Call_Factory> {
  const $Call_FactoryType();

  @override
  String get signature => r"Lokhttp3/Call$Factory;";

  @override
  Call_Factory fromReference(jni.JReference reference) =>
      Call_Factory.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Call_FactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Call_FactoryType) &&
        other is $Call_FactoryType;
  }
}

/// from: okhttp3.Call
class Call extends jni.JObject {
  @override
  late final jni.JObjType<Call> $type = type;

  Call.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Call");

  /// The type which includes information such as the signature of this class.
  static const type = $CallType();
  static final _id_request = _class.instanceMethodId(
    r"request",
    r"()Lokhttp3/Request;",
  );

  static final _request = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  request_.Request request() {
    return _request(reference.pointer, _id_request as jni.JMethodIDPtr)
        .object(const request_.$RequestType());
  }

  static final _id_execute = _class.instanceMethodId(
    r"execute",
    r"()Lokhttp3/Response;",
  );

  static final _execute = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.Response execute()
  /// The returned object must be released after use, by calling the [release] method.
  response_.Response execute() {
    return _execute(reference.pointer, _id_execute as jni.JMethodIDPtr)
        .object(const response_.$ResponseType());
  }

  static final _id_enqueue = _class.instanceMethodId(
    r"enqueue",
    r"(Lokhttp3/Callback;)V",
  );

  static final _enqueue = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enqueue(okhttp3.Callback callback)
  void enqueue(
    callback_.Callback callback,
  ) {
    _enqueue(reference.pointer, _id_enqueue as jni.JMethodIDPtr,
            callback.reference.pointer)
        .check();
  }

  static final _id_cancel = _class.instanceMethodId(
    r"cancel",
    r"()V",
  );

  static final _cancel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void cancel()
  void cancel() {
    _cancel(reference.pointer, _id_cancel as jni.JMethodIDPtr).check();
  }

  static final _id_isExecuted = _class.instanceMethodId(
    r"isExecuted",
    r"()Z",
  );

  static final _isExecuted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isExecuted()
  bool isExecuted() {
    return _isExecuted(reference.pointer, _id_isExecuted as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isCanceled = _class.instanceMethodId(
    r"isCanceled",
    r"()Z",
  );

  static final _isCanceled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isCanceled()
  bool isCanceled() {
    return _isCanceled(reference.pointer, _id_isCanceled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_timeout = _class.instanceMethodId(
    r"timeout",
    r"()Lokio/Timeout;",
  );

  static final _timeout = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject timeout() {
    return _timeout(reference.pointer, _id_timeout as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_clone = _class.instanceMethodId(
    r"clone",
    r"()Lokhttp3/Call;",
  );

  static final _clone = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.Call clone()
  /// The returned object must be released after use, by calling the [release] method.
  Call clone() {
    return _clone(reference.pointer, _id_clone as jni.JMethodIDPtr)
        .object(const $CallType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CallImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"request()Lokhttp3/Request;") {
        final $r = _$impls[$p]!.request();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"execute()Lokhttp3/Response;") {
        final $r = _$impls[$p]!.execute();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"enqueue(Lokhttp3/Callback;)V") {
        _$impls[$p]!.enqueue(
          $a[0].castTo(const callback_.$CallbackType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"cancel()V") {
        _$impls[$p]!.cancel();
        return jni.nullptr;
      }
      if ($d == r"isExecuted()Z") {
        final $r = _$impls[$p]!.isExecuted();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r"isCanceled()Z") {
        final $r = _$impls[$p]!.isCanceled();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r"timeout()Lokio/Timeout;") {
        final $r = _$impls[$p]!.timeout();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"clone()Lokhttp3/Call;") {
        final $r = _$impls[$p]!.clone();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Call.implement(
    $CallImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Call.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"okhttp3.Call",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CallImpl {
  factory $CallImpl({
    required request_.Request Function() request,
    required response_.Response Function() execute,
    required void Function(callback_.Callback callback) enqueue,
    required void Function() cancel,
    required bool Function() isExecuted,
    required bool Function() isCanceled,
    required jni.JObject Function() timeout,
    required Call Function() clone,
  }) = _$CallImpl;

  request_.Request request();
  response_.Response execute();
  void enqueue(callback_.Callback callback);
  void cancel();
  bool isExecuted();
  bool isCanceled();
  jni.JObject timeout();
  Call clone();
}

class _$CallImpl implements $CallImpl {
  _$CallImpl({
    required request_.Request Function() request,
    required response_.Response Function() execute,
    required void Function(callback_.Callback callback) enqueue,
    required void Function() cancel,
    required bool Function() isExecuted,
    required bool Function() isCanceled,
    required jni.JObject Function() timeout,
    required Call Function() clone,
  })  : _request = request,
        _execute = execute,
        _enqueue = enqueue,
        _cancel = cancel,
        _isExecuted = isExecuted,
        _isCanceled = isCanceled,
        _timeout = timeout,
        _clone = clone;

  final request_.Request Function() _request;
  final response_.Response Function() _execute;
  final void Function(callback_.Callback callback) _enqueue;
  final void Function() _cancel;
  final bool Function() _isExecuted;
  final bool Function() _isCanceled;
  final jni.JObject Function() _timeout;
  final Call Function() _clone;

  request_.Request request() {
    return _request();
  }

  response_.Response execute() {
    return _execute();
  }

  void enqueue(callback_.Callback callback) {
    return _enqueue(callback);
  }

  void cancel() {
    return _cancel();
  }

  bool isExecuted() {
    return _isExecuted();
  }

  bool isCanceled() {
    return _isCanceled();
  }

  jni.JObject timeout() {
    return _timeout();
  }

  Call clone() {
    return _clone();
  }
}

final class $CallType extends jni.JObjType<Call> {
  const $CallType();

  @override
  String get signature => r"Lokhttp3/Call;";

  @override
  Call fromReference(jni.JReference reference) => Call.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CallType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CallType) && other is $CallType;
  }
}
