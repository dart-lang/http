// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

/// from: okhttp3.Request$Builder
class Request_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Request_Builder> $type = type;

  Request_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Request$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Request_BuilderType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Request_Builder() {
    return Request_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r"(Lokhttp3/Request;)V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  factory Request_Builder.new1(
    Request request,
  ) {
    return Request_Builder.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, request.reference.pointer)
        .reference);
  }

  static final _id_url = _class.instanceMethodId(
    r"url",
    r"(Lokhttp3/HttpUrl;)Lokhttp3/Request$Builder;",
  );

  static final _url = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder url(okhttp3.HttpUrl httpUrl)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url(
    jni.JObject httpUrl,
  ) {
    return _url(reference.pointer, _id_url as jni.JMethodIDPtr,
            httpUrl.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_url1 = _class.instanceMethodId(
    r"url",
    r"(Ljava/lang/String;)Lokhttp3/Request$Builder;",
  );

  static final _url1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder url(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url1(
    jni.JString string,
  ) {
    return _url1(reference.pointer, _id_url1 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_url2 = _class.instanceMethodId(
    r"url",
    r"(Ljava/net/URL;)Lokhttp3/Request$Builder;",
  );

  static final _url2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder url(java.net.URL uRL)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url2(
    jni.JObject uRL,
  ) {
    return _url2(reference.pointer, _id_url2 as jni.JMethodIDPtr,
            uRL.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_header = _class.instanceMethodId(
    r"header",
    r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;",
  );

  static final _header = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder header(
    jni.JString string,
    jni.JString string1,
  ) {
    return _header(reference.pointer, _id_header as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_addHeader = _class.instanceMethodId(
    r"addHeader",
    r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;",
  );

  static final _addHeader = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) {
    return _addHeader(reference.pointer, _id_addHeader as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_removeHeader = _class.instanceMethodId(
    r"removeHeader",
    r"(Ljava/lang/String;)Lokhttp3/Request$Builder;",
  );

  static final _removeHeader = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder removeHeader(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder removeHeader(
    jni.JString string,
  ) {
    return _removeHeader(reference.pointer,
            _id_removeHeader as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_headers = _class.instanceMethodId(
    r"headers",
    r"(Lokhttp3/Headers;)Lokhttp3/Request$Builder;",
  );

  static final _headers = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder headers(
    Headers headers,
  ) {
    return _headers(reference.pointer, _id_headers as jni.JMethodIDPtr,
            headers.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_cacheControl = _class.instanceMethodId(
    r"cacheControl",
    r"(Lokhttp3/CacheControl;)Lokhttp3/Request$Builder;",
  );

  static final _cacheControl = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder cacheControl(okhttp3.CacheControl cacheControl)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder cacheControl(
    jni.JObject cacheControl,
  ) {
    return _cacheControl(
            reference.pointer,
            _id_cacheControl as jni.JMethodIDPtr,
            cacheControl.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_get0 = _class.instanceMethodId(
    r"get",
    r"()Lokhttp3/Request$Builder;",
  );

  static final _get0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okhttp3.Request$Builder get()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder get0() {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr)
        .object(const $Request_BuilderType());
  }

  static final _id_head = _class.instanceMethodId(
    r"head",
    r"()Lokhttp3/Request$Builder;",
  );

  static final _head = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okhttp3.Request$Builder head()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder head() {
    return _head(reference.pointer, _id_head as jni.JMethodIDPtr)
        .object(const $Request_BuilderType());
  }

  static final _id_post = _class.instanceMethodId(
    r"post",
    r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;",
  );

  static final _post = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder post(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder post(
    RequestBody requestBody,
  ) {
    return _post(reference.pointer, _id_post as jni.JMethodIDPtr,
            requestBody.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_delete = _class.instanceMethodId(
    r"delete",
    r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;",
  );

  static final _delete = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder delete(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete(
    RequestBody requestBody,
  ) {
    return _delete(reference.pointer, _id_delete as jni.JMethodIDPtr,
            requestBody.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_put = _class.instanceMethodId(
    r"put",
    r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;",
  );

  static final _put = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder put(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder put(
    RequestBody requestBody,
  ) {
    return _put(reference.pointer, _id_put as jni.JMethodIDPtr,
            requestBody.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_patch = _class.instanceMethodId(
    r"patch",
    r"(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;",
  );

  static final _patch = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder patch(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder patch(
    RequestBody requestBody,
  ) {
    return _patch(reference.pointer, _id_patch as jni.JMethodIDPtr,
            requestBody.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_method = _class.instanceMethodId(
    r"method",
    r"(Ljava/lang/String;Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;",
  );

  static final _method = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder method(java.lang.String string, okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder method(
    jni.JString string,
    RequestBody requestBody,
  ) {
    return _method(reference.pointer, _id_method as jni.JMethodIDPtr,
            string.reference.pointer, requestBody.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_tag = _class.instanceMethodId(
    r"tag",
    r"(Ljava/lang/Object;)Lokhttp3/Request$Builder;",
  );

  static final _tag = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder tag(java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder tag(
    jni.JObject object,
  ) {
    return _tag(reference.pointer, _id_tag as jni.JMethodIDPtr,
            object.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_tag1 = _class.instanceMethodId(
    r"tag",
    r"(Ljava/lang/Class;Ljava/lang/Object;)Lokhttp3/Request$Builder;",
  );

  static final _tag1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder tag(java.lang.Class class, T object)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder tag1<$T extends jni.JObject>(
    jni.JObject class0,
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return _tag1(reference.pointer, _id_tag1 as jni.JMethodIDPtr,
            class0.reference.pointer, object.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r"build",
    r"()Lokhttp3/Request;",
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okhttp3.Request build()
  /// The returned object must be released after use, by calling the [release] method.
  Request build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $RequestType());
  }

  static final _id_delete1 = _class.instanceMethodId(
    r"delete",
    r"()Lokhttp3/Request$Builder;",
  );

  static final _delete1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Request$Builder delete()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete1() {
    return _delete1(reference.pointer, _id_delete1 as jni.JMethodIDPtr)
        .object(const $Request_BuilderType());
  }
}

final class $Request_BuilderType extends jni.JObjType<Request_Builder> {
  const $Request_BuilderType();

  @override
  String get signature => r"Lokhttp3/Request$Builder;";

  @override
  Request_Builder fromReference(jni.JReference reference) =>
      Request_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Request_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Request_BuilderType) &&
        other is $Request_BuilderType;
  }
}

/// from: okhttp3.Request
class Request extends jni.JObject {
  @override
  late final jni.JObjType<Request> $type = type;

  Request.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Request");

  /// The type which includes information such as the signature of this class.
  static const type = $RequestType();
  static final _id_new0 = _class.constructorId(
    r"(Lokhttp3/HttpUrl;Ljava/lang/String;Lokhttp3/Headers;Lokhttp3/RequestBody;Ljava/util/Map;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.HttpUrl httpUrl, java.lang.String string, okhttp3.Headers headers, okhttp3.RequestBody requestBody, java.util.Map map)
  /// The returned object must be released after use, by calling the [release] method.
  factory Request(
    jni.JObject httpUrl,
    jni.JString string,
    Headers headers,
    RequestBody requestBody,
    jni.JMap<jni.JObject, jni.JObject> map,
  ) {
    return Request.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            httpUrl.reference.pointer,
            string.reference.pointer,
            headers.reference.pointer,
            requestBody.reference.pointer,
            map.reference.pointer)
        .reference);
  }

  static final _id_url = _class.instanceMethodId(
    r"url",
    r"()Lokhttp3/HttpUrl;",
  );

  static final _url = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.HttpUrl url()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject url() {
    return _url(reference.pointer, _id_url as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_method = _class.instanceMethodId(
    r"method",
    r"()Ljava/lang/String;",
  );

  static final _method = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.String method()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString method() {
    return _method(reference.pointer, _id_method as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_headers = _class.instanceMethodId(
    r"headers",
    r"()Lokhttp3/Headers;",
  );

  static final _headers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  Headers headers() {
    return _headers(reference.pointer, _id_headers as jni.JMethodIDPtr)
        .object(const $HeadersType());
  }

  static final _id_body = _class.instanceMethodId(
    r"body",
    r"()Lokhttp3/RequestBody;",
  );

  static final _body = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.RequestBody body()
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody body() {
    return _body(reference.pointer, _id_body as jni.JMethodIDPtr)
        .object(const $RequestBodyType());
  }

  static final _id_isHttps = _class.instanceMethodId(
    r"isHttps",
    r"()Z",
  );

  static final _isHttps = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean isHttps()
  bool isHttps() {
    return _isHttps(reference.pointer, _id_isHttps as jni.JMethodIDPtr).boolean;
  }

  static final _id_header = _class.instanceMethodId(
    r"header",
    r"(Ljava/lang/String;)Ljava/lang/String;",
  );

  static final _header = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String header(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString string,
  ) {
    return _header(reference.pointer, _id_header as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_headers1 = _class.instanceMethodId(
    r"headers",
    r"(Ljava/lang/String;)Ljava/util/List;",
  );

  static final _headers1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.List headers(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers1(
    jni.JString string,
  ) {
    return _headers1(reference.pointer, _id_headers1 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_tag = _class.instanceMethodId(
    r"tag",
    r"()Ljava/lang/Object;",
  );

  static final _tag = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.Object tag()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject tag() {
    return _tag(reference.pointer, _id_tag as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_tag1 = _class.instanceMethodId(
    r"tag",
    r"(Ljava/lang/Class;)Ljava/lang/Object;",
  );

  static final _tag1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final T tag(java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  $T tag1<$T extends jni.JObject>(
    jni.JObject class0, {
    required jni.JObjType<$T> T,
  }) {
    return _tag1(reference.pointer, _id_tag1 as jni.JMethodIDPtr,
            class0.reference.pointer)
        .object(T);
  }

  static final _id_newBuilder = _class.instanceMethodId(
    r"newBuilder",
    r"()Lokhttp3/Request$Builder;",
  );

  static final _newBuilder = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Request$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder newBuilder() {
    return _newBuilder(reference.pointer, _id_newBuilder as jni.JMethodIDPtr)
        .object(const $Request_BuilderType());
  }

  static final _id_cacheControl = _class.instanceMethodId(
    r"cacheControl",
    r"()Lokhttp3/CacheControl;",
  );

  static final _cacheControl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cacheControl() {
    return _cacheControl(
            reference.pointer, _id_cacheControl as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_toString1 = _class.instanceMethodId(
    r"toString",
    r"()Ljava/lang/String;",
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $RequestType extends jni.JObjType<Request> {
  const $RequestType();

  @override
  String get signature => r"Lokhttp3/Request;";

  @override
  Request fromReference(jni.JReference reference) =>
      Request.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestType) && other is $RequestType;
  }
}

/// from: okhttp3.RequestBody$Companion
class RequestBody_Companion extends jni.JObject {
  @override
  late final jni.JObjType<RequestBody_Companion> $type = type;

  RequestBody_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/RequestBody$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $RequestBody_CompanionType();
  static final _id_create = _class.instanceMethodId(
    r"create",
    r"(Ljava/lang/String;Lokhttp3/MediaType;)Lokhttp3/RequestBody;",
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(java.lang.String string, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create(
    jni.JString string,
    jni.JObject mediaType,
  ) {
    return _create(reference.pointer, _id_create as jni.JMethodIDPtr,
            string.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create1 = _class.instanceMethodId(
    r"create",
    r"(Lokio/ByteString;Lokhttp3/MediaType;)Lokhttp3/RequestBody;",
  );

  static final _create1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(okio.ByteString byteString, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create1(
    jni.JObject byteString,
    jni.JObject mediaType,
  ) {
    return _create1(reference.pointer, _id_create1 as jni.JMethodIDPtr,
            byteString.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create2 = _class.instanceMethodId(
    r"create",
    r"([BLokhttp3/MediaType;II)Lokhttp3/RequestBody;",
  );

  static final _create2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32,
                        ffi.Int32
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create2(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
    int i,
    int i1,
  ) {
    return _create2(reference.pointer, _id_create2 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer, i, i1)
        .object(const $RequestBodyType());
  }

  static final _id_create3 = _class.instanceMethodId(
    r"create",
    r"(Ljava/io/File;Lokhttp3/MediaType;)Lokhttp3/RequestBody;",
  );

  static final _create3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(java.io.File file, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create3(
    jni.JObject file,
    jni.JObject mediaType,
  ) {
    return _create3(reference.pointer, _id_create3 as jni.JMethodIDPtr,
            file.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create4 = _class.instanceMethodId(
    r"create",
    r"(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/RequestBody;",
  );

  static final _create4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create4(
    jni.JObject mediaType,
    jni.JString string,
  ) {
    return _create4(reference.pointer, _id_create4 as jni.JMethodIDPtr,
            mediaType.reference.pointer, string.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create5 = _class.instanceMethodId(
    r"create",
    r"(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/RequestBody;",
  );

  static final _create5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create5(
    jni.JObject mediaType,
    jni.JObject byteString,
  ) {
    return _create5(reference.pointer, _id_create5 as jni.JMethodIDPtr,
            mediaType.reference.pointer, byteString.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create6 = _class.instanceMethodId(
    r"create",
    r"(Lokhttp3/MediaType;[BII)Lokhttp3/RequestBody;",
  );

  static final _create6 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32,
                        ffi.Int32
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create6(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return _create6(reference.pointer, _id_create6 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer, i, i1)
        .object(const $RequestBodyType());
  }

  static final _id_create7 = _class.instanceMethodId(
    r"create",
    r"(Lokhttp3/MediaType;Ljava/io/File;)Lokhttp3/RequestBody;",
  );

  static final _create7 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create7(
    jni.JObject mediaType,
    jni.JObject file,
  ) {
    return _create7(reference.pointer, _id_create7 as jni.JMethodIDPtr,
            mediaType.reference.pointer, file.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create8 = _class.instanceMethodId(
    r"create",
    r"([BLokhttp3/MediaType;I)Lokhttp3/RequestBody;",
  );

  static final _create8 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType, int i)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create8(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
    int i,
  ) {
    return _create8(reference.pointer, _id_create8 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer, i)
        .object(const $RequestBodyType());
  }

  static final _id_create9 = _class.instanceMethodId(
    r"create",
    r"([BLokhttp3/MediaType;)Lokhttp3/RequestBody;",
  );

  static final _create9 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create9(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
  ) {
    return _create9(reference.pointer, _id_create9 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create10 = _class.instanceMethodId(
    r"create",
    r"([B)Lokhttp3/RequestBody;",
  );

  static final _create10 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create10(
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create10(reference.pointer, _id_create10 as jni.JMethodIDPtr,
            bs.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create11 = _class.instanceMethodId(
    r"create",
    r"(Lokhttp3/MediaType;[BI)Lokhttp3/RequestBody;",
  );

  static final _create11 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs, int i)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create11(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
    int i,
  ) {
    return _create11(reference.pointer, _id_create11 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer, i)
        .object(const $RequestBodyType());
  }

  static final _id_create12 = _class.instanceMethodId(
    r"create",
    r"(Lokhttp3/MediaType;[B)Lokhttp3/RequestBody;",
  );

  static final _create12 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create12(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create12(reference.pointer, _id_create12 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_new0 = _class.constructorId(
    r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory RequestBody_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return RequestBody_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $RequestBody_CompanionType
    extends jni.JObjType<RequestBody_Companion> {
  const $RequestBody_CompanionType();

  @override
  String get signature => r"Lokhttp3/RequestBody$Companion;";

  @override
  RequestBody_Companion fromReference(jni.JReference reference) =>
      RequestBody_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestBody_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestBody_CompanionType) &&
        other is $RequestBody_CompanionType;
  }
}

/// from: okhttp3.RequestBody
class RequestBody extends jni.JObject {
  @override
  late final jni.JObjType<RequestBody> $type = type;

  RequestBody.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/RequestBody");

  /// The type which includes information such as the signature of this class.
  static const type = $RequestBodyType();
  static final _id_Companion = _class.staticFieldId(
    r"Companion",
    r"Lokhttp3/RequestBody$Companion;",
  );

  /// from: static public final okhttp3.RequestBody$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody_Companion get Companion =>
      _id_Companion.get(_class, const $RequestBody_CompanionType());

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory RequestBody() {
    return RequestBody.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_contentType = _class.instanceMethodId(
    r"contentType",
    r"()Lokhttp3/MediaType;",
  );

  static final _contentType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.MediaType contentType()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject contentType() {
    return _contentType(reference.pointer, _id_contentType as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_contentLength = _class.instanceMethodId(
    r"contentLength",
    r"()J",
  );

  static final _contentLength = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public long contentLength()
  int contentLength() {
    return _contentLength(
            reference.pointer, _id_contentLength as jni.JMethodIDPtr)
        .long;
  }

  static final _id_writeTo = _class.instanceMethodId(
    r"writeTo",
    r"(Lokio/BufferedSink;)V",
  );

  static final _writeTo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void writeTo(okio.BufferedSink bufferedSink)
  void writeTo(
    jni.JObject bufferedSink,
  ) {
    _writeTo(reference.pointer, _id_writeTo as jni.JMethodIDPtr,
            bufferedSink.reference.pointer)
        .check();
  }

  static final _id_isDuplex = _class.instanceMethodId(
    r"isDuplex",
    r"()Z",
  );

  static final _isDuplex = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isDuplex()
  bool isDuplex() {
    return _isDuplex(reference.pointer, _id_isDuplex as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isOneShot = _class.instanceMethodId(
    r"isOneShot",
    r"()Z",
  );

  static final _isOneShot = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isOneShot()
  bool isOneShot() {
    return _isOneShot(reference.pointer, _id_isOneShot as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_create = _class.staticMethodId(
    r"create",
    r"(Ljava/lang/String;Lokhttp3/MediaType;)Lokhttp3/RequestBody;",
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(java.lang.String string, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create(
    jni.JString string,
    jni.JObject mediaType,
  ) {
    return _create(_class.reference.pointer, _id_create as jni.JMethodIDPtr,
            string.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create1 = _class.staticMethodId(
    r"create",
    r"(Lokio/ByteString;Lokhttp3/MediaType;)Lokhttp3/RequestBody;",
  );

  static final _create1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(okio.ByteString byteString, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create1(
    jni.JObject byteString,
    jni.JObject mediaType,
  ) {
    return _create1(_class.reference.pointer, _id_create1 as jni.JMethodIDPtr,
            byteString.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create2 = _class.staticMethodId(
    r"create",
    r"([BLokhttp3/MediaType;II)Lokhttp3/RequestBody;",
  );

  static final _create2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32,
                        ffi.Int32
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create2(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
    int i,
    int i1,
  ) {
    return _create2(_class.reference.pointer, _id_create2 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer, i, i1)
        .object(const $RequestBodyType());
  }

  static final _id_create3 = _class.staticMethodId(
    r"create",
    r"(Ljava/io/File;Lokhttp3/MediaType;)Lokhttp3/RequestBody;",
  );

  static final _create3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(java.io.File file, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create3(
    jni.JObject file,
    jni.JObject mediaType,
  ) {
    return _create3(_class.reference.pointer, _id_create3 as jni.JMethodIDPtr,
            file.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create4 = _class.staticMethodId(
    r"create",
    r"(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/RequestBody;",
  );

  static final _create4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create4(
    jni.JObject mediaType,
    jni.JString string,
  ) {
    return _create4(_class.reference.pointer, _id_create4 as jni.JMethodIDPtr,
            mediaType.reference.pointer, string.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create5 = _class.staticMethodId(
    r"create",
    r"(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/RequestBody;",
  );

  static final _create5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create5(
    jni.JObject mediaType,
    jni.JObject byteString,
  ) {
    return _create5(_class.reference.pointer, _id_create5 as jni.JMethodIDPtr,
            mediaType.reference.pointer, byteString.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create6 = _class.staticMethodId(
    r"create",
    r"(Lokhttp3/MediaType;[BII)Lokhttp3/RequestBody;",
  );

  static final _create6 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32,
                        ffi.Int32
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create6(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return _create6(_class.reference.pointer, _id_create6 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer, i, i1)
        .object(const $RequestBodyType());
  }

  static final _id_create7 = _class.staticMethodId(
    r"create",
    r"(Lokhttp3/MediaType;Ljava/io/File;)Lokhttp3/RequestBody;",
  );

  static final _create7 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create7(
    jni.JObject mediaType,
    jni.JObject file,
  ) {
    return _create7(_class.reference.pointer, _id_create7 as jni.JMethodIDPtr,
            mediaType.reference.pointer, file.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create8 = _class.staticMethodId(
    r"create",
    r"([BLokhttp3/MediaType;I)Lokhttp3/RequestBody;",
  );

  static final _create8 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create8(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
    int i,
  ) {
    return _create8(_class.reference.pointer, _id_create8 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer, i)
        .object(const $RequestBodyType());
  }

  static final _id_create9 = _class.staticMethodId(
    r"create",
    r"([BLokhttp3/MediaType;)Lokhttp3/RequestBody;",
  );

  static final _create9 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create9(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
  ) {
    return _create9(_class.reference.pointer, _id_create9 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create10 = _class.staticMethodId(
    r"create",
    r"([B)Lokhttp3/RequestBody;",
  );

  static final _create10 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create10(
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create10(_class.reference.pointer, _id_create10 as jni.JMethodIDPtr,
            bs.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create11 = _class.staticMethodId(
    r"create",
    r"(Lokhttp3/MediaType;[BI)Lokhttp3/RequestBody;",
  );

  static final _create11 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create11(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
    int i,
  ) {
    return _create11(_class.reference.pointer, _id_create11 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer, i)
        .object(const $RequestBodyType());
  }

  static final _id_create12 = _class.staticMethodId(
    r"create",
    r"(Lokhttp3/MediaType;[B)Lokhttp3/RequestBody;",
  );

  static final _create12 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create12(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create12(_class.reference.pointer, _id_create12 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer)
        .object(const $RequestBodyType());
  }
}

final class $RequestBodyType extends jni.JObjType<RequestBody> {
  const $RequestBodyType();

  @override
  String get signature => r"Lokhttp3/RequestBody;";

  @override
  RequestBody fromReference(jni.JReference reference) =>
      RequestBody.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestBodyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestBodyType) && other is $RequestBodyType;
  }
}

/// from: okhttp3.Response$Builder
class Response_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Response_Builder> $type = type;

  Response_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Response$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Response_BuilderType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Response_Builder() {
    return Response_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r"(Lokhttp3/Response;)V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  factory Response_Builder.new1(
    Response response,
  ) {
    return Response_Builder.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, response.reference.pointer)
        .reference);
  }

  static final _id_request = _class.instanceMethodId(
    r"request",
    r"(Lokhttp3/Request;)Lokhttp3/Response$Builder;",
  );

  static final _request = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder request(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder request(
    Request request,
  ) {
    return _request(reference.pointer, _id_request as jni.JMethodIDPtr,
            request.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_protocol = _class.instanceMethodId(
    r"protocol",
    r"(Lokhttp3/Protocol;)Lokhttp3/Response$Builder;",
  );

  static final _protocol = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder protocol(okhttp3.Protocol protocol)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder protocol(
    jni.JObject protocol,
  ) {
    return _protocol(reference.pointer, _id_protocol as jni.JMethodIDPtr,
            protocol.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_code = _class.instanceMethodId(
    r"code",
    r"(I)Lokhttp3/Response$Builder;",
  );

  static final _code = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public okhttp3.Response$Builder code(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder code(
    int i,
  ) {
    return _code(reference.pointer, _id_code as jni.JMethodIDPtr, i)
        .object(const $Response_BuilderType());
  }

  static final _id_message = _class.instanceMethodId(
    r"message",
    r"(Ljava/lang/String;)Lokhttp3/Response$Builder;",
  );

  static final _message = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder message(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder message(
    jni.JString string,
  ) {
    return _message(reference.pointer, _id_message as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_handshake = _class.instanceMethodId(
    r"handshake",
    r"(Lokhttp3/Handshake;)Lokhttp3/Response$Builder;",
  );

  static final _handshake = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder handshake(okhttp3.Handshake handshake)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder handshake(
    jni.JObject handshake,
  ) {
    return _handshake(reference.pointer, _id_handshake as jni.JMethodIDPtr,
            handshake.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_header = _class.instanceMethodId(
    r"header",
    r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Response$Builder;",
  );

  static final _header = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder header(
    jni.JString string,
    jni.JString string1,
  ) {
    return _header(reference.pointer, _id_header as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_addHeader = _class.instanceMethodId(
    r"addHeader",
    r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Response$Builder;",
  );

  static final _addHeader = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) {
    return _addHeader(reference.pointer, _id_addHeader as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_removeHeader = _class.instanceMethodId(
    r"removeHeader",
    r"(Ljava/lang/String;)Lokhttp3/Response$Builder;",
  );

  static final _removeHeader = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder removeHeader(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder removeHeader(
    jni.JString string,
  ) {
    return _removeHeader(reference.pointer,
            _id_removeHeader as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_headers = _class.instanceMethodId(
    r"headers",
    r"(Lokhttp3/Headers;)Lokhttp3/Response$Builder;",
  );

  static final _headers = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder headers(
    Headers headers,
  ) {
    return _headers(reference.pointer, _id_headers as jni.JMethodIDPtr,
            headers.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_body = _class.instanceMethodId(
    r"body",
    r"(Lokhttp3/ResponseBody;)Lokhttp3/Response$Builder;",
  );

  static final _body = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder body(okhttp3.ResponseBody responseBody)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder body(
    ResponseBody responseBody,
  ) {
    return _body(reference.pointer, _id_body as jni.JMethodIDPtr,
            responseBody.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_networkResponse = _class.instanceMethodId(
    r"networkResponse",
    r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;",
  );

  static final _networkResponse = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder networkResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder networkResponse(
    Response response,
  ) {
    return _networkResponse(reference.pointer,
            _id_networkResponse as jni.JMethodIDPtr, response.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_cacheResponse = _class.instanceMethodId(
    r"cacheResponse",
    r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;",
  );

  static final _cacheResponse = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder cacheResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder cacheResponse(
    Response response,
  ) {
    return _cacheResponse(reference.pointer,
            _id_cacheResponse as jni.JMethodIDPtr, response.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_priorResponse = _class.instanceMethodId(
    r"priorResponse",
    r"(Lokhttp3/Response;)Lokhttp3/Response$Builder;",
  );

  static final _priorResponse = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder priorResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder priorResponse(
    Response response,
  ) {
    return _priorResponse(reference.pointer,
            _id_priorResponse as jni.JMethodIDPtr, response.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_sentRequestAtMillis = _class.instanceMethodId(
    r"sentRequestAtMillis",
    r"(J)Lokhttp3/Response$Builder;",
  );

  static final _sentRequestAtMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public okhttp3.Response$Builder sentRequestAtMillis(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder sentRequestAtMillis(
    int j,
  ) {
    return _sentRequestAtMillis(
            reference.pointer, _id_sentRequestAtMillis as jni.JMethodIDPtr, j)
        .object(const $Response_BuilderType());
  }

  static final _id_receivedResponseAtMillis = _class.instanceMethodId(
    r"receivedResponseAtMillis",
    r"(J)Lokhttp3/Response$Builder;",
  );

  static final _receivedResponseAtMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public okhttp3.Response$Builder receivedResponseAtMillis(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder receivedResponseAtMillis(
    int j,
  ) {
    return _receivedResponseAtMillis(reference.pointer,
            _id_receivedResponseAtMillis as jni.JMethodIDPtr, j)
        .object(const $Response_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r"build",
    r"()Lokhttp3/Response;",
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okhttp3.Response build()
  /// The returned object must be released after use, by calling the [release] method.
  Response build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $ResponseType());
  }
}

final class $Response_BuilderType extends jni.JObjType<Response_Builder> {
  const $Response_BuilderType();

  @override
  String get signature => r"Lokhttp3/Response$Builder;";

  @override
  Response_Builder fromReference(jni.JReference reference) =>
      Response_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Response_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Response_BuilderType) &&
        other is $Response_BuilderType;
  }
}

/// from: okhttp3.Response
class Response extends jni.JObject {
  @override
  late final jni.JObjType<Response> $type = type;

  Response.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Response");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseType();
  static final _id_new0 = _class.constructorId(
    r"(Lokhttp3/Request;Lokhttp3/Protocol;Ljava/lang/String;ILokhttp3/Handshake;Lokhttp3/Headers;Lokhttp3/ResponseBody;Lokhttp3/Response;Lokhttp3/Response;Lokhttp3/Response;JJLokhttp3/internal/connection/Exchange;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.Request request, okhttp3.Protocol protocol, java.lang.String string, int i, okhttp3.Handshake handshake, okhttp3.Headers headers, okhttp3.ResponseBody responseBody, okhttp3.Response response, okhttp3.Response response1, okhttp3.Response response2, long j, long j1, okhttp3.internal.connection.Exchange exchange)
  /// The returned object must be released after use, by calling the [release] method.
  factory Response(
    Request request,
    jni.JObject protocol,
    jni.JString string,
    int i,
    jni.JObject handshake,
    Headers headers,
    ResponseBody responseBody,
    Response response,
    Response response1,
    Response response2,
    int j,
    int j1,
    jni.JObject exchange,
  ) {
    return Response.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            request.reference.pointer,
            protocol.reference.pointer,
            string.reference.pointer,
            i,
            handshake.reference.pointer,
            headers.reference.pointer,
            responseBody.reference.pointer,
            response.reference.pointer,
            response1.reference.pointer,
            response2.reference.pointer,
            j,
            j1,
            exchange.reference.pointer)
        .reference);
  }

  static final _id_request = _class.instanceMethodId(
    r"request",
    r"()Lokhttp3/Request;",
  );

  static final _request = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return _request(reference.pointer, _id_request as jni.JMethodIDPtr)
        .object(const $RequestType());
  }

  static final _id_protocol = _class.instanceMethodId(
    r"protocol",
    r"()Lokhttp3/Protocol;",
  );

  static final _protocol = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Protocol protocol()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject protocol() {
    return _protocol(reference.pointer, _id_protocol as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_message = _class.instanceMethodId(
    r"message",
    r"()Ljava/lang/String;",
  );

  static final _message = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.String message()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString message() {
    return _message(reference.pointer, _id_message as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_code = _class.instanceMethodId(
    r"code",
    r"()I",
  );

  static final _code = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int code()
  int code() {
    return _code(reference.pointer, _id_code as jni.JMethodIDPtr).integer;
  }

  static final _id_handshake = _class.instanceMethodId(
    r"handshake",
    r"()Lokhttp3/Handshake;",
  );

  static final _handshake = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Handshake handshake()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject handshake() {
    return _handshake(reference.pointer, _id_handshake as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_headers = _class.instanceMethodId(
    r"headers",
    r"()Lokhttp3/Headers;",
  );

  static final _headers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  Headers headers() {
    return _headers(reference.pointer, _id_headers as jni.JMethodIDPtr)
        .object(const $HeadersType());
  }

  static final _id_body = _class.instanceMethodId(
    r"body",
    r"()Lokhttp3/ResponseBody;",
  );

  static final _body = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.ResponseBody body()
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody body() {
    return _body(reference.pointer, _id_body as jni.JMethodIDPtr)
        .object(const $ResponseBodyType());
  }

  static final _id_networkResponse = _class.instanceMethodId(
    r"networkResponse",
    r"()Lokhttp3/Response;",
  );

  static final _networkResponse = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Response networkResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response networkResponse() {
    return _networkResponse(
            reference.pointer, _id_networkResponse as jni.JMethodIDPtr)
        .object(const $ResponseType());
  }

  static final _id_cacheResponse = _class.instanceMethodId(
    r"cacheResponse",
    r"()Lokhttp3/Response;",
  );

  static final _cacheResponse = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Response cacheResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response cacheResponse() {
    return _cacheResponse(
            reference.pointer, _id_cacheResponse as jni.JMethodIDPtr)
        .object(const $ResponseType());
  }

  static final _id_priorResponse = _class.instanceMethodId(
    r"priorResponse",
    r"()Lokhttp3/Response;",
  );

  static final _priorResponse = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Response priorResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response priorResponse() {
    return _priorResponse(
            reference.pointer, _id_priorResponse as jni.JMethodIDPtr)
        .object(const $ResponseType());
  }

  static final _id_sentRequestAtMillis = _class.instanceMethodId(
    r"sentRequestAtMillis",
    r"()J",
  );

  static final _sentRequestAtMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long sentRequestAtMillis()
  int sentRequestAtMillis() {
    return _sentRequestAtMillis(
            reference.pointer, _id_sentRequestAtMillis as jni.JMethodIDPtr)
        .long;
  }

  static final _id_receivedResponseAtMillis = _class.instanceMethodId(
    r"receivedResponseAtMillis",
    r"()J",
  );

  static final _receivedResponseAtMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long receivedResponseAtMillis()
  int receivedResponseAtMillis() {
    return _receivedResponseAtMillis(
            reference.pointer, _id_receivedResponseAtMillis as jni.JMethodIDPtr)
        .long;
  }

  static final _id_exchange = _class.instanceMethodId(
    r"exchange",
    r"()Lokhttp3/internal/connection/Exchange;",
  );

  static final _exchange = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.internal.connection.Exchange exchange()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject exchange() {
    return _exchange(reference.pointer, _id_exchange as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_isSuccessful = _class.instanceMethodId(
    r"isSuccessful",
    r"()Z",
  );

  static final _isSuccessful = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean isSuccessful()
  bool isSuccessful() {
    return _isSuccessful(
            reference.pointer, _id_isSuccessful as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_headers1 = _class.instanceMethodId(
    r"headers",
    r"(Ljava/lang/String;)Ljava/util/List;",
  );

  static final _headers1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.List headers(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers1(
    jni.JString string,
  ) {
    return _headers1(reference.pointer, _id_headers1 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_header = _class.instanceMethodId(
    r"header",
    r"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
  );

  static final _header = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString string,
    jni.JString string1,
  ) {
    return _header(reference.pointer, _id_header as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_trailers = _class.instanceMethodId(
    r"trailers",
    r"()Lokhttp3/Headers;",
  );

  static final _trailers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Headers trailers()
  /// The returned object must be released after use, by calling the [release] method.
  Headers trailers() {
    return _trailers(reference.pointer, _id_trailers as jni.JMethodIDPtr)
        .object(const $HeadersType());
  }

  static final _id_peekBody = _class.instanceMethodId(
    r"peekBody",
    r"(J)Lokhttp3/ResponseBody;",
  );

  static final _peekBody = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okhttp3.ResponseBody peekBody(long j)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody peekBody(
    int j,
  ) {
    return _peekBody(reference.pointer, _id_peekBody as jni.JMethodIDPtr, j)
        .object(const $ResponseBodyType());
  }

  static final _id_newBuilder = _class.instanceMethodId(
    r"newBuilder",
    r"()Lokhttp3/Response$Builder;",
  );

  static final _newBuilder = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Response$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder newBuilder() {
    return _newBuilder(reference.pointer, _id_newBuilder as jni.JMethodIDPtr)
        .object(const $Response_BuilderType());
  }

  static final _id_isRedirect = _class.instanceMethodId(
    r"isRedirect",
    r"()Z",
  );

  static final _isRedirect = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean isRedirect()
  bool isRedirect() {
    return _isRedirect(reference.pointer, _id_isRedirect as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_challenges = _class.instanceMethodId(
    r"challenges",
    r"()Ljava/util/List;",
  );

  static final _challenges = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List challenges()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> challenges() {
    return _challenges(reference.pointer, _id_challenges as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_cacheControl = _class.instanceMethodId(
    r"cacheControl",
    r"()Lokhttp3/CacheControl;",
  );

  static final _cacheControl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cacheControl() {
    return _cacheControl(
            reference.pointer, _id_cacheControl as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_close = _class.instanceMethodId(
    r"close",
    r"()V",
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  static final _id_toString1 = _class.instanceMethodId(
    r"toString",
    r"()Ljava/lang/String;",
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_header1 = _class.instanceMethodId(
    r"header",
    r"(Ljava/lang/String;)Ljava/lang/String;",
  );

  static final _header1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String header(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header1(
    jni.JString string,
  ) {
    return _header1(reference.pointer, _id_header1 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }
}

final class $ResponseType extends jni.JObjType<Response> {
  const $ResponseType();

  @override
  String get signature => r"Lokhttp3/Response;";

  @override
  Response fromReference(jni.JReference reference) =>
      Response.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseType) && other is $ResponseType;
  }
}

/// from: okhttp3.ResponseBody$BomAwareReader
class ResponseBody_BomAwareReader extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody_BomAwareReader> $type = type;

  ResponseBody_BomAwareReader.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"okhttp3/ResponseBody$BomAwareReader");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBody_BomAwareReaderType();
  static final _id_new0 = _class.constructorId(
    r"(Lokio/BufferedSource;Ljava/nio/charset/Charset;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okio.BufferedSource bufferedSource, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody_BomAwareReader(
    jni.JObject bufferedSource,
    jni.JObject charset,
  ) {
    return ResponseBody_BomAwareReader.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            bufferedSource.reference.pointer,
            charset.reference.pointer)
        .reference);
  }

  static final _id_read = _class.instanceMethodId(
    r"read",
    r"([CII)I",
  );

  static final _read = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32,
                        ffi.Int32
                      )>)>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int read(char[] cs, int i, int i1)
  int read(
    jni.JArray<jni.jchar> cs,
    int i,
    int i1,
  ) {
    return _read(reference.pointer, _id_read as jni.JMethodIDPtr,
            cs.reference.pointer, i, i1)
        .integer;
  }

  static final _id_close = _class.instanceMethodId(
    r"close",
    r"()V",
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }
}

final class $ResponseBody_BomAwareReaderType
    extends jni.JObjType<ResponseBody_BomAwareReader> {
  const $ResponseBody_BomAwareReaderType();

  @override
  String get signature => r"Lokhttp3/ResponseBody$BomAwareReader;";

  @override
  ResponseBody_BomAwareReader fromReference(jni.JReference reference) =>
      ResponseBody_BomAwareReader.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBody_BomAwareReaderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBody_BomAwareReaderType) &&
        other is $ResponseBody_BomAwareReaderType;
  }
}

/// from: okhttp3.ResponseBody$Companion
class ResponseBody_Companion extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody_Companion> $type = type;

  ResponseBody_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/ResponseBody$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBody_CompanionType();
  static final _id_create = _class.instanceMethodId(
    r"create",
    r"(Ljava/lang/String;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;",
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(java.lang.String string, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create(
    jni.JString string,
    jni.JObject mediaType,
  ) {
    return _create(reference.pointer, _id_create as jni.JMethodIDPtr,
            string.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create1 = _class.instanceMethodId(
    r"create",
    r"([BLokhttp3/MediaType;)Lokhttp3/ResponseBody;",
  );

  static final _create1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(byte[] bs, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create1(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
  ) {
    return _create1(reference.pointer, _id_create1 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create2 = _class.instanceMethodId(
    r"create",
    r"(Lokio/ByteString;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;",
  );

  static final _create2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(okio.ByteString byteString, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create2(
    jni.JObject byteString,
    jni.JObject mediaType,
  ) {
    return _create2(reference.pointer, _id_create2 as jni.JMethodIDPtr,
            byteString.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create3 = _class.instanceMethodId(
    r"create",
    r"(Lokio/BufferedSource;Lokhttp3/MediaType;J)Lokhttp3/ResponseBody;",
  );

  static final _create3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final okhttp3.ResponseBody create(okio.BufferedSource bufferedSource, okhttp3.MediaType mediaType, long j)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create3(
    jni.JObject bufferedSource,
    jni.JObject mediaType,
    int j,
  ) {
    return _create3(reference.pointer, _id_create3 as jni.JMethodIDPtr,
            bufferedSource.reference.pointer, mediaType.reference.pointer, j)
        .object(const $ResponseBodyType());
  }

  static final _id_create4 = _class.instanceMethodId(
    r"create",
    r"(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/ResponseBody;",
  );

  static final _create4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create4(
    jni.JObject mediaType,
    jni.JString string,
  ) {
    return _create4(reference.pointer, _id_create4 as jni.JMethodIDPtr,
            mediaType.reference.pointer, string.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create5 = _class.instanceMethodId(
    r"create",
    r"(Lokhttp3/MediaType;[B)Lokhttp3/ResponseBody;",
  );

  static final _create5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create5(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create5(reference.pointer, _id_create5 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create6 = _class.instanceMethodId(
    r"create",
    r"(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/ResponseBody;",
  );

  static final _create6 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create6(
    jni.JObject mediaType,
    jni.JObject byteString,
  ) {
    return _create6(reference.pointer, _id_create6 as jni.JMethodIDPtr,
            mediaType.reference.pointer, byteString.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create7 = _class.instanceMethodId(
    r"create",
    r"(Lokhttp3/MediaType;JLokio/BufferedSource;)Lokhttp3/ResponseBody;",
  );

  static final _create7 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, long j, okio.BufferedSource bufferedSource)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create7(
    jni.JObject mediaType,
    int j,
    jni.JObject bufferedSource,
  ) {
    return _create7(reference.pointer, _id_create7 as jni.JMethodIDPtr,
            mediaType.reference.pointer, j, bufferedSource.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_new0 = _class.constructorId(
    r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return ResponseBody_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $ResponseBody_CompanionType
    extends jni.JObjType<ResponseBody_Companion> {
  const $ResponseBody_CompanionType();

  @override
  String get signature => r"Lokhttp3/ResponseBody$Companion;";

  @override
  ResponseBody_Companion fromReference(jni.JReference reference) =>
      ResponseBody_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBody_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBody_CompanionType) &&
        other is $ResponseBody_CompanionType;
  }
}

/// from: okhttp3.ResponseBody
class ResponseBody extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody> $type = type;

  ResponseBody.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/ResponseBody");

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBodyType();
  static final _id_Companion = _class.staticFieldId(
    r"Companion",
    r"Lokhttp3/ResponseBody$Companion;",
  );

  /// from: static public final okhttp3.ResponseBody$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody_Companion get Companion =>
      _id_Companion.get(_class, const $ResponseBody_CompanionType());

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody() {
    return ResponseBody.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_contentType = _class.instanceMethodId(
    r"contentType",
    r"()Lokhttp3/MediaType;",
  );

  static final _contentType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.MediaType contentType()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject contentType() {
    return _contentType(reference.pointer, _id_contentType as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_contentLength = _class.instanceMethodId(
    r"contentLength",
    r"()J",
  );

  static final _contentLength = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract long contentLength()
  int contentLength() {
    return _contentLength(
            reference.pointer, _id_contentLength as jni.JMethodIDPtr)
        .long;
  }

  static final _id_byteStream = _class.instanceMethodId(
    r"byteStream",
    r"()Ljava/io/InputStream;",
  );

  static final _byteStream = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.io.InputStream byteStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject byteStream() {
    return _byteStream(reference.pointer, _id_byteStream as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_source = _class.instanceMethodId(
    r"source",
    r"()Lokio/BufferedSource;",
  );

  static final _source = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okio.BufferedSource source()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject source() {
    return _source(reference.pointer, _id_source as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_bytes = _class.instanceMethodId(
    r"bytes",
    r"()[B",
  );

  static final _bytes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final byte[] bytes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> bytes() {
    return _bytes(reference.pointer, _id_bytes as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _id_byteString = _class.instanceMethodId(
    r"byteString",
    r"()Lokio/ByteString;",
  );

  static final _byteString = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okio.ByteString byteString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject byteString() {
    return _byteString(reference.pointer, _id_byteString as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_charStream = _class.instanceMethodId(
    r"charStream",
    r"()Ljava/io/Reader;",
  );

  static final _charStream = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.io.Reader charStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject charStream() {
    return _charStream(reference.pointer, _id_charStream as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_string = _class.instanceMethodId(
    r"string",
    r"()Ljava/lang/String;",
  );

  static final _string = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.String string()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString string() {
    return _string(reference.pointer, _id_string as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_close = _class.instanceMethodId(
    r"close",
    r"()V",
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  static final _id_create = _class.staticMethodId(
    r"create",
    r"(Ljava/lang/String;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;",
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(java.lang.String string, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create(
    jni.JString string,
    jni.JObject mediaType,
  ) {
    return _create(_class.reference.pointer, _id_create as jni.JMethodIDPtr,
            string.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create1 = _class.staticMethodId(
    r"create",
    r"([BLokhttp3/MediaType;)Lokhttp3/ResponseBody;",
  );

  static final _create1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(byte[] bs, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create1(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
  ) {
    return _create1(_class.reference.pointer, _id_create1 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create2 = _class.staticMethodId(
    r"create",
    r"(Lokio/ByteString;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;",
  );

  static final _create2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(okio.ByteString byteString, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create2(
    jni.JObject byteString,
    jni.JObject mediaType,
  ) {
    return _create2(_class.reference.pointer, _id_create2 as jni.JMethodIDPtr,
            byteString.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create3 = _class.staticMethodId(
    r"create",
    r"(Lokio/BufferedSource;Lokhttp3/MediaType;J)Lokhttp3/ResponseBody;",
  );

  static final _create3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public final okhttp3.ResponseBody create(okio.BufferedSource bufferedSource, okhttp3.MediaType mediaType, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create3(
    jni.JObject bufferedSource,
    jni.JObject mediaType,
    int j,
  ) {
    return _create3(_class.reference.pointer, _id_create3 as jni.JMethodIDPtr,
            bufferedSource.reference.pointer, mediaType.reference.pointer, j)
        .object(const $ResponseBodyType());
  }

  static final _id_create4 = _class.staticMethodId(
    r"create",
    r"(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/ResponseBody;",
  );

  static final _create4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create4(
    jni.JObject mediaType,
    jni.JString string,
  ) {
    return _create4(_class.reference.pointer, _id_create4 as jni.JMethodIDPtr,
            mediaType.reference.pointer, string.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create5 = _class.staticMethodId(
    r"create",
    r"(Lokhttp3/MediaType;[B)Lokhttp3/ResponseBody;",
  );

  static final _create5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create5(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create5(_class.reference.pointer, _id_create5 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create6 = _class.staticMethodId(
    r"create",
    r"(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/ResponseBody;",
  );

  static final _create6 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create6(
    jni.JObject mediaType,
    jni.JObject byteString,
  ) {
    return _create6(_class.reference.pointer, _id_create6 as jni.JMethodIDPtr,
            mediaType.reference.pointer, byteString.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create7 = _class.staticMethodId(
    r"create",
    r"(Lokhttp3/MediaType;JLokio/BufferedSource;)Lokhttp3/ResponseBody;",
  );

  static final _create7 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, long j, okio.BufferedSource bufferedSource)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create7(
    jni.JObject mediaType,
    int j,
    jni.JObject bufferedSource,
  ) {
    return _create7(_class.reference.pointer, _id_create7 as jni.JMethodIDPtr,
            mediaType.reference.pointer, j, bufferedSource.reference.pointer)
        .object(const $ResponseBodyType());
  }
}

final class $ResponseBodyType extends jni.JObjType<ResponseBody> {
  const $ResponseBodyType();

  @override
  String get signature => r"Lokhttp3/ResponseBody;";

  @override
  ResponseBody fromReference(jni.JReference reference) =>
      ResponseBody.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBodyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBodyType) &&
        other is $ResponseBodyType;
  }
}

/// from: okhttp3.OkHttpClient$Builder
class OkHttpClient_Builder extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient_Builder> $type = type;

  OkHttpClient_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/OkHttpClient$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClient_BuilderType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Builder() {
    return OkHttpClient_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r"(Lokhttp3/OkHttpClient;)V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.OkHttpClient okHttpClient)
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Builder.new1(
    OkHttpClient okHttpClient,
  ) {
    return OkHttpClient_Builder.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, okHttpClient.reference.pointer)
        .reference);
  }

  static final _id_dispatcher = _class.instanceMethodId(
    r"dispatcher",
    r"(Lokhttp3/Dispatcher;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _dispatcher = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder dispatcher(okhttp3.Dispatcher dispatcher)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder dispatcher(
    Dispatcher dispatcher,
  ) {
    return _dispatcher(reference.pointer, _id_dispatcher as jni.JMethodIDPtr,
            dispatcher.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_connectionPool = _class.instanceMethodId(
    r"connectionPool",
    r"(Lokhttp3/ConnectionPool;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _connectionPool = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder connectionPool(okhttp3.ConnectionPool connectionPool)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionPool(
    ConnectionPool connectionPool,
  ) {
    return _connectionPool(
            reference.pointer,
            _id_connectionPool as jni.JMethodIDPtr,
            connectionPool.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_interceptors = _class.instanceMethodId(
    r"interceptors",
    r"()Ljava/util/List;",
  );

  static final _interceptors = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> interceptors() {
    return _interceptors(
            reference.pointer, _id_interceptors as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_addInterceptor = _class.instanceMethodId(
    r"addInterceptor",
    r"(Lokhttp3/Interceptor;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _addInterceptor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder addInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addInterceptor(
    jni.JObject interceptor,
  ) {
    return _addInterceptor(
            reference.pointer,
            _id_addInterceptor as jni.JMethodIDPtr,
            interceptor.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_networkInterceptors = _class.instanceMethodId(
    r"networkInterceptors",
    r"()Ljava/util/List;",
  );

  static final _networkInterceptors = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> networkInterceptors() {
    return _networkInterceptors(
            reference.pointer, _id_networkInterceptors as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_addNetworkInterceptor = _class.instanceMethodId(
    r"addNetworkInterceptor",
    r"(Lokhttp3/Interceptor;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _addNetworkInterceptor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder addNetworkInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addNetworkInterceptor(
    jni.JObject interceptor,
  ) {
    return _addNetworkInterceptor(
            reference.pointer,
            _id_addNetworkInterceptor as jni.JMethodIDPtr,
            interceptor.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_eventListener = _class.instanceMethodId(
    r"eventListener",
    r"(Lokhttp3/EventListener;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _eventListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder eventListener(okhttp3.EventListener eventListener)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder eventListener(
    jni.JObject eventListener,
  ) {
    return _eventListener(
            reference.pointer,
            _id_eventListener as jni.JMethodIDPtr,
            eventListener.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_eventListenerFactory = _class.instanceMethodId(
    r"eventListenerFactory",
    r"(Lokhttp3/EventListener$Factory;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _eventListenerFactory = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder eventListenerFactory(okhttp3.EventListener$Factory factory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder eventListenerFactory(
    jni.JObject factory0,
  ) {
    return _eventListenerFactory(
            reference.pointer,
            _id_eventListenerFactory as jni.JMethodIDPtr,
            factory0.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_retryOnConnectionFailure = _class.instanceMethodId(
    r"retryOnConnectionFailure",
    r"(Z)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _retryOnConnectionFailure = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Uint8,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okhttp3.OkHttpClient$Builder retryOnConnectionFailure(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder retryOnConnectionFailure(
    bool z,
  ) {
    return _retryOnConnectionFailure(reference.pointer,
            _id_retryOnConnectionFailure as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_authenticator = _class.instanceMethodId(
    r"authenticator",
    r"(Lokhttp3/Authenticator;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _authenticator = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder authenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder authenticator(
    jni.JObject authenticator,
  ) {
    return _authenticator(
            reference.pointer,
            _id_authenticator as jni.JMethodIDPtr,
            authenticator.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_followRedirects = _class.instanceMethodId(
    r"followRedirects",
    r"(Z)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _followRedirects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Uint8,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okhttp3.OkHttpClient$Builder followRedirects(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder followRedirects(
    bool z,
  ) {
    return _followRedirects(reference.pointer,
            _id_followRedirects as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_followSslRedirects = _class.instanceMethodId(
    r"followSslRedirects",
    r"(Z)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _followSslRedirects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Uint8,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okhttp3.OkHttpClient$Builder followSslRedirects(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder followSslRedirects(
    bool z,
  ) {
    return _followSslRedirects(reference.pointer,
            _id_followSslRedirects as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_cookieJar = _class.instanceMethodId(
    r"cookieJar",
    r"(Lokhttp3/CookieJar;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _cookieJar = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder cookieJar(okhttp3.CookieJar cookieJar)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder cookieJar(
    jni.JObject cookieJar,
  ) {
    return _cookieJar(reference.pointer, _id_cookieJar as jni.JMethodIDPtr,
            cookieJar.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_cache = _class.instanceMethodId(
    r"cache",
    r"(Lokhttp3/Cache;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _cache = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder cache(okhttp3.Cache cache)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder cache(
    Cache cache,
  ) {
    return _cache(reference.pointer, _id_cache as jni.JMethodIDPtr,
            cache.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_dns = _class.instanceMethodId(
    r"dns",
    r"(Lokhttp3/Dns;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _dns = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder dns(okhttp3.Dns dns)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder dns(
    jni.JObject dns,
  ) {
    return _dns(reference.pointer, _id_dns as jni.JMethodIDPtr,
            dns.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_proxy = _class.instanceMethodId(
    r"proxy",
    r"(Ljava/net/Proxy;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _proxy = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder proxy(java.net.Proxy proxy)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxy(
    jni.JObject proxy,
  ) {
    return _proxy(reference.pointer, _id_proxy as jni.JMethodIDPtr,
            proxy.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_proxySelector = _class.instanceMethodId(
    r"proxySelector",
    r"(Ljava/net/ProxySelector;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _proxySelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder proxySelector(java.net.ProxySelector proxySelector)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxySelector(
    jni.JObject proxySelector,
  ) {
    return _proxySelector(
            reference.pointer,
            _id_proxySelector as jni.JMethodIDPtr,
            proxySelector.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_proxyAuthenticator = _class.instanceMethodId(
    r"proxyAuthenticator",
    r"(Lokhttp3/Authenticator;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _proxyAuthenticator = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder proxyAuthenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxyAuthenticator(
    jni.JObject authenticator,
  ) {
    return _proxyAuthenticator(
            reference.pointer,
            _id_proxyAuthenticator as jni.JMethodIDPtr,
            authenticator.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_socketFactory = _class.instanceMethodId(
    r"socketFactory",
    r"(Ljavax/net/SocketFactory;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _socketFactory = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder socketFactory(javax.net.SocketFactory socketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder socketFactory(
    jni.JObject socketFactory,
  ) {
    return _socketFactory(
            reference.pointer,
            _id_socketFactory as jni.JMethodIDPtr,
            socketFactory.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_sslSocketFactory = _class.instanceMethodId(
    r"sslSocketFactory",
    r"(Ljavax/net/ssl/SSLSocketFactory;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _sslSocketFactory = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder sslSocketFactory(
    jni.JObject sSLSocketFactory,
  ) {
    return _sslSocketFactory(
            reference.pointer,
            _id_sslSocketFactory as jni.JMethodIDPtr,
            sSLSocketFactory.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_sslSocketFactory1 = _class.instanceMethodId(
    r"sslSocketFactory",
    r"(Ljavax/net/ssl/SSLSocketFactory;Ljavax/net/ssl/X509TrustManager;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _sslSocketFactory1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory, javax.net.ssl.X509TrustManager x509TrustManager)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder sslSocketFactory1(
    jni.JObject sSLSocketFactory,
    jni.JObject x509TrustManager,
  ) {
    return _sslSocketFactory1(
            reference.pointer,
            _id_sslSocketFactory1 as jni.JMethodIDPtr,
            sSLSocketFactory.reference.pointer,
            x509TrustManager.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_connectionSpecs = _class.instanceMethodId(
    r"connectionSpecs",
    r"(Ljava/util/List;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _connectionSpecs = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder connectionSpecs(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionSpecs(
    jni.JList<jni.JObject> list,
  ) {
    return _connectionSpecs(reference.pointer,
            _id_connectionSpecs as jni.JMethodIDPtr, list.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_protocols = _class.instanceMethodId(
    r"protocols",
    r"(Ljava/util/List;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _protocols = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder protocols(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder protocols(
    jni.JList<jni.JObject> list,
  ) {
    return _protocols(reference.pointer, _id_protocols as jni.JMethodIDPtr,
            list.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_hostnameVerifier = _class.instanceMethodId(
    r"hostnameVerifier",
    r"(Ljavax/net/ssl/HostnameVerifier;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _hostnameVerifier = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder hostnameVerifier(javax.net.ssl.HostnameVerifier hostnameVerifier)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder hostnameVerifier(
    jni.JObject hostnameVerifier,
  ) {
    return _hostnameVerifier(
            reference.pointer,
            _id_hostnameVerifier as jni.JMethodIDPtr,
            hostnameVerifier.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_certificatePinner = _class.instanceMethodId(
    r"certificatePinner",
    r"(Lokhttp3/CertificatePinner;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _certificatePinner = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder certificatePinner(okhttp3.CertificatePinner certificatePinner)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder certificatePinner(
    jni.JObject certificatePinner,
  ) {
    return _certificatePinner(
            reference.pointer,
            _id_certificatePinner as jni.JMethodIDPtr,
            certificatePinner.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_callTimeout = _class.instanceMethodId(
    r"callTimeout",
    r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _callTimeout = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder callTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder callTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return _callTimeout(reference.pointer, _id_callTimeout as jni.JMethodIDPtr,
            j, timeUnit.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_callTimeout1 = _class.instanceMethodId(
    r"callTimeout",
    r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _callTimeout1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder callTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder callTimeout1(
    jni.JObject duration,
  ) {
    return _callTimeout1(reference.pointer,
            _id_callTimeout1 as jni.JMethodIDPtr, duration.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_connectTimeout = _class.instanceMethodId(
    r"connectTimeout",
    r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _connectTimeout = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder connectTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return _connectTimeout(
            reference.pointer,
            _id_connectTimeout as jni.JMethodIDPtr,
            j,
            timeUnit.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_connectTimeout1 = _class.instanceMethodId(
    r"connectTimeout",
    r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _connectTimeout1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder connectTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectTimeout1(
    jni.JObject duration,
  ) {
    return _connectTimeout1(reference.pointer,
            _id_connectTimeout1 as jni.JMethodIDPtr, duration.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_readTimeout = _class.instanceMethodId(
    r"readTimeout",
    r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _readTimeout = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder readTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder readTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return _readTimeout(reference.pointer, _id_readTimeout as jni.JMethodIDPtr,
            j, timeUnit.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_readTimeout1 = _class.instanceMethodId(
    r"readTimeout",
    r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _readTimeout1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder readTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder readTimeout1(
    jni.JObject duration,
  ) {
    return _readTimeout1(reference.pointer,
            _id_readTimeout1 as jni.JMethodIDPtr, duration.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_writeTimeout = _class.instanceMethodId(
    r"writeTimeout",
    r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _writeTimeout = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder writeTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder writeTimeout(
    int j,
    jni.JObject timeUnit,
  ) {
    return _writeTimeout(reference.pointer,
            _id_writeTimeout as jni.JMethodIDPtr, j, timeUnit.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_writeTimeout1 = _class.instanceMethodId(
    r"writeTimeout",
    r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _writeTimeout1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder writeTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder writeTimeout1(
    jni.JObject duration,
  ) {
    return _writeTimeout1(reference.pointer,
            _id_writeTimeout1 as jni.JMethodIDPtr, duration.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_pingInterval = _class.instanceMethodId(
    r"pingInterval",
    r"(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _pingInterval = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder pingInterval(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder pingInterval(
    int j,
    jni.JObject timeUnit,
  ) {
    return _pingInterval(reference.pointer,
            _id_pingInterval as jni.JMethodIDPtr, j, timeUnit.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_pingInterval1 = _class.instanceMethodId(
    r"pingInterval",
    r"(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _pingInterval1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder pingInterval(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder pingInterval1(
    jni.JObject duration,
  ) {
    return _pingInterval1(reference.pointer,
            _id_pingInterval1 as jni.JMethodIDPtr, duration.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_minWebSocketMessageToCompress = _class.instanceMethodId(
    r"minWebSocketMessageToCompress",
    r"(J)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _minWebSocketMessageToCompress = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okhttp3.OkHttpClient$Builder minWebSocketMessageToCompress(long j)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder minWebSocketMessageToCompress(
    int j,
  ) {
    return _minWebSocketMessageToCompress(reference.pointer,
            _id_minWebSocketMessageToCompress as jni.JMethodIDPtr, j)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r"build",
    r"()Lokhttp3/OkHttpClient;",
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.OkHttpClient build()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $OkHttpClientType());
  }
}

final class $OkHttpClient_BuilderType
    extends jni.JObjType<OkHttpClient_Builder> {
  const $OkHttpClient_BuilderType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient$Builder;";

  @override
  OkHttpClient_Builder fromReference(jni.JReference reference) =>
      OkHttpClient_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClient_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_BuilderType) &&
        other is $OkHttpClient_BuilderType;
  }
}

/// from: okhttp3.OkHttpClient$Companion
class OkHttpClient_Companion extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient_Companion> $type = type;

  OkHttpClient_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/OkHttpClient$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClient_CompanionType();
  static final _id_new0 = _class.constructorId(
    r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return OkHttpClient_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $OkHttpClient_CompanionType
    extends jni.JObjType<OkHttpClient_Companion> {
  const $OkHttpClient_CompanionType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient$Companion;";

  @override
  OkHttpClient_Companion fromReference(jni.JReference reference) =>
      OkHttpClient_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClient_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_CompanionType) &&
        other is $OkHttpClient_CompanionType;
  }
}

/// from: okhttp3.OkHttpClient
class OkHttpClient extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient> $type = type;

  OkHttpClient.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/OkHttpClient");

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClientType();
  static final _id_Companion = _class.staticFieldId(
    r"Companion",
    r"Lokhttp3/OkHttpClient$Companion;",
  );

  /// from: static public final okhttp3.OkHttpClient$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static OkHttpClient_Companion get Companion =>
      _id_Companion.get(_class, const $OkHttpClient_CompanionType());

  static final _id_new0 = _class.constructorId(
    r"(Lokhttp3/OkHttpClient$Builder;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.OkHttpClient$Builder builder)
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient(
    OkHttpClient_Builder builder,
  ) {
    return OkHttpClient.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, builder.reference.pointer)
        .reference);
  }

  static final _id_dispatcher = _class.instanceMethodId(
    r"dispatcher",
    r"()Lokhttp3/Dispatcher;",
  );

  static final _dispatcher = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Dispatcher dispatcher()
  /// The returned object must be released after use, by calling the [release] method.
  Dispatcher dispatcher() {
    return _dispatcher(reference.pointer, _id_dispatcher as jni.JMethodIDPtr)
        .object(const $DispatcherType());
  }

  static final _id_connectionPool = _class.instanceMethodId(
    r"connectionPool",
    r"()Lokhttp3/ConnectionPool;",
  );

  static final _connectionPool = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.ConnectionPool connectionPool()
  /// The returned object must be released after use, by calling the [release] method.
  ConnectionPool connectionPool() {
    return _connectionPool(
            reference.pointer, _id_connectionPool as jni.JMethodIDPtr)
        .object(const $ConnectionPoolType());
  }

  static final _id_interceptors = _class.instanceMethodId(
    r"interceptors",
    r"()Ljava/util/List;",
  );

  static final _interceptors = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> interceptors() {
    return _interceptors(
            reference.pointer, _id_interceptors as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_networkInterceptors = _class.instanceMethodId(
    r"networkInterceptors",
    r"()Ljava/util/List;",
  );

  static final _networkInterceptors = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> networkInterceptors() {
    return _networkInterceptors(
            reference.pointer, _id_networkInterceptors as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_eventListenerFactory = _class.instanceMethodId(
    r"eventListenerFactory",
    r"()Lokhttp3/EventListener$Factory;",
  );

  static final _eventListenerFactory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.EventListener$Factory eventListenerFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject eventListenerFactory() {
    return _eventListenerFactory(
            reference.pointer, _id_eventListenerFactory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_retryOnConnectionFailure = _class.instanceMethodId(
    r"retryOnConnectionFailure",
    r"()Z",
  );

  static final _retryOnConnectionFailure = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean retryOnConnectionFailure()
  bool retryOnConnectionFailure() {
    return _retryOnConnectionFailure(
            reference.pointer, _id_retryOnConnectionFailure as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_authenticator = _class.instanceMethodId(
    r"authenticator",
    r"()Lokhttp3/Authenticator;",
  );

  static final _authenticator = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Authenticator authenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject authenticator() {
    return _authenticator(
            reference.pointer, _id_authenticator as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_followRedirects = _class.instanceMethodId(
    r"followRedirects",
    r"()Z",
  );

  static final _followRedirects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean followRedirects()
  bool followRedirects() {
    return _followRedirects(
            reference.pointer, _id_followRedirects as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_followSslRedirects = _class.instanceMethodId(
    r"followSslRedirects",
    r"()Z",
  );

  static final _followSslRedirects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean followSslRedirects()
  bool followSslRedirects() {
    return _followSslRedirects(
            reference.pointer, _id_followSslRedirects as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_cookieJar = _class.instanceMethodId(
    r"cookieJar",
    r"()Lokhttp3/CookieJar;",
  );

  static final _cookieJar = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.CookieJar cookieJar()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cookieJar() {
    return _cookieJar(reference.pointer, _id_cookieJar as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_cache = _class.instanceMethodId(
    r"cache",
    r"()Lokhttp3/Cache;",
  );

  static final _cache = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Cache cache()
  /// The returned object must be released after use, by calling the [release] method.
  Cache cache() {
    return _cache(reference.pointer, _id_cache as jni.JMethodIDPtr)
        .object(const $CacheType());
  }

  static final _id_dns = _class.instanceMethodId(
    r"dns",
    r"()Lokhttp3/Dns;",
  );

  static final _dns = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Dns dns()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dns() {
    return _dns(reference.pointer, _id_dns as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_proxy = _class.instanceMethodId(
    r"proxy",
    r"()Ljava/net/Proxy;",
  );

  static final _proxy = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.net.Proxy proxy()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxy() {
    return _proxy(reference.pointer, _id_proxy as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_proxySelector = _class.instanceMethodId(
    r"proxySelector",
    r"()Ljava/net/ProxySelector;",
  );

  static final _proxySelector = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.net.ProxySelector proxySelector()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxySelector() {
    return _proxySelector(
            reference.pointer, _id_proxySelector as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_proxyAuthenticator = _class.instanceMethodId(
    r"proxyAuthenticator",
    r"()Lokhttp3/Authenticator;",
  );

  static final _proxyAuthenticator = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Authenticator proxyAuthenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxyAuthenticator() {
    return _proxyAuthenticator(
            reference.pointer, _id_proxyAuthenticator as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_socketFactory = _class.instanceMethodId(
    r"socketFactory",
    r"()Ljavax/net/SocketFactory;",
  );

  static final _socketFactory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final javax.net.SocketFactory socketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject socketFactory() {
    return _socketFactory(
            reference.pointer, _id_socketFactory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_sslSocketFactory = _class.instanceMethodId(
    r"sslSocketFactory",
    r"()Ljavax/net/ssl/SSLSocketFactory;",
  );

  static final _sslSocketFactory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final javax.net.ssl.SSLSocketFactory sslSocketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject sslSocketFactory() {
    return _sslSocketFactory(
            reference.pointer, _id_sslSocketFactory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_x509TrustManager = _class.instanceMethodId(
    r"x509TrustManager",
    r"()Ljavax/net/ssl/X509TrustManager;",
  );

  static final _x509TrustManager = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final javax.net.ssl.X509TrustManager x509TrustManager()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject x509TrustManager() {
    return _x509TrustManager(
            reference.pointer, _id_x509TrustManager as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_connectionSpecs = _class.instanceMethodId(
    r"connectionSpecs",
    r"()Ljava/util/List;",
  );

  static final _connectionSpecs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List connectionSpecs()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> connectionSpecs() {
    return _connectionSpecs(
            reference.pointer, _id_connectionSpecs as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_protocols = _class.instanceMethodId(
    r"protocols",
    r"()Ljava/util/List;",
  );

  static final _protocols = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List protocols()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> protocols() {
    return _protocols(reference.pointer, _id_protocols as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_hostnameVerifier = _class.instanceMethodId(
    r"hostnameVerifier",
    r"()Ljavax/net/ssl/HostnameVerifier;",
  );

  static final _hostnameVerifier = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final javax.net.ssl.HostnameVerifier hostnameVerifier()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject hostnameVerifier() {
    return _hostnameVerifier(
            reference.pointer, _id_hostnameVerifier as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_certificatePinner = _class.instanceMethodId(
    r"certificatePinner",
    r"()Lokhttp3/CertificatePinner;",
  );

  static final _certificatePinner = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.CertificatePinner certificatePinner()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject certificatePinner() {
    return _certificatePinner(
            reference.pointer, _id_certificatePinner as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_certificateChainCleaner = _class.instanceMethodId(
    r"certificateChainCleaner",
    r"()Lokhttp3/internal/tls/CertificateChainCleaner;",
  );

  static final _certificateChainCleaner = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.internal.tls.CertificateChainCleaner certificateChainCleaner()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject certificateChainCleaner() {
    return _certificateChainCleaner(
            reference.pointer, _id_certificateChainCleaner as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_callTimeoutMillis = _class.instanceMethodId(
    r"callTimeoutMillis",
    r"()I",
  );

  static final _callTimeoutMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int callTimeoutMillis()
  int callTimeoutMillis() {
    return _callTimeoutMillis(
            reference.pointer, _id_callTimeoutMillis as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_connectTimeoutMillis = _class.instanceMethodId(
    r"connectTimeoutMillis",
    r"()I",
  );

  static final _connectTimeoutMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int connectTimeoutMillis()
  int connectTimeoutMillis() {
    return _connectTimeoutMillis(
            reference.pointer, _id_connectTimeoutMillis as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_readTimeoutMillis = _class.instanceMethodId(
    r"readTimeoutMillis",
    r"()I",
  );

  static final _readTimeoutMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int readTimeoutMillis()
  int readTimeoutMillis() {
    return _readTimeoutMillis(
            reference.pointer, _id_readTimeoutMillis as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_writeTimeoutMillis = _class.instanceMethodId(
    r"writeTimeoutMillis",
    r"()I",
  );

  static final _writeTimeoutMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int writeTimeoutMillis()
  int writeTimeoutMillis() {
    return _writeTimeoutMillis(
            reference.pointer, _id_writeTimeoutMillis as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_pingIntervalMillis = _class.instanceMethodId(
    r"pingIntervalMillis",
    r"()I",
  );

  static final _pingIntervalMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int pingIntervalMillis()
  int pingIntervalMillis() {
    return _pingIntervalMillis(
            reference.pointer, _id_pingIntervalMillis as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_minWebSocketMessageToCompress = _class.instanceMethodId(
    r"minWebSocketMessageToCompress",
    r"()J",
  );

  static final _minWebSocketMessageToCompress = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long minWebSocketMessageToCompress()
  int minWebSocketMessageToCompress() {
    return _minWebSocketMessageToCompress(reference.pointer,
            _id_minWebSocketMessageToCompress as jni.JMethodIDPtr)
        .long;
  }

  static final _id_getRouteDatabase = _class.instanceMethodId(
    r"getRouteDatabase",
    r"()Lokhttp3/internal/connection/RouteDatabase;",
  );

  static final _getRouteDatabase = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.internal.connection.RouteDatabase getRouteDatabase()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRouteDatabase() {
    return _getRouteDatabase(
            reference.pointer, _id_getRouteDatabase as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_new1 = _class.constructorId(
    r"()V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient.new1() {
    return OkHttpClient.fromReference(
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_newCall = _class.instanceMethodId(
    r"newCall",
    r"(Lokhttp3/Request;)Lokhttp3/Call;",
  );

  static final _newCall = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    Request request,
  ) {
    return _newCall(reference.pointer, _id_newCall as jni.JMethodIDPtr,
            request.reference.pointer)
        .object(const $CallType());
  }

  static final _id_newWebSocket = _class.instanceMethodId(
    r"newWebSocket",
    r"(Lokhttp3/Request;Lokhttp3/WebSocketListener;)Lokhttp3/WebSocket;",
  );

  static final _newWebSocket = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.WebSocket newWebSocket(okhttp3.Request request, okhttp3.WebSocketListener webSocketListener)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject newWebSocket(
    Request request,
    jni.JObject webSocketListener,
  ) {
    return _newWebSocket(
            reference.pointer,
            _id_newWebSocket as jni.JMethodIDPtr,
            request.reference.pointer,
            webSocketListener.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_newBuilder = _class.instanceMethodId(
    r"newBuilder",
    r"()Lokhttp3/OkHttpClient$Builder;",
  );

  static final _newBuilder = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okhttp3.OkHttpClient$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder newBuilder() {
    return _newBuilder(reference.pointer, _id_newBuilder as jni.JMethodIDPtr)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_clone = _class.instanceMethodId(
    r"clone",
    r"()Ljava/lang/Object;",
  );

  static final _clone = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Object clone()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject clone() {
    return _clone(reference.pointer, _id_clone as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $OkHttpClientType extends jni.JObjType<OkHttpClient> {
  const $OkHttpClientType();

  @override
  String get signature => r"Lokhttp3/OkHttpClient;";

  @override
  OkHttpClient fromReference(jni.JReference reference) =>
      OkHttpClient.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClientType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClientType) &&
        other is $OkHttpClientType;
  }
}

/// from: okhttp3.Call$Factory
class Call_Factory extends jni.JObject {
  @override
  late final jni.JObjType<Call_Factory> $type = type;

  Call_Factory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Call$Factory");

  /// The type which includes information such as the signature of this class.
  static const type = $Call_FactoryType();
  static final _id_newCall = _class.instanceMethodId(
    r"newCall",
    r"(Lokhttp3/Request;)Lokhttp3/Call;",
  );

  static final _newCall = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    Request request,
  ) {
    return _newCall(reference.pointer, _id_newCall as jni.JMethodIDPtr,
            request.reference.pointer)
        .object(const $CallType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Call_FactoryImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"newCall(Lokhttp3/Request;)Lokhttp3/Call;") {
        final $r = _$impls[$p]!.newCall(
          $a[0].castTo(const $RequestType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Call_Factory.implement(
    $Call_FactoryImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Call_Factory.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"okhttp3.Call$Factory",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Call_FactoryImpl {
  factory $Call_FactoryImpl({
    required Call Function(Request request) newCall,
  }) = _$Call_FactoryImpl;

  Call newCall(Request request);
}

class _$Call_FactoryImpl implements $Call_FactoryImpl {
  _$Call_FactoryImpl({
    required Call Function(Request request) newCall,
  }) : _newCall = newCall;

  final Call Function(Request request) _newCall;

  Call newCall(Request request) {
    return _newCall(request);
  }
}

final class $Call_FactoryType extends jni.JObjType<Call_Factory> {
  const $Call_FactoryType();

  @override
  String get signature => r"Lokhttp3/Call$Factory;";

  @override
  Call_Factory fromReference(jni.JReference reference) =>
      Call_Factory.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Call_FactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Call_FactoryType) &&
        other is $Call_FactoryType;
  }
}

/// from: okhttp3.Call
class Call extends jni.JObject {
  @override
  late final jni.JObjType<Call> $type = type;

  Call.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Call");

  /// The type which includes information such as the signature of this class.
  static const type = $CallType();
  static final _id_request = _class.instanceMethodId(
    r"request",
    r"()Lokhttp3/Request;",
  );

  static final _request = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return _request(reference.pointer, _id_request as jni.JMethodIDPtr)
        .object(const $RequestType());
  }

  static final _id_execute = _class.instanceMethodId(
    r"execute",
    r"()Lokhttp3/Response;",
  );

  static final _execute = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.Response execute()
  /// The returned object must be released after use, by calling the [release] method.
  Response execute() {
    return _execute(reference.pointer, _id_execute as jni.JMethodIDPtr)
        .object(const $ResponseType());
  }

  static final _id_enqueue = _class.instanceMethodId(
    r"enqueue",
    r"(Lokhttp3/Callback;)V",
  );

  static final _enqueue = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enqueue(okhttp3.Callback callback)
  void enqueue(
    Callback callback,
  ) {
    _enqueue(reference.pointer, _id_enqueue as jni.JMethodIDPtr,
            callback.reference.pointer)
        .check();
  }

  static final _id_cancel = _class.instanceMethodId(
    r"cancel",
    r"()V",
  );

  static final _cancel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void cancel()
  void cancel() {
    _cancel(reference.pointer, _id_cancel as jni.JMethodIDPtr).check();
  }

  static final _id_isExecuted = _class.instanceMethodId(
    r"isExecuted",
    r"()Z",
  );

  static final _isExecuted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isExecuted()
  bool isExecuted() {
    return _isExecuted(reference.pointer, _id_isExecuted as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isCanceled = _class.instanceMethodId(
    r"isCanceled",
    r"()Z",
  );

  static final _isCanceled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isCanceled()
  bool isCanceled() {
    return _isCanceled(reference.pointer, _id_isCanceled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_timeout = _class.instanceMethodId(
    r"timeout",
    r"()Lokio/Timeout;",
  );

  static final _timeout = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject timeout() {
    return _timeout(reference.pointer, _id_timeout as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_clone = _class.instanceMethodId(
    r"clone",
    r"()Lokhttp3/Call;",
  );

  static final _clone = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.Call clone()
  /// The returned object must be released after use, by calling the [release] method.
  Call clone() {
    return _clone(reference.pointer, _id_clone as jni.JMethodIDPtr)
        .object(const $CallType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CallImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"request()Lokhttp3/Request;") {
        final $r = _$impls[$p]!.request();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"execute()Lokhttp3/Response;") {
        final $r = _$impls[$p]!.execute();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"enqueue(Lokhttp3/Callback;)V") {
        _$impls[$p]!.enqueue(
          $a[0].castTo(const $CallbackType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"cancel()V") {
        _$impls[$p]!.cancel();
        return jni.nullptr;
      }
      if ($d == r"isExecuted()Z") {
        final $r = _$impls[$p]!.isExecuted();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r"isCanceled()Z") {
        final $r = _$impls[$p]!.isCanceled();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r"timeout()Lokio/Timeout;") {
        final $r = _$impls[$p]!.timeout();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"clone()Lokhttp3/Call;") {
        final $r = _$impls[$p]!.clone();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Call.implement(
    $CallImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Call.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"okhttp3.Call",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CallImpl {
  factory $CallImpl({
    required Request Function() request,
    required Response Function() execute,
    required void Function(Callback callback) enqueue,
    required void Function() cancel,
    required bool Function() isExecuted,
    required bool Function() isCanceled,
    required jni.JObject Function() timeout,
    required Call Function() clone,
  }) = _$CallImpl;

  Request request();
  Response execute();
  void enqueue(Callback callback);
  void cancel();
  bool isExecuted();
  bool isCanceled();
  jni.JObject timeout();
  Call clone();
}

class _$CallImpl implements $CallImpl {
  _$CallImpl({
    required Request Function() request,
    required Response Function() execute,
    required void Function(Callback callback) enqueue,
    required void Function() cancel,
    required bool Function() isExecuted,
    required bool Function() isCanceled,
    required jni.JObject Function() timeout,
    required Call Function() clone,
  })  : _request = request,
        _execute = execute,
        _enqueue = enqueue,
        _cancel = cancel,
        _isExecuted = isExecuted,
        _isCanceled = isCanceled,
        _timeout = timeout,
        _clone = clone;

  final Request Function() _request;
  final Response Function() _execute;
  final void Function(Callback callback) _enqueue;
  final void Function() _cancel;
  final bool Function() _isExecuted;
  final bool Function() _isCanceled;
  final jni.JObject Function() _timeout;
  final Call Function() _clone;

  Request request() {
    return _request();
  }

  Response execute() {
    return _execute();
  }

  void enqueue(Callback callback) {
    return _enqueue(callback);
  }

  void cancel() {
    return _cancel();
  }

  bool isExecuted() {
    return _isExecuted();
  }

  bool isCanceled() {
    return _isCanceled();
  }

  jni.JObject timeout() {
    return _timeout();
  }

  Call clone() {
    return _clone();
  }
}

final class $CallType extends jni.JObjType<Call> {
  const $CallType();

  @override
  String get signature => r"Lokhttp3/Call;";

  @override
  Call fromReference(jni.JReference reference) => Call.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CallType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CallType) && other is $CallType;
  }
}

/// from: okhttp3.Headers$Builder
class Headers_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Headers_Builder> $type = type;

  Headers_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Headers$Builder");

  /// The type which includes information such as the signature of this class.
  static const type = $Headers_BuilderType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Headers_Builder() {
    return Headers_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_add = _class.instanceMethodId(
    r"add",
    r"(Ljava/lang/String;)Lokhttp3/Headers$Builder;",
  );

  static final _add = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder add(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add(
    jni.JString string,
  ) {
    return _add(reference.pointer, _id_add as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_add1 = _class.instanceMethodId(
    r"add",
    r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;",
  );

  static final _add1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder add(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add1(
    jni.JString string,
    jni.JString string1,
  ) {
    return _add1(reference.pointer, _id_add1 as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_addUnsafeNonAscii = _class.instanceMethodId(
    r"addUnsafeNonAscii",
    r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;",
  );

  static final _addUnsafeNonAscii = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder addUnsafeNonAscii(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder addUnsafeNonAscii(
    jni.JString string,
    jni.JString string1,
  ) {
    return _addUnsafeNonAscii(
            reference.pointer,
            _id_addUnsafeNonAscii as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_addAll = _class.instanceMethodId(
    r"addAll",
    r"(Lokhttp3/Headers;)Lokhttp3/Headers$Builder;",
  );

  static final _addAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder addAll(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder addAll(
    Headers headers,
  ) {
    return _addAll(reference.pointer, _id_addAll as jni.JMethodIDPtr,
            headers.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_add2 = _class.instanceMethodId(
    r"add",
    r"(Ljava/lang/String;Ljava/util/Date;)Lokhttp3/Headers$Builder;",
  );

  static final _add2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder add(java.lang.String string, java.util.Date date)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add2(
    jni.JString string,
    jni.JObject date,
  ) {
    return _add2(reference.pointer, _id_add2 as jni.JMethodIDPtr,
            string.reference.pointer, date.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_add3 = _class.instanceMethodId(
    r"add",
    r"(Ljava/lang/String;Ljava/time/Instant;)Lokhttp3/Headers$Builder;",
  );

  static final _add3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder add(java.lang.String string, java.time.Instant instant)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add3(
    jni.JString string,
    jni.JObject instant,
  ) {
    return _add3(reference.pointer, _id_add3 as jni.JMethodIDPtr,
            string.reference.pointer, instant.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_set0 = _class.instanceMethodId(
    r"set",
    r"(Ljava/lang/String;Ljava/util/Date;)Lokhttp3/Headers$Builder;",
  );

  static final _set0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder set(java.lang.String string, java.util.Date date)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder set0(
    jni.JString string,
    jni.JObject date,
  ) {
    return _set0(reference.pointer, _id_set0 as jni.JMethodIDPtr,
            string.reference.pointer, date.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_set1 = _class.instanceMethodId(
    r"set",
    r"(Ljava/lang/String;Ljava/time/Instant;)Lokhttp3/Headers$Builder;",
  );

  static final _set1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder set(java.lang.String string, java.time.Instant instant)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder set1(
    jni.JString string,
    jni.JObject instant,
  ) {
    return _set1(reference.pointer, _id_set1 as jni.JMethodIDPtr,
            string.reference.pointer, instant.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_removeAll = _class.instanceMethodId(
    r"removeAll",
    r"(Ljava/lang/String;)Lokhttp3/Headers$Builder;",
  );

  static final _removeAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder removeAll(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder removeAll(
    jni.JString string,
  ) {
    return _removeAll(reference.pointer, _id_removeAll as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_set2 = _class.instanceMethodId(
    r"set",
    r"(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;",
  );

  static final _set2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder set(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder set2(
    jni.JString string,
    jni.JString string1,
  ) {
    return _set2(reference.pointer, _id_set2 as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_get0 = _class.instanceMethodId(
    r"get",
    r"(Ljava/lang/String;)Ljava/lang/String;",
  );

  static final _get0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString get0(
    jni.JString string,
  ) {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_build = _class.instanceMethodId(
    r"build",
    r"()Lokhttp3/Headers;",
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Headers build()
  /// The returned object must be released after use, by calling the [release] method.
  Headers build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $HeadersType());
  }
}

final class $Headers_BuilderType extends jni.JObjType<Headers_Builder> {
  const $Headers_BuilderType();

  @override
  String get signature => r"Lokhttp3/Headers$Builder;";

  @override
  Headers_Builder fromReference(jni.JReference reference) =>
      Headers_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Headers_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Headers_BuilderType) &&
        other is $Headers_BuilderType;
  }
}

/// from: okhttp3.Headers$Companion
class Headers_Companion extends jni.JObject {
  @override
  late final jni.JObjType<Headers_Companion> $type = type;

  Headers_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Headers$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $Headers_CompanionType();
  static final _id_of = _class.instanceMethodId(
    r"of",
    r"([Ljava/lang/String;)Lokhttp3/Headers;",
  );

  static final _of = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers of(java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  Headers of(
    jni.JArray<jni.JString> strings,
  ) {
    return _of(reference.pointer, _id_of as jni.JMethodIDPtr,
            strings.reference.pointer)
        .object(const $HeadersType());
  }

  static final _id_of1 = _class.instanceMethodId(
    r"of",
    r"(Ljava/util/Map;)Lokhttp3/Headers;",
  );

  static final _of1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers of(java.util.Map map)
  /// The returned object must be released after use, by calling the [release] method.
  Headers of1(
    jni.JMap<jni.JString, jni.JString> map,
  ) {
    return _of1(reference.pointer, _id_of1 as jni.JMethodIDPtr,
            map.reference.pointer)
        .object(const $HeadersType());
  }

  static final _id_new0 = _class.constructorId(
    r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Headers_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return Headers_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $Headers_CompanionType extends jni.JObjType<Headers_Companion> {
  const $Headers_CompanionType();

  @override
  String get signature => r"Lokhttp3/Headers$Companion;";

  @override
  Headers_Companion fromReference(jni.JReference reference) =>
      Headers_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Headers_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Headers_CompanionType) &&
        other is $Headers_CompanionType;
  }
}

/// from: okhttp3.Headers
class Headers extends jni.JObject {
  @override
  late final jni.JObjType<Headers> $type = type;

  Headers.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Headers");

  /// The type which includes information such as the signature of this class.
  static const type = $HeadersType();
  static final _id_Companion = _class.staticFieldId(
    r"Companion",
    r"Lokhttp3/Headers$Companion;",
  );

  /// from: static public final okhttp3.Headers$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static Headers_Companion get Companion =>
      _id_Companion.get(_class, const $Headers_CompanionType());

  static final _id_get0 = _class.instanceMethodId(
    r"get",
    r"(Ljava/lang/String;)Ljava/lang/String;",
  );

  static final _get0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString get0(
    jni.JString string,
  ) {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getDate = _class.instanceMethodId(
    r"getDate",
    r"(Ljava/lang/String;)Ljava/util/Date;",
  );

  static final _getDate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.Date getDate(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDate(
    jni.JString string,
  ) {
    return _getDate(reference.pointer, _id_getDate as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getInstant = _class.instanceMethodId(
    r"getInstant",
    r"(Ljava/lang/String;)Ljava/time/Instant;",
  );

  static final _getInstant = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.time.Instant getInstant(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getInstant(
    jni.JString string,
  ) {
    return _getInstant(reference.pointer, _id_getInstant as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_size = _class.instanceMethodId(
    r"size",
    r"()I",
  );

  static final _size = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int size()
  int size() {
    return _size(reference.pointer, _id_size as jni.JMethodIDPtr).integer;
  }

  static final _id_name = _class.instanceMethodId(
    r"name",
    r"(I)Ljava/lang/String;",
  );

  static final _name = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final java.lang.String name(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString name(
    int i,
  ) {
    return _name(reference.pointer, _id_name as jni.JMethodIDPtr, i)
        .object(const jni.JStringType());
  }

  static final _id_value = _class.instanceMethodId(
    r"value",
    r"(I)Ljava/lang/String;",
  );

  static final _value = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final java.lang.String value(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString value(
    int i,
  ) {
    return _value(reference.pointer, _id_value as jni.JMethodIDPtr, i)
        .object(const jni.JStringType());
  }

  static final _id_names = _class.instanceMethodId(
    r"names",
    r"()Ljava/util/Set;",
  );

  static final _names = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.Set names()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JString> names() {
    return _names(reference.pointer, _id_names as jni.JMethodIDPtr)
        .object(const jni.JSetType(jni.JStringType()));
  }

  static final _id_values = _class.instanceMethodId(
    r"values",
    r"(Ljava/lang/String;)Ljava/util/List;",
  );

  static final _values = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.List values(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> values(
    jni.JString string,
  ) {
    return _values(reference.pointer, _id_values as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_byteCount = _class.instanceMethodId(
    r"byteCount",
    r"()J",
  );

  static final _byteCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long byteCount()
  int byteCount() {
    return _byteCount(reference.pointer, _id_byteCount as jni.JMethodIDPtr)
        .long;
  }

  static final _id_iterator = _class.instanceMethodId(
    r"iterator",
    r"()Ljava/util/Iterator;",
  );

  static final _iterator = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.Iterator iterator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JIterator<jni.JObject> iterator() {
    return _iterator(reference.pointer, _id_iterator as jni.JMethodIDPtr)
        .object(const jni.JIteratorType(jni.JObjectType()));
  }

  static final _id_newBuilder = _class.instanceMethodId(
    r"newBuilder",
    r"()Lokhttp3/Headers$Builder;",
  );

  static final _newBuilder = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Headers$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder newBuilder() {
    return _newBuilder(reference.pointer, _id_newBuilder as jni.JMethodIDPtr)
        .object(const $Headers_BuilderType());
  }

  static final _id_equals = _class.instanceMethodId(
    r"equals",
    r"(Ljava/lang/Object;)Z",
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r"hashCode",
    r"()I",
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r"toString",
    r"()Ljava/lang/String;",
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_toMultimap = _class.instanceMethodId(
    r"toMultimap",
    r"()Ljava/util/Map;",
  );

  static final _toMultimap = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.Map toMultimap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JMap<jni.JString, jni.JList<jni.JString>> toMultimap() {
    return _toMultimap(reference.pointer, _id_toMultimap as jni.JMethodIDPtr)
        .object(const jni.JMapType(
            jni.JStringType(), jni.JListType(jni.JStringType())));
  }

  static final _id_of = _class.staticMethodId(
    r"of",
    r"([Ljava/lang/String;)Lokhttp3/Headers;",
  );

  static final _of = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.Headers of(java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  static Headers of(
    jni.JArray<jni.JString> strings,
  ) {
    return _of(_class.reference.pointer, _id_of as jni.JMethodIDPtr,
            strings.reference.pointer)
        .object(const $HeadersType());
  }

  static final _id_of1 = _class.staticMethodId(
    r"of",
    r"(Ljava/util/Map;)Lokhttp3/Headers;",
  );

  static final _of1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.Headers of(java.util.Map map)
  /// The returned object must be released after use, by calling the [release] method.
  static Headers of1(
    jni.JMap<jni.JString, jni.JString> map,
  ) {
    return _of1(_class.reference.pointer, _id_of1 as jni.JMethodIDPtr,
            map.reference.pointer)
        .object(const $HeadersType());
  }

  static final _id_new0 = _class.constructorId(
    r"([Ljava/lang/String;Lkotlin/jvm/internal/DefaultConstructorMarker;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String[] strings, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Headers(
    jni.JArray<jni.JString> strings,
    jni.JObject defaultConstructorMarker,
  ) {
    return Headers.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            strings.reference.pointer,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $HeadersType extends jni.JObjType<Headers> {
  const $HeadersType();

  @override
  String get signature => r"Lokhttp3/Headers;";

  @override
  Headers fromReference(jni.JReference reference) =>
      Headers.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($HeadersType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HeadersType) && other is $HeadersType;
  }
}

/// from: okhttp3.Callback
class Callback extends jni.JObject {
  @override
  late final jni.JObjType<Callback> $type = type;

  Callback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Callback");

  /// The type which includes information such as the signature of this class.
  static const type = $CallbackType();
  static final _id_onFailure = _class.instanceMethodId(
    r"onFailure",
    r"(Lokhttp3/Call;Ljava/io/IOException;)V",
  );

  static final _onFailure = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onFailure(okhttp3.Call call, java.io.IOException iOException)
  void onFailure(
    Call call,
    jni.JObject iOException,
  ) {
    _onFailure(reference.pointer, _id_onFailure as jni.JMethodIDPtr,
            call.reference.pointer, iOException.reference.pointer)
        .check();
  }

  static final _id_onResponse = _class.instanceMethodId(
    r"onResponse",
    r"(Lokhttp3/Call;Lokhttp3/Response;)V",
  );

  static final _onResponse = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onResponse(okhttp3.Call call, okhttp3.Response response)
  void onResponse(
    Call call,
    Response response,
  ) {
    _onResponse(reference.pointer, _id_onResponse as jni.JMethodIDPtr,
            call.reference.pointer, response.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onFailure(Lokhttp3/Call;Ljava/io/IOException;)V") {
        _$impls[$p]!.onFailure(
          $a[0].castTo(const $CallType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"onResponse(Lokhttp3/Call;Lokhttp3/Response;)V") {
        _$impls[$p]!.onResponse(
          $a[0].castTo(const $CallType(), releaseOriginal: true),
          $a[1].castTo(const $ResponseType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Callback.implement(
    $CallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Callback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"okhttp3.Callback",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CallbackImpl {
  factory $CallbackImpl({
    required void Function(Call call, jni.JObject iOException) onFailure,
    required void Function(Call call, Response response) onResponse,
  }) = _$CallbackImpl;

  void onFailure(Call call, jni.JObject iOException);
  void onResponse(Call call, Response response);
}

class _$CallbackImpl implements $CallbackImpl {
  _$CallbackImpl({
    required void Function(Call call, jni.JObject iOException) onFailure,
    required void Function(Call call, Response response) onResponse,
  })  : _onFailure = onFailure,
        _onResponse = onResponse;

  final void Function(Call call, jni.JObject iOException) _onFailure;
  final void Function(Call call, Response response) _onResponse;

  void onFailure(Call call, jni.JObject iOException) {
    return _onFailure(call, iOException);
  }

  void onResponse(Call call, Response response) {
    return _onResponse(call, response);
  }
}

final class $CallbackType extends jni.JObjType<Callback> {
  const $CallbackType();

  @override
  String get signature => r"Lokhttp3/Callback;";

  @override
  Callback fromReference(jni.JReference reference) =>
      Callback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CallbackType) && other is $CallbackType;
  }
}

/// from: okhttp3.ConnectionPool
class ConnectionPool extends jni.JObject {
  @override
  late final jni.JObjType<ConnectionPool> $type = type;

  ConnectionPool.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/ConnectionPool");

  /// The type which includes information such as the signature of this class.
  static const type = $ConnectionPoolType();
  static final _id_new0 = _class.constructorId(
    r"(Lokhttp3/internal/connection/RealConnectionPool;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.internal.connection.RealConnectionPool realConnectionPool)
  /// The returned object must be released after use, by calling the [release] method.
  factory ConnectionPool(
    jni.JObject realConnectionPool,
  ) {
    return ConnectionPool.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, realConnectionPool.reference.pointer)
        .reference);
  }

  static final _id_new1 = _class.constructorId(
    r"(IJLjava/util/concurrent/TimeUnit;)V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Int32,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  factory ConnectionPool.new1(
    int i,
    int j,
    jni.JObject timeUnit,
  ) {
    return ConnectionPool.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, i, j, timeUnit.reference.pointer)
        .reference);
  }

  static final _id_new2 = _class.constructorId(
    r"()V",
  );

  static final _new2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ConnectionPool.new2() {
    return ConnectionPool.fromReference(
        _new2(_class.reference.pointer, _id_new2 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_idleConnectionCount = _class.instanceMethodId(
    r"idleConnectionCount",
    r"()I",
  );

  static final _idleConnectionCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int idleConnectionCount()
  int idleConnectionCount() {
    return _idleConnectionCount(
            reference.pointer, _id_idleConnectionCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_connectionCount = _class.instanceMethodId(
    r"connectionCount",
    r"()I",
  );

  static final _connectionCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int connectionCount()
  int connectionCount() {
    return _connectionCount(
            reference.pointer, _id_connectionCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_evictAll = _class.instanceMethodId(
    r"evictAll",
    r"()V",
  );

  static final _evictAll = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void evictAll()
  void evictAll() {
    _evictAll(reference.pointer, _id_evictAll as jni.JMethodIDPtr).check();
  }
}

final class $ConnectionPoolType extends jni.JObjType<ConnectionPool> {
  const $ConnectionPoolType();

  @override
  String get signature => r"Lokhttp3/ConnectionPool;";

  @override
  ConnectionPool fromReference(jni.JReference reference) =>
      ConnectionPool.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ConnectionPoolType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ConnectionPoolType) &&
        other is $ConnectionPoolType;
  }
}

/// from: okhttp3.Dispatcher
class Dispatcher extends jni.JObject {
  @override
  late final jni.JObjType<Dispatcher> $type = type;

  Dispatcher.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Dispatcher");

  /// The type which includes information such as the signature of this class.
  static const type = $DispatcherType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Dispatcher() {
    return Dispatcher.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getMaxRequests = _class.instanceMethodId(
    r"getMaxRequests",
    r"()I",
  );

  static final _getMaxRequests = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int getMaxRequests()
  int getMaxRequests() {
    return _getMaxRequests(
            reference.pointer, _id_getMaxRequests as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setMaxRequests = _class.instanceMethodId(
    r"setMaxRequests",
    r"(I)V",
  );

  static final _setMaxRequests = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setMaxRequests(int i)
  void setMaxRequests(
    int i,
  ) {
    _setMaxRequests(
            reference.pointer, _id_setMaxRequests as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getMaxRequestsPerHost = _class.instanceMethodId(
    r"getMaxRequestsPerHost",
    r"()I",
  );

  static final _getMaxRequestsPerHost = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int getMaxRequestsPerHost()
  int getMaxRequestsPerHost() {
    return _getMaxRequestsPerHost(
            reference.pointer, _id_getMaxRequestsPerHost as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setMaxRequestsPerHost = _class.instanceMethodId(
    r"setMaxRequestsPerHost",
    r"(I)V",
  );

  static final _setMaxRequestsPerHost = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int32,)>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setMaxRequestsPerHost(int i)
  void setMaxRequestsPerHost(
    int i,
  ) {
    _setMaxRequestsPerHost(
            reference.pointer, _id_setMaxRequestsPerHost as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getIdleCallback = _class.instanceMethodId(
    r"getIdleCallback",
    r"()Ljava/lang/Runnable;",
  );

  static final _getIdleCallback = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.Runnable getIdleCallback()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getIdleCallback() {
    return _getIdleCallback(
            reference.pointer, _id_getIdleCallback as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setIdleCallback = _class.instanceMethodId(
    r"setIdleCallback",
    r"(Ljava/lang/Runnable;)V",
  );

  static final _setIdleCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void setIdleCallback(java.lang.Runnable runnable)
  void setIdleCallback(
    jni.JObject runnable,
  ) {
    _setIdleCallback(reference.pointer, _id_setIdleCallback as jni.JMethodIDPtr,
            runnable.reference.pointer)
        .check();
  }

  static final _id_executorService = _class.instanceMethodId(
    r"executorService",
    r"()Ljava/util/concurrent/ExecutorService;",
  );

  static final _executorService = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.concurrent.ExecutorService executorService()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject executorService() {
    return _executorService(
            reference.pointer, _id_executorService as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_new1 = _class.constructorId(
    r"(Ljava/util/concurrent/ExecutorService;)V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.util.concurrent.ExecutorService executorService)
  /// The returned object must be released after use, by calling the [release] method.
  factory Dispatcher.new1(
    jni.JObject executorService,
  ) {
    return Dispatcher.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, executorService.reference.pointer)
        .reference);
  }

  static final _id_cancelAll = _class.instanceMethodId(
    r"cancelAll",
    r"()V",
  );

  static final _cancelAll = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void cancelAll()
  void cancelAll() {
    _cancelAll(reference.pointer, _id_cancelAll as jni.JMethodIDPtr).check();
  }

  static final _id_queuedCalls = _class.instanceMethodId(
    r"queuedCalls",
    r"()Ljava/util/List;",
  );

  static final _queuedCalls = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List queuedCalls()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Call> queuedCalls() {
    return _queuedCalls(reference.pointer, _id_queuedCalls as jni.JMethodIDPtr)
        .object(const jni.JListType($CallType()));
  }

  static final _id_runningCalls = _class.instanceMethodId(
    r"runningCalls",
    r"()Ljava/util/List;",
  );

  static final _runningCalls = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List runningCalls()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Call> runningCalls() {
    return _runningCalls(
            reference.pointer, _id_runningCalls as jni.JMethodIDPtr)
        .object(const jni.JListType($CallType()));
  }

  static final _id_queuedCallsCount = _class.instanceMethodId(
    r"queuedCallsCount",
    r"()I",
  );

  static final _queuedCallsCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int queuedCallsCount()
  int queuedCallsCount() {
    return _queuedCallsCount(
            reference.pointer, _id_queuedCallsCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_runningCallsCount = _class.instanceMethodId(
    r"runningCallsCount",
    r"()I",
  );

  static final _runningCallsCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int runningCallsCount()
  int runningCallsCount() {
    return _runningCallsCount(
            reference.pointer, _id_runningCallsCount as jni.JMethodIDPtr)
        .integer;
  }
}

final class $DispatcherType extends jni.JObjType<Dispatcher> {
  const $DispatcherType();

  @override
  String get signature => r"Lokhttp3/Dispatcher;";

  @override
  Dispatcher fromReference(jni.JReference reference) =>
      Dispatcher.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($DispatcherType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($DispatcherType) && other is $DispatcherType;
  }
}

/// from: okhttp3.Cache$Companion
class Cache_Companion extends jni.JObject {
  @override
  late final jni.JObjType<Cache_Companion> $type = type;

  Cache_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Cache$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $Cache_CompanionType();
  static final _id_key = _class.instanceMethodId(
    r"key",
    r"(Lokhttp3/HttpUrl;)Ljava/lang/String;",
  );

  static final _key = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String key(okhttp3.HttpUrl httpUrl)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString key(
    jni.JObject httpUrl,
  ) {
    return _key(reference.pointer, _id_key as jni.JMethodIDPtr,
            httpUrl.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_varyMatches = _class.instanceMethodId(
    r"varyMatches",
    r"(Lokhttp3/Response;Lokhttp3/Headers;Lokhttp3/Request;)Z",
  );

  static final _varyMatches = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean varyMatches(okhttp3.Response response, okhttp3.Headers headers, okhttp3.Request request)
  bool varyMatches(
    Response response,
    Headers headers,
    Request request,
  ) {
    return _varyMatches(
            reference.pointer,
            _id_varyMatches as jni.JMethodIDPtr,
            response.reference.pointer,
            headers.reference.pointer,
            request.reference.pointer)
        .boolean;
  }

  static final _id_hasVaryAll = _class.instanceMethodId(
    r"hasVaryAll",
    r"(Lokhttp3/Response;)Z",
  );

  static final _hasVaryAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean hasVaryAll(okhttp3.Response response)
  bool hasVaryAll(
    Response response,
  ) {
    return _hasVaryAll(reference.pointer, _id_hasVaryAll as jni.JMethodIDPtr,
            response.reference.pointer)
        .boolean;
  }

  static final _id_varyHeaders = _class.instanceMethodId(
    r"varyHeaders",
    r"(Lokhttp3/Response;)Lokhttp3/Headers;",
  );

  static final _varyHeaders = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers varyHeaders(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Headers varyHeaders(
    Response response,
  ) {
    return _varyHeaders(reference.pointer, _id_varyHeaders as jni.JMethodIDPtr,
            response.reference.pointer)
        .object(const $HeadersType());
  }

  static final _id_new0 = _class.constructorId(
    r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Cache_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return Cache_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $Cache_CompanionType extends jni.JObjType<Cache_Companion> {
  const $Cache_CompanionType();

  @override
  String get signature => r"Lokhttp3/Cache$Companion;";

  @override
  Cache_Companion fromReference(jni.JReference reference) =>
      Cache_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Cache_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Cache_CompanionType) &&
        other is $Cache_CompanionType;
  }
}

/// from: okhttp3.Cache$Entry$Companion
class Cache_Entry_Companion extends jni.JObject {
  @override
  late final jni.JObjType<Cache_Entry_Companion> $type = type;

  Cache_Entry_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Cache$Entry$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $Cache_Entry_CompanionType();
  static final _id_new0 = _class.constructorId(
    r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Cache_Entry_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return Cache_Entry_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $Cache_Entry_CompanionType
    extends jni.JObjType<Cache_Entry_Companion> {
  const $Cache_Entry_CompanionType();

  @override
  String get signature => r"Lokhttp3/Cache$Entry$Companion;";

  @override
  Cache_Entry_Companion fromReference(jni.JReference reference) =>
      Cache_Entry_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Cache_Entry_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Cache_Entry_CompanionType) &&
        other is $Cache_Entry_CompanionType;
  }
}

/// from: okhttp3.Cache
class Cache extends jni.JObject {
  @override
  late final jni.JObjType<Cache> $type = type;

  Cache.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"okhttp3/Cache");

  /// The type which includes information such as the signature of this class.
  static const type = $CacheType();
  static final _id_Companion = _class.staticFieldId(
    r"Companion",
    r"Lokhttp3/Cache$Companion;",
  );

  /// from: static public final okhttp3.Cache$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static Cache_Companion get Companion =>
      _id_Companion.get(_class, const $Cache_CompanionType());

  static final _id_new0 = _class.constructorId(
    r"(Ljava/io/File;JLokhttp3/internal/io/FileSystem;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.io.File file, long j, okhttp3.internal.io.FileSystem fileSystem)
  /// The returned object must be released after use, by calling the [release] method.
  factory Cache(
    jni.JObject file,
    int j,
    jni.JObject fileSystem,
  ) {
    return Cache.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            file.reference.pointer,
            j,
            fileSystem.reference.pointer)
        .reference);
  }

  static final _id_isClosed = _class.instanceMethodId(
    r"isClosed",
    r"()Z",
  );

  static final _isClosed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallBooleanMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean isClosed()
  bool isClosed() {
    return _isClosed(reference.pointer, _id_isClosed as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_new1 = _class.constructorId(
    r"(Ljava/io/File;J)V",
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.io.File file, long j)
  /// The returned object must be released after use, by calling the [release] method.
  factory Cache.new1(
    jni.JObject file,
    int j,
  ) {
    return Cache.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, file.reference.pointer, j)
        .reference);
  }

  static final _id_initialize = _class.instanceMethodId(
    r"initialize",
    r"()V",
  );

  static final _initialize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void initialize()
  void initialize() {
    _initialize(reference.pointer, _id_initialize as jni.JMethodIDPtr).check();
  }

  static final _id_delete = _class.instanceMethodId(
    r"delete",
    r"()V",
  );

  static final _delete = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void delete()
  void delete() {
    _delete(reference.pointer, _id_delete as jni.JMethodIDPtr).check();
  }

  static final _id_evictAll = _class.instanceMethodId(
    r"evictAll",
    r"()V",
  );

  static final _evictAll = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void evictAll()
  void evictAll() {
    _evictAll(reference.pointer, _id_evictAll as jni.JMethodIDPtr).check();
  }

  static final _id_urls = _class.instanceMethodId(
    r"urls",
    r"()Ljava/util/Iterator;",
  );

  static final _urls = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.Iterator urls()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JIterator<jni.JString> urls() {
    return _urls(reference.pointer, _id_urls as jni.JMethodIDPtr)
        .object(const jni.JIteratorType(jni.JStringType()));
  }

  static final _id_writeAbortCount = _class.instanceMethodId(
    r"writeAbortCount",
    r"()I",
  );

  static final _writeAbortCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int writeAbortCount()
  int writeAbortCount() {
    return _writeAbortCount(
            reference.pointer, _id_writeAbortCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_writeSuccessCount = _class.instanceMethodId(
    r"writeSuccessCount",
    r"()I",
  );

  static final _writeSuccessCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int writeSuccessCount()
  int writeSuccessCount() {
    return _writeSuccessCount(
            reference.pointer, _id_writeSuccessCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_size = _class.instanceMethodId(
    r"size",
    r"()J",
  );

  static final _size = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long size()
  int size() {
    return _size(reference.pointer, _id_size as jni.JMethodIDPtr).long;
  }

  static final _id_maxSize = _class.instanceMethodId(
    r"maxSize",
    r"()J",
  );

  static final _maxSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallLongMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long maxSize()
  int maxSize() {
    return _maxSize(reference.pointer, _id_maxSize as jni.JMethodIDPtr).long;
  }

  static final _id_flush = _class.instanceMethodId(
    r"flush",
    r"()V",
  );

  static final _flush = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void flush()
  void flush() {
    _flush(reference.pointer, _id_flush as jni.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(
    r"close",
    r"()V",
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  static final _id_directory = _class.instanceMethodId(
    r"directory",
    r"()Ljava/io/File;",
  );

  static final _directory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.io.File directory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject directory() {
    return _directory(reference.pointer, _id_directory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_networkCount = _class.instanceMethodId(
    r"networkCount",
    r"()I",
  );

  static final _networkCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int networkCount()
  int networkCount() {
    return _networkCount(
            reference.pointer, _id_networkCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_hitCount = _class.instanceMethodId(
    r"hitCount",
    r"()I",
  );

  static final _hitCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int hitCount()
  int hitCount() {
    return _hitCount(reference.pointer, _id_hitCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_requestCount = _class.instanceMethodId(
    r"requestCount",
    r"()I",
  );

  static final _requestCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallIntMethod")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int requestCount()
  int requestCount() {
    return _requestCount(
            reference.pointer, _id_requestCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_key = _class.staticMethodId(
    r"key",
    r"(Lokhttp3/HttpUrl;)Ljava/lang/String;",
  );

  static final _key = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallStaticObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final java.lang.String key(okhttp3.HttpUrl httpUrl)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString key(
    jni.JObject httpUrl,
  ) {
    return _key(_class.reference.pointer, _id_key as jni.JMethodIDPtr,
            httpUrl.reference.pointer)
        .object(const jni.JStringType());
  }
}

final class $CacheType extends jni.JObjType<Cache> {
  const $CacheType();

  @override
  String get signature => r"Lokhttp3/Cache;";

  @override
  Cache fromReference(jni.JReference reference) =>
      Cache.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CacheType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CacheType) && other is $CacheType;
  }
}

/// from: com.example.ok_http.RedirectReceivedCallback
class RedirectReceivedCallback extends jni.JObject {
  @override
  late final jni.JObjType<RedirectReceivedCallback> $type = type;

  RedirectReceivedCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/example/ok_http/RedirectReceivedCallback");

  /// The type which includes information such as the signature of this class.
  static const type = $RedirectReceivedCallbackType();
  static final _id_onRedirectReceived = _class.instanceMethodId(
    r"onRedirectReceived",
    r"(Lokhttp3/Response;Ljava/lang/String;)V",
  );

  static final _onRedirectReceived = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onRedirectReceived(okhttp3.Response response, java.lang.String string)
  void onRedirectReceived(
    Response response,
    jni.JString string,
  ) {
    _onRedirectReceived(
            reference.pointer,
            _id_onRedirectReceived as jni.JMethodIDPtr,
            response.reference.pointer,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $RedirectReceivedCallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onRedirectReceived(Lokhttp3/Response;Ljava/lang/String;)V") {
        _$impls[$p]!.onRedirectReceived(
          $a[0].castTo(const $ResponseType(), releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory RedirectReceivedCallback.implement(
    $RedirectReceivedCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = RedirectReceivedCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.example.ok_http.RedirectReceivedCallback",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $RedirectReceivedCallbackImpl {
  factory $RedirectReceivedCallbackImpl({
    required void Function(Response response, jni.JString string)
        onRedirectReceived,
  }) = _$RedirectReceivedCallbackImpl;

  void onRedirectReceived(Response response, jni.JString string);
}

class _$RedirectReceivedCallbackImpl implements $RedirectReceivedCallbackImpl {
  _$RedirectReceivedCallbackImpl({
    required void Function(Response response, jni.JString string)
        onRedirectReceived,
  }) : _onRedirectReceived = onRedirectReceived;

  final void Function(Response response, jni.JString string)
      _onRedirectReceived;

  void onRedirectReceived(Response response, jni.JString string) {
    return _onRedirectReceived(response, string);
  }
}

final class $RedirectReceivedCallbackType
    extends jni.JObjType<RedirectReceivedCallback> {
  const $RedirectReceivedCallbackType();

  @override
  String get signature => r"Lcom/example/ok_http/RedirectReceivedCallback;";

  @override
  RedirectReceivedCallback fromReference(jni.JReference reference) =>
      RedirectReceivedCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RedirectReceivedCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RedirectReceivedCallbackType) &&
        other is $RedirectReceivedCallbackType;
  }
}

/// from: com.example.ok_http.RedirectInterceptor$Companion
class RedirectInterceptor_Companion extends jni.JObject {
  @override
  late final jni.JObjType<RedirectInterceptor_Companion> $type = type;

  RedirectInterceptor_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/example/ok_http/RedirectInterceptor$Companion");

  /// The type which includes information such as the signature of this class.
  static const type = $RedirectInterceptor_CompanionType();
  static final _id_addRedirectInterceptor = _class.instanceMethodId(
    r"addRedirectInterceptor",
    r"(Lokhttp3/OkHttpClient$Builder;IZLcom/example/ok_http/RedirectReceivedCallback;)Lokhttp3/OkHttpClient$Builder;",
  );

  static final _addRedirectInterceptor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int32,
                        ffi.Uint8,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder addRedirectInterceptor(okhttp3.OkHttpClient$Builder builder, int i, boolean z, com.example.ok_http.RedirectReceivedCallback redirectReceivedCallback)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addRedirectInterceptor(
    OkHttpClient_Builder builder,
    int i,
    bool z,
    RedirectReceivedCallback redirectReceivedCallback,
  ) {
    return _addRedirectInterceptor(
            reference.pointer,
            _id_addRedirectInterceptor as jni.JMethodIDPtr,
            builder.reference.pointer,
            i,
            z ? 1 : 0,
            redirectReceivedCallback.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_new0 = _class.constructorId(
    r"(Lkotlin/jvm/internal/DefaultConstructorMarker;)V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory RedirectInterceptor_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return RedirectInterceptor_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $RedirectInterceptor_CompanionType
    extends jni.JObjType<RedirectInterceptor_Companion> {
  const $RedirectInterceptor_CompanionType();

  @override
  String get signature =>
      r"Lcom/example/ok_http/RedirectInterceptor$Companion;";

  @override
  RedirectInterceptor_Companion fromReference(jni.JReference reference) =>
      RedirectInterceptor_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RedirectInterceptor_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RedirectInterceptor_CompanionType) &&
        other is $RedirectInterceptor_CompanionType;
  }
}

/// from: com.example.ok_http.RedirectInterceptor
class RedirectInterceptor extends jni.JObject {
  @override
  late final jni.JObjType<RedirectInterceptor> $type = type;

  RedirectInterceptor.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/example/ok_http/RedirectInterceptor");

  /// The type which includes information such as the signature of this class.
  static const type = $RedirectInterceptorType();
  static final _id_Companion = _class.staticFieldId(
    r"Companion",
    r"Lcom/example/ok_http/RedirectInterceptor$Companion;",
  );

  /// from: static public final com.example.ok_http.RedirectInterceptor$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static RedirectInterceptor_Companion get Companion =>
      _id_Companion.get(_class, const $RedirectInterceptor_CompanionType());

  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory RedirectInterceptor() {
    return RedirectInterceptor.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $RedirectInterceptorType extends jni.JObjType<RedirectInterceptor> {
  const $RedirectInterceptorType();

  @override
  String get signature => r"Lcom/example/ok_http/RedirectInterceptor;";

  @override
  RedirectInterceptor fromReference(jni.JReference reference) =>
      RedirectInterceptor.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RedirectInterceptorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RedirectInterceptorType) &&
        other is $RedirectInterceptorType;
  }
}

/// from: com.example.ok_http.AsyncInputStreamReader
class AsyncInputStreamReader extends jni.JObject {
  @override
  late final jni.JObjType<AsyncInputStreamReader> $type = type;

  AsyncInputStreamReader.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r"com/example/ok_http/AsyncInputStreamReader");

  /// The type which includes information such as the signature of this class.
  static const type = $AsyncInputStreamReaderType();
  static final _id_new0 = _class.constructorId(
    r"()V",
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_NewObject")
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory AsyncInputStreamReader() {
    return AsyncInputStreamReader.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_readAsync = _class.instanceMethodId(
    r"readAsync",
    r"(Ljava/io/InputStream;Lcom/example/ok_http/DataCallback;)Ljava/util/concurrent/Future;",
  );

  static final _readAsync = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>("globalEnv_CallObjectMethod")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.concurrent.Future readAsync(java.io.InputStream inputStream, com.example.ok_http.DataCallback dataCallback)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject readAsync(
    jni.JObject inputStream,
    DataCallback dataCallback,
  ) {
    return _readAsync(reference.pointer, _id_readAsync as jni.JMethodIDPtr,
            inputStream.reference.pointer, dataCallback.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_shutdown = _class.instanceMethodId(
    r"shutdown",
    r"()V",
  );

  static final _shutdown = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void shutdown()
  void shutdown() {
    _shutdown(reference.pointer, _id_shutdown as jni.JMethodIDPtr).check();
  }
}

final class $AsyncInputStreamReaderType
    extends jni.JObjType<AsyncInputStreamReader> {
  const $AsyncInputStreamReaderType();

  @override
  String get signature => r"Lcom/example/ok_http/AsyncInputStreamReader;";

  @override
  AsyncInputStreamReader fromReference(jni.JReference reference) =>
      AsyncInputStreamReader.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($AsyncInputStreamReaderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($AsyncInputStreamReaderType) &&
        other is $AsyncInputStreamReaderType;
  }
}

/// from: com.example.ok_http.DataCallback
class DataCallback extends jni.JObject {
  @override
  late final jni.JObjType<DataCallback> $type = type;

  DataCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r"com/example/ok_http/DataCallback");

  /// The type which includes information such as the signature of this class.
  static const type = $DataCallbackType();
  static final _id_onDataRead = _class.instanceMethodId(
    r"onDataRead",
    r"([B)V",
  );

  static final _onDataRead = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onDataRead(byte[] bs)
  void onDataRead(
    jni.JArray<jni.jbyte> bs,
  ) {
    _onDataRead(reference.pointer, _id_onDataRead as jni.JMethodIDPtr,
            bs.reference.pointer)
        .check();
  }

  static final _id_onFinished = _class.instanceMethodId(
    r"onFinished",
    r"()V",
  );

  static final _onFinished = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>("globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void onFinished()
  void onFinished() {
    _onFinished(reference.pointer, _id_onFinished as jni.JMethodIDPtr).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r"onError",
    r"(Ljava/io/IOException;)V",
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          "globalEnv_CallVoidMethod")
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onError(java.io.IOException iOException)
  void onError(
    jni.JObject iOException,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            iOException.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $DataCallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onDataRead([B)V") {
        _$impls[$p]!.onDataRead(
          $a[0].castTo(const jni.JArrayType(jni.jbyteType()),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r"onFinished()V") {
        _$impls[$p]!.onFinished();
        return jni.nullptr;
      }
      if ($d == r"onError(Ljava/io/IOException;)V") {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory DataCallback.implement(
    $DataCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = DataCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.example.ok_http.DataCallback",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $DataCallbackImpl {
  factory $DataCallbackImpl({
    required void Function(jni.JArray<jni.jbyte> bs) onDataRead,
    required void Function() onFinished,
    required void Function(jni.JObject iOException) onError,
  }) = _$DataCallbackImpl;

  void onDataRead(jni.JArray<jni.jbyte> bs);
  void onFinished();
  void onError(jni.JObject iOException);
}

class _$DataCallbackImpl implements $DataCallbackImpl {
  _$DataCallbackImpl({
    required void Function(jni.JArray<jni.jbyte> bs) onDataRead,
    required void Function() onFinished,
    required void Function(jni.JObject iOException) onError,
  })  : _onDataRead = onDataRead,
        _onFinished = onFinished,
        _onError = onError;

  final void Function(jni.JArray<jni.jbyte> bs) _onDataRead;
  final void Function() _onFinished;
  final void Function(jni.JObject iOException) _onError;

  void onDataRead(jni.JArray<jni.jbyte> bs) {
    return _onDataRead(bs);
  }

  void onFinished() {
    return _onFinished();
  }

  void onError(jni.JObject iOException) {
    return _onError(iOException);
  }
}

final class $DataCallbackType extends jni.JObjType<DataCallback> {
  const $DataCallbackType();

  @override
  String get signature => r"Lcom/example/ok_http/DataCallback;";

  @override
  DataCallback fromReference(jni.JReference reference) =>
      DataCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($DataCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataCallbackType) &&
        other is $DataCallbackType;
  }
}
