// ignore_for_file: prefer_expression_function_bodies

// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

/// from: okhttp3.Request$Builder
class Request_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Request_Builder> $type = type;

  Request_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Request$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $Request_BuilderType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Request_Builder() {
    return Request_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(Lokhttp3/Request;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  factory Request_Builder.new1(
    Request request,
  ) {
    return Request_Builder.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, request.reference.pointer)
        .reference);
  }

  static final _id_url = _class.instanceMethodId(
    r'url',
    r'(Lokhttp3/HttpUrl;)Lokhttp3/Request$Builder;',
  );

  static final _url = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder url(okhttp3.HttpUrl httpUrl)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url(
    jni.JObject httpUrl,
  ) {
    return _url(reference.pointer, _id_url as jni.JMethodIDPtr,
            httpUrl.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_url1 = _class.instanceMethodId(
    r'url',
    r'(Ljava/lang/String;)Lokhttp3/Request$Builder;',
  );

  static final _url1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder url(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url1(
    jni.JString string,
  ) {
    return _url1(reference.pointer, _id_url1 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_url2 = _class.instanceMethodId(
    r'url',
    r'(Ljava/net/URL;)Lokhttp3/Request$Builder;',
  );

  static final _url2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder url(java.net.URL uRL)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder url2(
    jni.JObject uRL,
  ) {
    return _url2(reference.pointer, _id_url2 as jni.JMethodIDPtr,
            uRL.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_header = _class.instanceMethodId(
    r'header',
    r'(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;',
  );

  static final _header = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder header(
    jni.JString string,
    jni.JString string1,
  ) {
    return _header(reference.pointer, _id_header as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_addHeader = _class.instanceMethodId(
    r'addHeader',
    r'(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Request$Builder;',
  );

  static final _addHeader = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) {
    return _addHeader(reference.pointer, _id_addHeader as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_removeHeader = _class.instanceMethodId(
    r'removeHeader',
    r'(Ljava/lang/String;)Lokhttp3/Request$Builder;',
  );

  static final _removeHeader = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder removeHeader(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder removeHeader(
    jni.JString string,
  ) {
    return _removeHeader(reference.pointer,
            _id_removeHeader as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_headers = _class.instanceMethodId(
    r'headers',
    r'(Lokhttp3/Headers;)Lokhttp3/Request$Builder;',
  );

  static final _headers = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder headers(
    Headers headers,
  ) {
    return _headers(reference.pointer, _id_headers as jni.JMethodIDPtr,
            headers.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_cacheControl = _class.instanceMethodId(
    r'cacheControl',
    r'(Lokhttp3/CacheControl;)Lokhttp3/Request$Builder;',
  );

  static final _cacheControl = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder cacheControl(okhttp3.CacheControl cacheControl)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder cacheControl(
    jni.JObject cacheControl,
  ) {
    return _cacheControl(
            reference.pointer,
            _id_cacheControl as jni.JMethodIDPtr,
            cacheControl.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_get0 = _class.instanceMethodId(
    r'get',
    r'()Lokhttp3/Request$Builder;',
  );

  static final _get0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okhttp3.Request$Builder get()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder get0() {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr)
        .object(const $Request_BuilderType());
  }

  static final _id_head = _class.instanceMethodId(
    r'head',
    r'()Lokhttp3/Request$Builder;',
  );

  static final _head = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okhttp3.Request$Builder head()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder head() {
    return _head(reference.pointer, _id_head as jni.JMethodIDPtr)
        .object(const $Request_BuilderType());
  }

  static final _id_post = _class.instanceMethodId(
    r'post',
    r'(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;',
  );

  static final _post = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder post(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder post(
    RequestBody requestBody,
  ) {
    return _post(reference.pointer, _id_post as jni.JMethodIDPtr,
            requestBody.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_delete = _class.instanceMethodId(
    r'delete',
    r'(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;',
  );

  static final _delete = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder delete(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete(
    RequestBody requestBody,
  ) {
    return _delete(reference.pointer, _id_delete as jni.JMethodIDPtr,
            requestBody.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_put = _class.instanceMethodId(
    r'put',
    r'(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;',
  );

  static final _put = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder put(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder put(
    RequestBody requestBody,
  ) {
    return _put(reference.pointer, _id_put as jni.JMethodIDPtr,
            requestBody.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_patch = _class.instanceMethodId(
    r'patch',
    r'(Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;',
  );

  static final _patch = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder patch(okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder patch(
    RequestBody requestBody,
  ) {
    return _patch(reference.pointer, _id_patch as jni.JMethodIDPtr,
            requestBody.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_method = _class.instanceMethodId(
    r'method',
    r'(Ljava/lang/String;Lokhttp3/RequestBody;)Lokhttp3/Request$Builder;',
  );

  static final _method = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder method(java.lang.String string, okhttp3.RequestBody requestBody)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder method(
    jni.JString string,
    RequestBody requestBody,
  ) {
    return _method(reference.pointer, _id_method as jni.JMethodIDPtr,
            string.reference.pointer, requestBody.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_tag = _class.instanceMethodId(
    r'tag',
    r'(Ljava/lang/Object;)Lokhttp3/Request$Builder;',
  );

  static final _tag = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder tag(java.lang.Object object)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder tag(
    jni.JObject object,
  ) {
    return _tag(reference.pointer, _id_tag as jni.JMethodIDPtr,
            object.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_tag1 = _class.instanceMethodId(
    r'tag',
    r'(Ljava/lang/Class;Ljava/lang/Object;)Lokhttp3/Request$Builder;',
  );

  static final _tag1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Request$Builder tag(java.lang.Class class, T object)
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder tag1<$T extends jni.JObject>(
    jni.JObject class0,
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return _tag1(reference.pointer, _id_tag1 as jni.JMethodIDPtr,
            class0.reference.pointer, object.reference.pointer)
        .object(const $Request_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Lokhttp3/Request;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okhttp3.Request build()
  /// The returned object must be released after use, by calling the [release] method.
  Request build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $RequestType());
  }

  static final _id_delete1 = _class.instanceMethodId(
    r'delete',
    r'()Lokhttp3/Request$Builder;',
  );

  static final _delete1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Request$Builder delete()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder delete1() {
    return _delete1(reference.pointer, _id_delete1 as jni.JMethodIDPtr)
        .object(const $Request_BuilderType());
  }
}

final class $Request_BuilderType extends jni.JObjType<Request_Builder> {
  const $Request_BuilderType();

  @override
  String get signature => r'Lokhttp3/Request$Builder;';

  @override
  Request_Builder fromReference(jni.JReference reference) =>
      Request_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Request_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Request_BuilderType) &&
        other is $Request_BuilderType;
  }
}

/// from: okhttp3.Request
class Request extends jni.JObject {
  @override
  late final jni.JObjType<Request> $type = type;

  Request.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Request');

  /// The type which includes information such as the signature of this class.
  static const type = $RequestType();
  static final _id_new0 = _class.constructorId(
    r'(Lokhttp3/HttpUrl;Ljava/lang/String;Lokhttp3/Headers;Lokhttp3/RequestBody;Ljava/util/Map;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.HttpUrl httpUrl, java.lang.String string, okhttp3.Headers headers, okhttp3.RequestBody requestBody, java.util.Map map)
  /// The returned object must be released after use, by calling the [release] method.
  factory Request(
    jni.JObject httpUrl,
    jni.JString string,
    Headers headers,
    RequestBody requestBody,
    jni.JMap<jni.JObject, jni.JObject> map,
  ) {
    return Request.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            httpUrl.reference.pointer,
            string.reference.pointer,
            headers.reference.pointer,
            requestBody.reference.pointer,
            map.reference.pointer)
        .reference);
  }

  static final _id_url = _class.instanceMethodId(
    r'url',
    r'()Lokhttp3/HttpUrl;',
  );

  static final _url = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.HttpUrl url()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject url() {
    return _url(reference.pointer, _id_url as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_method = _class.instanceMethodId(
    r'method',
    r'()Ljava/lang/String;',
  );

  static final _method = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.String method()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString method() {
    return _method(reference.pointer, _id_method as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_headers = _class.instanceMethodId(
    r'headers',
    r'()Lokhttp3/Headers;',
  );

  static final _headers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  Headers headers() {
    return _headers(reference.pointer, _id_headers as jni.JMethodIDPtr)
        .object(const $HeadersType());
  }

  static final _id_body = _class.instanceMethodId(
    r'body',
    r'()Lokhttp3/RequestBody;',
  );

  static final _body = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.RequestBody body()
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody body() {
    return _body(reference.pointer, _id_body as jni.JMethodIDPtr)
        .object(const $RequestBodyType());
  }

  static final _id_isHttps = _class.instanceMethodId(
    r'isHttps',
    r'()Z',
  );

  static final _isHttps = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean isHttps()
  bool isHttps() {
    return _isHttps(reference.pointer, _id_isHttps as jni.JMethodIDPtr).boolean;
  }

  static final _id_header = _class.instanceMethodId(
    r'header',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _header = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String header(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString string,
  ) {
    return _header(reference.pointer, _id_header as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_headers1 = _class.instanceMethodId(
    r'headers',
    r'(Ljava/lang/String;)Ljava/util/List;',
  );

  static final _headers1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.List headers(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers1(
    jni.JString string,
  ) {
    return _headers1(reference.pointer, _id_headers1 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_tag = _class.instanceMethodId(
    r'tag',
    r'()Ljava/lang/Object;',
  );

  static final _tag = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.Object tag()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject tag() {
    return _tag(reference.pointer, _id_tag as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_tag1 = _class.instanceMethodId(
    r'tag',
    r'(Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _tag1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final T tag(java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  $T tag1<$T extends jni.JObject>(
    jni.JObject class0, {
    required jni.JObjType<$T> T,
  }) {
    return _tag1(reference.pointer, _id_tag1 as jni.JMethodIDPtr,
            class0.reference.pointer)
        .object(T);
  }

  static final _id_newBuilder = _class.instanceMethodId(
    r'newBuilder',
    r'()Lokhttp3/Request$Builder;',
  );

  static final _newBuilder = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Request$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Request_Builder newBuilder() {
    return _newBuilder(reference.pointer, _id_newBuilder as jni.JMethodIDPtr)
        .object(const $Request_BuilderType());
  }

  static final _id_cacheControl = _class.instanceMethodId(
    r'cacheControl',
    r'()Lokhttp3/CacheControl;',
  );

  static final _cacheControl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cacheControl() {
    return _cacheControl(
            reference.pointer, _id_cacheControl as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $RequestType extends jni.JObjType<Request> {
  const $RequestType();

  @override
  String get signature => r'Lokhttp3/Request;';

  @override
  Request fromReference(jni.JReference reference) =>
      Request.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestType) && other is $RequestType;
  }
}

/// from: okhttp3.RequestBody$Companion
class RequestBody_Companion extends jni.JObject {
  @override
  late final jni.JObjType<RequestBody_Companion> $type = type;

  RequestBody_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/RequestBody$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $RequestBody_CompanionType();
  static final _id_create = _class.instanceMethodId(
    r'create',
    r'(Ljava/lang/String;Lokhttp3/MediaType;)Lokhttp3/RequestBody;',
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(java.lang.String string, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create(
    jni.JString string,
    jni.JObject mediaType,
  ) {
    return _create(reference.pointer, _id_create as jni.JMethodIDPtr,
            string.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create1 = _class.instanceMethodId(
    r'create',
    r'(Lokio/ByteString;Lokhttp3/MediaType;)Lokhttp3/RequestBody;',
  );

  static final _create1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(okio.ByteString byteString, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create1(
    ByteString byteString,
    jni.JObject mediaType,
  ) {
    return _create1(reference.pointer, _id_create1 as jni.JMethodIDPtr,
            byteString.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create2 = _class.instanceMethodId(
    r'create',
    r'([BLokhttp3/MediaType;II)Lokhttp3/RequestBody;',
  );

  static final _create2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create2(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
    int i,
    int i1,
  ) {
    return _create2(reference.pointer, _id_create2 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer, i, i1)
        .object(const $RequestBodyType());
  }

  static final _id_create3 = _class.instanceMethodId(
    r'create',
    r'(Ljava/io/File;Lokhttp3/MediaType;)Lokhttp3/RequestBody;',
  );

  static final _create3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(java.io.File file, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create3(
    jni.JObject file,
    jni.JObject mediaType,
  ) {
    return _create3(reference.pointer, _id_create3 as jni.JMethodIDPtr,
            file.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create4 = _class.instanceMethodId(
    r'create',
    r'(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/RequestBody;',
  );

  static final _create4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create4(
    jni.JObject mediaType,
    jni.JString string,
  ) {
    return _create4(reference.pointer, _id_create4 as jni.JMethodIDPtr,
            mediaType.reference.pointer, string.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create5 = _class.instanceMethodId(
    r'create',
    r'(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/RequestBody;',
  );

  static final _create5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create5(
    jni.JObject mediaType,
    ByteString byteString,
  ) {
    return _create5(reference.pointer, _id_create5 as jni.JMethodIDPtr,
            mediaType.reference.pointer, byteString.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create6 = _class.instanceMethodId(
    r'create',
    r'(Lokhttp3/MediaType;[BII)Lokhttp3/RequestBody;',
  );

  static final _create6 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create6(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return _create6(reference.pointer, _id_create6 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer, i, i1)
        .object(const $RequestBodyType());
  }

  static final _id_create7 = _class.instanceMethodId(
    r'create',
    r'(Lokhttp3/MediaType;Ljava/io/File;)Lokhttp3/RequestBody;',
  );

  static final _create7 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create7(
    jni.JObject mediaType,
    jni.JObject file,
  ) {
    return _create7(reference.pointer, _id_create7 as jni.JMethodIDPtr,
            mediaType.reference.pointer, file.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create8 = _class.instanceMethodId(
    r'create',
    r'([BLokhttp3/MediaType;I)Lokhttp3/RequestBody;',
  );

  static final _create8 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType, int i)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create8(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
    int i,
  ) {
    return _create8(reference.pointer, _id_create8 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer, i)
        .object(const $RequestBodyType());
  }

  static final _id_create9 = _class.instanceMethodId(
    r'create',
    r'([BLokhttp3/MediaType;)Lokhttp3/RequestBody;',
  );

  static final _create9 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create9(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
  ) {
    return _create9(reference.pointer, _id_create9 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create10 = _class.instanceMethodId(
    r'create',
    r'([B)Lokhttp3/RequestBody;',
  );

  static final _create10 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create10(
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create10(reference.pointer, _id_create10 as jni.JMethodIDPtr,
            bs.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create11 = _class.instanceMethodId(
    r'create',
    r'(Lokhttp3/MediaType;[BI)Lokhttp3/RequestBody;',
  );

  static final _create11 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs, int i)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create11(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
    int i,
  ) {
    return _create11(reference.pointer, _id_create11 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer, i)
        .object(const $RequestBodyType());
  }

  static final _id_create12 = _class.instanceMethodId(
    r'create',
    r'(Lokhttp3/MediaType;[B)Lokhttp3/RequestBody;',
  );

  static final _create12 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  RequestBody create12(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create12(reference.pointer, _id_create12 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory RequestBody_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return RequestBody_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $RequestBody_CompanionType
    extends jni.JObjType<RequestBody_Companion> {
  const $RequestBody_CompanionType();

  @override
  String get signature => r'Lokhttp3/RequestBody$Companion;';

  @override
  RequestBody_Companion fromReference(jni.JReference reference) =>
      RequestBody_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestBody_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestBody_CompanionType) &&
        other is $RequestBody_CompanionType;
  }
}

/// from: okhttp3.RequestBody
class RequestBody extends jni.JObject {
  @override
  late final jni.JObjType<RequestBody> $type = type;

  RequestBody.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/RequestBody');

  /// The type which includes information such as the signature of this class.
  static const type = $RequestBodyType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lokhttp3/RequestBody$Companion;',
  );

  /// from: static public final okhttp3.RequestBody$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody_Companion get Companion =>
      _id_Companion.get(_class, const $RequestBody_CompanionType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory RequestBody() {
    return RequestBody.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_contentType = _class.instanceMethodId(
    r'contentType',
    r'()Lokhttp3/MediaType;',
  );

  static final _contentType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.MediaType contentType()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject contentType() {
    return _contentType(reference.pointer, _id_contentType as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_contentLength = _class.instanceMethodId(
    r'contentLength',
    r'()J',
  );

  static final _contentLength = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public long contentLength()
  int contentLength() {
    return _contentLength(
            reference.pointer, _id_contentLength as jni.JMethodIDPtr)
        .long;
  }

  static final _id_writeTo = _class.instanceMethodId(
    r'writeTo',
    r'(Lokio/BufferedSink;)V',
  );

  static final _writeTo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void writeTo(okio.BufferedSink bufferedSink)
  void writeTo(
    jni.JObject bufferedSink,
  ) {
    _writeTo(reference.pointer, _id_writeTo as jni.JMethodIDPtr,
            bufferedSink.reference.pointer)
        .check();
  }

  static final _id_isDuplex = _class.instanceMethodId(
    r'isDuplex',
    r'()Z',
  );

  static final _isDuplex = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isDuplex()
  bool isDuplex() {
    return _isDuplex(reference.pointer, _id_isDuplex as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isOneShot = _class.instanceMethodId(
    r'isOneShot',
    r'()Z',
  );

  static final _isOneShot = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public boolean isOneShot()
  bool isOneShot() {
    return _isOneShot(reference.pointer, _id_isOneShot as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_create = _class.staticMethodId(
    r'create',
    r'(Ljava/lang/String;Lokhttp3/MediaType;)Lokhttp3/RequestBody;',
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(java.lang.String string, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create(
    jni.JString string,
    jni.JObject mediaType,
  ) {
    return _create(_class.reference.pointer, _id_create as jni.JMethodIDPtr,
            string.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create1 = _class.staticMethodId(
    r'create',
    r'(Lokio/ByteString;Lokhttp3/MediaType;)Lokhttp3/RequestBody;',
  );

  static final _create1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(okio.ByteString byteString, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create1(
    ByteString byteString,
    jni.JObject mediaType,
  ) {
    return _create1(_class.reference.pointer, _id_create1 as jni.JMethodIDPtr,
            byteString.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create2 = _class.staticMethodId(
    r'create',
    r'([BLokhttp3/MediaType;II)Lokhttp3/RequestBody;',
  );

  static final _create2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create2(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
    int i,
    int i1,
  ) {
    return _create2(_class.reference.pointer, _id_create2 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer, i, i1)
        .object(const $RequestBodyType());
  }

  static final _id_create3 = _class.staticMethodId(
    r'create',
    r'(Ljava/io/File;Lokhttp3/MediaType;)Lokhttp3/RequestBody;',
  );

  static final _create3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(java.io.File file, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create3(
    jni.JObject file,
    jni.JObject mediaType,
  ) {
    return _create3(_class.reference.pointer, _id_create3 as jni.JMethodIDPtr,
            file.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create4 = _class.staticMethodId(
    r'create',
    r'(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/RequestBody;',
  );

  static final _create4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create4(
    jni.JObject mediaType,
    jni.JString string,
  ) {
    return _create4(_class.reference.pointer, _id_create4 as jni.JMethodIDPtr,
            mediaType.reference.pointer, string.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create5 = _class.staticMethodId(
    r'create',
    r'(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/RequestBody;',
  );

  static final _create5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create5(
    jni.JObject mediaType,
    ByteString byteString,
  ) {
    return _create5(_class.reference.pointer, _id_create5 as jni.JMethodIDPtr,
            mediaType.reference.pointer, byteString.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create6 = _class.staticMethodId(
    r'create',
    r'(Lokhttp3/MediaType;[BII)Lokhttp3/RequestBody;',
  );

  static final _create6 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create6(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return _create6(_class.reference.pointer, _id_create6 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer, i, i1)
        .object(const $RequestBodyType());
  }

  static final _id_create7 = _class.staticMethodId(
    r'create',
    r'(Lokhttp3/MediaType;Ljava/io/File;)Lokhttp3/RequestBody;',
  );

  static final _create7 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create7(
    jni.JObject mediaType,
    jni.JObject file,
  ) {
    return _create7(_class.reference.pointer, _id_create7 as jni.JMethodIDPtr,
            mediaType.reference.pointer, file.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create8 = _class.staticMethodId(
    r'create',
    r'([BLokhttp3/MediaType;I)Lokhttp3/RequestBody;',
  );

  static final _create8 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create8(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
    int i,
  ) {
    return _create8(_class.reference.pointer, _id_create8 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer, i)
        .object(const $RequestBodyType());
  }

  static final _id_create9 = _class.staticMethodId(
    r'create',
    r'([BLokhttp3/MediaType;)Lokhttp3/RequestBody;',
  );

  static final _create9 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(byte[] bs, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create9(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
  ) {
    return _create9(_class.reference.pointer, _id_create9 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create10 = _class.staticMethodId(
    r'create',
    r'([B)Lokhttp3/RequestBody;',
  );

  static final _create10 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create10(
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create10(_class.reference.pointer, _id_create10 as jni.JMethodIDPtr,
            bs.reference.pointer)
        .object(const $RequestBodyType());
  }

  static final _id_create11 = _class.staticMethodId(
    r'create',
    r'(Lokhttp3/MediaType;[BI)Lokhttp3/RequestBody;',
  );

  static final _create11 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create11(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
    int i,
  ) {
    return _create11(_class.reference.pointer, _id_create11 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer, i)
        .object(const $RequestBodyType());
  }

  static final _id_create12 = _class.staticMethodId(
    r'create',
    r'(Lokhttp3/MediaType;[B)Lokhttp3/RequestBody;',
  );

  static final _create12 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.RequestBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static RequestBody create12(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create12(_class.reference.pointer, _id_create12 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer)
        .object(const $RequestBodyType());
  }
}

final class $RequestBodyType extends jni.JObjType<RequestBody> {
  const $RequestBodyType();

  @override
  String get signature => r'Lokhttp3/RequestBody;';

  @override
  RequestBody fromReference(jni.JReference reference) =>
      RequestBody.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RequestBodyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RequestBodyType) && other is $RequestBodyType;
  }
}

/// from: okhttp3.Response$Builder
class Response_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Response_Builder> $type = type;

  Response_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Response$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $Response_BuilderType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Response_Builder() {
    return Response_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(Lokhttp3/Response;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  factory Response_Builder.new1(
    Response response,
  ) {
    return Response_Builder.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, response.reference.pointer)
        .reference);
  }

  static final _id_request = _class.instanceMethodId(
    r'request',
    r'(Lokhttp3/Request;)Lokhttp3/Response$Builder;',
  );

  static final _request = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder request(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder request(
    Request request,
  ) {
    return _request(reference.pointer, _id_request as jni.JMethodIDPtr,
            request.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_protocol = _class.instanceMethodId(
    r'protocol',
    r'(Lokhttp3/Protocol;)Lokhttp3/Response$Builder;',
  );

  static final _protocol = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder protocol(okhttp3.Protocol protocol)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder protocol(
    jni.JObject protocol,
  ) {
    return _protocol(reference.pointer, _id_protocol as jni.JMethodIDPtr,
            protocol.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_code = _class.instanceMethodId(
    r'code',
    r'(I)Lokhttp3/Response$Builder;',
  );

  static final _code = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public okhttp3.Response$Builder code(int i)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder code(
    int i,
  ) {
    return _code(reference.pointer, _id_code as jni.JMethodIDPtr, i)
        .object(const $Response_BuilderType());
  }

  static final _id_message = _class.instanceMethodId(
    r'message',
    r'(Ljava/lang/String;)Lokhttp3/Response$Builder;',
  );

  static final _message = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder message(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder message(
    jni.JString string,
  ) {
    return _message(reference.pointer, _id_message as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_handshake = _class.instanceMethodId(
    r'handshake',
    r'(Lokhttp3/Handshake;)Lokhttp3/Response$Builder;',
  );

  static final _handshake = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder handshake(okhttp3.Handshake handshake)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder handshake(
    jni.JObject handshake,
  ) {
    return _handshake(reference.pointer, _id_handshake as jni.JMethodIDPtr,
            handshake.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_header = _class.instanceMethodId(
    r'header',
    r'(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Response$Builder;',
  );

  static final _header = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder header(
    jni.JString string,
    jni.JString string1,
  ) {
    return _header(reference.pointer, _id_header as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_addHeader = _class.instanceMethodId(
    r'addHeader',
    r'(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Response$Builder;',
  );

  static final _addHeader = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder addHeader(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder addHeader(
    jni.JString string,
    jni.JString string1,
  ) {
    return _addHeader(reference.pointer, _id_addHeader as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_removeHeader = _class.instanceMethodId(
    r'removeHeader',
    r'(Ljava/lang/String;)Lokhttp3/Response$Builder;',
  );

  static final _removeHeader = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder removeHeader(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder removeHeader(
    jni.JString string,
  ) {
    return _removeHeader(reference.pointer,
            _id_removeHeader as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_headers = _class.instanceMethodId(
    r'headers',
    r'(Lokhttp3/Headers;)Lokhttp3/Response$Builder;',
  );

  static final _headers = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder headers(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder headers(
    Headers headers,
  ) {
    return _headers(reference.pointer, _id_headers as jni.JMethodIDPtr,
            headers.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_body = _class.instanceMethodId(
    r'body',
    r'(Lokhttp3/ResponseBody;)Lokhttp3/Response$Builder;',
  );

  static final _body = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder body(okhttp3.ResponseBody responseBody)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder body(
    ResponseBody responseBody,
  ) {
    return _body(reference.pointer, _id_body as jni.JMethodIDPtr,
            responseBody.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_networkResponse = _class.instanceMethodId(
    r'networkResponse',
    r'(Lokhttp3/Response;)Lokhttp3/Response$Builder;',
  );

  static final _networkResponse = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder networkResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder networkResponse(
    Response response,
  ) {
    return _networkResponse(reference.pointer,
            _id_networkResponse as jni.JMethodIDPtr, response.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_cacheResponse = _class.instanceMethodId(
    r'cacheResponse',
    r'(Lokhttp3/Response;)Lokhttp3/Response$Builder;',
  );

  static final _cacheResponse = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder cacheResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder cacheResponse(
    Response response,
  ) {
    return _cacheResponse(reference.pointer,
            _id_cacheResponse as jni.JMethodIDPtr, response.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_priorResponse = _class.instanceMethodId(
    r'priorResponse',
    r'(Lokhttp3/Response;)Lokhttp3/Response$Builder;',
  );

  static final _priorResponse = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Response$Builder priorResponse(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder priorResponse(
    Response response,
  ) {
    return _priorResponse(reference.pointer,
            _id_priorResponse as jni.JMethodIDPtr, response.reference.pointer)
        .object(const $Response_BuilderType());
  }

  static final _id_sentRequestAtMillis = _class.instanceMethodId(
    r'sentRequestAtMillis',
    r'(J)Lokhttp3/Response$Builder;',
  );

  static final _sentRequestAtMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public okhttp3.Response$Builder sentRequestAtMillis(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder sentRequestAtMillis(
    int j,
  ) {
    return _sentRequestAtMillis(
            reference.pointer, _id_sentRequestAtMillis as jni.JMethodIDPtr, j)
        .object(const $Response_BuilderType());
  }

  static final _id_receivedResponseAtMillis = _class.instanceMethodId(
    r'receivedResponseAtMillis',
    r'(J)Lokhttp3/Response$Builder;',
  );

  static final _receivedResponseAtMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public okhttp3.Response$Builder receivedResponseAtMillis(long j)
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder receivedResponseAtMillis(
    int j,
  ) {
    return _receivedResponseAtMillis(reference.pointer,
            _id_receivedResponseAtMillis as jni.JMethodIDPtr, j)
        .object(const $Response_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Lokhttp3/Response;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okhttp3.Response build()
  /// The returned object must be released after use, by calling the [release] method.
  Response build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $ResponseType());
  }
}

final class $Response_BuilderType extends jni.JObjType<Response_Builder> {
  const $Response_BuilderType();

  @override
  String get signature => r'Lokhttp3/Response$Builder;';

  @override
  Response_Builder fromReference(jni.JReference reference) =>
      Response_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Response_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Response_BuilderType) &&
        other is $Response_BuilderType;
  }
}

/// from: okhttp3.Response
class Response extends jni.JObject {
  @override
  late final jni.JObjType<Response> $type = type;

  Response.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Response');

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseType();
  static final _id_new0 = _class.constructorId(
    r'(Lokhttp3/Request;Lokhttp3/Protocol;Ljava/lang/String;ILokhttp3/Handshake;Lokhttp3/Headers;Lokhttp3/ResponseBody;Lokhttp3/Response;Lokhttp3/Response;Lokhttp3/Response;JJLokhttp3/internal/connection/Exchange;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              int,
              int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.Request request, okhttp3.Protocol protocol, java.lang.String string, int i, okhttp3.Handshake handshake, okhttp3.Headers headers, okhttp3.ResponseBody responseBody, okhttp3.Response response, okhttp3.Response response1, okhttp3.Response response2, long j, long j1, okhttp3.internal.connection.Exchange exchange)
  /// The returned object must be released after use, by calling the [release] method.
  factory Response(
    Request request,
    jni.JObject protocol,
    jni.JString string,
    int i,
    jni.JObject handshake,
    Headers headers,
    ResponseBody responseBody,
    Response response,
    Response response1,
    Response response2,
    int j,
    int j1,
    jni.JObject exchange,
  ) {
    return Response.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            request.reference.pointer,
            protocol.reference.pointer,
            string.reference.pointer,
            i,
            handshake.reference.pointer,
            headers.reference.pointer,
            responseBody.reference.pointer,
            response.reference.pointer,
            response1.reference.pointer,
            response2.reference.pointer,
            j,
            j1,
            exchange.reference.pointer)
        .reference);
  }

  static final _id_request = _class.instanceMethodId(
    r'request',
    r'()Lokhttp3/Request;',
  );

  static final _request = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return _request(reference.pointer, _id_request as jni.JMethodIDPtr)
        .object(const $RequestType());
  }

  static final _id_protocol = _class.instanceMethodId(
    r'protocol',
    r'()Lokhttp3/Protocol;',
  );

  static final _protocol = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Protocol protocol()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject protocol() {
    return _protocol(reference.pointer, _id_protocol as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_message = _class.instanceMethodId(
    r'message',
    r'()Ljava/lang/String;',
  );

  static final _message = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.String message()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString message() {
    return _message(reference.pointer, _id_message as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_code = _class.instanceMethodId(
    r'code',
    r'()I',
  );

  static final _code = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int code()
  int code() {
    return _code(reference.pointer, _id_code as jni.JMethodIDPtr).integer;
  }

  static final _id_handshake = _class.instanceMethodId(
    r'handshake',
    r'()Lokhttp3/Handshake;',
  );

  static final _handshake = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Handshake handshake()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject handshake() {
    return _handshake(reference.pointer, _id_handshake as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_headers = _class.instanceMethodId(
    r'headers',
    r'()Lokhttp3/Headers;',
  );

  static final _headers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Headers headers()
  /// The returned object must be released after use, by calling the [release] method.
  Headers headers() {
    return _headers(reference.pointer, _id_headers as jni.JMethodIDPtr)
        .object(const $HeadersType());
  }

  static final _id_body = _class.instanceMethodId(
    r'body',
    r'()Lokhttp3/ResponseBody;',
  );

  static final _body = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.ResponseBody body()
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody body() {
    return _body(reference.pointer, _id_body as jni.JMethodIDPtr)
        .object(const $ResponseBodyType());
  }

  static final _id_networkResponse = _class.instanceMethodId(
    r'networkResponse',
    r'()Lokhttp3/Response;',
  );

  static final _networkResponse = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Response networkResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response networkResponse() {
    return _networkResponse(
            reference.pointer, _id_networkResponse as jni.JMethodIDPtr)
        .object(const $ResponseType());
  }

  static final _id_cacheResponse = _class.instanceMethodId(
    r'cacheResponse',
    r'()Lokhttp3/Response;',
  );

  static final _cacheResponse = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Response cacheResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response cacheResponse() {
    return _cacheResponse(
            reference.pointer, _id_cacheResponse as jni.JMethodIDPtr)
        .object(const $ResponseType());
  }

  static final _id_priorResponse = _class.instanceMethodId(
    r'priorResponse',
    r'()Lokhttp3/Response;',
  );

  static final _priorResponse = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Response priorResponse()
  /// The returned object must be released after use, by calling the [release] method.
  Response priorResponse() {
    return _priorResponse(
            reference.pointer, _id_priorResponse as jni.JMethodIDPtr)
        .object(const $ResponseType());
  }

  static final _id_sentRequestAtMillis = _class.instanceMethodId(
    r'sentRequestAtMillis',
    r'()J',
  );

  static final _sentRequestAtMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long sentRequestAtMillis()
  int sentRequestAtMillis() {
    return _sentRequestAtMillis(
            reference.pointer, _id_sentRequestAtMillis as jni.JMethodIDPtr)
        .long;
  }

  static final _id_receivedResponseAtMillis = _class.instanceMethodId(
    r'receivedResponseAtMillis',
    r'()J',
  );

  static final _receivedResponseAtMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long receivedResponseAtMillis()
  int receivedResponseAtMillis() {
    return _receivedResponseAtMillis(
            reference.pointer, _id_receivedResponseAtMillis as jni.JMethodIDPtr)
        .long;
  }

  static final _id_exchange = _class.instanceMethodId(
    r'exchange',
    r'()Lokhttp3/internal/connection/Exchange;',
  );

  static final _exchange = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.internal.connection.Exchange exchange()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject exchange() {
    return _exchange(reference.pointer, _id_exchange as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_isSuccessful = _class.instanceMethodId(
    r'isSuccessful',
    r'()Z',
  );

  static final _isSuccessful = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean isSuccessful()
  bool isSuccessful() {
    return _isSuccessful(
            reference.pointer, _id_isSuccessful as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_headers1 = _class.instanceMethodId(
    r'headers',
    r'(Ljava/lang/String;)Ljava/util/List;',
  );

  static final _headers1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.List headers(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> headers1(
    jni.JString string,
  ) {
    return _headers1(reference.pointer, _id_headers1 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_header = _class.instanceMethodId(
    r'header',
    r'(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _header = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String header(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header(
    jni.JString string,
    jni.JString string1,
  ) {
    return _header(reference.pointer, _id_header as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_trailers = _class.instanceMethodId(
    r'trailers',
    r'()Lokhttp3/Headers;',
  );

  static final _trailers = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Headers trailers()
  /// The returned object must be released after use, by calling the [release] method.
  Headers trailers() {
    return _trailers(reference.pointer, _id_trailers as jni.JMethodIDPtr)
        .object(const $HeadersType());
  }

  static final _id_peekBody = _class.instanceMethodId(
    r'peekBody',
    r'(J)Lokhttp3/ResponseBody;',
  );

  static final _peekBody = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okhttp3.ResponseBody peekBody(long j)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody peekBody(
    int j,
  ) {
    return _peekBody(reference.pointer, _id_peekBody as jni.JMethodIDPtr, j)
        .object(const $ResponseBodyType());
  }

  static final _id_newBuilder = _class.instanceMethodId(
    r'newBuilder',
    r'()Lokhttp3/Response$Builder;',
  );

  static final _newBuilder = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Response$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Response_Builder newBuilder() {
    return _newBuilder(reference.pointer, _id_newBuilder as jni.JMethodIDPtr)
        .object(const $Response_BuilderType());
  }

  static final _id_isRedirect = _class.instanceMethodId(
    r'isRedirect',
    r'()Z',
  );

  static final _isRedirect = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean isRedirect()
  bool isRedirect() {
    return _isRedirect(reference.pointer, _id_isRedirect as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_challenges = _class.instanceMethodId(
    r'challenges',
    r'()Ljava/util/List;',
  );

  static final _challenges = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List challenges()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> challenges() {
    return _challenges(reference.pointer, _id_challenges as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_cacheControl = _class.instanceMethodId(
    r'cacheControl',
    r'()Lokhttp3/CacheControl;',
  );

  static final _cacheControl = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.CacheControl cacheControl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cacheControl() {
    return _cacheControl(
            reference.pointer, _id_cacheControl as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_header1 = _class.instanceMethodId(
    r'header',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _header1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String header(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString header1(
    jni.JString string,
  ) {
    return _header1(reference.pointer, _id_header1 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }
}

final class $ResponseType extends jni.JObjType<Response> {
  const $ResponseType();

  @override
  String get signature => r'Lokhttp3/Response;';

  @override
  Response fromReference(jni.JReference reference) =>
      Response.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseType) && other is $ResponseType;
  }
}

/// from: okhttp3.ResponseBody$BomAwareReader
class ResponseBody_BomAwareReader extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody_BomAwareReader> $type = type;

  ResponseBody_BomAwareReader.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'okhttp3/ResponseBody$BomAwareReader');

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBody_BomAwareReaderType();
  static final _id_new0 = _class.constructorId(
    r'(Lokio/BufferedSource;Ljava/nio/charset/Charset;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okio.BufferedSource bufferedSource, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody_BomAwareReader(
    jni.JObject bufferedSource,
    jni.JObject charset,
  ) {
    return ResponseBody_BomAwareReader.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            bufferedSource.reference.pointer,
            charset.reference.pointer)
        .reference);
  }

  static final _id_read = _class.instanceMethodId(
    r'read',
    r'([CII)I',
  );

  static final _read = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int read(char[] cs, int i, int i1)
  int read(
    jni.JArray<jni.jchar> cs,
    int i,
    int i1,
  ) {
    return _read(reference.pointer, _id_read as jni.JMethodIDPtr,
            cs.reference.pointer, i, i1)
        .integer;
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }
}

final class $ResponseBody_BomAwareReaderType
    extends jni.JObjType<ResponseBody_BomAwareReader> {
  const $ResponseBody_BomAwareReaderType();

  @override
  String get signature => r'Lokhttp3/ResponseBody$BomAwareReader;';

  @override
  ResponseBody_BomAwareReader fromReference(jni.JReference reference) =>
      ResponseBody_BomAwareReader.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBody_BomAwareReaderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBody_BomAwareReaderType) &&
        other is $ResponseBody_BomAwareReaderType;
  }
}

/// from: okhttp3.ResponseBody$Companion
class ResponseBody_Companion extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody_Companion> $type = type;

  ResponseBody_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/ResponseBody$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBody_CompanionType();
  static final _id_create = _class.instanceMethodId(
    r'create',
    r'(Ljava/lang/String;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;',
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(java.lang.String string, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create(
    jni.JString string,
    jni.JObject mediaType,
  ) {
    return _create(reference.pointer, _id_create as jni.JMethodIDPtr,
            string.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create1 = _class.instanceMethodId(
    r'create',
    r'([BLokhttp3/MediaType;)Lokhttp3/ResponseBody;',
  );

  static final _create1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(byte[] bs, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create1(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
  ) {
    return _create1(reference.pointer, _id_create1 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create2 = _class.instanceMethodId(
    r'create',
    r'(Lokio/ByteString;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;',
  );

  static final _create2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(okio.ByteString byteString, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create2(
    ByteString byteString,
    jni.JObject mediaType,
  ) {
    return _create2(reference.pointer, _id_create2 as jni.JMethodIDPtr,
            byteString.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create3 = _class.instanceMethodId(
    r'create',
    r'(Lokio/BufferedSource;Lokhttp3/MediaType;J)Lokhttp3/ResponseBody;',
  );

  static final _create3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public final okhttp3.ResponseBody create(okio.BufferedSource bufferedSource, okhttp3.MediaType mediaType, long j)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create3(
    jni.JObject bufferedSource,
    jni.JObject mediaType,
    int j,
  ) {
    return _create3(reference.pointer, _id_create3 as jni.JMethodIDPtr,
            bufferedSource.reference.pointer, mediaType.reference.pointer, j)
        .object(const $ResponseBodyType());
  }

  static final _id_create4 = _class.instanceMethodId(
    r'create',
    r'(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/ResponseBody;',
  );

  static final _create4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create4(
    jni.JObject mediaType,
    jni.JString string,
  ) {
    return _create4(reference.pointer, _id_create4 as jni.JMethodIDPtr,
            mediaType.reference.pointer, string.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create5 = _class.instanceMethodId(
    r'create',
    r'(Lokhttp3/MediaType;[B)Lokhttp3/ResponseBody;',
  );

  static final _create5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create5(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create5(reference.pointer, _id_create5 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create6 = _class.instanceMethodId(
    r'create',
    r'(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/ResponseBody;',
  );

  static final _create6 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create6(
    jni.JObject mediaType,
    ByteString byteString,
  ) {
    return _create6(reference.pointer, _id_create6 as jni.JMethodIDPtr,
            mediaType.reference.pointer, byteString.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create7 = _class.instanceMethodId(
    r'create',
    r'(Lokhttp3/MediaType;JLokio/BufferedSource;)Lokhttp3/ResponseBody;',
  );

  static final _create7 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, long j, okio.BufferedSource bufferedSource)
  /// The returned object must be released after use, by calling the [release] method.
  ResponseBody create7(
    jni.JObject mediaType,
    int j,
    jni.JObject bufferedSource,
  ) {
    return _create7(reference.pointer, _id_create7 as jni.JMethodIDPtr,
            mediaType.reference.pointer, j, bufferedSource.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return ResponseBody_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $ResponseBody_CompanionType
    extends jni.JObjType<ResponseBody_Companion> {
  const $ResponseBody_CompanionType();

  @override
  String get signature => r'Lokhttp3/ResponseBody$Companion;';

  @override
  ResponseBody_Companion fromReference(jni.JReference reference) =>
      ResponseBody_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBody_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBody_CompanionType) &&
        other is $ResponseBody_CompanionType;
  }
}

/// from: okhttp3.ResponseBody
class ResponseBody extends jni.JObject {
  @override
  late final jni.JObjType<ResponseBody> $type = type;

  ResponseBody.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/ResponseBody');

  /// The type which includes information such as the signature of this class.
  static const type = $ResponseBodyType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lokhttp3/ResponseBody$Companion;',
  );

  /// from: static public final okhttp3.ResponseBody$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody_Companion get Companion =>
      _id_Companion.get(_class, const $ResponseBody_CompanionType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ResponseBody() {
    return ResponseBody.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_contentType = _class.instanceMethodId(
    r'contentType',
    r'()Lokhttp3/MediaType;',
  );

  static final _contentType = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.MediaType contentType()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject contentType() {
    return _contentType(reference.pointer, _id_contentType as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_contentLength = _class.instanceMethodId(
    r'contentLength',
    r'()J',
  );

  static final _contentLength = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract long contentLength()
  int contentLength() {
    return _contentLength(
            reference.pointer, _id_contentLength as jni.JMethodIDPtr)
        .long;
  }

  static final _id_byteStream = _class.instanceMethodId(
    r'byteStream',
    r'()Ljava/io/InputStream;',
  );

  static final _byteStream = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.io.InputStream byteStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject byteStream() {
    return _byteStream(reference.pointer, _id_byteStream as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_source = _class.instanceMethodId(
    r'source',
    r'()Lokio/BufferedSource;',
  );

  static final _source = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okio.BufferedSource source()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject source() {
    return _source(reference.pointer, _id_source as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_bytes = _class.instanceMethodId(
    r'bytes',
    r'()[B',
  );

  static final _bytes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final byte[] bytes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> bytes() {
    return _bytes(reference.pointer, _id_bytes as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _id_byteString = _class.instanceMethodId(
    r'byteString',
    r'()Lokio/ByteString;',
  );

  static final _byteString = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okio.ByteString byteString()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString byteString() {
    return _byteString(reference.pointer, _id_byteString as jni.JMethodIDPtr)
        .object(const $ByteStringType());
  }

  static final _id_charStream = _class.instanceMethodId(
    r'charStream',
    r'()Ljava/io/Reader;',
  );

  static final _charStream = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.io.Reader charStream()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject charStream() {
    return _charStream(reference.pointer, _id_charStream as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_string = _class.instanceMethodId(
    r'string',
    r'()Ljava/lang/String;',
  );

  static final _string = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.String string()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString string() {
    return _string(reference.pointer, _id_string as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  static final _id_create = _class.staticMethodId(
    r'create',
    r'(Ljava/lang/String;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;',
  );

  static final _create = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(java.lang.String string, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create(
    jni.JString string,
    jni.JObject mediaType,
  ) {
    return _create(_class.reference.pointer, _id_create as jni.JMethodIDPtr,
            string.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create1 = _class.staticMethodId(
    r'create',
    r'([BLokhttp3/MediaType;)Lokhttp3/ResponseBody;',
  );

  static final _create1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(byte[] bs, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create1(
    jni.JArray<jni.jbyte> bs,
    jni.JObject mediaType,
  ) {
    return _create1(_class.reference.pointer, _id_create1 as jni.JMethodIDPtr,
            bs.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create2 = _class.staticMethodId(
    r'create',
    r'(Lokio/ByteString;Lokhttp3/MediaType;)Lokhttp3/ResponseBody;',
  );

  static final _create2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(okio.ByteString byteString, okhttp3.MediaType mediaType)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create2(
    ByteString byteString,
    jni.JObject mediaType,
  ) {
    return _create2(_class.reference.pointer, _id_create2 as jni.JMethodIDPtr,
            byteString.reference.pointer, mediaType.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create3 = _class.staticMethodId(
    r'create',
    r'(Lokio/BufferedSource;Lokhttp3/MediaType;J)Lokhttp3/ResponseBody;',
  );

  static final _create3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public final okhttp3.ResponseBody create(okio.BufferedSource bufferedSource, okhttp3.MediaType mediaType, long j)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create3(
    jni.JObject bufferedSource,
    jni.JObject mediaType,
    int j,
  ) {
    return _create3(_class.reference.pointer, _id_create3 as jni.JMethodIDPtr,
            bufferedSource.reference.pointer, mediaType.reference.pointer, j)
        .object(const $ResponseBodyType());
  }

  static final _id_create4 = _class.staticMethodId(
    r'create',
    r'(Lokhttp3/MediaType;Ljava/lang/String;)Lokhttp3/ResponseBody;',
  );

  static final _create4 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create4(
    jni.JObject mediaType,
    jni.JString string,
  ) {
    return _create4(_class.reference.pointer, _id_create4 as jni.JMethodIDPtr,
            mediaType.reference.pointer, string.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create5 = _class.staticMethodId(
    r'create',
    r'(Lokhttp3/MediaType;[B)Lokhttp3/ResponseBody;',
  );

  static final _create5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create5(
    jni.JObject mediaType,
    jni.JArray<jni.jbyte> bs,
  ) {
    return _create5(_class.reference.pointer, _id_create5 as jni.JMethodIDPtr,
            mediaType.reference.pointer, bs.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create6 = _class.staticMethodId(
    r'create',
    r'(Lokhttp3/MediaType;Lokio/ByteString;)Lokhttp3/ResponseBody;',
  );

  static final _create6 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create6(
    jni.JObject mediaType,
    ByteString byteString,
  ) {
    return _create6(_class.reference.pointer, _id_create6 as jni.JMethodIDPtr,
            mediaType.reference.pointer, byteString.reference.pointer)
        .object(const $ResponseBodyType());
  }

  static final _id_create7 = _class.staticMethodId(
    r'create',
    r'(Lokhttp3/MediaType;JLokio/BufferedSource;)Lokhttp3/ResponseBody;',
  );

  static final _create7 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.ResponseBody create(okhttp3.MediaType mediaType, long j, okio.BufferedSource bufferedSource)
  /// The returned object must be released after use, by calling the [release] method.
  static ResponseBody create7(
    jni.JObject mediaType,
    int j,
    jni.JObject bufferedSource,
  ) {
    return _create7(_class.reference.pointer, _id_create7 as jni.JMethodIDPtr,
            mediaType.reference.pointer, j, bufferedSource.reference.pointer)
        .object(const $ResponseBodyType());
  }
}

final class $ResponseBodyType extends jni.JObjType<ResponseBody> {
  const $ResponseBodyType();

  @override
  String get signature => r'Lokhttp3/ResponseBody;';

  @override
  ResponseBody fromReference(jni.JReference reference) =>
      ResponseBody.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ResponseBodyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ResponseBodyType) &&
        other is $ResponseBodyType;
  }
}

/// from: okhttp3.OkHttpClient$Builder
class OkHttpClient_Builder extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient_Builder> $type = type;

  OkHttpClient_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/OkHttpClient$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClient_BuilderType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Builder() {
    return OkHttpClient_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(Lokhttp3/OkHttpClient;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.OkHttpClient okHttpClient)
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Builder.new1(
    OkHttpClient okHttpClient,
  ) {
    return OkHttpClient_Builder.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, okHttpClient.reference.pointer)
        .reference);
  }

  static final _id_dispatcher = _class.instanceMethodId(
    r'dispatcher',
    r'(Lokhttp3/Dispatcher;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _dispatcher = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder dispatcher(okhttp3.Dispatcher dispatcher)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder dispatcher(
    Dispatcher dispatcher,
  ) {
    return _dispatcher(reference.pointer, _id_dispatcher as jni.JMethodIDPtr,
            dispatcher.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_connectionPool = _class.instanceMethodId(
    r'connectionPool',
    r'(Lokhttp3/ConnectionPool;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _connectionPool = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder connectionPool(okhttp3.ConnectionPool connectionPool)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionPool(
    ConnectionPool connectionPool,
  ) {
    return _connectionPool(
            reference.pointer,
            _id_connectionPool as jni.JMethodIDPtr,
            connectionPool.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_interceptors = _class.instanceMethodId(
    r'interceptors',
    r'()Ljava/util/List;',
  );

  static final _interceptors = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> interceptors() {
    return _interceptors(
            reference.pointer, _id_interceptors as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_addInterceptor = _class.instanceMethodId(
    r'addInterceptor',
    r'(Lokhttp3/Interceptor;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _addInterceptor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder addInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addInterceptor(
    jni.JObject interceptor,
  ) {
    return _addInterceptor(
            reference.pointer,
            _id_addInterceptor as jni.JMethodIDPtr,
            interceptor.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_networkInterceptors = _class.instanceMethodId(
    r'networkInterceptors',
    r'()Ljava/util/List;',
  );

  static final _networkInterceptors = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> networkInterceptors() {
    return _networkInterceptors(
            reference.pointer, _id_networkInterceptors as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_addNetworkInterceptor = _class.instanceMethodId(
    r'addNetworkInterceptor',
    r'(Lokhttp3/Interceptor;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _addNetworkInterceptor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder addNetworkInterceptor(okhttp3.Interceptor interceptor)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addNetworkInterceptor(
    jni.JObject interceptor,
  ) {
    return _addNetworkInterceptor(
            reference.pointer,
            _id_addNetworkInterceptor as jni.JMethodIDPtr,
            interceptor.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_eventListener = _class.instanceMethodId(
    r'eventListener',
    r'(Lokhttp3/EventListener;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _eventListener = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder eventListener(okhttp3.EventListener eventListener)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder eventListener(
    jni.JObject eventListener,
  ) {
    return _eventListener(
            reference.pointer,
            _id_eventListener as jni.JMethodIDPtr,
            eventListener.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_eventListenerFactory = _class.instanceMethodId(
    r'eventListenerFactory',
    r'(Lokhttp3/EventListener$Factory;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _eventListenerFactory = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder eventListenerFactory(okhttp3.EventListener$Factory factory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder eventListenerFactory(
    jni.JObject factory0,
  ) {
    return _eventListenerFactory(
            reference.pointer,
            _id_eventListenerFactory as jni.JMethodIDPtr,
            factory0.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_retryOnConnectionFailure = _class.instanceMethodId(
    r'retryOnConnectionFailure',
    r'(Z)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _retryOnConnectionFailure = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okhttp3.OkHttpClient$Builder retryOnConnectionFailure(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder retryOnConnectionFailure(
    bool z,
  ) {
    return _retryOnConnectionFailure(reference.pointer,
            _id_retryOnConnectionFailure as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_authenticator = _class.instanceMethodId(
    r'authenticator',
    r'(Lokhttp3/Authenticator;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _authenticator = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder authenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder authenticator(
    jni.JObject authenticator,
  ) {
    return _authenticator(
            reference.pointer,
            _id_authenticator as jni.JMethodIDPtr,
            authenticator.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_followRedirects = _class.instanceMethodId(
    r'followRedirects',
    r'(Z)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _followRedirects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okhttp3.OkHttpClient$Builder followRedirects(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder followRedirects(
    bool z,
  ) {
    return _followRedirects(reference.pointer,
            _id_followRedirects as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_followSslRedirects = _class.instanceMethodId(
    r'followSslRedirects',
    r'(Z)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _followSslRedirects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okhttp3.OkHttpClient$Builder followSslRedirects(boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder followSslRedirects(
    bool z,
  ) {
    return _followSslRedirects(reference.pointer,
            _id_followSslRedirects as jni.JMethodIDPtr, z ? 1 : 0)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_cookieJar = _class.instanceMethodId(
    r'cookieJar',
    r'(Lokhttp3/CookieJar;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _cookieJar = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder cookieJar(okhttp3.CookieJar cookieJar)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder cookieJar(
    jni.JObject cookieJar,
  ) {
    return _cookieJar(reference.pointer, _id_cookieJar as jni.JMethodIDPtr,
            cookieJar.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_cache = _class.instanceMethodId(
    r'cache',
    r'(Lokhttp3/Cache;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _cache = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder cache(okhttp3.Cache cache)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder cache(
    Cache cache,
  ) {
    return _cache(reference.pointer, _id_cache as jni.JMethodIDPtr,
            cache.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_dns = _class.instanceMethodId(
    r'dns',
    r'(Lokhttp3/Dns;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _dns = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder dns(okhttp3.Dns dns)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder dns(
    jni.JObject dns,
  ) {
    return _dns(reference.pointer, _id_dns as jni.JMethodIDPtr,
            dns.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_proxy = _class.instanceMethodId(
    r'proxy',
    r'(Ljava/net/Proxy;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _proxy = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder proxy(java.net.Proxy proxy)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxy(
    jni.JObject proxy,
  ) {
    return _proxy(reference.pointer, _id_proxy as jni.JMethodIDPtr,
            proxy.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_proxySelector = _class.instanceMethodId(
    r'proxySelector',
    r'(Ljava/net/ProxySelector;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _proxySelector = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder proxySelector(java.net.ProxySelector proxySelector)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxySelector(
    jni.JObject proxySelector,
  ) {
    return _proxySelector(
            reference.pointer,
            _id_proxySelector as jni.JMethodIDPtr,
            proxySelector.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_proxyAuthenticator = _class.instanceMethodId(
    r'proxyAuthenticator',
    r'(Lokhttp3/Authenticator;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _proxyAuthenticator = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder proxyAuthenticator(okhttp3.Authenticator authenticator)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder proxyAuthenticator(
    jni.JObject authenticator,
  ) {
    return _proxyAuthenticator(
            reference.pointer,
            _id_proxyAuthenticator as jni.JMethodIDPtr,
            authenticator.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_socketFactory = _class.instanceMethodId(
    r'socketFactory',
    r'(Ljavax/net/SocketFactory;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _socketFactory = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder socketFactory(javax.net.SocketFactory socketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder socketFactory(
    jni.JObject socketFactory,
  ) {
    return _socketFactory(
            reference.pointer,
            _id_socketFactory as jni.JMethodIDPtr,
            socketFactory.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_sslSocketFactory = _class.instanceMethodId(
    r'sslSocketFactory',
    r'(Ljavax/net/ssl/SSLSocketFactory;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _sslSocketFactory = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder sslSocketFactory(
    jni.JObject sSLSocketFactory,
  ) {
    return _sslSocketFactory(
            reference.pointer,
            _id_sslSocketFactory as jni.JMethodIDPtr,
            sSLSocketFactory.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_sslSocketFactory1 = _class.instanceMethodId(
    r'sslSocketFactory',
    r'(Ljavax/net/ssl/SSLSocketFactory;Ljavax/net/ssl/X509TrustManager;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _sslSocketFactory1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder sslSocketFactory(javax.net.ssl.SSLSocketFactory sSLSocketFactory, javax.net.ssl.X509TrustManager x509TrustManager)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder sslSocketFactory1(
    jni.JObject sSLSocketFactory,
    jni.JObject x509TrustManager,
  ) {
    return _sslSocketFactory1(
            reference.pointer,
            _id_sslSocketFactory1 as jni.JMethodIDPtr,
            sSLSocketFactory.reference.pointer,
            x509TrustManager.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_connectionSpecs = _class.instanceMethodId(
    r'connectionSpecs',
    r'(Ljava/util/List;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _connectionSpecs = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder connectionSpecs(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectionSpecs(
    jni.JList<jni.JObject> list,
  ) {
    return _connectionSpecs(reference.pointer,
            _id_connectionSpecs as jni.JMethodIDPtr, list.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_protocols = _class.instanceMethodId(
    r'protocols',
    r'(Ljava/util/List;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _protocols = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder protocols(java.util.List list)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder protocols(
    jni.JList<jni.JObject> list,
  ) {
    return _protocols(reference.pointer, _id_protocols as jni.JMethodIDPtr,
            list.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_hostnameVerifier = _class.instanceMethodId(
    r'hostnameVerifier',
    r'(Ljavax/net/ssl/HostnameVerifier;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _hostnameVerifier = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder hostnameVerifier(javax.net.ssl.HostnameVerifier hostnameVerifier)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder hostnameVerifier(
    jni.JObject hostnameVerifier,
  ) {
    return _hostnameVerifier(
            reference.pointer,
            _id_hostnameVerifier as jni.JMethodIDPtr,
            hostnameVerifier.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_certificatePinner = _class.instanceMethodId(
    r'certificatePinner',
    r'(Lokhttp3/CertificatePinner;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _certificatePinner = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder certificatePinner(okhttp3.CertificatePinner certificatePinner)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder certificatePinner(
    jni.JObject certificatePinner,
  ) {
    return _certificatePinner(
            reference.pointer,
            _id_certificatePinner as jni.JMethodIDPtr,
            certificatePinner.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_callTimeout = _class.instanceMethodId(
    r'callTimeout',
    r'(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _callTimeout = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder callTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder callTimeout(
    int j,
    TimeUnit timeUnit,
  ) {
    return _callTimeout(reference.pointer, _id_callTimeout as jni.JMethodIDPtr,
            j, timeUnit.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_callTimeout1 = _class.instanceMethodId(
    r'callTimeout',
    r'(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _callTimeout1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder callTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder callTimeout1(
    jni.JObject duration,
  ) {
    return _callTimeout1(reference.pointer,
            _id_callTimeout1 as jni.JMethodIDPtr, duration.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_connectTimeout = _class.instanceMethodId(
    r'connectTimeout',
    r'(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _connectTimeout = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder connectTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectTimeout(
    int j,
    TimeUnit timeUnit,
  ) {
    return _connectTimeout(
            reference.pointer,
            _id_connectTimeout as jni.JMethodIDPtr,
            j,
            timeUnit.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_connectTimeout1 = _class.instanceMethodId(
    r'connectTimeout',
    r'(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _connectTimeout1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder connectTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder connectTimeout1(
    jni.JObject duration,
  ) {
    return _connectTimeout1(reference.pointer,
            _id_connectTimeout1 as jni.JMethodIDPtr, duration.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_readTimeout = _class.instanceMethodId(
    r'readTimeout',
    r'(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _readTimeout = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder readTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder readTimeout(
    int j,
    TimeUnit timeUnit,
  ) {
    return _readTimeout(reference.pointer, _id_readTimeout as jni.JMethodIDPtr,
            j, timeUnit.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_readTimeout1 = _class.instanceMethodId(
    r'readTimeout',
    r'(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _readTimeout1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder readTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder readTimeout1(
    jni.JObject duration,
  ) {
    return _readTimeout1(reference.pointer,
            _id_readTimeout1 as jni.JMethodIDPtr, duration.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_writeTimeout = _class.instanceMethodId(
    r'writeTimeout',
    r'(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _writeTimeout = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder writeTimeout(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder writeTimeout(
    int j,
    TimeUnit timeUnit,
  ) {
    return _writeTimeout(reference.pointer,
            _id_writeTimeout as jni.JMethodIDPtr, j, timeUnit.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_writeTimeout1 = _class.instanceMethodId(
    r'writeTimeout',
    r'(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _writeTimeout1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder writeTimeout(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder writeTimeout1(
    jni.JObject duration,
  ) {
    return _writeTimeout1(reference.pointer,
            _id_writeTimeout1 as jni.JMethodIDPtr, duration.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_pingInterval = _class.instanceMethodId(
    r'pingInterval',
    r'(JLjava/util/concurrent/TimeUnit;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _pingInterval = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder pingInterval(long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder pingInterval(
    int j,
    TimeUnit timeUnit,
  ) {
    return _pingInterval(reference.pointer,
            _id_pingInterval as jni.JMethodIDPtr, j, timeUnit.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_pingInterval1 = _class.instanceMethodId(
    r'pingInterval',
    r'(Ljava/time/Duration;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _pingInterval1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder pingInterval(java.time.Duration duration)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder pingInterval1(
    jni.JObject duration,
  ) {
    return _pingInterval1(reference.pointer,
            _id_pingInterval1 as jni.JMethodIDPtr, duration.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_minWebSocketMessageToCompress = _class.instanceMethodId(
    r'minWebSocketMessageToCompress',
    r'(J)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _minWebSocketMessageToCompress = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okhttp3.OkHttpClient$Builder minWebSocketMessageToCompress(long j)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder minWebSocketMessageToCompress(
    int j,
  ) {
    return _minWebSocketMessageToCompress(reference.pointer,
            _id_minWebSocketMessageToCompress as jni.JMethodIDPtr, j)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Lokhttp3/OkHttpClient;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.OkHttpClient build()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $OkHttpClientType());
  }
}

final class $OkHttpClient_BuilderType
    extends jni.JObjType<OkHttpClient_Builder> {
  const $OkHttpClient_BuilderType();

  @override
  String get signature => r'Lokhttp3/OkHttpClient$Builder;';

  @override
  OkHttpClient_Builder fromReference(jni.JReference reference) =>
      OkHttpClient_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClient_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_BuilderType) &&
        other is $OkHttpClient_BuilderType;
  }
}

/// from: okhttp3.OkHttpClient$Companion
class OkHttpClient_Companion extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient_Companion> $type = type;

  OkHttpClient_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/OkHttpClient$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClient_CompanionType();
  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return OkHttpClient_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $OkHttpClient_CompanionType
    extends jni.JObjType<OkHttpClient_Companion> {
  const $OkHttpClient_CompanionType();

  @override
  String get signature => r'Lokhttp3/OkHttpClient$Companion;';

  @override
  OkHttpClient_Companion fromReference(jni.JReference reference) =>
      OkHttpClient_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClient_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClient_CompanionType) &&
        other is $OkHttpClient_CompanionType;
  }
}

/// from: okhttp3.OkHttpClient
class OkHttpClient extends jni.JObject {
  @override
  late final jni.JObjType<OkHttpClient> $type = type;

  OkHttpClient.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/OkHttpClient');

  /// The type which includes information such as the signature of this class.
  static const type = $OkHttpClientType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lokhttp3/OkHttpClient$Companion;',
  );

  /// from: static public final okhttp3.OkHttpClient$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static OkHttpClient_Companion get Companion =>
      _id_Companion.get(_class, const $OkHttpClient_CompanionType());

  static final _id_new0 = _class.constructorId(
    r'(Lokhttp3/OkHttpClient$Builder;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.OkHttpClient$Builder builder)
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient(
    OkHttpClient_Builder builder,
  ) {
    return OkHttpClient.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, builder.reference.pointer)
        .reference);
  }

  static final _id_dispatcher = _class.instanceMethodId(
    r'dispatcher',
    r'()Lokhttp3/Dispatcher;',
  );

  static final _dispatcher = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Dispatcher dispatcher()
  /// The returned object must be released after use, by calling the [release] method.
  Dispatcher dispatcher() {
    return _dispatcher(reference.pointer, _id_dispatcher as jni.JMethodIDPtr)
        .object(const $DispatcherType());
  }

  static final _id_connectionPool = _class.instanceMethodId(
    r'connectionPool',
    r'()Lokhttp3/ConnectionPool;',
  );

  static final _connectionPool = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.ConnectionPool connectionPool()
  /// The returned object must be released after use, by calling the [release] method.
  ConnectionPool connectionPool() {
    return _connectionPool(
            reference.pointer, _id_connectionPool as jni.JMethodIDPtr)
        .object(const $ConnectionPoolType());
  }

  static final _id_interceptors = _class.instanceMethodId(
    r'interceptors',
    r'()Ljava/util/List;',
  );

  static final _interceptors = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List interceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> interceptors() {
    return _interceptors(
            reference.pointer, _id_interceptors as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_networkInterceptors = _class.instanceMethodId(
    r'networkInterceptors',
    r'()Ljava/util/List;',
  );

  static final _networkInterceptors = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List networkInterceptors()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> networkInterceptors() {
    return _networkInterceptors(
            reference.pointer, _id_networkInterceptors as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_eventListenerFactory = _class.instanceMethodId(
    r'eventListenerFactory',
    r'()Lokhttp3/EventListener$Factory;',
  );

  static final _eventListenerFactory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.EventListener$Factory eventListenerFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject eventListenerFactory() {
    return _eventListenerFactory(
            reference.pointer, _id_eventListenerFactory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_retryOnConnectionFailure = _class.instanceMethodId(
    r'retryOnConnectionFailure',
    r'()Z',
  );

  static final _retryOnConnectionFailure = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean retryOnConnectionFailure()
  bool retryOnConnectionFailure() {
    return _retryOnConnectionFailure(
            reference.pointer, _id_retryOnConnectionFailure as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_authenticator = _class.instanceMethodId(
    r'authenticator',
    r'()Lokhttp3/Authenticator;',
  );

  static final _authenticator = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Authenticator authenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject authenticator() {
    return _authenticator(
            reference.pointer, _id_authenticator as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_followRedirects = _class.instanceMethodId(
    r'followRedirects',
    r'()Z',
  );

  static final _followRedirects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean followRedirects()
  bool followRedirects() {
    return _followRedirects(
            reference.pointer, _id_followRedirects as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_followSslRedirects = _class.instanceMethodId(
    r'followSslRedirects',
    r'()Z',
  );

  static final _followSslRedirects = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean followSslRedirects()
  bool followSslRedirects() {
    return _followSslRedirects(
            reference.pointer, _id_followSslRedirects as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_cookieJar = _class.instanceMethodId(
    r'cookieJar',
    r'()Lokhttp3/CookieJar;',
  );

  static final _cookieJar = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.CookieJar cookieJar()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject cookieJar() {
    return _cookieJar(reference.pointer, _id_cookieJar as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_cache = _class.instanceMethodId(
    r'cache',
    r'()Lokhttp3/Cache;',
  );

  static final _cache = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Cache cache()
  /// The returned object must be released after use, by calling the [release] method.
  Cache cache() {
    return _cache(reference.pointer, _id_cache as jni.JMethodIDPtr)
        .object(const $CacheType());
  }

  static final _id_dns = _class.instanceMethodId(
    r'dns',
    r'()Lokhttp3/Dns;',
  );

  static final _dns = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Dns dns()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject dns() {
    return _dns(reference.pointer, _id_dns as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_proxy = _class.instanceMethodId(
    r'proxy',
    r'()Ljava/net/Proxy;',
  );

  static final _proxy = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.net.Proxy proxy()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxy() {
    return _proxy(reference.pointer, _id_proxy as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_proxySelector = _class.instanceMethodId(
    r'proxySelector',
    r'()Ljava/net/ProxySelector;',
  );

  static final _proxySelector = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.net.ProxySelector proxySelector()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxySelector() {
    return _proxySelector(
            reference.pointer, _id_proxySelector as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_proxyAuthenticator = _class.instanceMethodId(
    r'proxyAuthenticator',
    r'()Lokhttp3/Authenticator;',
  );

  static final _proxyAuthenticator = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Authenticator proxyAuthenticator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject proxyAuthenticator() {
    return _proxyAuthenticator(
            reference.pointer, _id_proxyAuthenticator as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_socketFactory = _class.instanceMethodId(
    r'socketFactory',
    r'()Ljavax/net/SocketFactory;',
  );

  static final _socketFactory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final javax.net.SocketFactory socketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject socketFactory() {
    return _socketFactory(
            reference.pointer, _id_socketFactory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_sslSocketFactory = _class.instanceMethodId(
    r'sslSocketFactory',
    r'()Ljavax/net/ssl/SSLSocketFactory;',
  );

  static final _sslSocketFactory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final javax.net.ssl.SSLSocketFactory sslSocketFactory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject sslSocketFactory() {
    return _sslSocketFactory(
            reference.pointer, _id_sslSocketFactory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_x509TrustManager = _class.instanceMethodId(
    r'x509TrustManager',
    r'()Ljavax/net/ssl/X509TrustManager;',
  );

  static final _x509TrustManager = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final javax.net.ssl.X509TrustManager x509TrustManager()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject x509TrustManager() {
    return _x509TrustManager(
            reference.pointer, _id_x509TrustManager as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_connectionSpecs = _class.instanceMethodId(
    r'connectionSpecs',
    r'()Ljava/util/List;',
  );

  static final _connectionSpecs = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List connectionSpecs()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> connectionSpecs() {
    return _connectionSpecs(
            reference.pointer, _id_connectionSpecs as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_protocols = _class.instanceMethodId(
    r'protocols',
    r'()Ljava/util/List;',
  );

  static final _protocols = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List protocols()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> protocols() {
    return _protocols(reference.pointer, _id_protocols as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_hostnameVerifier = _class.instanceMethodId(
    r'hostnameVerifier',
    r'()Ljavax/net/ssl/HostnameVerifier;',
  );

  static final _hostnameVerifier = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final javax.net.ssl.HostnameVerifier hostnameVerifier()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject hostnameVerifier() {
    return _hostnameVerifier(
            reference.pointer, _id_hostnameVerifier as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_certificatePinner = _class.instanceMethodId(
    r'certificatePinner',
    r'()Lokhttp3/CertificatePinner;',
  );

  static final _certificatePinner = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.CertificatePinner certificatePinner()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject certificatePinner() {
    return _certificatePinner(
            reference.pointer, _id_certificatePinner as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_certificateChainCleaner = _class.instanceMethodId(
    r'certificateChainCleaner',
    r'()Lokhttp3/internal/tls/CertificateChainCleaner;',
  );

  static final _certificateChainCleaner = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.internal.tls.CertificateChainCleaner certificateChainCleaner()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject certificateChainCleaner() {
    return _certificateChainCleaner(
            reference.pointer, _id_certificateChainCleaner as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_callTimeoutMillis = _class.instanceMethodId(
    r'callTimeoutMillis',
    r'()I',
  );

  static final _callTimeoutMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int callTimeoutMillis()
  int callTimeoutMillis() {
    return _callTimeoutMillis(
            reference.pointer, _id_callTimeoutMillis as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_connectTimeoutMillis = _class.instanceMethodId(
    r'connectTimeoutMillis',
    r'()I',
  );

  static final _connectTimeoutMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int connectTimeoutMillis()
  int connectTimeoutMillis() {
    return _connectTimeoutMillis(
            reference.pointer, _id_connectTimeoutMillis as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_readTimeoutMillis = _class.instanceMethodId(
    r'readTimeoutMillis',
    r'()I',
  );

  static final _readTimeoutMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int readTimeoutMillis()
  int readTimeoutMillis() {
    return _readTimeoutMillis(
            reference.pointer, _id_readTimeoutMillis as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_writeTimeoutMillis = _class.instanceMethodId(
    r'writeTimeoutMillis',
    r'()I',
  );

  static final _writeTimeoutMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int writeTimeoutMillis()
  int writeTimeoutMillis() {
    return _writeTimeoutMillis(
            reference.pointer, _id_writeTimeoutMillis as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_pingIntervalMillis = _class.instanceMethodId(
    r'pingIntervalMillis',
    r'()I',
  );

  static final _pingIntervalMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int pingIntervalMillis()
  int pingIntervalMillis() {
    return _pingIntervalMillis(
            reference.pointer, _id_pingIntervalMillis as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_minWebSocketMessageToCompress = _class.instanceMethodId(
    r'minWebSocketMessageToCompress',
    r'()J',
  );

  static final _minWebSocketMessageToCompress = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long minWebSocketMessageToCompress()
  int minWebSocketMessageToCompress() {
    return _minWebSocketMessageToCompress(reference.pointer,
            _id_minWebSocketMessageToCompress as jni.JMethodIDPtr)
        .long;
  }

  static final _id_getRouteDatabase = _class.instanceMethodId(
    r'getRouteDatabase',
    r'()Lokhttp3/internal/connection/RouteDatabase;',
  );

  static final _getRouteDatabase = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.internal.connection.RouteDatabase getRouteDatabase()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRouteDatabase() {
    return _getRouteDatabase(
            reference.pointer, _id_getRouteDatabase as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_new1 = _class.constructorId(
    r'()V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory OkHttpClient.new1() {
    return OkHttpClient.fromReference(
        _new1(_class.reference.pointer, _id_new1 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_newCall = _class.instanceMethodId(
    r'newCall',
    r'(Lokhttp3/Request;)Lokhttp3/Call;',
  );

  static final _newCall = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    Request request,
  ) {
    return _newCall(reference.pointer, _id_newCall as jni.JMethodIDPtr,
            request.reference.pointer)
        .object(const $CallType());
  }

  static final _id_newWebSocket = _class.instanceMethodId(
    r'newWebSocket',
    r'(Lokhttp3/Request;Lokhttp3/WebSocketListener;)Lokhttp3/WebSocket;',
  );

  static final _newWebSocket = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public okhttp3.WebSocket newWebSocket(okhttp3.Request request, okhttp3.WebSocketListener webSocketListener)
  /// The returned object must be released after use, by calling the [release] method.
  WebSocket newWebSocket(
    Request request,
    jni.JObject webSocketListener,
  ) {
    return _newWebSocket(
            reference.pointer,
            _id_newWebSocket as jni.JMethodIDPtr,
            request.reference.pointer,
            webSocketListener.reference.pointer)
        .object(const $WebSocketType());
  }

  static final _id_newBuilder = _class.instanceMethodId(
    r'newBuilder',
    r'()Lokhttp3/OkHttpClient$Builder;',
  );

  static final _newBuilder = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okhttp3.OkHttpClient$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder newBuilder() {
    return _newBuilder(reference.pointer, _id_newBuilder as jni.JMethodIDPtr)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Ljava/lang/Object;',
  );

  static final _clone = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.Object clone()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject clone() {
    return _clone(reference.pointer, _id_clone as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }
}

final class $OkHttpClientType extends jni.JObjType<OkHttpClient> {
  const $OkHttpClientType();

  @override
  String get signature => r'Lokhttp3/OkHttpClient;';

  @override
  OkHttpClient fromReference(jni.JReference reference) =>
      OkHttpClient.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OkHttpClientType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OkHttpClientType) &&
        other is $OkHttpClientType;
  }
}

/// from: okhttp3.Call$Factory
class Call_Factory extends jni.JObject {
  @override
  late final jni.JObjType<Call_Factory> $type = type;

  Call_Factory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Call$Factory');

  /// The type which includes information such as the signature of this class.
  static const type = $Call_FactoryType();
  static final _id_newCall = _class.instanceMethodId(
    r'newCall',
    r'(Lokhttp3/Request;)Lokhttp3/Call;',
  );

  static final _newCall = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract okhttp3.Call newCall(okhttp3.Request request)
  /// The returned object must be released after use, by calling the [release] method.
  Call newCall(
    Request request,
  ) {
    return _newCall(reference.pointer, _id_newCall as jni.JMethodIDPtr,
            request.reference.pointer)
        .object(const $CallType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Call_FactoryImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'newCall(Lokhttp3/Request;)Lokhttp3/Call;') {
        final $r = _$impls[$p]!.newCall(
          $a[0].castTo(const $RequestType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Call_Factory.implement(
    $Call_FactoryImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Call_Factory.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'okhttp3.Call$Factory',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Call_FactoryImpl {
  factory $Call_FactoryImpl({
    required Call Function(Request request) newCall,
  }) = _$Call_FactoryImpl;

  Call newCall(Request request);
}

class _$Call_FactoryImpl implements $Call_FactoryImpl {
  _$Call_FactoryImpl({
    required Call Function(Request request) newCall,
  }) : _newCall = newCall;

  final Call Function(Request request) _newCall;

  Call newCall(Request request) {
    return _newCall(request);
  }
}

final class $Call_FactoryType extends jni.JObjType<Call_Factory> {
  const $Call_FactoryType();

  @override
  String get signature => r'Lokhttp3/Call$Factory;';

  @override
  Call_Factory fromReference(jni.JReference reference) =>
      Call_Factory.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Call_FactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Call_FactoryType) &&
        other is $Call_FactoryType;
  }
}

/// from: okhttp3.Call
class Call extends jni.JObject {
  @override
  late final jni.JObjType<Call> $type = type;

  Call.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Call');

  /// The type which includes information such as the signature of this class.
  static const type = $CallType();
  static final _id_request = _class.instanceMethodId(
    r'request',
    r'()Lokhttp3/Request;',
  );

  static final _request = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return _request(reference.pointer, _id_request as jni.JMethodIDPtr)
        .object(const $RequestType());
  }

  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'()Lokhttp3/Response;',
  );

  static final _execute = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.Response execute()
  /// The returned object must be released after use, by calling the [release] method.
  Response execute() {
    return _execute(reference.pointer, _id_execute as jni.JMethodIDPtr)
        .object(const $ResponseType());
  }

  static final _id_enqueue = _class.instanceMethodId(
    r'enqueue',
    r'(Lokhttp3/Callback;)V',
  );

  static final _enqueue = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void enqueue(okhttp3.Callback callback)
  void enqueue(
    Callback callback,
  ) {
    _enqueue(reference.pointer, _id_enqueue as jni.JMethodIDPtr,
            callback.reference.pointer)
        .check();
  }

  static final _id_cancel = _class.instanceMethodId(
    r'cancel',
    r'()V',
  );

  static final _cancel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void cancel()
  void cancel() {
    _cancel(reference.pointer, _id_cancel as jni.JMethodIDPtr).check();
  }

  static final _id_isExecuted = _class.instanceMethodId(
    r'isExecuted',
    r'()Z',
  );

  static final _isExecuted = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isExecuted()
  bool isExecuted() {
    return _isExecuted(reference.pointer, _id_isExecuted as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isCanceled = _class.instanceMethodId(
    r'isCanceled',
    r'()Z',
  );

  static final _isCanceled = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isCanceled()
  bool isCanceled() {
    return _isCanceled(reference.pointer, _id_isCanceled as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_timeout = _class.instanceMethodId(
    r'timeout',
    r'()Lokio/Timeout;',
  );

  static final _timeout = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okio.Timeout timeout()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject timeout() {
    return _timeout(reference.pointer, _id_timeout as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lokhttp3/Call;',
  );

  static final _clone = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.Call clone()
  /// The returned object must be released after use, by calling the [release] method.
  Call clone() {
    return _clone(reference.pointer, _id_clone as jni.JMethodIDPtr)
        .object(const $CallType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CallImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'request()Lokhttp3/Request;') {
        final $r = _$impls[$p]!.request();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'execute()Lokhttp3/Response;') {
        final $r = _$impls[$p]!.execute();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'enqueue(Lokhttp3/Callback;)V') {
        _$impls[$p]!.enqueue(
          $a[0].castTo(const $CallbackType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'cancel()V') {
        _$impls[$p]!.cancel();
        return jni.nullptr;
      }
      if ($d == r'isExecuted()Z') {
        final $r = _$impls[$p]!.isExecuted();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'isCanceled()Z') {
        final $r = _$impls[$p]!.isCanceled();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'timeout()Lokio/Timeout;') {
        final $r = _$impls[$p]!.timeout();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'clone()Lokhttp3/Call;') {
        final $r = _$impls[$p]!.clone();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Call.implement(
    $CallImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Call.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'okhttp3.Call',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CallImpl {
  factory $CallImpl({
    required Request Function() request,
    required Response Function() execute,
    required void Function(Callback callback) enqueue,
    required void Function() cancel,
    required bool Function() isExecuted,
    required bool Function() isCanceled,
    required jni.JObject Function() timeout,
    required Call Function() clone,
  }) = _$CallImpl;

  Request request();
  Response execute();
  void enqueue(Callback callback);
  void cancel();
  bool isExecuted();
  bool isCanceled();
  jni.JObject timeout();
  Call clone();
}

class _$CallImpl implements $CallImpl {
  _$CallImpl({
    required Request Function() request,
    required Response Function() execute,
    required void Function(Callback callback) enqueue,
    required void Function() cancel,
    required bool Function() isExecuted,
    required bool Function() isCanceled,
    required jni.JObject Function() timeout,
    required Call Function() clone,
  })  : _request = request,
        _execute = execute,
        _enqueue = enqueue,
        _cancel = cancel,
        _isExecuted = isExecuted,
        _isCanceled = isCanceled,
        _timeout = timeout,
        _clone = clone;

  final Request Function() _request;
  final Response Function() _execute;
  final void Function(Callback callback) _enqueue;
  final void Function() _cancel;
  final bool Function() _isExecuted;
  final bool Function() _isCanceled;
  final jni.JObject Function() _timeout;
  final Call Function() _clone;

  Request request() {
    return _request();
  }

  Response execute() {
    return _execute();
  }

  void enqueue(Callback callback) {
    return _enqueue(callback);
  }

  void cancel() {
    return _cancel();
  }

  bool isExecuted() {
    return _isExecuted();
  }

  bool isCanceled() {
    return _isCanceled();
  }

  jni.JObject timeout() {
    return _timeout();
  }

  Call clone() {
    return _clone();
  }
}

final class $CallType extends jni.JObjType<Call> {
  const $CallType();

  @override
  String get signature => r'Lokhttp3/Call;';

  @override
  Call fromReference(jni.JReference reference) => Call.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CallType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CallType) && other is $CallType;
  }
}

/// from: okhttp3.Headers$Builder
class Headers_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Headers_Builder> $type = type;

  Headers_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Headers$Builder');

  /// The type which includes information such as the signature of this class.
  static const type = $Headers_BuilderType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Headers_Builder() {
    return Headers_Builder.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_add = _class.instanceMethodId(
    r'add',
    r'(Ljava/lang/String;)Lokhttp3/Headers$Builder;',
  );

  static final _add = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder add(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add(
    jni.JString string,
  ) {
    return _add(reference.pointer, _id_add as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_add1 = _class.instanceMethodId(
    r'add',
    r'(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;',
  );

  static final _add1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder add(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add1(
    jni.JString string,
    jni.JString string1,
  ) {
    return _add1(reference.pointer, _id_add1 as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_addUnsafeNonAscii = _class.instanceMethodId(
    r'addUnsafeNonAscii',
    r'(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;',
  );

  static final _addUnsafeNonAscii = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder addUnsafeNonAscii(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder addUnsafeNonAscii(
    jni.JString string,
    jni.JString string1,
  ) {
    return _addUnsafeNonAscii(
            reference.pointer,
            _id_addUnsafeNonAscii as jni.JMethodIDPtr,
            string.reference.pointer,
            string1.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_addAll = _class.instanceMethodId(
    r'addAll',
    r'(Lokhttp3/Headers;)Lokhttp3/Headers$Builder;',
  );

  static final _addAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder addAll(okhttp3.Headers headers)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder addAll(
    Headers headers,
  ) {
    return _addAll(reference.pointer, _id_addAll as jni.JMethodIDPtr,
            headers.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_add2 = _class.instanceMethodId(
    r'add',
    r'(Ljava/lang/String;Ljava/util/Date;)Lokhttp3/Headers$Builder;',
  );

  static final _add2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder add(java.lang.String string, java.util.Date date)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add2(
    jni.JString string,
    jni.JObject date,
  ) {
    return _add2(reference.pointer, _id_add2 as jni.JMethodIDPtr,
            string.reference.pointer, date.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_add3 = _class.instanceMethodId(
    r'add',
    r'(Ljava/lang/String;Ljava/time/Instant;)Lokhttp3/Headers$Builder;',
  );

  static final _add3 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder add(java.lang.String string, java.time.Instant instant)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder add3(
    jni.JString string,
    jni.JObject instant,
  ) {
    return _add3(reference.pointer, _id_add3 as jni.JMethodIDPtr,
            string.reference.pointer, instant.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_set0 = _class.instanceMethodId(
    r'set',
    r'(Ljava/lang/String;Ljava/util/Date;)Lokhttp3/Headers$Builder;',
  );

  static final _set0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder set(java.lang.String string, java.util.Date date)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder set0(
    jni.JString string,
    jni.JObject date,
  ) {
    return _set0(reference.pointer, _id_set0 as jni.JMethodIDPtr,
            string.reference.pointer, date.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_set1 = _class.instanceMethodId(
    r'set',
    r'(Ljava/lang/String;Ljava/time/Instant;)Lokhttp3/Headers$Builder;',
  );

  static final _set1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder set(java.lang.String string, java.time.Instant instant)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder set1(
    jni.JString string,
    jni.JObject instant,
  ) {
    return _set1(reference.pointer, _id_set1 as jni.JMethodIDPtr,
            string.reference.pointer, instant.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_removeAll = _class.instanceMethodId(
    r'removeAll',
    r'(Ljava/lang/String;)Lokhttp3/Headers$Builder;',
  );

  static final _removeAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder removeAll(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder removeAll(
    jni.JString string,
  ) {
    return _removeAll(reference.pointer, _id_removeAll as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_set2 = _class.instanceMethodId(
    r'set',
    r'(Ljava/lang/String;Ljava/lang/String;)Lokhttp3/Headers$Builder;',
  );

  static final _set2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers$Builder set(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder set2(
    jni.JString string,
    jni.JString string1,
  ) {
    return _set2(reference.pointer, _id_set2 as jni.JMethodIDPtr,
            string.reference.pointer, string1.reference.pointer)
        .object(const $Headers_BuilderType());
  }

  static final _id_get0 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _get0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString get0(
    jni.JString string,
  ) {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Lokhttp3/Headers;',
  );

  static final _build = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Headers build()
  /// The returned object must be released after use, by calling the [release] method.
  Headers build() {
    return _build(reference.pointer, _id_build as jni.JMethodIDPtr)
        .object(const $HeadersType());
  }
}

final class $Headers_BuilderType extends jni.JObjType<Headers_Builder> {
  const $Headers_BuilderType();

  @override
  String get signature => r'Lokhttp3/Headers$Builder;';

  @override
  Headers_Builder fromReference(jni.JReference reference) =>
      Headers_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Headers_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Headers_BuilderType) &&
        other is $Headers_BuilderType;
  }
}

/// from: okhttp3.Headers$Companion
class Headers_Companion extends jni.JObject {
  @override
  late final jni.JObjType<Headers_Companion> $type = type;

  Headers_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Headers$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $Headers_CompanionType();
  static final _id_of = _class.instanceMethodId(
    r'of',
    r'([Ljava/lang/String;)Lokhttp3/Headers;',
  );

  static final _of = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers of(java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  Headers of(
    jni.JArray<jni.JString> strings,
  ) {
    return _of(reference.pointer, _id_of as jni.JMethodIDPtr,
            strings.reference.pointer)
        .object(const $HeadersType());
  }

  static final _id_of1 = _class.instanceMethodId(
    r'of',
    r'(Ljava/util/Map;)Lokhttp3/Headers;',
  );

  static final _of1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers of(java.util.Map map)
  /// The returned object must be released after use, by calling the [release] method.
  Headers of1(
    jni.JMap<jni.JString, jni.JString> map,
  ) {
    return _of1(reference.pointer, _id_of1 as jni.JMethodIDPtr,
            map.reference.pointer)
        .object(const $HeadersType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Headers_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return Headers_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $Headers_CompanionType extends jni.JObjType<Headers_Companion> {
  const $Headers_CompanionType();

  @override
  String get signature => r'Lokhttp3/Headers$Companion;';

  @override
  Headers_Companion fromReference(jni.JReference reference) =>
      Headers_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Headers_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Headers_CompanionType) &&
        other is $Headers_CompanionType;
  }
}

/// from: okhttp3.Headers
class Headers extends jni.JObject {
  @override
  late final jni.JObjType<Headers> $type = type;

  Headers.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Headers');

  /// The type which includes information such as the signature of this class.
  static const type = $HeadersType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lokhttp3/Headers$Companion;',
  );

  /// from: static public final okhttp3.Headers$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static Headers_Companion get Companion =>
      _id_Companion.get(_class, const $Headers_CompanionType());

  static final _id_get0 = _class.instanceMethodId(
    r'get',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _get0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String get(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString get0(
    jni.JString string,
  ) {
    return _get0(reference.pointer, _id_get0 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_getDate = _class.instanceMethodId(
    r'getDate',
    r'(Ljava/lang/String;)Ljava/util/Date;',
  );

  static final _getDate = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.Date getDate(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDate(
    jni.JString string,
  ) {
    return _getDate(reference.pointer, _id_getDate as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_getInstant = _class.instanceMethodId(
    r'getInstant',
    r'(Ljava/lang/String;)Ljava/time/Instant;',
  );

  static final _getInstant = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.time.Instant getInstant(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getInstant(
    jni.JString string,
  ) {
    return _getInstant(reference.pointer, _id_getInstant as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int size()
  int size() {
    return _size(reference.pointer, _id_size as jni.JMethodIDPtr).integer;
  }

  static final _id_name = _class.instanceMethodId(
    r'name',
    r'(I)Ljava/lang/String;',
  );

  static final _name = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final java.lang.String name(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString name(
    int i,
  ) {
    return _name(reference.pointer, _id_name as jni.JMethodIDPtr, i)
        .object(const jni.JStringType());
  }

  static final _id_value = _class.instanceMethodId(
    r'value',
    r'(I)Ljava/lang/String;',
  );

  static final _value = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final java.lang.String value(int i)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString value(
    int i,
  ) {
    return _value(reference.pointer, _id_value as jni.JMethodIDPtr, i)
        .object(const jni.JStringType());
  }

  static final _id_names = _class.instanceMethodId(
    r'names',
    r'()Ljava/util/Set;',
  );

  static final _names = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.Set names()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JString> names() {
    return _names(reference.pointer, _id_names as jni.JMethodIDPtr)
        .object(const jni.JSetType(jni.JStringType()));
  }

  static final _id_values = _class.instanceMethodId(
    r'values',
    r'(Ljava/lang/String;)Ljava/util/List;',
  );

  static final _values = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.List values(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> values(
    jni.JString string,
  ) {
    return _values(reference.pointer, _id_values as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _id_byteCount = _class.instanceMethodId(
    r'byteCount',
    r'()J',
  );

  static final _byteCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long byteCount()
  int byteCount() {
    return _byteCount(reference.pointer, _id_byteCount as jni.JMethodIDPtr)
        .long;
  }

  static final _id_iterator = _class.instanceMethodId(
    r'iterator',
    r'()Ljava/util/Iterator;',
  );

  static final _iterator = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.util.Iterator iterator()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JIterator<jni.JObject> iterator() {
    return _iterator(reference.pointer, _id_iterator as jni.JMethodIDPtr)
        .object(const jni.JIteratorType(jni.JObjectType()));
  }

  static final _id_newBuilder = _class.instanceMethodId(
    r'newBuilder',
    r'()Lokhttp3/Headers$Builder;',
  );

  static final _newBuilder = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okhttp3.Headers$Builder newBuilder()
  /// The returned object must be released after use, by calling the [release] method.
  Headers_Builder newBuilder() {
    return _newBuilder(reference.pointer, _id_newBuilder as jni.JMethodIDPtr)
        .object(const $Headers_BuilderType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_toMultimap = _class.instanceMethodId(
    r'toMultimap',
    r'()Ljava/util/Map;',
  );

  static final _toMultimap = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.Map toMultimap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JMap<jni.JString, jni.JList<jni.JString>> toMultimap() {
    return _toMultimap(reference.pointer, _id_toMultimap as jni.JMethodIDPtr)
        .object(const jni.JMapType(
            jni.JStringType(), jni.JListType(jni.JStringType())));
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'([Ljava/lang/String;)Lokhttp3/Headers;',
  );

  static final _of = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.Headers of(java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  static Headers of(
    jni.JArray<jni.JString> strings,
  ) {
    return _of(_class.reference.pointer, _id_of as jni.JMethodIDPtr,
            strings.reference.pointer)
        .object(const $HeadersType());
  }

  static final _id_of1 = _class.staticMethodId(
    r'of',
    r'(Ljava/util/Map;)Lokhttp3/Headers;',
  );

  static final _of1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okhttp3.Headers of(java.util.Map map)
  /// The returned object must be released after use, by calling the [release] method.
  static Headers of1(
    jni.JMap<jni.JString, jni.JString> map,
  ) {
    return _of1(_class.reference.pointer, _id_of1 as jni.JMethodIDPtr,
            map.reference.pointer)
        .object(const $HeadersType());
  }

  static final _id_new0 = _class.constructorId(
    r'([Ljava/lang/String;Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String[] strings, kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Headers(
    jni.JArray<jni.JString> strings,
    jni.JObject defaultConstructorMarker,
  ) {
    return Headers.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            strings.reference.pointer,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $HeadersType extends jni.JObjType<Headers> {
  const $HeadersType();

  @override
  String get signature => r'Lokhttp3/Headers;';

  @override
  Headers fromReference(jni.JReference reference) =>
      Headers.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($HeadersType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($HeadersType) && other is $HeadersType;
  }
}

/// from: okhttp3.Callback
class Callback extends jni.JObject {
  @override
  late final jni.JObjType<Callback> $type = type;

  Callback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Callback');

  /// The type which includes information such as the signature of this class.
  static const type = $CallbackType();
  static final _id_onFailure = _class.instanceMethodId(
    r'onFailure',
    r'(Lokhttp3/Call;Ljava/io/IOException;)V',
  );

  static final _onFailure = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onFailure(okhttp3.Call call, java.io.IOException iOException)
  void onFailure(
    Call call,
    jni.JObject iOException,
  ) {
    _onFailure(reference.pointer, _id_onFailure as jni.JMethodIDPtr,
            call.reference.pointer, iOException.reference.pointer)
        .check();
  }

  static final _id_onResponse = _class.instanceMethodId(
    r'onResponse',
    r'(Lokhttp3/Call;Lokhttp3/Response;)V',
  );

  static final _onResponse = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onResponse(okhttp3.Call call, okhttp3.Response response)
  void onResponse(
    Call call,
    Response response,
  ) {
    _onResponse(reference.pointer, _id_onResponse as jni.JMethodIDPtr,
            call.reference.pointer, response.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $CallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onFailure(Lokhttp3/Call;Ljava/io/IOException;)V') {
        _$impls[$p]!.onFailure(
          $a[0].castTo(const $CallType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onResponse(Lokhttp3/Call;Lokhttp3/Response;)V') {
        _$impls[$p]!.onResponse(
          $a[0].castTo(const $CallType(), releaseOriginal: true),
          $a[1].castTo(const $ResponseType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory Callback.implement(
    $CallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Callback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'okhttp3.Callback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $CallbackImpl {
  factory $CallbackImpl({
    required void Function(Call call, jni.JObject iOException) onFailure,
    required void Function(Call call, Response response) onResponse,
  }) = _$CallbackImpl;

  void onFailure(Call call, jni.JObject iOException);
  void onResponse(Call call, Response response);
}

class _$CallbackImpl implements $CallbackImpl {
  _$CallbackImpl({
    required void Function(Call call, jni.JObject iOException) onFailure,
    required void Function(Call call, Response response) onResponse,
  })  : _onFailure = onFailure,
        _onResponse = onResponse;

  final void Function(Call call, jni.JObject iOException) _onFailure;
  final void Function(Call call, Response response) _onResponse;

  void onFailure(Call call, jni.JObject iOException) {
    return _onFailure(call, iOException);
  }

  void onResponse(Call call, Response response) {
    return _onResponse(call, response);
  }
}

final class $CallbackType extends jni.JObjType<Callback> {
  const $CallbackType();

  @override
  String get signature => r'Lokhttp3/Callback;';

  @override
  Callback fromReference(jni.JReference reference) =>
      Callback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CallbackType) && other is $CallbackType;
  }
}

/// from: okhttp3.ConnectionPool
class ConnectionPool extends jni.JObject {
  @override
  late final jni.JObjType<ConnectionPool> $type = type;

  ConnectionPool.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/ConnectionPool');

  /// The type which includes information such as the signature of this class.
  static const type = $ConnectionPoolType();
  static final _id_new0 = _class.constructorId(
    r'(Lokhttp3/internal/connection/RealConnectionPool;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(okhttp3.internal.connection.RealConnectionPool realConnectionPool)
  /// The returned object must be released after use, by calling the [release] method.
  factory ConnectionPool(
    jni.JObject realConnectionPool,
  ) {
    return ConnectionPool.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, realConnectionPool.reference.pointer)
        .reference);
  }

  static final _id_new1 = _class.constructorId(
    r'(IJLjava/util/concurrent/TimeUnit;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  factory ConnectionPool.new1(
    int i,
    int j,
    TimeUnit timeUnit,
  ) {
    return ConnectionPool.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, i, j, timeUnit.reference.pointer)
        .reference);
  }

  static final _id_new2 = _class.constructorId(
    r'()V',
  );

  static final _new2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory ConnectionPool.new2() {
    return ConnectionPool.fromReference(
        _new2(_class.reference.pointer, _id_new2 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_idleConnectionCount = _class.instanceMethodId(
    r'idleConnectionCount',
    r'()I',
  );

  static final _idleConnectionCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int idleConnectionCount()
  int idleConnectionCount() {
    return _idleConnectionCount(
            reference.pointer, _id_idleConnectionCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_connectionCount = _class.instanceMethodId(
    r'connectionCount',
    r'()I',
  );

  static final _connectionCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int connectionCount()
  int connectionCount() {
    return _connectionCount(
            reference.pointer, _id_connectionCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_evictAll = _class.instanceMethodId(
    r'evictAll',
    r'()V',
  );

  static final _evictAll = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void evictAll()
  void evictAll() {
    _evictAll(reference.pointer, _id_evictAll as jni.JMethodIDPtr).check();
  }
}

final class $ConnectionPoolType extends jni.JObjType<ConnectionPool> {
  const $ConnectionPoolType();

  @override
  String get signature => r'Lokhttp3/ConnectionPool;';

  @override
  ConnectionPool fromReference(jni.JReference reference) =>
      ConnectionPool.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ConnectionPoolType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ConnectionPoolType) &&
        other is $ConnectionPoolType;
  }
}

/// from: okhttp3.Dispatcher
class Dispatcher extends jni.JObject {
  @override
  late final jni.JObjType<Dispatcher> $type = type;

  Dispatcher.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Dispatcher');

  /// The type which includes information such as the signature of this class.
  static const type = $DispatcherType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Dispatcher() {
    return Dispatcher.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_getMaxRequests = _class.instanceMethodId(
    r'getMaxRequests',
    r'()I',
  );

  static final _getMaxRequests = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int getMaxRequests()
  int getMaxRequests() {
    return _getMaxRequests(
            reference.pointer, _id_getMaxRequests as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setMaxRequests = _class.instanceMethodId(
    r'setMaxRequests',
    r'(I)V',
  );

  static final _setMaxRequests = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setMaxRequests(int i)
  void setMaxRequests(
    int i,
  ) {
    _setMaxRequests(
            reference.pointer, _id_setMaxRequests as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getMaxRequestsPerHost = _class.instanceMethodId(
    r'getMaxRequestsPerHost',
    r'()I',
  );

  static final _getMaxRequestsPerHost = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int getMaxRequestsPerHost()
  int getMaxRequestsPerHost() {
    return _getMaxRequestsPerHost(
            reference.pointer, _id_getMaxRequestsPerHost as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_setMaxRequestsPerHost = _class.instanceMethodId(
    r'setMaxRequestsPerHost',
    r'(I)V',
  );

  static final _setMaxRequestsPerHost = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final void setMaxRequestsPerHost(int i)
  void setMaxRequestsPerHost(
    int i,
  ) {
    _setMaxRequestsPerHost(
            reference.pointer, _id_setMaxRequestsPerHost as jni.JMethodIDPtr, i)
        .check();
  }

  static final _id_getIdleCallback = _class.instanceMethodId(
    r'getIdleCallback',
    r'()Ljava/lang/Runnable;',
  );

  static final _getIdleCallback = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.lang.Runnable getIdleCallback()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getIdleCallback() {
    return _getIdleCallback(
            reference.pointer, _id_getIdleCallback as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_setIdleCallback = _class.instanceMethodId(
    r'setIdleCallback',
    r'(Ljava/lang/Runnable;)V',
  );

  static final _setIdleCallback = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final void setIdleCallback(java.lang.Runnable runnable)
  void setIdleCallback(
    jni.JObject runnable,
  ) {
    _setIdleCallback(reference.pointer, _id_setIdleCallback as jni.JMethodIDPtr,
            runnable.reference.pointer)
        .check();
  }

  static final _id_executorService = _class.instanceMethodId(
    r'executorService',
    r'()Ljava/util/concurrent/ExecutorService;',
  );

  static final _executorService = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.concurrent.ExecutorService executorService()
  /// The returned object must be released after use, by calling the [release] method.
  ExecutorService executorService() {
    return _executorService(
            reference.pointer, _id_executorService as jni.JMethodIDPtr)
        .object(const $ExecutorServiceType());
  }

  static final _id_new1 = _class.constructorId(
    r'(Ljava/util/concurrent/ExecutorService;)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.util.concurrent.ExecutorService executorService)
  /// The returned object must be released after use, by calling the [release] method.
  factory Dispatcher.new1(
    ExecutorService executorService,
  ) {
    return Dispatcher.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, executorService.reference.pointer)
        .reference);
  }

  static final _id_cancelAll = _class.instanceMethodId(
    r'cancelAll',
    r'()V',
  );

  static final _cancelAll = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void cancelAll()
  void cancelAll() {
    _cancelAll(reference.pointer, _id_cancelAll as jni.JMethodIDPtr).check();
  }

  static final _id_queuedCalls = _class.instanceMethodId(
    r'queuedCalls',
    r'()Ljava/util/List;',
  );

  static final _queuedCalls = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List queuedCalls()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Call> queuedCalls() {
    return _queuedCalls(reference.pointer, _id_queuedCalls as jni.JMethodIDPtr)
        .object(const jni.JListType($CallType()));
  }

  static final _id_runningCalls = _class.instanceMethodId(
    r'runningCalls',
    r'()Ljava/util/List;',
  );

  static final _runningCalls = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.List runningCalls()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Call> runningCalls() {
    return _runningCalls(
            reference.pointer, _id_runningCalls as jni.JMethodIDPtr)
        .object(const jni.JListType($CallType()));
  }

  static final _id_queuedCallsCount = _class.instanceMethodId(
    r'queuedCallsCount',
    r'()I',
  );

  static final _queuedCallsCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int queuedCallsCount()
  int queuedCallsCount() {
    return _queuedCallsCount(
            reference.pointer, _id_queuedCallsCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_runningCallsCount = _class.instanceMethodId(
    r'runningCallsCount',
    r'()I',
  );

  static final _runningCallsCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int runningCallsCount()
  int runningCallsCount() {
    return _runningCallsCount(
            reference.pointer, _id_runningCallsCount as jni.JMethodIDPtr)
        .integer;
  }
}

final class $DispatcherType extends jni.JObjType<Dispatcher> {
  const $DispatcherType();

  @override
  String get signature => r'Lokhttp3/Dispatcher;';

  @override
  Dispatcher fromReference(jni.JReference reference) =>
      Dispatcher.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($DispatcherType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($DispatcherType) && other is $DispatcherType;
  }
}

/// from: java.util.concurrent.ExecutorService
class ExecutorService extends jni.JObject {
  @override
  late final jni.JObjType<ExecutorService> $type = type;

  ExecutorService.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'java/util/concurrent/ExecutorService');

  /// The type which includes information such as the signature of this class.
  static const type = $ExecutorServiceType();
  static final _id_shutdown = _class.instanceMethodId(
    r'shutdown',
    r'()V',
  );

  static final _shutdown = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void shutdown()
  void shutdown() {
    _shutdown(reference.pointer, _id_shutdown as jni.JMethodIDPtr).check();
  }

  static final _id_shutdownNow = _class.instanceMethodId(
    r'shutdownNow',
    r'()Ljava/util/List;',
  );

  static final _shutdownNow = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract java.util.List shutdownNow()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JObject> shutdownNow() {
    return _shutdownNow(reference.pointer, _id_shutdownNow as jni.JMethodIDPtr)
        .object(const jni.JListType(jni.JObjectType()));
  }

  static final _id_isShutdown = _class.instanceMethodId(
    r'isShutdown',
    r'()Z',
  );

  static final _isShutdown = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isShutdown()
  bool isShutdown() {
    return _isShutdown(reference.pointer, _id_isShutdown as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_isTerminated = _class.instanceMethodId(
    r'isTerminated',
    r'()Z',
  );

  static final _isTerminated = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract boolean isTerminated()
  bool isTerminated() {
    return _isTerminated(
            reference.pointer, _id_isTerminated as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_awaitTermination = _class.instanceMethodId(
    r'awaitTermination',
    r'(JLjava/util/concurrent/TimeUnit;)Z',
  );

  static final _awaitTermination = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean awaitTermination(long j, java.util.concurrent.TimeUnit timeUnit)
  bool awaitTermination(
    int j,
    TimeUnit timeUnit,
  ) {
    return _awaitTermination(
            reference.pointer,
            _id_awaitTermination as jni.JMethodIDPtr,
            j,
            timeUnit.reference.pointer)
        .boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ExecutorServiceImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'shutdown()V') {
        _$impls[$p]!.shutdown();
        return jni.nullptr;
      }
      if ($d == r'shutdownNow()Ljava/util/List;') {
        final $r = _$impls[$p]!.shutdownNow();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'isShutdown()Z') {
        final $r = _$impls[$p]!.isShutdown();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'isTerminated()Z') {
        final $r = _$impls[$p]!.isTerminated();
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'awaitTermination(JLjava/util/concurrent/TimeUnit;)Z') {
        final $r = _$impls[$p]!.awaitTermination(
          $a[0]
              .castTo(const jni.JLongType(), releaseOriginal: true)
              .longValue(releaseOriginal: true),
          $a[1].castTo(const $TimeUnitType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory ExecutorService.implement(
    $ExecutorServiceImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ExecutorService.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'java.util.concurrent.ExecutorService',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ExecutorServiceImpl {
  factory $ExecutorServiceImpl({
    required void Function() shutdown,
    required jni.JList<jni.JObject> Function() shutdownNow,
    required bool Function() isShutdown,
    required bool Function() isTerminated,
    required bool Function(int j, TimeUnit timeUnit) awaitTermination,
  }) = _$ExecutorServiceImpl;

  void shutdown();
  jni.JList<jni.JObject> shutdownNow();
  bool isShutdown();
  bool isTerminated();
  bool awaitTermination(int j, TimeUnit timeUnit);
}

class _$ExecutorServiceImpl implements $ExecutorServiceImpl {
  _$ExecutorServiceImpl({
    required void Function() shutdown,
    required jni.JList<jni.JObject> Function() shutdownNow,
    required bool Function() isShutdown,
    required bool Function() isTerminated,
    required bool Function(int j, TimeUnit timeUnit) awaitTermination,
  })  : _shutdown = shutdown,
        _shutdownNow = shutdownNow,
        _isShutdown = isShutdown,
        _isTerminated = isTerminated,
        _awaitTermination = awaitTermination;

  final void Function() _shutdown;
  final jni.JList<jni.JObject> Function() _shutdownNow;
  final bool Function() _isShutdown;
  final bool Function() _isTerminated;
  final bool Function(int j, TimeUnit timeUnit) _awaitTermination;

  void shutdown() {
    return _shutdown();
  }

  jni.JList<jni.JObject> shutdownNow() {
    return _shutdownNow();
  }

  bool isShutdown() {
    return _isShutdown();
  }

  bool isTerminated() {
    return _isTerminated();
  }

  bool awaitTermination(int j, TimeUnit timeUnit) {
    return _awaitTermination(j, timeUnit);
  }
}

final class $ExecutorServiceType extends jni.JObjType<ExecutorService> {
  const $ExecutorServiceType();

  @override
  String get signature => r'Ljava/util/concurrent/ExecutorService;';

  @override
  ExecutorService fromReference(jni.JReference reference) =>
      ExecutorService.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExecutorServiceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExecutorServiceType) &&
        other is $ExecutorServiceType;
  }
}

/// from: okhttp3.Cache$Companion
class Cache_Companion extends jni.JObject {
  @override
  late final jni.JObjType<Cache_Companion> $type = type;

  Cache_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Cache$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $Cache_CompanionType();
  static final _id_key = _class.instanceMethodId(
    r'key',
    r'(Lokhttp3/HttpUrl;)Ljava/lang/String;',
  );

  static final _key = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final java.lang.String key(okhttp3.HttpUrl httpUrl)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString key(
    jni.JObject httpUrl,
  ) {
    return _key(reference.pointer, _id_key as jni.JMethodIDPtr,
            httpUrl.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_varyMatches = _class.instanceMethodId(
    r'varyMatches',
    r'(Lokhttp3/Response;Lokhttp3/Headers;Lokhttp3/Request;)Z',
  );

  static final _varyMatches = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean varyMatches(okhttp3.Response response, okhttp3.Headers headers, okhttp3.Request request)
  bool varyMatches(
    Response response,
    Headers headers,
    Request request,
  ) {
    return _varyMatches(
            reference.pointer,
            _id_varyMatches as jni.JMethodIDPtr,
            response.reference.pointer,
            headers.reference.pointer,
            request.reference.pointer)
        .boolean;
  }

  static final _id_hasVaryAll = _class.instanceMethodId(
    r'hasVaryAll',
    r'(Lokhttp3/Response;)Z',
  );

  static final _hasVaryAll = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean hasVaryAll(okhttp3.Response response)
  bool hasVaryAll(
    Response response,
  ) {
    return _hasVaryAll(reference.pointer, _id_hasVaryAll as jni.JMethodIDPtr,
            response.reference.pointer)
        .boolean;
  }

  static final _id_varyHeaders = _class.instanceMethodId(
    r'varyHeaders',
    r'(Lokhttp3/Response;)Lokhttp3/Headers;',
  );

  static final _varyHeaders = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.Headers varyHeaders(okhttp3.Response response)
  /// The returned object must be released after use, by calling the [release] method.
  Headers varyHeaders(
    Response response,
  ) {
    return _varyHeaders(reference.pointer, _id_varyHeaders as jni.JMethodIDPtr,
            response.reference.pointer)
        .object(const $HeadersType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Cache_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return Cache_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $Cache_CompanionType extends jni.JObjType<Cache_Companion> {
  const $Cache_CompanionType();

  @override
  String get signature => r'Lokhttp3/Cache$Companion;';

  @override
  Cache_Companion fromReference(jni.JReference reference) =>
      Cache_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Cache_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Cache_CompanionType) &&
        other is $Cache_CompanionType;
  }
}

/// from: okhttp3.Cache$Entry$Companion
class Cache_Entry_Companion extends jni.JObject {
  @override
  late final jni.JObjType<Cache_Entry_Companion> $type = type;

  Cache_Entry_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Cache$Entry$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $Cache_Entry_CompanionType();
  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory Cache_Entry_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return Cache_Entry_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $Cache_Entry_CompanionType
    extends jni.JObjType<Cache_Entry_Companion> {
  const $Cache_Entry_CompanionType();

  @override
  String get signature => r'Lokhttp3/Cache$Entry$Companion;';

  @override
  Cache_Entry_Companion fromReference(jni.JReference reference) =>
      Cache_Entry_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Cache_Entry_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Cache_Entry_CompanionType) &&
        other is $Cache_Entry_CompanionType;
  }
}

/// from: okhttp3.Cache
class Cache extends jni.JObject {
  @override
  late final jni.JObjType<Cache> $type = type;

  Cache.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/Cache');

  /// The type which includes information such as the signature of this class.
  static const type = $CacheType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lokhttp3/Cache$Companion;',
  );

  /// from: static public final okhttp3.Cache$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static Cache_Companion get Companion =>
      _id_Companion.get(_class, const $Cache_CompanionType());

  static final _id_new0 = _class.constructorId(
    r'(Ljava/io/File;JLokhttp3/internal/io/FileSystem;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Int64,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.io.File file, long j, okhttp3.internal.io.FileSystem fileSystem)
  /// The returned object must be released after use, by calling the [release] method.
  factory Cache(
    jni.JObject file,
    int j,
    jni.JObject fileSystem,
  ) {
    return Cache.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            file.reference.pointer,
            j,
            fileSystem.reference.pointer)
        .reference);
  }

  static final _id_isClosed = _class.instanceMethodId(
    r'isClosed',
    r'()Z',
  );

  static final _isClosed = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final boolean isClosed()
  bool isClosed() {
    return _isClosed(reference.pointer, _id_isClosed as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_new1 = _class.constructorId(
    r'(Ljava/io/File;J)V',
  );

  static final _new1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.io.File file, long j)
  /// The returned object must be released after use, by calling the [release] method.
  factory Cache.new1(
    jni.JObject file,
    int j,
  ) {
    return Cache.fromReference(_new1(_class.reference.pointer,
            _id_new1 as jni.JMethodIDPtr, file.reference.pointer, j)
        .reference);
  }

  static final _id_initialize = _class.instanceMethodId(
    r'initialize',
    r'()V',
  );

  static final _initialize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void initialize()
  void initialize() {
    _initialize(reference.pointer, _id_initialize as jni.JMethodIDPtr).check();
  }

  static final _id_delete = _class.instanceMethodId(
    r'delete',
    r'()V',
  );

  static final _delete = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void delete()
  void delete() {
    _delete(reference.pointer, _id_delete as jni.JMethodIDPtr).check();
  }

  static final _id_evictAll = _class.instanceMethodId(
    r'evictAll',
    r'()V',
  );

  static final _evictAll = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void evictAll()
  void evictAll() {
    _evictAll(reference.pointer, _id_evictAll as jni.JMethodIDPtr).check();
  }

  static final _id_urls = _class.instanceMethodId(
    r'urls',
    r'()Ljava/util/Iterator;',
  );

  static final _urls = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.util.Iterator urls()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JIterator<jni.JString> urls() {
    return _urls(reference.pointer, _id_urls as jni.JMethodIDPtr)
        .object(const jni.JIteratorType(jni.JStringType()));
  }

  static final _id_writeAbortCount = _class.instanceMethodId(
    r'writeAbortCount',
    r'()I',
  );

  static final _writeAbortCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int writeAbortCount()
  int writeAbortCount() {
    return _writeAbortCount(
            reference.pointer, _id_writeAbortCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_writeSuccessCount = _class.instanceMethodId(
    r'writeSuccessCount',
    r'()I',
  );

  static final _writeSuccessCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int writeSuccessCount()
  int writeSuccessCount() {
    return _writeSuccessCount(
            reference.pointer, _id_writeSuccessCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()J',
  );

  static final _size = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long size()
  int size() {
    return _size(reference.pointer, _id_size as jni.JMethodIDPtr).long;
  }

  static final _id_maxSize = _class.instanceMethodId(
    r'maxSize',
    r'()J',
  );

  static final _maxSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final long maxSize()
  int maxSize() {
    return _maxSize(reference.pointer, _id_maxSize as jni.JMethodIDPtr).long;
  }

  static final _id_flush = _class.instanceMethodId(
    r'flush',
    r'()V',
  );

  static final _flush = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void flush()
  void flush() {
    _flush(reference.pointer, _id_flush as jni.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'()V',
  );

  static final _close = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void close()
  void close() {
    _close(reference.pointer, _id_close as jni.JMethodIDPtr).check();
  }

  static final _id_directory = _class.instanceMethodId(
    r'directory',
    r'()Ljava/io/File;',
  );

  static final _directory = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final java.io.File directory()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject directory() {
    return _directory(reference.pointer, _id_directory as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_networkCount = _class.instanceMethodId(
    r'networkCount',
    r'()I',
  );

  static final _networkCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int networkCount()
  int networkCount() {
    return _networkCount(
            reference.pointer, _id_networkCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_hitCount = _class.instanceMethodId(
    r'hitCount',
    r'()I',
  );

  static final _hitCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int hitCount()
  int hitCount() {
    return _hitCount(reference.pointer, _id_hitCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_requestCount = _class.instanceMethodId(
    r'requestCount',
    r'()I',
  );

  static final _requestCount = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int requestCount()
  int requestCount() {
    return _requestCount(
            reference.pointer, _id_requestCount as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_key = _class.staticMethodId(
    r'key',
    r'(Lokhttp3/HttpUrl;)Ljava/lang/String;',
  );

  static final _key = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final java.lang.String key(okhttp3.HttpUrl httpUrl)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString key(
    jni.JObject httpUrl,
  ) {
    return _key(_class.reference.pointer, _id_key as jni.JMethodIDPtr,
            httpUrl.reference.pointer)
        .object(const jni.JStringType());
  }
}

final class $CacheType extends jni.JObjType<Cache> {
  const $CacheType();

  @override
  String get signature => r'Lokhttp3/Cache;';

  @override
  Cache fromReference(jni.JReference reference) =>
      Cache.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($CacheType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($CacheType) && other is $CacheType;
  }
}

/// from: com.example.ok_http.RedirectReceivedCallback
class RedirectReceivedCallback extends jni.JObject {
  @override
  late final jni.JObjType<RedirectReceivedCallback> $type = type;

  RedirectReceivedCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/example/ok_http/RedirectReceivedCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $RedirectReceivedCallbackType();
  static final _id_onRedirectReceived = _class.instanceMethodId(
    r'onRedirectReceived',
    r'(Lokhttp3/Response;Ljava/lang/String;)V',
  );

  static final _onRedirectReceived = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onRedirectReceived(okhttp3.Response response, java.lang.String string)
  void onRedirectReceived(
    Response response,
    jni.JString string,
  ) {
    _onRedirectReceived(
            reference.pointer,
            _id_onRedirectReceived as jni.JMethodIDPtr,
            response.reference.pointer,
            string.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $RedirectReceivedCallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onRedirectReceived(Lokhttp3/Response;Ljava/lang/String;)V') {
        _$impls[$p]!.onRedirectReceived(
          $a[0].castTo(const $ResponseType(), releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory RedirectReceivedCallback.implement(
    $RedirectReceivedCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = RedirectReceivedCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.example.ok_http.RedirectReceivedCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $RedirectReceivedCallbackImpl {
  factory $RedirectReceivedCallbackImpl({
    required void Function(Response response, jni.JString string)
        onRedirectReceived,
  }) = _$RedirectReceivedCallbackImpl;

  void onRedirectReceived(Response response, jni.JString string);
}

class _$RedirectReceivedCallbackImpl implements $RedirectReceivedCallbackImpl {
  _$RedirectReceivedCallbackImpl({
    required void Function(Response response, jni.JString string)
        onRedirectReceived,
  }) : _onRedirectReceived = onRedirectReceived;

  final void Function(Response response, jni.JString string)
      _onRedirectReceived;

  void onRedirectReceived(Response response, jni.JString string) {
    return _onRedirectReceived(response, string);
  }
}

final class $RedirectReceivedCallbackType
    extends jni.JObjType<RedirectReceivedCallback> {
  const $RedirectReceivedCallbackType();

  @override
  String get signature => r'Lcom/example/ok_http/RedirectReceivedCallback;';

  @override
  RedirectReceivedCallback fromReference(jni.JReference reference) =>
      RedirectReceivedCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RedirectReceivedCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RedirectReceivedCallbackType) &&
        other is $RedirectReceivedCallbackType;
  }
}

/// from: com.example.ok_http.RedirectInterceptor$Companion
class RedirectInterceptor_Companion extends jni.JObject {
  @override
  late final jni.JObjType<RedirectInterceptor_Companion> $type = type;

  RedirectInterceptor_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/example/ok_http/RedirectInterceptor$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $RedirectInterceptor_CompanionType();
  static final _id_addRedirectInterceptor = _class.instanceMethodId(
    r'addRedirectInterceptor',
    r'(Lokhttp3/OkHttpClient$Builder;IZLcom/example/ok_http/RedirectReceivedCallback;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _addRedirectInterceptor = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder addRedirectInterceptor(okhttp3.OkHttpClient$Builder builder, int i, boolean z, com.example.ok_http.RedirectReceivedCallback redirectReceivedCallback)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addRedirectInterceptor(
    OkHttpClient_Builder builder,
    int i,
    bool z,
    RedirectReceivedCallback redirectReceivedCallback,
  ) {
    return _addRedirectInterceptor(
            reference.pointer,
            _id_addRedirectInterceptor as jni.JMethodIDPtr,
            builder.reference.pointer,
            i,
            z ? 1 : 0,
            redirectReceivedCallback.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory RedirectInterceptor_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return RedirectInterceptor_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $RedirectInterceptor_CompanionType
    extends jni.JObjType<RedirectInterceptor_Companion> {
  const $RedirectInterceptor_CompanionType();

  @override
  String get signature =>
      r'Lcom/example/ok_http/RedirectInterceptor$Companion;';

  @override
  RedirectInterceptor_Companion fromReference(jni.JReference reference) =>
      RedirectInterceptor_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RedirectInterceptor_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RedirectInterceptor_CompanionType) &&
        other is $RedirectInterceptor_CompanionType;
  }
}

/// from: com.example.ok_http.RedirectInterceptor
class RedirectInterceptor extends jni.JObject {
  @override
  late final jni.JObjType<RedirectInterceptor> $type = type;

  RedirectInterceptor.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/example/ok_http/RedirectInterceptor');

  /// The type which includes information such as the signature of this class.
  static const type = $RedirectInterceptorType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lcom/example/ok_http/RedirectInterceptor$Companion;',
  );

  /// from: static public final com.example.ok_http.RedirectInterceptor$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static RedirectInterceptor_Companion get Companion =>
      _id_Companion.get(_class, const $RedirectInterceptor_CompanionType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory RedirectInterceptor() {
    return RedirectInterceptor.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $RedirectInterceptorType extends jni.JObjType<RedirectInterceptor> {
  const $RedirectInterceptorType();

  @override
  String get signature => r'Lcom/example/ok_http/RedirectInterceptor;';

  @override
  RedirectInterceptor fromReference(jni.JReference reference) =>
      RedirectInterceptor.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RedirectInterceptorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RedirectInterceptorType) &&
        other is $RedirectInterceptorType;
  }
}

/// from: com.example.ok_http.AsyncInputStreamReader
class AsyncInputStreamReader extends jni.JObject {
  @override
  late final jni.JObjType<AsyncInputStreamReader> $type = type;

  AsyncInputStreamReader.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/example/ok_http/AsyncInputStreamReader');

  /// The type which includes information such as the signature of this class.
  static const type = $AsyncInputStreamReaderType();
  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory AsyncInputStreamReader() {
    return AsyncInputStreamReader.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }

  static final _id_readAsync = _class.instanceMethodId(
    r'readAsync',
    r'(Ljava/io/InputStream;Lcom/example/ok_http/DataCallback;)Ljava/util/concurrent/Future;',
  );

  static final _readAsync = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.concurrent.Future readAsync(java.io.InputStream inputStream, com.example.ok_http.DataCallback dataCallback)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject readAsync(
    jni.JObject inputStream,
    DataCallback dataCallback,
  ) {
    return _readAsync(reference.pointer, _id_readAsync as jni.JMethodIDPtr,
            inputStream.reference.pointer, dataCallback.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _id_shutdown = _class.instanceMethodId(
    r'shutdown',
    r'()V',
  );

  static final _shutdown = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final void shutdown()
  void shutdown() {
    _shutdown(reference.pointer, _id_shutdown as jni.JMethodIDPtr).check();
  }
}

final class $AsyncInputStreamReaderType
    extends jni.JObjType<AsyncInputStreamReader> {
  const $AsyncInputStreamReaderType();

  @override
  String get signature => r'Lcom/example/ok_http/AsyncInputStreamReader;';

  @override
  AsyncInputStreamReader fromReference(jni.JReference reference) =>
      AsyncInputStreamReader.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($AsyncInputStreamReaderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($AsyncInputStreamReaderType) &&
        other is $AsyncInputStreamReaderType;
  }
}

/// from: com.example.ok_http.DataCallback
class DataCallback extends jni.JObject {
  @override
  late final jni.JObjType<DataCallback> $type = type;

  DataCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'com/example/ok_http/DataCallback');

  /// The type which includes information such as the signature of this class.
  static const type = $DataCallbackType();
  static final _id_onDataRead = _class.instanceMethodId(
    r'onDataRead',
    r'([B)V',
  );

  static final _onDataRead = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onDataRead(byte[] bs)
  void onDataRead(
    jni.JArray<jni.jbyte> bs,
  ) {
    _onDataRead(reference.pointer, _id_onDataRead as jni.JMethodIDPtr,
            bs.reference.pointer)
        .check();
  }

  static final _id_onFinished = _class.instanceMethodId(
    r'onFinished',
    r'()V',
  );

  static final _onFinished = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void onFinished()
  void onFinished() {
    _onFinished(reference.pointer, _id_onFinished as jni.JMethodIDPtr).check();
  }

  static final _id_onError = _class.instanceMethodId(
    r'onError',
    r'(Ljava/io/IOException;)V',
  );

  static final _onError = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onError(java.io.IOException iOException)
  void onError(
    jni.JObject iOException,
  ) {
    _onError(reference.pointer, _id_onError as jni.JMethodIDPtr,
            iOException.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $DataCallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onDataRead([B)V') {
        _$impls[$p]!.onDataRead(
          $a[0].castTo(const jni.JArrayType(jni.jbyteType()),
              releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onFinished()V') {
        _$impls[$p]!.onFinished();
        return jni.nullptr;
      }
      if ($d == r'onError(Ljava/io/IOException;)V') {
        _$impls[$p]!.onError(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory DataCallback.implement(
    $DataCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = DataCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.example.ok_http.DataCallback',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $DataCallbackImpl {
  factory $DataCallbackImpl({
    required void Function(jni.JArray<jni.jbyte> bs) onDataRead,
    required void Function() onFinished,
    required void Function(jni.JObject iOException) onError,
  }) = _$DataCallbackImpl;

  void onDataRead(jni.JArray<jni.jbyte> bs);
  void onFinished();
  void onError(jni.JObject iOException);
}

class _$DataCallbackImpl implements $DataCallbackImpl {
  _$DataCallbackImpl({
    required void Function(jni.JArray<jni.jbyte> bs) onDataRead,
    required void Function() onFinished,
    required void Function(jni.JObject iOException) onError,
  })  : _onDataRead = onDataRead,
        _onFinished = onFinished,
        _onError = onError;

  final void Function(jni.JArray<jni.jbyte> bs) _onDataRead;
  final void Function() _onFinished;
  final void Function(jni.JObject iOException) _onError;

  void onDataRead(jni.JArray<jni.jbyte> bs) {
    return _onDataRead(bs);
  }

  void onFinished() {
    return _onFinished();
  }

  void onError(jni.JObject iOException) {
    return _onError(iOException);
  }
}

final class $DataCallbackType extends jni.JObjType<DataCallback> {
  const $DataCallbackType();

  @override
  String get signature => r'Lcom/example/ok_http/DataCallback;';

  @override
  DataCallback fromReference(jni.JReference reference) =>
      DataCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($DataCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($DataCallbackType) &&
        other is $DataCallbackType;
  }
}

/// from: okhttp3.WebSocket$Factory
class WebSocket_Factory extends jni.JObject {
  @override
  late final jni.JObjType<WebSocket_Factory> $type = type;

  WebSocket_Factory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/WebSocket$Factory');

  /// The type which includes information such as the signature of this class.
  static const type = $WebSocket_FactoryType();
  static final _id_newWebSocket = _class.instanceMethodId(
    r'newWebSocket',
    r'(Lokhttp3/Request;Lokhttp3/WebSocketListener;)Lokhttp3/WebSocket;',
  );

  static final _newWebSocket = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract okhttp3.WebSocket newWebSocket(okhttp3.Request request, okhttp3.WebSocketListener webSocketListener)
  /// The returned object must be released after use, by calling the [release] method.
  WebSocket newWebSocket(
    Request request,
    jni.JObject webSocketListener,
  ) {
    return _newWebSocket(
            reference.pointer,
            _id_newWebSocket as jni.JMethodIDPtr,
            request.reference.pointer,
            webSocketListener.reference.pointer)
        .object(const $WebSocketType());
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $WebSocket_FactoryImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r'newWebSocket(Lokhttp3/Request;Lokhttp3/WebSocketListener;)Lokhttp3/WebSocket;') {
        final $r = _$impls[$p]!.newWebSocket(
          $a[0].castTo(const $RequestType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory WebSocket_Factory.implement(
    $WebSocket_FactoryImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = WebSocket_Factory.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'okhttp3.WebSocket$Factory',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $WebSocket_FactoryImpl {
  factory $WebSocket_FactoryImpl({
    required WebSocket Function(Request request, jni.JObject webSocketListener)
        newWebSocket,
  }) = _$WebSocket_FactoryImpl;

  WebSocket newWebSocket(Request request, jni.JObject webSocketListener);
}

class _$WebSocket_FactoryImpl implements $WebSocket_FactoryImpl {
  _$WebSocket_FactoryImpl({
    required WebSocket Function(Request request, jni.JObject webSocketListener)
        newWebSocket,
  }) : _newWebSocket = newWebSocket;

  final WebSocket Function(Request request, jni.JObject webSocketListener)
      _newWebSocket;

  WebSocket newWebSocket(Request request, jni.JObject webSocketListener) {
    return _newWebSocket(request, webSocketListener);
  }
}

final class $WebSocket_FactoryType extends jni.JObjType<WebSocket_Factory> {
  const $WebSocket_FactoryType();

  @override
  String get signature => r'Lokhttp3/WebSocket$Factory;';

  @override
  WebSocket_Factory fromReference(jni.JReference reference) =>
      WebSocket_Factory.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebSocket_FactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocket_FactoryType) &&
        other is $WebSocket_FactoryType;
  }
}

/// from: okhttp3.WebSocket
class WebSocket extends jni.JObject {
  @override
  late final jni.JObjType<WebSocket> $type = type;

  WebSocket.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okhttp3/WebSocket');

  /// The type which includes information such as the signature of this class.
  static const type = $WebSocketType();
  static final _id_request = _class.instanceMethodId(
    r'request',
    r'()Lokhttp3/Request;',
  );

  static final _request = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract okhttp3.Request request()
  /// The returned object must be released after use, by calling the [release] method.
  Request request() {
    return _request(reference.pointer, _id_request as jni.JMethodIDPtr)
        .object(const $RequestType());
  }

  static final _id_queueSize = _class.instanceMethodId(
    r'queueSize',
    r'()J',
  );

  static final _queueSize = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract long queueSize()
  int queueSize() {
    return _queueSize(reference.pointer, _id_queueSize as jni.JMethodIDPtr)
        .long;
  }

  static final _id_send = _class.instanceMethodId(
    r'send',
    r'(Ljava/lang/String;)Z',
  );

  static final _send = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean send(java.lang.String string)
  bool send(
    jni.JString string,
  ) {
    return _send(reference.pointer, _id_send as jni.JMethodIDPtr,
            string.reference.pointer)
        .boolean;
  }

  static final _id_send1 = _class.instanceMethodId(
    r'send',
    r'(Lokio/ByteString;)Z',
  );

  static final _send1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean send(okio.ByteString byteString)
  bool send1(
    ByteString byteString,
  ) {
    return _send1(reference.pointer, _id_send1 as jni.JMethodIDPtr,
            byteString.reference.pointer)
        .boolean;
  }

  static final _id_close = _class.instanceMethodId(
    r'close',
    r'(ILjava/lang/String;)Z',
  );

  static final _close = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<($Int32, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean close(int i, java.lang.String string)
  bool close(
    int i,
    jni.JString string,
  ) {
    return _close(reference.pointer, _id_close as jni.JMethodIDPtr, i,
            string.reference.pointer)
        .boolean;
  }

  static final _id_cancel = _class.instanceMethodId(
    r'cancel',
    r'()V',
  );

  static final _cancel = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public abstract void cancel()
  void cancel() {
    _cancel(reference.pointer, _id_cancel as jni.JMethodIDPtr).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $WebSocketImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'request()Lokhttp3/Request;') {
        final $r = _$impls[$p]!.request();
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r'queueSize()J') {
        final $r = _$impls[$p]!.queueSize();
        return jni.JLong($r).reference.toPointer();
      }
      if ($d == r'send(Ljava/lang/String;)Z') {
        final $r = _$impls[$p]!.send(
          $a[0].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'send(Lokio/ByteString;)Z') {
        final $r = _$impls[$p]!.send1(
          $a[0].castTo(const $ByteStringType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'close(ILjava/lang/String;)Z') {
        final $r = _$impls[$p]!.close(
          $a[0]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
      if ($d == r'cancel()V') {
        _$impls[$p]!.cancel();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory WebSocket.implement(
    $WebSocketImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = WebSocket.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'okhttp3.WebSocket',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $WebSocketImpl {
  factory $WebSocketImpl({
    required Request Function() request,
    required int Function() queueSize,
    required bool Function(jni.JString string) send,
    required bool Function(ByteString byteString) send1,
    required bool Function(int i, jni.JString string) close,
    required void Function() cancel,
  }) = _$WebSocketImpl;

  Request request();
  int queueSize();
  bool send(jni.JString string);
  bool send1(ByteString byteString);
  bool close(int i, jni.JString string);
  void cancel();
}

class _$WebSocketImpl implements $WebSocketImpl {
  _$WebSocketImpl({
    required Request Function() request,
    required int Function() queueSize,
    required bool Function(jni.JString string) send,
    required bool Function(ByteString byteString) send1,
    required bool Function(int i, jni.JString string) close,
    required void Function() cancel,
  })  : _request = request,
        _queueSize = queueSize,
        _send = send,
        _send1 = send1,
        _close = close,
        _cancel = cancel;

  final Request Function() _request;
  final int Function() _queueSize;
  final bool Function(jni.JString string) _send;
  final bool Function(ByteString byteString) _send1;
  final bool Function(int i, jni.JString string) _close;
  final void Function() _cancel;

  Request request() {
    return _request();
  }

  int queueSize() {
    return _queueSize();
  }

  bool send(jni.JString string) {
    return _send(string);
  }

  bool send1(ByteString byteString) {
    return _send1(byteString);
  }

  bool close(int i, jni.JString string) {
    return _close(i, string);
  }

  void cancel() {
    return _cancel();
  }
}

final class $WebSocketType extends jni.JObjType<WebSocket> {
  const $WebSocketType();

  @override
  String get signature => r'Lokhttp3/WebSocket;';

  @override
  WebSocket fromReference(jni.JReference reference) =>
      WebSocket.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebSocketType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocketType) && other is $WebSocketType;
  }
}

/// from: com.example.ok_http.WebSocketListenerProxy$WebSocketListener
class WebSocketListenerProxy_WebSocketListener extends jni.JObject {
  @override
  late final jni.JObjType<WebSocketListenerProxy_WebSocketListener> $type =
      type;

  WebSocketListenerProxy_WebSocketListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(
      r'com/example/ok_http/WebSocketListenerProxy$WebSocketListener');

  /// The type which includes information such as the signature of this class.
  static const type = $WebSocketListenerProxy_WebSocketListenerType();
  static final _id_onOpen = _class.instanceMethodId(
    r'onOpen',
    r'(Lokhttp3/WebSocket;Lokhttp3/Response;)V',
  );

  static final _onOpen = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onOpen(okhttp3.WebSocket webSocket, okhttp3.Response response)
  void onOpen(
    WebSocket webSocket,
    Response response,
  ) {
    _onOpen(reference.pointer, _id_onOpen as jni.JMethodIDPtr,
            webSocket.reference.pointer, response.reference.pointer)
        .check();
  }

  static final _id_onMessage = _class.instanceMethodId(
    r'onMessage',
    r'(Lokhttp3/WebSocket;Ljava/lang/String;)V',
  );

  static final _onMessage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onMessage(okhttp3.WebSocket webSocket, java.lang.String string)
  void onMessage(
    WebSocket webSocket,
    jni.JString string,
  ) {
    _onMessage(reference.pointer, _id_onMessage as jni.JMethodIDPtr,
            webSocket.reference.pointer, string.reference.pointer)
        .check();
  }

  static final _id_onMessage1 = _class.instanceMethodId(
    r'onMessage',
    r'(Lokhttp3/WebSocket;Lokio/ByteString;)V',
  );

  static final _onMessage1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onMessage(okhttp3.WebSocket webSocket, okio.ByteString byteString)
  void onMessage1(
    WebSocket webSocket,
    ByteString byteString,
  ) {
    _onMessage1(reference.pointer, _id_onMessage1 as jni.JMethodIDPtr,
            webSocket.reference.pointer, byteString.reference.pointer)
        .check();
  }

  static final _id_onClosing = _class.instanceMethodId(
    r'onClosing',
    r'(Lokhttp3/WebSocket;ILjava/lang/String;)V',
  );

  static final _onClosing = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onClosing(okhttp3.WebSocket webSocket, int i, java.lang.String string)
  void onClosing(
    WebSocket webSocket,
    int i,
    jni.JString string,
  ) {
    _onClosing(reference.pointer, _id_onClosing as jni.JMethodIDPtr,
            webSocket.reference.pointer, i, string.reference.pointer)
        .check();
  }

  static final _id_onFailure = _class.instanceMethodId(
    r'onFailure',
    r'(Lokhttp3/WebSocket;Ljava/lang/Throwable;Lokhttp3/Response;)V',
  );

  static final _onFailure = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onFailure(okhttp3.WebSocket webSocket, java.lang.Throwable throwable, okhttp3.Response response)
  void onFailure(
    WebSocket webSocket,
    jni.JObject throwable,
    Response response,
  ) {
    _onFailure(
            reference.pointer,
            _id_onFailure as jni.JMethodIDPtr,
            webSocket.reference.pointer,
            throwable.reference.pointer,
            response.reference.pointer)
        .check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $WebSocketListenerProxy_WebSocketListenerImpl> _$impls =
      {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r'onOpen(Lokhttp3/WebSocket;Lokhttp3/Response;)V') {
        _$impls[$p]!.onOpen(
          $a[0].castTo(const $WebSocketType(), releaseOriginal: true),
          $a[1].castTo(const $ResponseType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onMessage(Lokhttp3/WebSocket;Ljava/lang/String;)V') {
        _$impls[$p]!.onMessage(
          $a[0].castTo(const $WebSocketType(), releaseOriginal: true),
          $a[1].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onMessage(Lokhttp3/WebSocket;Lokio/ByteString;)V') {
        _$impls[$p]!.onMessage1(
          $a[0].castTo(const $WebSocketType(), releaseOriginal: true),
          $a[1].castTo(const $ByteStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d == r'onClosing(Lokhttp3/WebSocket;ILjava/lang/String;)V') {
        _$impls[$p]!.onClosing(
          $a[0].castTo(const $WebSocketType(), releaseOriginal: true),
          $a[1]
              .castTo(const jni.JIntegerType(), releaseOriginal: true)
              .intValue(releaseOriginal: true),
          $a[2].castTo(const jni.JStringType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
      if ($d ==
          r'onFailure(Lokhttp3/WebSocket;Ljava/lang/Throwable;Lokhttp3/Response;)V') {
        _$impls[$p]!.onFailure(
          $a[0].castTo(const $WebSocketType(), releaseOriginal: true),
          $a[1].castTo(const jni.JObjectType(), releaseOriginal: true),
          $a[2].castTo(const $ResponseType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e);
    }
    return jni.nullptr;
  }

  factory WebSocketListenerProxy_WebSocketListener.implement(
    $WebSocketListenerProxy_WebSocketListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = WebSocketListenerProxy_WebSocketListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r'com.example.ok_http.WebSocketListenerProxy$WebSocketListener',
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $WebSocketListenerProxy_WebSocketListenerImpl {
  factory $WebSocketListenerProxy_WebSocketListenerImpl({
    required void Function(WebSocket webSocket, Response response) onOpen,
    required void Function(WebSocket webSocket, jni.JString string) onMessage,
    required void Function(WebSocket webSocket, ByteString byteString)
        onMessage1,
    required void Function(WebSocket webSocket, int i, jni.JString string)
        onClosing,
    required void Function(
            WebSocket webSocket, jni.JObject throwable, Response response)
        onFailure,
  }) = _$WebSocketListenerProxy_WebSocketListenerImpl;

  void onOpen(WebSocket webSocket, Response response);
  void onMessage(WebSocket webSocket, jni.JString string);
  void onMessage1(WebSocket webSocket, ByteString byteString);
  void onClosing(WebSocket webSocket, int i, jni.JString string);
  void onFailure(WebSocket webSocket, jni.JObject throwable, Response response);
}

class _$WebSocketListenerProxy_WebSocketListenerImpl
    implements $WebSocketListenerProxy_WebSocketListenerImpl {
  _$WebSocketListenerProxy_WebSocketListenerImpl({
    required void Function(WebSocket webSocket, Response response) onOpen,
    required void Function(WebSocket webSocket, jni.JString string) onMessage,
    required void Function(WebSocket webSocket, ByteString byteString)
        onMessage1,
    required void Function(WebSocket webSocket, int i, jni.JString string)
        onClosing,
    required void Function(
            WebSocket webSocket, jni.JObject throwable, Response response)
        onFailure,
  })  : _onOpen = onOpen,
        _onMessage = onMessage,
        _onMessage1 = onMessage1,
        _onClosing = onClosing,
        _onFailure = onFailure;

  final void Function(WebSocket webSocket, Response response) _onOpen;
  final void Function(WebSocket webSocket, jni.JString string) _onMessage;
  final void Function(WebSocket webSocket, ByteString byteString) _onMessage1;
  final void Function(WebSocket webSocket, int i, jni.JString string)
      _onClosing;
  final void Function(
      WebSocket webSocket, jni.JObject throwable, Response response) _onFailure;

  void onOpen(WebSocket webSocket, Response response) {
    return _onOpen(webSocket, response);
  }

  void onMessage(WebSocket webSocket, jni.JString string) {
    return _onMessage(webSocket, string);
  }

  void onMessage1(WebSocket webSocket, ByteString byteString) {
    return _onMessage1(webSocket, byteString);
  }

  void onClosing(WebSocket webSocket, int i, jni.JString string) {
    return _onClosing(webSocket, i, string);
  }

  void onFailure(
      WebSocket webSocket, jni.JObject throwable, Response response) {
    return _onFailure(webSocket, throwable, response);
  }
}

final class $WebSocketListenerProxy_WebSocketListenerType
    extends jni.JObjType<WebSocketListenerProxy_WebSocketListener> {
  const $WebSocketListenerProxy_WebSocketListenerType();

  @override
  String get signature =>
      r'Lcom/example/ok_http/WebSocketListenerProxy$WebSocketListener;';

  @override
  WebSocketListenerProxy_WebSocketListener fromReference(
          jni.JReference reference) =>
      WebSocketListenerProxy_WebSocketListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebSocketListenerProxy_WebSocketListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType ==
            ($WebSocketListenerProxy_WebSocketListenerType) &&
        other is $WebSocketListenerProxy_WebSocketListenerType;
  }
}

/// from: com.example.ok_http.WebSocketListenerProxy
class WebSocketListenerProxy extends jni.JObject {
  @override
  late final jni.JObjType<WebSocketListenerProxy> $type = type;

  WebSocketListenerProxy.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/example/ok_http/WebSocketListenerProxy');

  /// The type which includes information such as the signature of this class.
  static const type = $WebSocketListenerProxyType();
  static final _id_new0 = _class.constructorId(
    r'(Lcom/example/ok_http/WebSocketListenerProxy$WebSocketListener;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.example.ok_http.WebSocketListenerProxy$WebSocketListener webSocketListener)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebSocketListenerProxy(
    WebSocketListenerProxy_WebSocketListener webSocketListener,
  ) {
    return WebSocketListenerProxy.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, webSocketListener.reference.pointer)
        .reference);
  }

  static final _id_onOpen = _class.instanceMethodId(
    r'onOpen',
    r'(Lokhttp3/WebSocket;Lokhttp3/Response;)V',
  );

  static final _onOpen = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onOpen(okhttp3.WebSocket webSocket, okhttp3.Response response)
  void onOpen(
    WebSocket webSocket,
    Response response,
  ) {
    _onOpen(reference.pointer, _id_onOpen as jni.JMethodIDPtr,
            webSocket.reference.pointer, response.reference.pointer)
        .check();
  }

  static final _id_onMessage = _class.instanceMethodId(
    r'onMessage',
    r'(Lokhttp3/WebSocket;Ljava/lang/String;)V',
  );

  static final _onMessage = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onMessage(okhttp3.WebSocket webSocket, java.lang.String string)
  void onMessage(
    WebSocket webSocket,
    jni.JString string,
  ) {
    _onMessage(reference.pointer, _id_onMessage as jni.JMethodIDPtr,
            webSocket.reference.pointer, string.reference.pointer)
        .check();
  }

  static final _id_onMessage1 = _class.instanceMethodId(
    r'onMessage',
    r'(Lokhttp3/WebSocket;Lokio/ByteString;)V',
  );

  static final _onMessage1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void onMessage(okhttp3.WebSocket webSocket, okio.ByteString byteString)
  void onMessage1(
    WebSocket webSocket,
    ByteString byteString,
  ) {
    _onMessage1(reference.pointer, _id_onMessage1 as jni.JMethodIDPtr,
            webSocket.reference.pointer, byteString.reference.pointer)
        .check();
  }

  static final _id_onClosing = _class.instanceMethodId(
    r'onClosing',
    r'(Lokhttp3/WebSocket;ILjava/lang/String;)V',
  );

  static final _onClosing = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void onClosing(okhttp3.WebSocket webSocket, int i, java.lang.String string)
  void onClosing(
    WebSocket webSocket,
    int i,
    jni.JString string,
  ) {
    _onClosing(reference.pointer, _id_onClosing as jni.JMethodIDPtr,
            webSocket.reference.pointer, i, string.reference.pointer)
        .check();
  }

  static final _id_onFailure = _class.instanceMethodId(
    r'onFailure',
    r'(Lokhttp3/WebSocket;Ljava/lang/Throwable;Lokhttp3/Response;)V',
  );

  static final _onFailure = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>,
              jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void onFailure(okhttp3.WebSocket webSocket, java.lang.Throwable throwable, okhttp3.Response response)
  void onFailure(
    WebSocket webSocket,
    jni.JObject throwable,
    Response response,
  ) {
    _onFailure(
            reference.pointer,
            _id_onFailure as jni.JMethodIDPtr,
            webSocket.reference.pointer,
            throwable.reference.pointer,
            response.reference.pointer)
        .check();
  }
}

final class $WebSocketListenerProxyType
    extends jni.JObjType<WebSocketListenerProxy> {
  const $WebSocketListenerProxyType();

  @override
  String get signature => r'Lcom/example/ok_http/WebSocketListenerProxy;';

  @override
  WebSocketListenerProxy fromReference(jni.JReference reference) =>
      WebSocketListenerProxy.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebSocketListenerProxyType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocketListenerProxyType) &&
        other is $WebSocketListenerProxyType;
  }
}

/// from: okio.ByteString$Companion
class ByteString_Companion extends jni.JObject {
  @override
  late final jni.JObjType<ByteString_Companion> $type = type;

  ByteString_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okio/ByteString$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $ByteString_CompanionType();
  static final _id_of = _class.instanceMethodId(
    r'of',
    r'([B)Lokio/ByteString;',
  );

  static final _of = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okio.ByteString of(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString of(
    jni.JArray<jni.jbyte> bs,
  ) {
    return _of(
            reference.pointer, _id_of as jni.JMethodIDPtr, bs.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_of1 = _class.instanceMethodId(
    r'of',
    r'([BII)Lokio/ByteString;',
  );

  static final _of1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final okio.ByteString of(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString of1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return _of1(reference.pointer, _id_of1 as jni.JMethodIDPtr,
            bs.reference.pointer, i, i1)
        .object(const $ByteStringType());
  }

  static final _id_of2 = _class.instanceMethodId(
    r'of',
    r'(Ljava/nio/ByteBuffer;)Lokio/ByteString;',
  );

  static final _of2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okio.ByteString of(java.nio.ByteBuffer byteBuffer)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString of2(
    jni.JByteBuffer byteBuffer,
  ) {
    return _of2(reference.pointer, _id_of2 as jni.JMethodIDPtr,
            byteBuffer.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_encodeUtf8 = _class.instanceMethodId(
    r'encodeUtf8',
    r'(Ljava/lang/String;)Lokio/ByteString;',
  );

  static final _encodeUtf8 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okio.ByteString encodeUtf8(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString encodeUtf8(
    jni.JString string,
  ) {
    return _encodeUtf8(reference.pointer, _id_encodeUtf8 as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_encodeString = _class.instanceMethodId(
    r'encodeString',
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/ByteString;',
  );

  static final _encodeString = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public final okio.ByteString encodeString(java.lang.String string, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString encodeString(
    jni.JString string,
    jni.JObject charset,
  ) {
    return _encodeString(
            reference.pointer,
            _id_encodeString as jni.JMethodIDPtr,
            string.reference.pointer,
            charset.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_decodeBase64 = _class.instanceMethodId(
    r'decodeBase64',
    r'(Ljava/lang/String;)Lokio/ByteString;',
  );

  static final _decodeBase64 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okio.ByteString decodeBase64(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString decodeBase64(
    jni.JString string,
  ) {
    return _decodeBase64(reference.pointer,
            _id_decodeBase64 as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_decodeHex = _class.instanceMethodId(
    r'decodeHex',
    r'(Ljava/lang/String;)Lokio/ByteString;',
  );

  static final _decodeHex = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okio.ByteString decodeHex(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString decodeHex(
    jni.JString string,
  ) {
    return _decodeHex(reference.pointer, _id_decodeHex as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_read = _class.instanceMethodId(
    r'read',
    r'(Ljava/io/InputStream;I)Lokio/ByteString;',
  );

  static final _read = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public final okio.ByteString read(java.io.InputStream inputStream, int i)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString read(
    jni.JObject inputStream,
    int i,
  ) {
    return _read(reference.pointer, _id_read as jni.JMethodIDPtr,
            inputStream.reference.pointer, i)
        .object(const $ByteStringType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteString_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return ByteString_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $ByteString_CompanionType
    extends jni.JObjType<ByteString_Companion> {
  const $ByteString_CompanionType();

  @override
  String get signature => r'Lokio/ByteString$Companion;';

  @override
  ByteString_Companion fromReference(jni.JReference reference) =>
      ByteString_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ByteString_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteString_CompanionType) &&
        other is $ByteString_CompanionType;
  }
}

/// from: okio.ByteString
class ByteString extends jni.JObject {
  @override
  late final jni.JObjType<ByteString> $type = type;

  ByteString.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'okio/ByteString');

  /// The type which includes information such as the signature of this class.
  static const type = $ByteStringType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lokio/ByteString$Companion;',
  );

  /// from: static public final okio.ByteString$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString_Companion get Companion =>
      _id_Companion.get(_class, const $ByteString_CompanionType());

  static final _id_EMPTY = _class.staticFieldId(
    r'EMPTY',
    r'Lokio/ByteString;',
  );

  /// from: static public final okio.ByteString EMPTY
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString get EMPTY => _id_EMPTY.get(_class, const $ByteStringType());

  static final _id_new0 = _class.constructorId(
    r'([B)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  factory ByteString(
    jni.JArray<jni.jbyte> bs,
  ) {
    return ByteString.fromReference(_new0(_class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr, bs.reference.pointer)
        .reference);
  }

  static final _id_utf8 = _class.instanceMethodId(
    r'utf8',
    r'()Ljava/lang/String;',
  );

  static final _utf8 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String utf8()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString utf8() {
    return _utf8(reference.pointer, _id_utf8 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_string = _class.instanceMethodId(
    r'string',
    r'(Ljava/nio/charset/Charset;)Ljava/lang/String;',
  );

  static final _string = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String string(java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString string(
    jni.JObject charset,
  ) {
    return _string(reference.pointer, _id_string as jni.JMethodIDPtr,
            charset.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _id_base64 = _class.instanceMethodId(
    r'base64',
    r'()Ljava/lang/String;',
  );

  static final _base64 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String base64()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString base64() {
    return _base64(reference.pointer, _id_base64 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_md5 = _class.instanceMethodId(
    r'md5',
    r'()Lokio/ByteString;',
  );

  static final _md5 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okio.ByteString md5()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString md5() {
    return _md5(reference.pointer, _id_md5 as jni.JMethodIDPtr)
        .object(const $ByteStringType());
  }

  static final _id_sha1 = _class.instanceMethodId(
    r'sha1',
    r'()Lokio/ByteString;',
  );

  static final _sha1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okio.ByteString sha1()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString sha1() {
    return _sha1(reference.pointer, _id_sha1 as jni.JMethodIDPtr)
        .object(const $ByteStringType());
  }

  static final _id_sha256 = _class.instanceMethodId(
    r'sha256',
    r'()Lokio/ByteString;',
  );

  static final _sha256 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okio.ByteString sha256()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString sha256() {
    return _sha256(reference.pointer, _id_sha256 as jni.JMethodIDPtr)
        .object(const $ByteStringType());
  }

  static final _id_sha512 = _class.instanceMethodId(
    r'sha512',
    r'()Lokio/ByteString;',
  );

  static final _sha512 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okio.ByteString sha512()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString sha512() {
    return _sha512(reference.pointer, _id_sha512 as jni.JMethodIDPtr)
        .object(const $ByteStringType());
  }

  static final _id_hmacSha1 = _class.instanceMethodId(
    r'hmacSha1',
    r'(Lokio/ByteString;)Lokio/ByteString;',
  );

  static final _hmacSha1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okio.ByteString hmacSha1(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hmacSha1(
    ByteString byteString,
  ) {
    return _hmacSha1(reference.pointer, _id_hmacSha1 as jni.JMethodIDPtr,
            byteString.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_hmacSha256 = _class.instanceMethodId(
    r'hmacSha256',
    r'(Lokio/ByteString;)Lokio/ByteString;',
  );

  static final _hmacSha256 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okio.ByteString hmacSha256(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hmacSha256(
    ByteString byteString,
  ) {
    return _hmacSha256(reference.pointer, _id_hmacSha256 as jni.JMethodIDPtr,
            byteString.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_hmacSha512 = _class.instanceMethodId(
    r'hmacSha512',
    r'(Lokio/ByteString;)Lokio/ByteString;',
  );

  static final _hmacSha512 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public okio.ByteString hmacSha512(okio.ByteString byteString)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString hmacSha512(
    ByteString byteString,
  ) {
    return _hmacSha512(reference.pointer, _id_hmacSha512 as jni.JMethodIDPtr,
            byteString.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_base64Url = _class.instanceMethodId(
    r'base64Url',
    r'()Ljava/lang/String;',
  );

  static final _base64Url = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String base64Url()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString base64Url() {
    return _base64Url(reference.pointer, _id_base64Url as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_hex = _class.instanceMethodId(
    r'hex',
    r'()Ljava/lang/String;',
  );

  static final _hex = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String hex()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString hex() {
    return _hex(reference.pointer, _id_hex as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_toAsciiLowercase = _class.instanceMethodId(
    r'toAsciiLowercase',
    r'()Lokio/ByteString;',
  );

  static final _toAsciiLowercase = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okio.ByteString toAsciiLowercase()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString toAsciiLowercase() {
    return _toAsciiLowercase(
            reference.pointer, _id_toAsciiLowercase as jni.JMethodIDPtr)
        .object(const $ByteStringType());
  }

  static final _id_toAsciiUppercase = _class.instanceMethodId(
    r'toAsciiUppercase',
    r'()Lokio/ByteString;',
  );

  static final _toAsciiUppercase = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public okio.ByteString toAsciiUppercase()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString toAsciiUppercase() {
    return _toAsciiUppercase(
            reference.pointer, _id_toAsciiUppercase as jni.JMethodIDPtr)
        .object(const $ByteStringType());
  }

  static final _id_substring = _class.instanceMethodId(
    r'substring',
    r'(II)Lokio/ByteString;',
  );

  static final _substring = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32, $Int32)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int, int)>();

  /// from: public okio.ByteString substring(int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString substring(
    int i,
    int i1,
  ) {
    return _substring(
            reference.pointer, _id_substring as jni.JMethodIDPtr, i, i1)
        .object(const $ByteStringType());
  }

  static final _id_getByte = _class.instanceMethodId(
    r'getByte',
    r'(I)B',
  );

  static final _getByte = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallByteMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final byte getByte(int i)
  int getByte(
    int i,
  ) {
    return _getByte(reference.pointer, _id_getByte as jni.JMethodIDPtr, i).byte;
  }

  static final _id_size = _class.instanceMethodId(
    r'size',
    r'()I',
  );

  static final _size = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final int size()
  int size() {
    return _size(reference.pointer, _id_size as jni.JMethodIDPtr).integer;
  }

  static final _id_toByteArray = _class.instanceMethodId(
    r'toByteArray',
    r'()[B',
  );

  static final _toByteArray = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public byte[] toByteArray()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> toByteArray() {
    return _toByteArray(reference.pointer, _id_toByteArray as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _id_asByteBuffer = _class.instanceMethodId(
    r'asByteBuffer',
    r'()Ljava/nio/ByteBuffer;',
  );

  static final _asByteBuffer = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.nio.ByteBuffer asByteBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JByteBuffer asByteBuffer() {
    return _asByteBuffer(
            reference.pointer, _id_asByteBuffer as jni.JMethodIDPtr)
        .object(const jni.JByteBufferType());
  }

  static final _id_write = _class.instanceMethodId(
    r'write',
    r'(Ljava/io/OutputStream;)V',
  );

  static final _write = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void write(java.io.OutputStream outputStream)
  void write(
    jni.JObject outputStream,
  ) {
    _write(reference.pointer, _id_write as jni.JMethodIDPtr,
            outputStream.reference.pointer)
        .check();
  }

  static final _id_rangeEquals = _class.instanceMethodId(
    r'rangeEquals',
    r'(ILokio/ByteString;II)Z',
  );

  static final _rangeEquals = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public boolean rangeEquals(int i, okio.ByteString byteString, int i1, int i2)
  bool rangeEquals(
    int i,
    ByteString byteString,
    int i1,
    int i2,
  ) {
    return _rangeEquals(reference.pointer, _id_rangeEquals as jni.JMethodIDPtr,
            i, byteString.reference.pointer, i1, i2)
        .boolean;
  }

  static final _id_rangeEquals1 = _class.instanceMethodId(
    r'rangeEquals',
    r'(I[BII)Z',
  );

  static final _rangeEquals1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public boolean rangeEquals(int i, byte[] bs, int i1, int i2)
  bool rangeEquals1(
    int i,
    jni.JArray<jni.jbyte> bs,
    int i1,
    int i2,
  ) {
    return _rangeEquals1(
            reference.pointer,
            _id_rangeEquals1 as jni.JMethodIDPtr,
            i,
            bs.reference.pointer,
            i1,
            i2)
        .boolean;
  }

  static final _id_copyInto = _class.instanceMethodId(
    r'copyInto',
    r'(I[BII)V',
  );

  static final _copyInto = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        $Int32,
                        ffi.Pointer<ffi.Void>,
                        $Int32,
                        $Int32
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              int, ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void copyInto(int i, byte[] bs, int i1, int i2)
  void copyInto(
    int i,
    jni.JArray<jni.jbyte> bs,
    int i1,
    int i2,
  ) {
    _copyInto(reference.pointer, _id_copyInto as jni.JMethodIDPtr, i,
            bs.reference.pointer, i1, i2)
        .check();
  }

  static final _id_startsWith = _class.instanceMethodId(
    r'startsWith',
    r'(Lokio/ByteString;)Z',
  );

  static final _startsWith = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean startsWith(okio.ByteString byteString)
  bool startsWith(
    ByteString byteString,
  ) {
    return _startsWith(reference.pointer, _id_startsWith as jni.JMethodIDPtr,
            byteString.reference.pointer)
        .boolean;
  }

  static final _id_startsWith1 = _class.instanceMethodId(
    r'startsWith',
    r'([B)Z',
  );

  static final _startsWith1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean startsWith(byte[] bs)
  bool startsWith1(
    jni.JArray<jni.jbyte> bs,
  ) {
    return _startsWith1(reference.pointer, _id_startsWith1 as jni.JMethodIDPtr,
            bs.reference.pointer)
        .boolean;
  }

  static final _id_endsWith = _class.instanceMethodId(
    r'endsWith',
    r'(Lokio/ByteString;)Z',
  );

  static final _endsWith = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean endsWith(okio.ByteString byteString)
  bool endsWith(
    ByteString byteString,
  ) {
    return _endsWith(reference.pointer, _id_endsWith as jni.JMethodIDPtr,
            byteString.reference.pointer)
        .boolean;
  }

  static final _id_endsWith1 = _class.instanceMethodId(
    r'endsWith',
    r'([B)Z',
  );

  static final _endsWith1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean endsWith(byte[] bs)
  bool endsWith1(
    jni.JArray<jni.jbyte> bs,
  ) {
    return _endsWith1(reference.pointer, _id_endsWith1 as jni.JMethodIDPtr,
            bs.reference.pointer)
        .boolean;
  }

  static final _id_indexOf = _class.instanceMethodId(
    r'indexOf',
    r'(Lokio/ByteString;I)I',
  );

  static final _indexOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public final int indexOf(okio.ByteString byteString, int i)
  int indexOf(
    ByteString byteString,
    int i,
  ) {
    return _indexOf(reference.pointer, _id_indexOf as jni.JMethodIDPtr,
            byteString.reference.pointer, i)
        .integer;
  }

  static final _id_indexOf1 = _class.instanceMethodId(
    r'indexOf',
    r'([BI)I',
  );

  static final _indexOf1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public int indexOf(byte[] bs, int i)
  int indexOf1(
    jni.JArray<jni.jbyte> bs,
    int i,
  ) {
    return _indexOf1(reference.pointer, _id_indexOf1 as jni.JMethodIDPtr,
            bs.reference.pointer, i)
        .integer;
  }

  static final _id_lastIndexOf = _class.instanceMethodId(
    r'lastIndexOf',
    r'(Lokio/ByteString;I)I',
  );

  static final _lastIndexOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public final int lastIndexOf(okio.ByteString byteString, int i)
  int lastIndexOf(
    ByteString byteString,
    int i,
  ) {
    return _lastIndexOf(reference.pointer, _id_lastIndexOf as jni.JMethodIDPtr,
            byteString.reference.pointer, i)
        .integer;
  }

  static final _id_lastIndexOf1 = _class.instanceMethodId(
    r'lastIndexOf',
    r'([BI)I',
  );

  static final _lastIndexOf1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public int lastIndexOf(byte[] bs, int i)
  int lastIndexOf1(
    jni.JArray<jni.jbyte> bs,
    int i,
  ) {
    return _lastIndexOf1(reference.pointer,
            _id_lastIndexOf1 as jni.JMethodIDPtr, bs.reference.pointer, i)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Lokio/ByteString;)I',
  );

  static final _compareTo = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(okio.ByteString byteString)
  int compareTo(
    ByteString byteString,
  ) {
    return _compareTo(reference.pointer, _id_compareTo as jni.JMethodIDPtr,
            byteString.reference.pointer)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_substring1 = _class.instanceMethodId(
    r'substring',
    r'(I)Lokio/ByteString;',
  );

  static final _substring1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public final okio.ByteString substring(int i)
  /// The returned object must be released after use, by calling the [release] method.
  ByteString substring1(
    int i,
  ) {
    return _substring1(reference.pointer, _id_substring1 as jni.JMethodIDPtr, i)
        .object(const $ByteStringType());
  }

  static final _id_substring2 = _class.instanceMethodId(
    r'substring',
    r'()Lokio/ByteString;',
  );

  static final _substring2 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public final okio.ByteString substring()
  /// The returned object must be released after use, by calling the [release] method.
  ByteString substring2() {
    return _substring2(reference.pointer, _id_substring2 as jni.JMethodIDPtr)
        .object(const $ByteStringType());
  }

  static final _id_indexOf2 = _class.instanceMethodId(
    r'indexOf',
    r'(Lokio/ByteString;)I',
  );

  static final _indexOf2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int indexOf(okio.ByteString byteString)
  int indexOf2(
    ByteString byteString,
  ) {
    return _indexOf2(reference.pointer, _id_indexOf2 as jni.JMethodIDPtr,
            byteString.reference.pointer)
        .integer;
  }

  static final _id_indexOf3 = _class.instanceMethodId(
    r'indexOf',
    r'([B)I',
  );

  static final _indexOf3 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int indexOf(byte[] bs)
  int indexOf3(
    jni.JArray<jni.jbyte> bs,
  ) {
    return _indexOf3(reference.pointer, _id_indexOf3 as jni.JMethodIDPtr,
            bs.reference.pointer)
        .integer;
  }

  static final _id_lastIndexOf2 = _class.instanceMethodId(
    r'lastIndexOf',
    r'(Lokio/ByteString;)I',
  );

  static final _lastIndexOf2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int lastIndexOf(okio.ByteString byteString)
  int lastIndexOf2(
    ByteString byteString,
  ) {
    return _lastIndexOf2(reference.pointer,
            _id_lastIndexOf2 as jni.JMethodIDPtr, byteString.reference.pointer)
        .integer;
  }

  static final _id_lastIndexOf3 = _class.instanceMethodId(
    r'lastIndexOf',
    r'([B)I',
  );

  static final _lastIndexOf3 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final int lastIndexOf(byte[] bs)
  int lastIndexOf3(
    jni.JArray<jni.jbyte> bs,
  ) {
    return _lastIndexOf3(reference.pointer,
            _id_lastIndexOf3 as jni.JMethodIDPtr, bs.reference.pointer)
        .integer;
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'([B)Lokio/ByteString;',
  );

  static final _of = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okio.ByteString of(byte[] bs)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString of(
    jni.JArray<jni.jbyte> bs,
  ) {
    return _of(_class.reference.pointer, _id_of as jni.JMethodIDPtr,
            bs.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_of1 = _class.staticMethodId(
    r'of',
    r'([BII)Lokio/ByteString;',
  );

  static final _of1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32, $Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public final okio.ByteString of(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString of1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return _of1(_class.reference.pointer, _id_of1 as jni.JMethodIDPtr,
            bs.reference.pointer, i, i1)
        .object(const $ByteStringType());
  }

  static final _id_of2 = _class.staticMethodId(
    r'of',
    r'(Ljava/nio/ByteBuffer;)Lokio/ByteString;',
  );

  static final _of2 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okio.ByteString of(java.nio.ByteBuffer byteBuffer)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString of2(
    jni.JByteBuffer byteBuffer,
  ) {
    return _of2(_class.reference.pointer, _id_of2 as jni.JMethodIDPtr,
            byteBuffer.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_encodeUtf8 = _class.staticMethodId(
    r'encodeUtf8',
    r'(Ljava/lang/String;)Lokio/ByteString;',
  );

  static final _encodeUtf8 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okio.ByteString encodeUtf8(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString encodeUtf8(
    jni.JString string,
  ) {
    return _encodeUtf8(_class.reference.pointer,
            _id_encodeUtf8 as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_encodeString = _class.staticMethodId(
    r'encodeString',
    r'(Ljava/lang/String;Ljava/nio/charset/Charset;)Lokio/ByteString;',
  );

  static final _encodeString = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public final okio.ByteString encodeString(java.lang.String string, java.nio.charset.Charset charset)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString encodeString(
    jni.JString string,
    jni.JObject charset,
  ) {
    return _encodeString(
            _class.reference.pointer,
            _id_encodeString as jni.JMethodIDPtr,
            string.reference.pointer,
            charset.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_decodeBase64 = _class.staticMethodId(
    r'decodeBase64',
    r'(Ljava/lang/String;)Lokio/ByteString;',
  );

  static final _decodeBase64 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okio.ByteString decodeBase64(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString decodeBase64(
    jni.JString string,
  ) {
    return _decodeBase64(_class.reference.pointer,
            _id_decodeBase64 as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_decodeHex = _class.staticMethodId(
    r'decodeHex',
    r'(Ljava/lang/String;)Lokio/ByteString;',
  );

  static final _decodeHex = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public final okio.ByteString decodeHex(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString decodeHex(
    jni.JString string,
  ) {
    return _decodeHex(_class.reference.pointer,
            _id_decodeHex as jni.JMethodIDPtr, string.reference.pointer)
        .object(const $ByteStringType());
  }

  static final _id_read = _class.staticMethodId(
    r'read',
    r'(Ljava/io/InputStream;I)Lokio/ByteString;',
  );

  static final _read = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public final okio.ByteString read(java.io.InputStream inputStream, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static ByteString read(
    jni.JObject inputStream,
    int i,
  ) {
    return _read(_class.reference.pointer, _id_read as jni.JMethodIDPtr,
            inputStream.reference.pointer, i)
        .object(const $ByteStringType());
  }

  static final _id_compareTo1 = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/lang/Object;)I',
  );

  static final _compareTo1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(java.lang.Object object)
  int compareTo1(
    jni.JObject object,
  ) {
    return _compareTo1(reference.pointer, _id_compareTo1 as jni.JMethodIDPtr,
            object.reference.pointer)
        .integer;
  }
}

final class $ByteStringType extends jni.JObjType<ByteString> {
  const $ByteStringType();

  @override
  String get signature => r'Lokio/ByteString;';

  @override
  ByteString fromReference(jni.JReference reference) =>
      ByteString.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ByteStringType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ByteStringType) && other is $ByteStringType;
  }
}

/// from: com.example.ok_http.WebSocketInterceptor$Companion
class WebSocketInterceptor_Companion extends jni.JObject {
  @override
  late final jni.JObjType<WebSocketInterceptor_Companion> $type = type;

  WebSocketInterceptor_Companion.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/example/ok_http/WebSocketInterceptor$Companion');

  /// The type which includes information such as the signature of this class.
  static const type = $WebSocketInterceptor_CompanionType();
  static final _id_addWSInterceptor = _class.instanceMethodId(
    r'addWSInterceptor',
    r'(Lokhttp3/OkHttpClient$Builder;)Lokhttp3/OkHttpClient$Builder;',
  );

  static final _addWSInterceptor = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public final okhttp3.OkHttpClient$Builder addWSInterceptor(okhttp3.OkHttpClient$Builder builder)
  /// The returned object must be released after use, by calling the [release] method.
  OkHttpClient_Builder addWSInterceptor(
    OkHttpClient_Builder builder,
  ) {
    return _addWSInterceptor(reference.pointer,
            _id_addWSInterceptor as jni.JMethodIDPtr, builder.reference.pointer)
        .object(const $OkHttpClient_BuilderType());
  }

  static final _id_new0 = _class.constructorId(
    r'(Lkotlin/jvm/internal/DefaultConstructorMarker;)V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(kotlin.jvm.internal.DefaultConstructorMarker defaultConstructorMarker)
  /// The returned object must be released after use, by calling the [release] method.
  factory WebSocketInterceptor_Companion(
    jni.JObject defaultConstructorMarker,
  ) {
    return WebSocketInterceptor_Companion.fromReference(_new0(
            _class.reference.pointer,
            _id_new0 as jni.JMethodIDPtr,
            defaultConstructorMarker.reference.pointer)
        .reference);
  }
}

final class $WebSocketInterceptor_CompanionType
    extends jni.JObjType<WebSocketInterceptor_Companion> {
  const $WebSocketInterceptor_CompanionType();

  @override
  String get signature =>
      r'Lcom/example/ok_http/WebSocketInterceptor$Companion;';

  @override
  WebSocketInterceptor_Companion fromReference(jni.JReference reference) =>
      WebSocketInterceptor_Companion.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebSocketInterceptor_CompanionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocketInterceptor_CompanionType) &&
        other is $WebSocketInterceptor_CompanionType;
  }
}

/// from: com.example.ok_http.WebSocketInterceptor
class WebSocketInterceptor extends jni.JObject {
  @override
  late final jni.JObjType<WebSocketInterceptor> $type = type;

  WebSocketInterceptor.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'com/example/ok_http/WebSocketInterceptor');

  /// The type which includes information such as the signature of this class.
  static const type = $WebSocketInterceptorType();
  static final _id_Companion = _class.staticFieldId(
    r'Companion',
    r'Lcom/example/ok_http/WebSocketInterceptor$Companion;',
  );

  /// from: static public final com.example.ok_http.WebSocketInterceptor$Companion Companion
  /// The returned object must be released after use, by calling the [release] method.
  static WebSocketInterceptor_Companion get Companion =>
      _id_Companion.get(_class, const $WebSocketInterceptor_CompanionType());

  static final _id_new0 = _class.constructorId(
    r'()V',
  );

  static final _new0 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_NewObject')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory WebSocketInterceptor() {
    return WebSocketInterceptor.fromReference(
        _new0(_class.reference.pointer, _id_new0 as jni.JMethodIDPtr)
            .reference);
  }
}

final class $WebSocketInterceptorType
    extends jni.JObjType<WebSocketInterceptor> {
  const $WebSocketInterceptorType();

  @override
  String get signature => r'Lcom/example/ok_http/WebSocketInterceptor;';

  @override
  WebSocketInterceptor fromReference(jni.JReference reference) =>
      WebSocketInterceptor.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($WebSocketInterceptorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($WebSocketInterceptorType) &&
        other is $WebSocketInterceptorType;
  }
}

/// from: java.util.concurrent.TimeUnit
class TimeUnit extends jni.JObject {
  @override
  late final jni.JObjType<TimeUnit> $type = type;

  TimeUnit.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'java/util/concurrent/TimeUnit');

  /// The type which includes information such as the signature of this class.
  static const type = $TimeUnitType();
  static final _id_NANOSECONDS = _class.staticFieldId(
    r'NANOSECONDS',
    r'Ljava/util/concurrent/TimeUnit;',
  );

  /// from: static public final java.util.concurrent.TimeUnit NANOSECONDS
  /// The returned object must be released after use, by calling the [release] method.
  static TimeUnit get NANOSECONDS =>
      _id_NANOSECONDS.get(_class, const $TimeUnitType());

  static final _id_MICROSECONDS = _class.staticFieldId(
    r'MICROSECONDS',
    r'Ljava/util/concurrent/TimeUnit;',
  );

  /// from: static public final java.util.concurrent.TimeUnit MICROSECONDS
  /// The returned object must be released after use, by calling the [release] method.
  static TimeUnit get MICROSECONDS =>
      _id_MICROSECONDS.get(_class, const $TimeUnitType());

  static final _id_MILLISECONDS = _class.staticFieldId(
    r'MILLISECONDS',
    r'Ljava/util/concurrent/TimeUnit;',
  );

  /// from: static public final java.util.concurrent.TimeUnit MILLISECONDS
  /// The returned object must be released after use, by calling the [release] method.
  static TimeUnit get MILLISECONDS =>
      _id_MILLISECONDS.get(_class, const $TimeUnitType());

  static final _id_SECONDS = _class.staticFieldId(
    r'SECONDS',
    r'Ljava/util/concurrent/TimeUnit;',
  );

  /// from: static public final java.util.concurrent.TimeUnit SECONDS
  /// The returned object must be released after use, by calling the [release] method.
  static TimeUnit get SECONDS => _id_SECONDS.get(_class, const $TimeUnitType());

  static final _id_MINUTES = _class.staticFieldId(
    r'MINUTES',
    r'Ljava/util/concurrent/TimeUnit;',
  );

  /// from: static public final java.util.concurrent.TimeUnit MINUTES
  /// The returned object must be released after use, by calling the [release] method.
  static TimeUnit get MINUTES => _id_MINUTES.get(_class, const $TimeUnitType());

  static final _id_HOURS = _class.staticFieldId(
    r'HOURS',
    r'Ljava/util/concurrent/TimeUnit;',
  );

  /// from: static public final java.util.concurrent.TimeUnit HOURS
  /// The returned object must be released after use, by calling the [release] method.
  static TimeUnit get HOURS => _id_HOURS.get(_class, const $TimeUnitType());

  static final _id_DAYS = _class.staticFieldId(
    r'DAYS',
    r'Ljava/util/concurrent/TimeUnit;',
  );

  /// from: static public final java.util.concurrent.TimeUnit DAYS
  /// The returned object must be released after use, by calling the [release] method.
  static TimeUnit get DAYS => _id_DAYS.get(_class, const $TimeUnitType());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Ljava/util/concurrent/TimeUnit;',
  );

  static final _values = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: static public java.util.concurrent.TimeUnit[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<TimeUnit> values() {
    return _values(_class.reference.pointer, _id_values as jni.JMethodIDPtr)
        .object(const jni.JArrayType($TimeUnitType()));
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Ljava/util/concurrent/TimeUnit;',
  );

  static final _valueOf = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.TimeUnit valueOf(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static TimeUnit valueOf(
    jni.JString string,
  ) {
    return _valueOf(_class.reference.pointer, _id_valueOf as jni.JMethodIDPtr,
            string.reference.pointer)
        .object(const $TimeUnitType());
  }

  static final _id_convert = _class.instanceMethodId(
    r'convert',
    r'(JLjava/util/concurrent/TimeUnit;)J',
  );

  static final _convert = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Int64, ffi.Pointer<ffi.Void>)>)>>(
          'globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: public long convert(long j, java.util.concurrent.TimeUnit timeUnit)
  int convert(
    int j,
    TimeUnit timeUnit,
  ) {
    return _convert(reference.pointer, _id_convert as jni.JMethodIDPtr, j,
            timeUnit.reference.pointer)
        .long;
  }

  static final _id_convert1 = _class.instanceMethodId(
    r'convert',
    r'(Ljava/time/Duration;)J',
  );

  static final _convert1 = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: public long convert(java.time.Duration duration)
  int convert1(
    jni.JObject duration,
  ) {
    return _convert1(reference.pointer, _id_convert1 as jni.JMethodIDPtr,
            duration.reference.pointer)
        .long;
  }

  static final _id_toNanos = _class.instanceMethodId(
    r'toNanos',
    r'(J)J',
  );

  static final _toNanos = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public long toNanos(long j)
  int toNanos(
    int j,
  ) {
    return _toNanos(reference.pointer, _id_toNanos as jni.JMethodIDPtr, j).long;
  }

  static final _id_toMicros = _class.instanceMethodId(
    r'toMicros',
    r'(J)J',
  );

  static final _toMicros = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public long toMicros(long j)
  int toMicros(
    int j,
  ) {
    return _toMicros(reference.pointer, _id_toMicros as jni.JMethodIDPtr, j)
        .long;
  }

  static final _id_toMillis = _class.instanceMethodId(
    r'toMillis',
    r'(J)J',
  );

  static final _toMillis = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public long toMillis(long j)
  int toMillis(
    int j,
  ) {
    return _toMillis(reference.pointer, _id_toMillis as jni.JMethodIDPtr, j)
        .long;
  }

  static final _id_toSeconds = _class.instanceMethodId(
    r'toSeconds',
    r'(J)J',
  );

  static final _toSeconds = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public long toSeconds(long j)
  int toSeconds(
    int j,
  ) {
    return _toSeconds(reference.pointer, _id_toSeconds as jni.JMethodIDPtr, j)
        .long;
  }

  static final _id_toMinutes = _class.instanceMethodId(
    r'toMinutes',
    r'(J)J',
  );

  static final _toMinutes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public long toMinutes(long j)
  int toMinutes(
    int j,
  ) {
    return _toMinutes(reference.pointer, _id_toMinutes as jni.JMethodIDPtr, j)
        .long;
  }

  static final _id_toHours = _class.instanceMethodId(
    r'toHours',
    r'(J)J',
  );

  static final _toHours = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public long toHours(long j)
  int toHours(
    int j,
  ) {
    return _toHours(reference.pointer, _id_toHours as jni.JMethodIDPtr, j).long;
  }

  static final _id_toDays = _class.instanceMethodId(
    r'toDays',
    r'(J)J',
  );

  static final _toDays = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public long toDays(long j)
  int toDays(
    int j,
  ) {
    return _toDays(reference.pointer, _id_toDays as jni.JMethodIDPtr, j).long;
  }

  static final _id_timedWait = _class.instanceMethodId(
    r'timedWait',
    r'(Ljava/lang/Object;J)V',
  );

  static final _timedWait = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void timedWait(java.lang.Object object, long j)
  void timedWait(
    jni.JObject object,
    int j,
  ) {
    _timedWait(reference.pointer, _id_timedWait as jni.JMethodIDPtr,
            object.reference.pointer, j)
        .check();
  }

  static final _id_timedJoin = _class.instanceMethodId(
    r'timedJoin',
    r'(Ljava/lang/Thread;J)V',
  );

  static final _timedJoin = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, ffi.Int64)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: public void timedJoin(java.lang.Thread thread, long j)
  void timedJoin(
    jni.JObject thread,
    int j,
  ) {
    _timedJoin(reference.pointer, _id_timedJoin as jni.JMethodIDPtr,
            thread.reference.pointer, j)
        .check();
  }

  static final _id_sleep = _class.instanceMethodId(
    r'sleep',
    r'(J)V',
  );

  static final _sleep = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<(ffi.Int64,)>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: public void sleep(long j)
  void sleep(
    int j,
  ) {
    _sleep(reference.pointer, _id_sleep as jni.JMethodIDPtr, j).check();
  }

  static final _id_toChronoUnit = _class.instanceMethodId(
    r'toChronoUnit',
    r'()Ljava/time/temporal/ChronoUnit;',
  );

  static final _toChronoUnit = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: public java.time.temporal.ChronoUnit toChronoUnit()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject toChronoUnit() {
    return _toChronoUnit(
            reference.pointer, _id_toChronoUnit as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/temporal/ChronoUnit;)Ljava/util/concurrent/TimeUnit;',
  );

  static final _of = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.TimeUnit of(java.time.temporal.ChronoUnit chronoUnit)
  /// The returned object must be released after use, by calling the [release] method.
  static TimeUnit of(
    jni.JObject chronoUnit,
  ) {
    return _of(_class.reference.pointer, _id_of as jni.JMethodIDPtr,
            chronoUnit.reference.pointer)
        .object(const $TimeUnitType());
  }
}

final class $TimeUnitType extends jni.JObjType<TimeUnit> {
  const $TimeUnitType();

  @override
  String get signature => r'Ljava/util/concurrent/TimeUnit;';

  @override
  TimeUnit fromReference(jni.JReference reference) =>
      TimeUnit.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($TimeUnitType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($TimeUnitType) && other is $TimeUnitType;
  }
}
