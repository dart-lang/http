// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: return_of_invalid_type

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<
  ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external bool _NativeCupertinoHttp_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeCupertinoHttp_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  instancetype Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external instancetype _NativeCupertinoHttp_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl>
_NativeCupertinoHttp_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_r8gdi7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_r8gdi7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_16sve1d(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_16sve1d(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_xx612k(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_xx612k(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_1otpo83(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_1otpo83(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeCupertinoHttp_protocolTrampoline_xx612k(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ffi.Pointer<objc.ObjCBlockImpl> arg4,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeCupertinoHttp_protocolTrampoline_1tz5yf(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCObjectImpl> arg3,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeCupertinoHttp_protocolTrampoline_fjrv01(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_l2g8ke(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_l2g8ke(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeCupertinoHttp_protocolTrampoline_l2g8ke(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ffi.Pointer<objc.ObjCObjectImpl> arg4,
  ffi.Pointer<objc.ObjCBlockImpl> arg5,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_n8yd09(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_n8yd09(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_bklti2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_bklti2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeCupertinoHttp_protocolTrampoline_bklti2(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<objc.ObjCBlockImpl> arg3,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_jyim80(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_jyim80(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Int64,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external void _NativeCupertinoHttp_protocolTrampoline_jyim80(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  int arg3,
  ffi.Pointer<objc.ObjCBlockImpl> arg4,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_h68abb(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_h68abb(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Int64,
    ffi.Int64,
    ffi.Int64,
  )
>()
external void _NativeCupertinoHttp_protocolTrampoline_h68abb(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  int arg3,
  int arg4,
  int arg5,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_ly2579(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_ly2579(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Int64,
    ffi.Int64,
  )
>()
external void _NativeCupertinoHttp_protocolTrampoline_ly2579(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  int arg3,
  int arg4,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_1lx650f(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_1lx650f(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Long,
    ffi.Pointer<objc.ObjCObjectImpl>,
  )
>()
external void _NativeCupertinoHttp_protocolTrampoline_1lx650f(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  int arg3,
  ffi.Pointer<objc.ObjCObjectImpl> arg4,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapListenerBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
_NativeCupertinoHttp_wrapBlockingBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)
>()
external void _NativeCupertinoHttp_protocolTrampoline_ovsamd(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

/// !
/// @enum NSURLCacheStoragePolicy
///
/// @discussion The NSURLCacheStoragePolicy enum defines constants that
/// can be used to specify the type of storage that is allowable for an
/// NSCachedURLResponse object that is to be stored in an NSURLCache.
///
/// @constant NSURLCacheStorageAllowed Specifies that storage in an
/// NSURLCache is allowed without restriction.
///
/// @constant NSURLCacheStorageAllowedInMemoryOnly Specifies that
/// storage in an NSURLCache is allowed; however storage should be
/// done in memory only, no disk storage should be done.
///
/// @constant NSURLCacheStorageNotAllowed Specifies that storage in an
/// NSURLCache is not allowed in any fashion, either in memory or on
/// disk.
enum NSURLCacheStoragePolicy {
  NSURLCacheStorageAllowed(0),
  NSURLCacheStorageAllowedInMemoryOnly(1),
  NSURLCacheStorageNotAllowed(2);

  final int value;
  const NSURLCacheStoragePolicy(this.value);

  static NSURLCacheStoragePolicy fromValue(int value) => switch (value) {
    0 => NSURLCacheStorageAllowed,
    1 => NSURLCacheStorageAllowedInMemoryOnly,
    2 => NSURLCacheStorageNotAllowed,
    _ => throw ArgumentError(
      'Unknown value for NSURLCacheStoragePolicy: $value',
    ),
  };
}

/// WARNING: NSCachedURLResponse is a stub. To generate bindings for this class, include
/// NSCachedURLResponse in your config's objc-interfaces list.
///
/// !
/// @class NSCachedURLResponse
/// NSCachedURLResponse is a class whose objects functions as a wrapper for
/// objects that are stored in the framework's caching system.
/// It is used to maintain characteristics and attributes of a cached
/// object.
extension type NSCachedURLResponse._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [NSCachedURLResponse] that points to the same underlying object as [other].
  NSCachedURLResponse.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSCachedURLResponse',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }

  /// Constructs a [NSCachedURLResponse] that wraps the given raw object pointer.
  NSCachedURLResponse.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSCachedURLResponse',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }
}

late final _class_NSURLCache = objc.getClass("NSURLCache");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_sharedURLCache = objc.registerName("sharedURLCache");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setSharedURLCache_ = objc.registerName("setSharedURLCache:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_initWithMemoryCapacity_diskCapacity_diskPath_ = objc
    .registerName("initWithMemoryCapacity:diskCapacity:diskPath:");
final _objc_msgSend_1dqnse5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_initWithMemoryCapacity_diskCapacity_directoryURL_ = objc
    .registerName("initWithMemoryCapacity:diskCapacity:directoryURL:");
late final _class_NSURLRequest = objc.getClass("NSURLRequest");
late final _sel_requestWithURL_ = objc.registerName("requestWithURL:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_supportsSecureCoding = objc.registerName(
  "supportsSecureCoding",
);
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

/// !
/// @enum NSURLRequestCachePolicy
///
/// @discussion The NSURLRequestCachePolicy enum defines constants that
/// can be used to specify the type of interactions that take place with
/// the caching system when the URL loading system processes a request.
/// Specifically, these constants cover interactions that have to do
/// with whether already-existing cache data is returned to satisfy a
/// URL load request.
///
/// @constant NSURLRequestUseProtocolCachePolicy Specifies that the
/// caching logic defined in the protocol implementation, if any, is
/// used for a particular URL load request. This is the default policy
/// for URL load requests.
///
/// @constant NSURLRequestReloadIgnoringLocalCacheData Specifies that the
/// data for the URL load should be loaded from the origin source. No
/// existing local cache data, regardless of its freshness or validity,
/// should be used to satisfy a URL load request.
///
/// @constant NSURLRequestReloadIgnoringLocalAndRemoteCacheData Specifies that
/// not only should the local cache data be ignored, but that proxies and
/// other intermediates should be instructed to disregard their caches
/// so far as the protocol allows.
///
/// @constant NSURLRequestReloadIgnoringCacheData Older name for
/// NSURLRequestReloadIgnoringLocalCacheData.
///
/// @constant NSURLRequestReturnCacheDataElseLoad Specifies that the
/// existing cache data should be used to satisfy a URL load request,
/// regardless of its age or expiration date. However, if there is no
/// existing data in the cache corresponding to a URL load request,
/// the URL is loaded from the origin source.
///
/// @constant NSURLRequestReturnCacheDataDontLoad Specifies that the
/// existing cache data should be used to satisfy a URL load request,
/// regardless of its age or expiration date. However, if there is no
/// existing data in the cache corresponding to a URL load request, no
/// attempt is made to load the URL from the origin source, and the
/// load is considered to have failed. This constant specifies a
/// behavior that is similar to an "offline" mode.
///
/// @constant NSURLRequestReloadRevalidatingCacheData Specifies that
/// the existing cache data may be used provided the origin source
/// confirms its validity, otherwise the URL is loaded from the
/// origin source.
enum NSURLRequestCachePolicy {
  NSURLRequestUseProtocolCachePolicy(0),
  NSURLRequestReloadIgnoringLocalCacheData(1),
  NSURLRequestReloadIgnoringLocalAndRemoteCacheData(4),
  NSURLRequestReturnCacheDataElseLoad(2),
  NSURLRequestReturnCacheDataDontLoad(3),
  NSURLRequestReloadRevalidatingCacheData(5);

  static const NSURLRequestReloadIgnoringCacheData =
      NSURLRequestReloadIgnoringLocalCacheData;

  final int value;
  const NSURLRequestCachePolicy(this.value);

  static NSURLRequestCachePolicy fromValue(int value) => switch (value) {
    0 => NSURLRequestUseProtocolCachePolicy,
    1 => NSURLRequestReloadIgnoringLocalCacheData,
    4 => NSURLRequestReloadIgnoringLocalAndRemoteCacheData,
    2 => NSURLRequestReturnCacheDataElseLoad,
    3 => NSURLRequestReturnCacheDataDontLoad,
    5 => NSURLRequestReloadRevalidatingCacheData,
    _ => throw ArgumentError(
      'Unknown value for NSURLRequestCachePolicy: $value',
    ),
  };

  @override
  String toString() {
    if (this == NSURLRequestReloadIgnoringLocalCacheData)
      return "NSURLRequestCachePolicy.NSURLRequestReloadIgnoringLocalCacheData, NSURLRequestCachePolicy.NSURLRequestReloadIgnoringCacheData";
    return super.toString();
  }
}

late final _sel_requestWithURL_cachePolicy_timeoutInterval_ = objc.registerName(
  "requestWithURL:cachePolicy:timeoutInterval:",
);
final _objc_msgSend_1ajs603 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        double,
      )
    >();
late final _sel_initWithURL_ = objc.registerName("initWithURL:");
late final _sel_initWithURL_cachePolicy_timeoutInterval_ = objc.registerName(
  "initWithURL:cachePolicy:timeoutInterval:",
);
late final _sel_URL = objc.registerName("URL");
late final _sel_cachePolicy = objc.registerName("cachePolicy");
final _objc_msgSend_8jm3uo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_timeoutInterval = objc.registerName("timeoutInterval");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Double Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_mainDocumentURL = objc.registerName("mainDocumentURL");

/// !
/// @enum NSURLRequestNetworkServiceType
///
/// @discussion The NSURLRequestNetworkServiceType enum defines constants that
/// can be used to specify the service type to associate with this request.  The
/// service type is used to provide the networking layers a hint of the purpose
/// of the request.
///
/// @constant NSURLNetworkServiceTypeDefault Is the default value for an NSURLRequest
/// when created.  This value should be left unchanged for the vast majority of requests.
///
/// @constant NSURLNetworkServiceTypeVoIP Specifies that the request is for voice over IP
/// control traffic.
///
/// @constant NSURLNetworkServiceTypeVideo Specifies that the request is for video
/// traffic.
///
/// @constant NSURLNetworkServiceTypeBackground Specifies that the request is for background
/// traffic (such as a file download).
///
/// @constant NSURLNetworkServiceTypeVoice Specifies that the request is for voice data.
///
/// @constant NSURLNetworkServiceTypeResponsiveData Specifies that the request is for responsive (time sensitive) data.
///
/// @constant NSURLNetworkServiceTypeAVStreaming Specifies that the request is streaming audio/video data.
///
/// @constant NSURLNetworkServiceTypeResponsiveAV Specifies that the request is for responsive (time sensitive) audio/video data.
///
/// @constant NSURLNetworkServiceTypeCallSignaling Specifies that the request is for call signaling.
enum NSURLRequestNetworkServiceType {
  /// Standard internet traffic
  NSURLNetworkServiceTypeDefault(0),

  /// Voice over IP control traffic
  NSURLNetworkServiceTypeVoIP(1),

  /// Video traffic
  NSURLNetworkServiceTypeVideo(2),

  /// Background traffic
  NSURLNetworkServiceTypeBackground(3),

  /// Voice data
  NSURLNetworkServiceTypeVoice(4),

  /// Responsive data
  NSURLNetworkServiceTypeResponsiveData(6),

  /// Multimedia Audio/Video Streaming
  NSURLNetworkServiceTypeAVStreaming(8),

  /// Responsive Multimedia Audio/Video
  NSURLNetworkServiceTypeResponsiveAV(9),

  /// Call Signaling
  NSURLNetworkServiceTypeCallSignaling(11);

  final int value;
  const NSURLRequestNetworkServiceType(this.value);

  static NSURLRequestNetworkServiceType fromValue(int value) => switch (value) {
    0 => NSURLNetworkServiceTypeDefault,
    1 => NSURLNetworkServiceTypeVoIP,
    2 => NSURLNetworkServiceTypeVideo,
    3 => NSURLNetworkServiceTypeBackground,
    4 => NSURLNetworkServiceTypeVoice,
    6 => NSURLNetworkServiceTypeResponsiveData,
    8 => NSURLNetworkServiceTypeAVStreaming,
    9 => NSURLNetworkServiceTypeResponsiveAV,
    11 => NSURLNetworkServiceTypeCallSignaling,
    _ => throw ArgumentError(
      'Unknown value for NSURLRequestNetworkServiceType: $value',
    ),
  };
}

late final _sel_networkServiceType = objc.registerName("networkServiceType");
final _objc_msgSend_t4uaw1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_allowsCellularAccess = objc.registerName(
  "allowsCellularAccess",
);
late final _sel_allowsExpensiveNetworkAccess = objc.registerName(
  "allowsExpensiveNetworkAccess",
);
late final _sel_allowsConstrainedNetworkAccess = objc.registerName(
  "allowsConstrainedNetworkAccess",
);
late final _sel_assumesHTTP3Capable = objc.registerName("assumesHTTP3Capable");

/// !
/// @enum NSURLRequestAttribution
///
/// @discussion The NSURLRequestAttribution enum is used to indicate whether the
/// user or developer specified the URL.
///
/// @constant NSURLRequestAttributionDeveloper Indicates that the URL was specified
/// by the developer. This is the default value for an NSURLRequest when created.
///
/// @constant NSURLRequestAttributionUser Indicates that the URL was specified by
/// the user.
enum NSURLRequestAttribution {
  NSURLRequestAttributionDeveloper(0),
  NSURLRequestAttributionUser(1);

  final int value;
  const NSURLRequestAttribution(this.value);

  static NSURLRequestAttribution fromValue(int value) => switch (value) {
    0 => NSURLRequestAttributionDeveloper,
    1 => NSURLRequestAttributionUser,
    _ => throw ArgumentError(
      'Unknown value for NSURLRequestAttribution: $value',
    ),
  };
}

late final _sel_attribution = objc.registerName("attribution");
final _objc_msgSend_i3avs9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_requiresDNSSECValidation = objc.registerName(
  "requiresDNSSECValidation",
);
late final _sel_allowsPersistentDNS = objc.registerName("allowsPersistentDNS");
late final _sel_cookiePartitionIdentifier = objc.registerName(
  "cookiePartitionIdentifier",
);
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSCoder.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        objc.NSCoder.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
      ffi.Pointer<ffi.Void>,
      objc.NSCoder,
    )
  >
  fromFunction(
    Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
          ffi.Pointer<ffi.Void>,
          objc.NSCoder,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
              fn(
                arg0,
                objc.NSCoder.fromPointer(arg1, retain: true, release: true),
              )?.ref.retainAndReturnPointer() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder$CallExtension
    on
        objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObjectImpl>?> Function(
            ffi.Pointer<ffi.Void>,
            objc.NSCoder,
          )
        > {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true,
        );
}

late final _sel_HTTPMethod = objc.registerName("HTTPMethod");
late final _sel_allHTTPHeaderFields = objc.registerName("allHTTPHeaderFields");
late final _sel_valueForHTTPHeaderField_ = objc.registerName(
  "valueForHTTPHeaderField:",
);
late final _sel_HTTPBody = objc.registerName("HTTPBody");
late final _sel_HTTPBodyStream = objc.registerName("HTTPBodyStream");
late final _sel_HTTPShouldHandleCookies = objc.registerName(
  "HTTPShouldHandleCookies",
);
late final _sel_HTTPShouldUsePipelining = objc.registerName(
  "HTTPShouldUsePipelining",
);

/// !
/// @category NSURLRequest(NSHTTPURLRequest)
/// The NSHTTPURLRequest on NSURLRequest provides methods for accessing
/// information specific to HTTP protocol requests.
extension NSHTTPURLRequest on NSURLRequest {
  /// !
  /// @abstract Returns the request body data of the receiver.
  /// @discussion This data is sent as the message body of the request, as
  /// in done in an HTTP POST request.
  /// @result The request body data of the receiver.
  objc.NSData? get HTTPBody {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPBody',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_HTTPBody);
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the request body stream of the receiver
  /// if any has been set
  /// @discussion The stream is returned for examination only; it is
  /// not safe for the caller to manipulate the stream in any way.  Also
  /// note that the HTTPBodyStream and HTTPBody are mutually exclusive - only
  /// one can be set on a given request.  Also note that the body stream is
  /// preserved across copies, but is LOST when the request is coded via the
  /// NSCoding protocol
  /// @result The request body stream of the receiver.
  objc.NSInputStream? get HTTPBodyStream {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPBodyStream',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_HTTPBodyStream,
    );
    return $ret.address == 0
        ? null
        : objc.NSInputStream.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the HTTP request method of the receiver.
  /// @result the HTTP request method of the receiver.
  objc.NSString? get HTTPMethod {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPMethod',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_HTTPMethod);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Determine whether default cookie handling will happen for
  /// this request.
  /// @discussion NOTE: This value is not used prior to 10.3
  /// @result YES if cookies will be sent with and set for this request;
  /// otherwise NO.
  bool get HTTPShouldHandleCookies {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPShouldHandleCookies',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_HTTPShouldHandleCookies,
    );
  }

  /// !
  /// @abstract Reports whether the receiver is not expected to wait for the
  /// previous response before transmitting.
  /// @result YES if the receiver should transmit before the previous response
  /// is received.  NO if the receiver should wait for the previous response
  /// before transmitting.
  bool get HTTPShouldUsePipelining {
    objc.checkOsVersionInternal(
      'NSURLRequest.HTTPShouldUsePipelining',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_HTTPShouldUsePipelining,
    );
  }

  /// !
  /// @abstract Returns a dictionary containing all the HTTP header fields
  /// of the receiver.
  /// @result a dictionary containing all the HTTP header fields of the
  /// receiver.
  objc.NSDictionary? get allHTTPHeaderFields {
    objc.checkOsVersionInternal(
      'NSURLRequest.allHTTPHeaderFields',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_allHTTPHeaderFields,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @method valueForHTTPHeaderField:
  /// @abstract Returns the value which corresponds to the given header
  /// field. Note that, in keeping with the HTTP RFC, HTTP header field
  /// names are case-insensitive.
  /// @param field the header field name to use for the lookup
  /// (case-insensitive).
  /// @result the value associated with the given header field, or nil if
  /// there is no value associated with the given header field.
  objc.NSString? valueForHTTPHeaderField(objc.NSString field) {
    objc.checkOsVersionInternal(
      'NSURLRequest.valueForHTTPHeaderField:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_valueForHTTPHeaderField_,
      field.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }
}

/// NSURLRequest
extension type NSURLRequest._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying,
        objc.NSMutableCopying {
  /// Constructs a [NSURLRequest] that points to the same underlying object as [other].
  NSURLRequest.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [NSURLRequest] that wraps the given raw object pointer.
  NSURLRequest.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLRequest].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLRequest,
  );

  /// alloc
  static NSURLRequest alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLRequest, _sel_alloc);
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLRequest allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLRequest,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSURLRequest new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLRequest, _sel_new);
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method requestWithURL:
  /// @abstract Allocates and initializes an NSURLRequest with the given
  /// URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSURLRequest requestWithURL(objc.NSURL URL) {
    objc.checkOsVersionInternal(
      'NSURLRequest.requestWithURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSURLRequest,
      _sel_requestWithURL_,
      URL.ref.pointer,
    );
    return NSURLRequest.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @method requestWithURL:cachePolicy:timeoutInterval:
  /// @abstract Allocates and initializes a NSURLRequest with the given
  /// URL and cache policy.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSURLRequest requestWithURL$1(
    objc.NSURL URL, {
    required NSURLRequestCachePolicy cachePolicy,
    required double timeoutInterval,
  }) {
    objc.checkOsVersionInternal(
      'NSURLRequest.requestWithURL:cachePolicy:timeoutInterval:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1ajs603(
      _class_NSURLRequest,
      _sel_requestWithURL_cachePolicy_timeoutInterval_,
      URL.ref.pointer,
      cachePolicy.value,
      timeoutInterval,
    );
    return NSURLRequest.fromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSURLRequest, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of NSURLRequest constructed with the default `new` method.
  NSURLRequest() : this.as(new$().object$);
}

extension NSURLRequest$Methods on NSURLRequest {
  /// !
  /// @abstract Returns the URL of the receiver.
  /// @result The URL of the receiver.
  objc.NSURL? get URL {
    objc.checkOsVersionInternal(
      'NSURLRequest.URL',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract returns whether a connection created with this request is allowed to use
  /// the built in cellular radios (if present).
  /// @result YES if the receiver is allowed to use the built in cellular radios to
  /// satisfy the request, NO otherwise.
  bool get allowsCellularAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsCellularAccess',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsCellularAccess);
  }

  /// !
  /// @abstract returns whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as constrained.
  /// @result YES if the receiver is allowed to use an interface marked as constrained to
  /// satisfy the request, NO otherwise.
  bool get allowsConstrainedNetworkAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsConstrainedNetworkAccess',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsConstrainedNetworkAccess,
    );
  }

  /// !
  /// @abstract returns whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as expensive.
  /// @result YES if the receiver is allowed to use an interface marked as expensive to
  /// satisfy the request, NO otherwise.
  bool get allowsExpensiveNetworkAccess {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsExpensiveNetworkAccess',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsExpensiveNetworkAccess,
    );
  }

  /// !
  /// @abstract Allows storing and usage of DNS answers, potentially beyond TTL expiry,
  /// in a persistent per-process cache. This should only be set for hostnames whose resolutions
  /// are not expected to change across networks.
  /// @discussion YES, if the DNS lookup for this request is allowed to use a persistent per-process cache,
  /// NO otherwise. Defaults to NO.
  bool get allowsPersistentDNS {
    objc.checkOsVersionInternal(
      'NSURLRequest.allowsPersistentDNS',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsPersistentDNS);
  }

  /// !
  /// @abstract returns whether we assume that server supports HTTP/3. Enables QUIC
  /// racing without HTTP/3 service discovery.
  /// @result YES if server endpoint is known to support HTTP/3. Defaults to NO.
  /// The default may be YES in a future OS update.
  bool get assumesHTTP3Capable {
    objc.checkOsVersionInternal(
      'NSURLRequest.assumesHTTP3Capable',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_assumesHTTP3Capable);
  }

  /// !
  /// @abstract Returns the NSURLRequestAttribution associated with this request.
  /// @discussion This will return NSURLRequestAttributionDeveloper for requests that
  /// have not explicitly set an attribution.
  /// @result The NSURLRequestAttribution associated with this request.
  NSURLRequestAttribution get attribution {
    objc.checkOsVersionInternal(
      'NSURLRequest.attribution',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_i3avs9(object$.ref.pointer, _sel_attribution);
    return NSURLRequestAttribution.fromValue($ret);
  }

  /// !
  /// @abstract Returns the cache policy of the receiver.
  /// @result The cache policy of the receiver.
  NSURLRequestCachePolicy get cachePolicy {
    objc.checkOsVersionInternal(
      'NSURLRequest.cachePolicy',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_8jm3uo(object$.ref.pointer, _sel_cachePolicy);
    return NSURLRequestCachePolicy.fromValue($ret);
  }

  /// Cookie partition identifier used for cookie storage and retrieval.
  objc.NSString? get cookiePartitionIdentifier {
    objc.checkOsVersionInternal(
      'NSURLRequest.cookiePartitionIdentifier',
      iOS: (false, (18, 2, 0)),
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_cookiePartitionIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// init
  NSURLRequest init() {
    objc.checkOsVersionInternal(
      'NSURLRequest.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSURLRequest? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method initWithURL:
  /// @abstract Initializes an NSURLRequest with the given URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result An initialized NSURLRequest.
  NSURLRequest initWithURL(objc.NSURL URL) {
    objc.checkOsVersionInternal(
      'NSURLRequest.initWithURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_,
      URL.ref.pointer,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method initWithURL:
  /// @abstract Initializes an NSURLRequest with the given URL and
  /// cache policy.
  /// @discussion This is the designated initializer for the
  /// NSURLRequest class.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result An initialized NSURLRequest.
  NSURLRequest initWithURL$1(
    objc.NSURL URL, {
    required NSURLRequestCachePolicy cachePolicy,
    required double timeoutInterval,
  }) {
    objc.checkOsVersionInternal(
      'NSURLRequest.initWithURL:cachePolicy:timeoutInterval:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1ajs603(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_cachePolicy_timeoutInterval_,
      URL.ref.pointer,
      cachePolicy.value,
      timeoutInterval,
    );
    return NSURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @abstract The main document URL associated with this load.
  /// @discussion This URL is used for the cookie "same domain as main
  /// document" policy, and attributing the request as a sub-resource
  /// of a user-specified URL. There may also be other future uses.
  /// See setMainDocumentURL:
  /// @result The main document URL.
  objc.NSURL? get mainDocumentURL {
    objc.checkOsVersionInternal(
      'NSURLRequest.mainDocumentURL',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_mainDocumentURL,
    );
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the NSURLRequestNetworkServiceType associated with this request.
  /// @discussion  This will return NSURLNetworkServiceTypeDefault for requests that have
  /// not explicitly set a networkServiceType (using the setNetworkServiceType method).
  /// @result The NSURLRequestNetworkServiceType associated with this request.
  NSURLRequestNetworkServiceType get networkServiceType {
    objc.checkOsVersionInternal(
      'NSURLRequest.networkServiceType',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_t4uaw1(
      object$.ref.pointer,
      _sel_networkServiceType,
    );
    return NSURLRequestNetworkServiceType.fromValue($ret);
  }

  /// !
  /// @abstract sets whether a request is required to do DNSSEC validation during DNS lookup.
  /// @discussion YES, if the DNS lookup for this request should require DNSSEC validation,
  /// No otherwise. Defaults to NO.
  bool get requiresDNSSECValidation {
    objc.checkOsVersionInternal(
      'NSURLRequest.requiresDNSSECValidation',
      iOS: (false, (16, 1, 0)),
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_requiresDNSSECValidation,
    );
  }

  /// !
  /// @abstract Returns the timeout interval of the receiver.
  /// @discussion The timeout interval specifies the limit on the idle
  /// interval allotted to a request in the process of loading. The "idle
  /// interval" is defined as the period of time that has passed since the
  /// last instance of load activity occurred for a request that is in the
  /// process of loading. Hence, when an instance of load activity occurs
  /// (e.g. bytes are received from the network for a request), the idle
  /// interval for a request is reset to 0. If the idle interval ever
  /// becomes greater than or equal to the timeout interval, the request
  /// is considered to have timed out. This timeout interval is measured
  /// in seconds.
  /// @result The timeout interval of the receiver.
  double get timeoutInterval {
    objc.checkOsVersionInternal(
      'NSURLRequest.timeoutInterval',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_timeoutInterval)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_timeoutInterval);
  }
}

late final _sel_cachedResponseForRequest_ = objc.registerName(
  "cachedResponseForRequest:",
);
late final _sel_storeCachedResponse_forRequest_ = objc.registerName(
  "storeCachedResponse:forRequest:",
);
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_removeCachedResponseForRequest_ = objc.registerName(
  "removeCachedResponseForRequest:",
);
late final _sel_removeAllCachedResponses = objc.registerName(
  "removeAllCachedResponses",
);
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_removeCachedResponsesSinceDate_ = objc.registerName(
  "removeCachedResponsesSinceDate:",
);
late final _sel_memoryCapacity = objc.registerName("memoryCapacity");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setMemoryCapacity_ = objc.registerName("setMemoryCapacity:");
final _objc_msgSend_1i9r4xy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_diskCapacity = objc.registerName("diskCapacity");
late final _sel_setDiskCapacity_ = objc.registerName("setDiskCapacity:");
late final _sel_currentMemoryUsage = objc.registerName("currentMemoryUsage");
late final _sel_currentDiskUsage = objc.registerName("currentDiskUsage");

/// WARNING: NSURLSessionDataTask is a stub. To generate bindings for this class, include
/// NSURLSessionDataTask in your config's objc-interfaces list.
///
/// NSURLSessionDataTask
extension type NSURLSessionDataTask._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSURLSessionTask {
  /// Constructs a [NSURLSessionDataTask] that points to the same underlying object as [other].
  NSURLSessionDataTask.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [NSURLSessionDataTask] that wraps the given raw object pointer.
  NSURLSessionDataTask.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_storeCachedResponse_forDataTask_ = objc.registerName(
  "storeCachedResponse:forDataTask:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>`.
abstract final class ObjCBlock_ffiVoid_NSCachedURLResponse {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> fromFunction(
    void Function(NSCachedURLResponse?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NSCachedURLResponse.fromPointer(
                arg0,
                retain: true,
                release: true,
              ),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> listener(
    void Function(NSCachedURLResponse?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NSCachedURLResponse.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> blocking(
    void Function(NSCachedURLResponse?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NSCachedURLResponse.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NSCachedURLResponse.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>`.
extension ObjCBlock_ffiVoid_NSCachedURLResponse$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> {
  void call(NSCachedURLResponse? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_getCachedResponseForDataTask_completionHandler_ = objc
    .registerName("getCachedResponseForDataTask:completionHandler:");
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_removeCachedResponseForDataTask_ = objc.registerName(
  "removeCachedResponseForDataTask:",
);

/// NSURLSessionTaskAdditions
extension NSURLSessionTaskAdditions on NSURLCache {
  /// getCachedResponseForDataTask:completionHandler:
  void getCachedResponseForDataTask(
    NSURLSessionDataTask dataTask, {
    required objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLCache.getCachedResponseForDataTask:completionHandler:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_getCachedResponseForDataTask_completionHandler_,
      dataTask.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// removeCachedResponseForDataTask:
  void removeCachedResponseForDataTask(NSURLSessionDataTask dataTask) {
    objc.checkOsVersionInternal(
      'NSURLCache.removeCachedResponseForDataTask:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeCachedResponseForDataTask_,
      dataTask.ref.pointer,
    );
  }

  /// storeCachedResponse:forDataTask:
  void storeCachedResponse$1(
    NSCachedURLResponse cachedResponse, {
    required NSURLSessionDataTask forDataTask,
  }) {
    objc.checkOsVersionInternal(
      'NSURLCache.storeCachedResponse:forDataTask:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_storeCachedResponse_forDataTask_,
      cachedResponse.ref.pointer,
      forDataTask.ref.pointer,
    );
  }
}

/// NSURLCache
extension type NSURLCache._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSURLCache] that points to the same underlying object as [other].
  NSURLCache.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLCache',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSURLCache] that wraps the given raw object pointer.
  NSURLCache.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLCache',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLCache].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLCache,
  );

  /// alloc
  static NSURLCache alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLCache, _sel_alloc);
    return NSURLCache.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLCache allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLCache,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLCache.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSURLCache new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLCache, _sel_new);
    return NSURLCache.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @property sharedURLCache
  /// @abstract Returns the shared NSURLCache instance or
  /// sets the NSURLCache instance shared by all clients of
  /// the current process. This will be the new object returned when
  /// calls to the <tt>sharedURLCache</tt> method are made.
  /// @discussion Unless set explicitly through a call to
  /// <tt>+setSharedURLCache:</tt>, this method returns an NSURLCache
  /// instance created with the following default values:
  /// <ul>
  /// <li>Memory capacity: 4 megabytes (4 * 1024 * 1024 bytes)
  /// <li>Disk capacity: 20 megabytes (20 * 1024 * 1024 bytes)
  /// <li>Disk path: <nobr>(user home directory)/Library/Caches/(application bundle id)</nobr>
  /// </ul>
  /// <p>Users who do not have special caching requirements or
  /// constraints should find the default shared cache instance
  /// acceptable. If this default shared cache instance is not
  /// acceptable, <tt>+setSharedURLCache:</tt> can be called to set a
  /// different NSURLCache instance to be returned from this method.
  /// Callers should take care to ensure that the setter is called
  /// at a time when no other caller has a reference to the previously-set
  /// shared URL cache. This is to prevent storing cache data from
  /// becoming unexpectedly unretrievable.
  /// @result the shared NSURLCache instance.
  static void setSharedURLCache(NSURLCache value) {
    objc.checkOsVersionInternal(
      'NSURLCache.setSharedURLCache:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      _class_NSURLCache,
      _sel_setSharedURLCache_,
      value.ref.pointer,
    );
  }

  /// !
  /// @property sharedURLCache
  /// @abstract Returns the shared NSURLCache instance or
  /// sets the NSURLCache instance shared by all clients of
  /// the current process. This will be the new object returned when
  /// calls to the <tt>sharedURLCache</tt> method are made.
  /// @discussion Unless set explicitly through a call to
  /// <tt>+setSharedURLCache:</tt>, this method returns an NSURLCache
  /// instance created with the following default values:
  /// <ul>
  /// <li>Memory capacity: 4 megabytes (4 * 1024 * 1024 bytes)
  /// <li>Disk capacity: 20 megabytes (20 * 1024 * 1024 bytes)
  /// <li>Disk path: <nobr>(user home directory)/Library/Caches/(application bundle id)</nobr>
  /// </ul>
  /// <p>Users who do not have special caching requirements or
  /// constraints should find the default shared cache instance
  /// acceptable. If this default shared cache instance is not
  /// acceptable, <tt>+setSharedURLCache:</tt> can be called to set a
  /// different NSURLCache instance to be returned from this method.
  /// Callers should take care to ensure that the setter is called
  /// at a time when no other caller has a reference to the previously-set
  /// shared URL cache. This is to prevent storing cache data from
  /// becoming unexpectedly unretrievable.
  /// @result the shared NSURLCache instance.
  static NSURLCache getSharedURLCache() {
    objc.checkOsVersionInternal(
      'NSURLCache.sharedURLCache',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSURLCache, _sel_sharedURLCache);
    return NSURLCache.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSURLCache constructed with the default `new` method.
  NSURLCache() : this.as(new$().object$);
}

extension NSURLCache$Methods on NSURLCache {
  /// !
  /// @method cachedResponseForRequest:
  /// @abstract Returns the NSCachedURLResponse stored in the cache with
  /// the given request.
  /// @discussion The method returns nil if there is no
  /// NSCachedURLResponse stored using the given request.
  /// @param request the NSURLRequest to use as a key for the lookup.
  /// @result The NSCachedURLResponse stored in the cache with the given
  /// request, or nil if there is no NSCachedURLResponse stored with the
  /// given request.
  NSCachedURLResponse? cachedResponseForRequest(NSURLRequest request) {
    objc.checkOsVersionInternal(
      'NSURLCache.cachedResponseForRequest:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_cachedResponseForRequest_,
      request.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSCachedURLResponse.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the current amount of space consumed by the
  /// on-disk cache of the receiver.
  /// @discussion This size, measured in bytes, indicates the current
  /// usage of the on-disk cache.
  /// @result the current usage of the on-disk cache of the receiver.
  int get currentDiskUsage {
    objc.checkOsVersionInternal(
      'NSURLCache.currentDiskUsage',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_currentDiskUsage);
  }

  /// !
  /// @abstract Returns the current amount of space consumed by the
  /// in-memory cache of the receiver.
  /// @discussion This size, measured in bytes, indicates the current
  /// usage of the in-memory cache.
  /// @result the current usage of the in-memory cache of the receiver.
  int get currentMemoryUsage {
    objc.checkOsVersionInternal(
      'NSURLCache.currentMemoryUsage',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_currentMemoryUsage);
  }

  /// !
  /// @abstract The on-disk capacity of the receiver.
  /// @discussion The on-disk capacity, measured in bytes, for the receiver. On mutation the on-disk cache will truncate its contents to the size given, if necessary.
  int get diskCapacity {
    objc.checkOsVersionInternal(
      'NSURLCache.diskCapacity',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_diskCapacity);
  }

  /// init
  NSURLCache init() {
    objc.checkOsVersionInternal(
      'NSURLCache.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLCache.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method initWithMemoryCapacity:diskCapacity:directoryURL:
  /// @abstract Initializes an NSURLCache with the given capacity and directory.
  /// @param memoryCapacity the capacity, measured in bytes, for the cache in memory. Or 0 to disable memory cache.
  /// @param diskCapacity the capacity, measured in bytes, for the cache on disk. Or 0 to disable disk cache.
  /// @param directoryURL the path to a directory on disk where the cache data is stored. Or nil for default directory.
  /// @result an initialized NSURLCache, with the given capacity, optionally backed by disk.
  NSURLCache initWithMemoryCapacity(
    int memoryCapacity, {
    required int diskCapacity,
    objc.NSURL? directoryURL,
  }) {
    objc.checkOsVersionInternal(
      'NSURLCache.initWithMemoryCapacity:diskCapacity:directoryURL:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1dqnse5(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithMemoryCapacity_diskCapacity_directoryURL_,
      memoryCapacity,
      diskCapacity,
      directoryURL?.ref.pointer ?? ffi.nullptr,
    );
    return NSURLCache.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method initWithMemoryCapacity:diskCapacity:diskPath:
  /// @abstract Initializes an NSURLCache with the given capacity and
  /// path.
  /// @discussion The returned NSURLCache is backed by disk, so
  /// developers can be more liberal with space when choosing the
  /// capacity for this kind of cache. A disk cache measured in the tens
  /// of megabytes should be acceptable in most cases.
  /// @param memoryCapacity the capacity, measured in bytes, for the cache in memory.
  /// @param diskCapacity the capacity, measured in bytes, for the cache on disk.
  /// @param path the path on disk where the cache data is stored.
  /// @result an initialized NSURLCache, with the given capacity, backed
  /// by disk.
  NSURLCache initWithMemoryCapacity$1(
    int memoryCapacity, {
    required int diskCapacity,
    objc.NSString? diskPath,
  }) {
    objc.checkOsVersionInternal(
      'NSURLCache.initWithMemoryCapacity:diskCapacity:diskPath:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1dqnse5(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithMemoryCapacity_diskCapacity_diskPath_,
      memoryCapacity,
      diskCapacity,
      diskPath?.ref.pointer ?? ffi.nullptr,
    );
    return NSURLCache.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @abstract In-memory capacity of the receiver.
  /// @discussion At the time this call is made, the in-memory cache will truncate its contents to the size given, if necessary.
  /// @result The in-memory capacity, measured in bytes, for the receiver.
  int get memoryCapacity {
    objc.checkOsVersionInternal(
      'NSURLCache.memoryCapacity',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_memoryCapacity);
  }

  /// !
  /// @method removeAllCachedResponses
  /// @abstract Clears the given cache, removing all NSCachedURLResponse
  /// objects that it stores.
  void removeAllCachedResponses() {
    objc.checkOsVersionInternal(
      'NSURLCache.removeAllCachedResponses',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_removeAllCachedResponses);
  }

  /// !
  /// @method removeCachedResponseForRequest:
  /// @abstract Removes the NSCachedURLResponse from the cache that is
  /// stored using the given request.
  /// @discussion No action is taken if there is no NSCachedURLResponse
  /// stored with the given request.
  /// @param request the NSURLRequest to use as a key for the lookup.
  void removeCachedResponseForRequest(NSURLRequest request) {
    objc.checkOsVersionInternal(
      'NSURLCache.removeCachedResponseForRequest:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeCachedResponseForRequest_,
      request.ref.pointer,
    );
  }

  /// !
  /// @method removeCachedResponsesSince:
  /// @abstract Clears the given cache of any cached responses since the provided date.
  void removeCachedResponsesSinceDate(objc.NSDate date) {
    objc.checkOsVersionInternal(
      'NSURLCache.removeCachedResponsesSinceDate:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_removeCachedResponsesSinceDate_,
      date.ref.pointer,
    );
  }

  /// !
  /// @abstract The on-disk capacity of the receiver.
  /// @discussion The on-disk capacity, measured in bytes, for the receiver. On mutation the on-disk cache will truncate its contents to the size given, if necessary.
  set diskCapacity(int value) {
    objc.checkOsVersionInternal(
      'NSURLCache.setDiskCapacity:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_1i9r4xy(object$.ref.pointer, _sel_setDiskCapacity_, value);
  }

  /// !
  /// @abstract In-memory capacity of the receiver.
  /// @discussion At the time this call is made, the in-memory cache will truncate its contents to the size given, if necessary.
  /// @result The in-memory capacity, measured in bytes, for the receiver.
  set memoryCapacity(int value) {
    objc.checkOsVersionInternal(
      'NSURLCache.setMemoryCapacity:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_1i9r4xy(object$.ref.pointer, _sel_setMemoryCapacity_, value);
  }

  /// !
  /// @method storeCachedResponse:forRequest:
  /// @abstract Stores the given NSCachedURLResponse in the cache using
  /// the given request.
  /// @param cachedResponse The cached response to store.
  /// @param request the NSURLRequest to use as a key for the storage.
  void storeCachedResponse(
    NSCachedURLResponse cachedResponse, {
    required NSURLRequest forRequest,
  }) {
    objc.checkOsVersionInternal(
      'NSURLCache.storeCachedResponse:forRequest:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_storeCachedResponse_forRequest_,
      cachedResponse.ref.pointer,
      forRequest.ref.pointer,
    );
  }
}

late final _class_NSMutableURLRequest = objc.getClass("NSMutableURLRequest");
late final _sel_setURL_ = objc.registerName("setURL:");
late final _sel_setCachePolicy_ = objc.registerName("setCachePolicy:");
final _objc_msgSend_1yjxuv2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setTimeoutInterval_ = objc.registerName("setTimeoutInterval:");
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
late final _sel_setMainDocumentURL_ = objc.registerName("setMainDocumentURL:");
late final _sel_setNetworkServiceType_ = objc.registerName(
  "setNetworkServiceType:",
);
final _objc_msgSend_1mse4s1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setAllowsCellularAccess_ = objc.registerName(
  "setAllowsCellularAccess:",
);
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        bool,
      )
    >();
late final _sel_setAllowsExpensiveNetworkAccess_ = objc.registerName(
  "setAllowsExpensiveNetworkAccess:",
);
late final _sel_setAllowsConstrainedNetworkAccess_ = objc.registerName(
  "setAllowsConstrainedNetworkAccess:",
);
late final _sel_setAssumesHTTP3Capable_ = objc.registerName(
  "setAssumesHTTP3Capable:",
);
late final _sel_setAttribution_ = objc.registerName("setAttribution:");
final _objc_msgSend_1nw1jep = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_setRequiresDNSSECValidation_ = objc.registerName(
  "setRequiresDNSSECValidation:",
);
late final _sel_setAllowsPersistentDNS_ = objc.registerName(
  "setAllowsPersistentDNS:",
);
late final _sel_setCookiePartitionIdentifier_ = objc.registerName(
  "setCookiePartitionIdentifier:",
);
late final _sel_setHTTPMethod_ = objc.registerName("setHTTPMethod:");
late final _sel_setAllHTTPHeaderFields_ = objc.registerName(
  "setAllHTTPHeaderFields:",
);
late final _sel_setValue_forHTTPHeaderField_ = objc.registerName(
  "setValue:forHTTPHeaderField:",
);
late final _sel_addValue_forHTTPHeaderField_ = objc.registerName(
  "addValue:forHTTPHeaderField:",
);
late final _sel_setHTTPBody_ = objc.registerName("setHTTPBody:");
late final _sel_setHTTPBodyStream_ = objc.registerName("setHTTPBodyStream:");
late final _sel_setHTTPShouldHandleCookies_ = objc.registerName(
  "setHTTPShouldHandleCookies:",
);
late final _sel_setHTTPShouldUsePipelining_ = objc.registerName(
  "setHTTPShouldUsePipelining:",
);

/// !
/// @category NSMutableURLRequest(NSMutableHTTPURLRequest)
/// The NSMutableHTTPURLRequest on NSMutableURLRequest provides methods
/// for configuring information specific to HTTP protocol requests.
extension NSMutableHTTPURLRequest on NSMutableURLRequest {
  /// !
  /// @abstract Sets the request body data of the receiver.
  /// @discussion This data is sent as the message body of the request, as
  /// in done in an HTTP POST request.
  objc.NSData? get HTTPBody {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.HTTPBody',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_HTTPBody);
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the request body to be the contents of the given stream.
  /// @discussion The provided stream should be unopened; the request will take
  /// over the stream's delegate.  The entire stream's contents will be
  /// transmitted as the HTTP body of the request.  Note that the body stream
  /// and the body data (set by setHTTPBody:, above) are mutually exclusive
  /// - setting one will clear the other.
  objc.NSInputStream? get HTTPBodyStream {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.HTTPBodyStream',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_HTTPBodyStream,
    );
    return $ret.address == 0
        ? null
        : objc.NSInputStream.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the HTTP request method of the receiver.
  objc.NSString get HTTPMethod {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.HTTPMethod',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_HTTPMethod);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Decide whether default cookie handling will happen for
  /// this request (YES if cookies should be sent with and set for this request;
  /// otherwise NO).
  /// @discussion The default is YES - in other words, cookies are sent from and
  /// stored to the cookie manager by default.
  /// NOTE: In releases prior to 10.3, this value is ignored
  bool get HTTPShouldHandleCookies {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.HTTPShouldHandleCookies',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_HTTPShouldHandleCookies,
    );
  }

  /// !
  /// @abstract Sets whether the request should not wait for the previous response
  /// before transmitting (YES if the receiver should transmit before the previous response is
  /// received.  NO to wait for the previous response before transmitting)
  /// @discussion Calling this method with a YES value does not guarantee HTTP
  /// pipelining behavior.  This method may have no effect if an HTTP proxy is
  /// configured, or if the HTTP request uses an unsafe request method (e.g., POST
  /// requests will not pipeline).  Pipelining behavior also may not begin until
  /// the second request on a given TCP connection.  There may be other situations
  /// where pipelining does not occur even though YES was set.
  /// HTTP 1.1 allows the client to send multiple requests to the server without
  /// waiting for a response.  Though HTTP 1.1 requires support for pipelining,
  /// some servers report themselves as being HTTP 1.1 but do not support
  /// pipelining (disconnecting, sending resources misordered, omitting part of
  /// a resource, etc.).
  bool get HTTPShouldUsePipelining {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.HTTPShouldUsePipelining',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_HTTPShouldUsePipelining,
    );
  }

  /// !
  /// @method addValue:forHTTPHeaderField:
  /// @abstract Adds an HTTP header field in the current header
  /// dictionary.
  /// @discussion This method provides a way to add values to header
  /// fields incrementally. If a value was previously set for the given
  /// header field, the given value is appended to the previously-existing
  /// value. The appropriate field delimiter, a comma in the case of HTTP,
  /// is added by the implementation, and should not be added to the given
  /// value by the caller. Note that, in keeping with the HTTP RFC, HTTP
  /// header field names are case-insensitive.
  /// @param value the header field value.
  /// @param field the header field name (case-insensitive).
  void addValue(
    objc.NSString value, {
    required objc.NSString forHTTPHeaderField,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.addValue:forHTTPHeaderField:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_addValue_forHTTPHeaderField_,
      value.ref.pointer,
      forHTTPHeaderField.ref.pointer,
    );
  }

  /// !
  /// @abstract Sets the HTTP header fields of the receiver to the given
  /// dictionary.
  /// @discussion This method replaces all header fields that may have
  /// existed before this method call.
  /// <p>Since HTTP header fields must be string values, each object and
  /// key in the dictionary passed to this method must answer YES when
  /// sent an <tt>-isKindOfClass:[NSString class]</tt> message. If either
  /// the key or value for a key-value pair answers NO when sent this
  /// message, the key-value pair is skipped.
  objc.NSDictionary? get allHTTPHeaderFields {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.allHTTPHeaderFields',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_allHTTPHeaderFields,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the HTTP header fields of the receiver to the given
  /// dictionary.
  /// @discussion This method replaces all header fields that may have
  /// existed before this method call.
  /// <p>Since HTTP header fields must be string values, each object and
  /// key in the dictionary passed to this method must answer YES when
  /// sent an <tt>-isKindOfClass:[NSString class]</tt> message. If either
  /// the key or value for a key-value pair answers NO when sent this
  /// message, the key-value pair is skipped.
  set allHTTPHeaderFields(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setAllHTTPHeaderFields:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setAllHTTPHeaderFields_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// !
  /// @abstract Sets the request body data of the receiver.
  /// @discussion This data is sent as the message body of the request, as
  /// in done in an HTTP POST request.
  set HTTPBody(objc.NSData? value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setHTTPBody:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setHTTPBody_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// !
  /// @abstract Sets the request body to be the contents of the given stream.
  /// @discussion The provided stream should be unopened; the request will take
  /// over the stream's delegate.  The entire stream's contents will be
  /// transmitted as the HTTP body of the request.  Note that the body stream
  /// and the body data (set by setHTTPBody:, above) are mutually exclusive
  /// - setting one will clear the other.
  set HTTPBodyStream(objc.NSInputStream? value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setHTTPBodyStream:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setHTTPBodyStream_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// !
  /// @abstract Sets the HTTP request method of the receiver.
  set HTTPMethod(objc.NSString value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setHTTPMethod:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setHTTPMethod_,
      value.ref.pointer,
    );
  }

  /// !
  /// @abstract Decide whether default cookie handling will happen for
  /// this request (YES if cookies should be sent with and set for this request;
  /// otherwise NO).
  /// @discussion The default is YES - in other words, cookies are sent from and
  /// stored to the cookie manager by default.
  /// NOTE: In releases prior to 10.3, this value is ignored
  set HTTPShouldHandleCookies(bool value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setHTTPShouldHandleCookies:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setHTTPShouldHandleCookies_,
      value,
    );
  }

  /// !
  /// @abstract Sets whether the request should not wait for the previous response
  /// before transmitting (YES if the receiver should transmit before the previous response is
  /// received.  NO to wait for the previous response before transmitting)
  /// @discussion Calling this method with a YES value does not guarantee HTTP
  /// pipelining behavior.  This method may have no effect if an HTTP proxy is
  /// configured, or if the HTTP request uses an unsafe request method (e.g., POST
  /// requests will not pipeline).  Pipelining behavior also may not begin until
  /// the second request on a given TCP connection.  There may be other situations
  /// where pipelining does not occur even though YES was set.
  /// HTTP 1.1 allows the client to send multiple requests to the server without
  /// waiting for a response.  Though HTTP 1.1 requires support for pipelining,
  /// some servers report themselves as being HTTP 1.1 but do not support
  /// pipelining (disconnecting, sending resources misordered, omitting part of
  /// a resource, etc.).
  set HTTPShouldUsePipelining(bool value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setHTTPShouldUsePipelining:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setHTTPShouldUsePipelining_,
      value,
    );
  }

  /// !
  /// @method setValue:forHTTPHeaderField:
  /// @abstract Sets the value of the given HTTP header field.
  /// @discussion If a value was previously set for the given header
  /// field, that value is replaced with the given value. Note that, in
  /// keeping with the HTTP RFC, HTTP header field names are
  /// case-insensitive.
  /// @param value the header field value.
  /// @param field the header field name (case-insensitive).
  void setValue(
    objc.NSString? value, {
    required objc.NSString forHTTPHeaderField,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setValue:forHTTPHeaderField:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_setValue_forHTTPHeaderField_,
      value?.ref.pointer ?? ffi.nullptr,
      forHTTPHeaderField.ref.pointer,
    );
  }
}

/// !
/// @class NSMutableURLRequest
///
/// @abstract An NSMutableURLRequest object represents a mutable URL load
/// request in a manner independent of protocol and URL scheme.
///
/// @discussion This specialization of NSURLRequest is provided to aid
/// developers who may find it more convenient to mutate a single request
/// object for a series of URL loads instead of creating an immutable
/// NSURLRequest for each load. This programming model is supported by
/// the following contract stipulation between NSMutableURLRequest and
/// NSURLConnection: NSURLConnection makes a deep copy of each
/// NSMutableURLRequest object passed to one of its initializers.
/// <p>NSMutableURLRequest is designed to be extended to support
/// protocol-specific data by adding categories to access a property
/// object provided in an interface targeted at protocol implementors.
/// <ul>
/// <li>Protocol implementors should direct their attention to the
/// NSMutableURLRequestExtensibility category on
/// NSMutableURLRequest for more information on how to provide
/// extensions on NSMutableURLRequest to support protocol-specific
/// request information.
/// <li>Clients of this API who wish to create NSMutableURLRequest
/// objects to load URL content should consult the protocol-specific
/// NSMutableURLRequest categories that are available. The
/// NSMutableHTTPURLRequest category on NSMutableURLRequest is an
/// example.
/// </ul>
extension type NSMutableURLRequest._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSURLRequest {
  /// Constructs a [NSMutableURLRequest] that points to the same underlying object as [other].
  NSMutableURLRequest.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSMutableURLRequest] that wraps the given raw object pointer.
  NSMutableURLRequest.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSMutableURLRequest].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSMutableURLRequest,
  );

  /// alloc
  static NSMutableURLRequest alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableURLRequest, _sel_alloc);
    return NSMutableURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSMutableURLRequest allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSMutableURLRequest,
      _sel_allocWithZone_,
      zone,
    );
    return NSMutableURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSMutableURLRequest new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSMutableURLRequest, _sel_new);
    return NSMutableURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method requestWithURL:
  /// @abstract Allocates and initializes an NSURLRequest with the given
  /// URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSMutableURLRequest requestWithURL(objc.NSURL URL) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.requestWithURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSMutableURLRequest,
      _sel_requestWithURL_,
      URL.ref.pointer,
    );
    return NSMutableURLRequest.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @method requestWithURL:cachePolicy:timeoutInterval:
  /// @abstract Allocates and initializes a NSURLRequest with the given
  /// URL and cache policy.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSMutableURLRequest requestWithURL$1(
    objc.NSURL URL, {
    required NSURLRequestCachePolicy cachePolicy,
    required double timeoutInterval,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.requestWithURL:cachePolicy:timeoutInterval:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1ajs603(
      _class_NSMutableURLRequest,
      _sel_requestWithURL_cachePolicy_timeoutInterval_,
      URL.ref.pointer,
      cachePolicy.value,
      timeoutInterval,
    );
    return NSMutableURLRequest.fromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSMutableURLRequest,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of NSMutableURLRequest constructed with the default `new` method.
  NSMutableURLRequest() : this.as(new$().object$);
}

extension NSMutableURLRequest$Methods on NSMutableURLRequest {
  /// !
  /// @abstract The URL of the receiver.
  objc.NSURL? get URL {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.URL',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// the built in cellular radios (if present).
  /// @discussion NO if the receiver should not be allowed to use the built in
  /// cellular radios to satisfy the request, YES otherwise.  The default is YES.
  bool get allowsCellularAccess {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.allowsCellularAccess',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsCellularAccess);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as constrained.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as constrained to
  /// satisfy the request, YES otherwise.
  bool get allowsConstrainedNetworkAccess {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.allowsConstrainedNetworkAccess',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsConstrainedNetworkAccess,
    );
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as expensive.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as expensive to
  /// satisfy the request, YES otherwise.
  bool get allowsExpensiveNetworkAccess {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.allowsExpensiveNetworkAccess',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsExpensiveNetworkAccess,
    );
  }

  /// !
  /// @abstract Allows storing and usage of DNS answers, potentially beyond TTL expiry,
  /// in a persistent per-process cache. This should only be set for hostnames whose resolutions
  /// are not expected to change across networks.
  /// @discussion YES, if the DNS lookup for this request is allowed to use a persistent per-process cache,
  /// NO otherwise. Defaults to NO.
  bool get allowsPersistentDNS {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.allowsPersistentDNS',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsPersistentDNS);
  }

  /// !
  /// @abstract returns whether we assume that server supports HTTP/3. Enables QUIC
  /// racing without HTTP/3 service discovery.
  /// @result YES if server endpoint is known to support HTTP/3. Defaults to NO.
  /// The default may be YES in a future OS update.
  bool get assumesHTTP3Capable {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.assumesHTTP3Capable',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_assumesHTTP3Capable);
  }

  /// !
  /// @abstract Sets the NSURLRequestAttribution to associate with this request.
  /// @discussion Set to NSURLRequestAttributionUser if the URL was specified by the
  /// user. Defaults to NSURLRequestAttributionDeveloper.
  NSURLRequestAttribution get attribution {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.attribution',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_i3avs9(object$.ref.pointer, _sel_attribution);
    return NSURLRequestAttribution.fromValue($ret);
  }

  /// !
  /// @abstract The cache policy of the receiver.
  NSURLRequestCachePolicy get cachePolicy {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.cachePolicy',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_8jm3uo(object$.ref.pointer, _sel_cachePolicy);
    return NSURLRequestCachePolicy.fromValue($ret);
  }

  /// Cookie partition identifier used for cookie storage and retrieval.
  objc.NSString? get cookiePartitionIdentifier {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.cookiePartitionIdentifier',
      iOS: (false, (18, 2, 0)),
      macOS: (false, (15, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_cookiePartitionIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NSMutableURLRequest init() {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSMutableURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSMutableURLRequest? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSMutableURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method initWithURL:
  /// @abstract Initializes an NSURLRequest with the given URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result An initialized NSURLRequest.
  NSMutableURLRequest initWithURL(objc.NSURL URL) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.initWithURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_,
      URL.ref.pointer,
    );
    return NSMutableURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method initWithURL:
  /// @abstract Initializes an NSURLRequest with the given URL and
  /// cache policy.
  /// @discussion This is the designated initializer for the
  /// NSURLRequest class.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result An initialized NSURLRequest.
  NSMutableURLRequest initWithURL$1(
    objc.NSURL URL, {
    required NSURLRequestCachePolicy cachePolicy,
    required double timeoutInterval,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.initWithURL:cachePolicy:timeoutInterval:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_1ajs603(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_cachePolicy_timeoutInterval_,
      URL.ref.pointer,
      cachePolicy.value,
      timeoutInterval,
    );
    return NSMutableURLRequest.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @abstract Sets the main document URL
  /// @discussion The caller should pass the URL for an appropriate main
  /// document, if known. For example, when loading a web page, the URL
  /// of the main html document for the top-level frame should be
  /// passed.  This main document is used to implement the cookie "only
  /// from same domain as main document" policy, attributing this request
  /// as a sub-resource of a user-specified URL, and possibly other things
  /// in the future.
  objc.NSURL? get mainDocumentURL {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.mainDocumentURL',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_mainDocumentURL,
    );
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the NSURLRequestNetworkServiceType to associate with this request
  /// @discussion This method is used to provide the network layers with a hint as to the purpose
  /// of the request.  Most clients should not need to use this method.
  NSURLRequestNetworkServiceType get networkServiceType {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.networkServiceType',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_t4uaw1(
      object$.ref.pointer,
      _sel_networkServiceType,
    );
    return NSURLRequestNetworkServiceType.fromValue($ret);
  }

  /// !
  /// @abstract sets whether a request is required to do DNSSEC validation during DNS lookup.
  /// @discussion YES, if the DNS lookup for this request should require DNSSEC validation,
  /// No otherwise. Defaults to NO.
  bool get requiresDNSSECValidation {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.requiresDNSSECValidation',
      iOS: (false, (16, 1, 0)),
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_requiresDNSSECValidation,
    );
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// the built in cellular radios (if present).
  /// @discussion NO if the receiver should not be allowed to use the built in
  /// cellular radios to satisfy the request, YES otherwise.  The default is YES.
  set allowsCellularAccess$1(bool value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setAllowsCellularAccess:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 8, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsCellularAccess_,
      value,
    );
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as constrained.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as constrained to
  /// satisfy the request, YES otherwise.
  set allowsConstrainedNetworkAccess$1(bool value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setAllowsConstrainedNetworkAccess:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsConstrainedNetworkAccess_,
      value,
    );
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as expensive.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as expensive to
  /// satisfy the request, YES otherwise.
  set allowsExpensiveNetworkAccess$1(bool value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setAllowsExpensiveNetworkAccess:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsExpensiveNetworkAccess_,
      value,
    );
  }

  /// !
  /// @abstract Allows storing and usage of DNS answers, potentially beyond TTL expiry,
  /// in a persistent per-process cache. This should only be set for hostnames whose resolutions
  /// are not expected to change across networks.
  /// @discussion YES, if the DNS lookup for this request is allowed to use a persistent per-process cache,
  /// NO otherwise. Defaults to NO.
  set allowsPersistentDNS$1(bool value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setAllowsPersistentDNS:',
      iOS: (false, (18, 0, 0)),
      macOS: (false, (15, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsPersistentDNS_,
      value,
    );
  }

  /// !
  /// @abstract returns whether we assume that server supports HTTP/3. Enables QUIC
  /// racing without HTTP/3 service discovery.
  /// @result YES if server endpoint is known to support HTTP/3. Defaults to NO.
  /// The default may be YES in a future OS update.
  set assumesHTTP3Capable$1(bool value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setAssumesHTTP3Capable:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAssumesHTTP3Capable_,
      value,
    );
  }

  /// !
  /// @abstract Sets the NSURLRequestAttribution to associate with this request.
  /// @discussion Set to NSURLRequestAttributionUser if the URL was specified by the
  /// user. Defaults to NSURLRequestAttributionDeveloper.
  set attribution$1(NSURLRequestAttribution value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setAttribution:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_1nw1jep(
      object$.ref.pointer,
      _sel_setAttribution_,
      value.value,
    );
  }

  /// !
  /// @abstract The cache policy of the receiver.
  set cachePolicy$1(NSURLRequestCachePolicy value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setCachePolicy:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_1yjxuv2(
      object$.ref.pointer,
      _sel_setCachePolicy_,
      value.value,
    );
  }

  /// Cookie partition identifier used for cookie storage and retrieval.
  set cookiePartitionIdentifier$1(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setCookiePartitionIdentifier:',
      iOS: (false, (18, 2, 0)),
      macOS: (false, (15, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setCookiePartitionIdentifier_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// !
  /// @abstract Sets the main document URL
  /// @discussion The caller should pass the URL for an appropriate main
  /// document, if known. For example, when loading a web page, the URL
  /// of the main html document for the top-level frame should be
  /// passed.  This main document is used to implement the cookie "only
  /// from same domain as main document" policy, attributing this request
  /// as a sub-resource of a user-specified URL, and possibly other things
  /// in the future.
  set mainDocumentURL$1(objc.NSURL? value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setMainDocumentURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setMainDocumentURL_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// !
  /// @abstract Sets the NSURLRequestNetworkServiceType to associate with this request
  /// @discussion This method is used to provide the network layers with a hint as to the purpose
  /// of the request.  Most clients should not need to use this method.
  set networkServiceType$1(NSURLRequestNetworkServiceType value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setNetworkServiceType:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1mse4s1(
      object$.ref.pointer,
      _sel_setNetworkServiceType_,
      value.value,
    );
  }

  /// !
  /// @abstract sets whether a request is required to do DNSSEC validation during DNS lookup.
  /// @discussion YES, if the DNS lookup for this request should require DNSSEC validation,
  /// No otherwise. Defaults to NO.
  set requiresDNSSECValidation$1(bool value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setRequiresDNSSECValidation:',
      iOS: (false, (16, 1, 0)),
      macOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setRequiresDNSSECValidation_,
      value,
    );
  }

  /// !
  /// @abstract Sets the timeout interval of the receiver.
  /// @discussion The timeout interval specifies the limit on the idle
  /// interval allotted to a request in the process of loading. The "idle
  /// interval" is defined as the period of time that has passed since the
  /// last instance of load activity occurred for a request that is in the
  /// process of loading. Hence, when an instance of load activity occurs
  /// (e.g. bytes are received from the network for a request), the idle
  /// interval for a request is reset to 0. If the idle interval ever
  /// becomes greater than or equal to the timeout interval, the request
  /// is considered to have timed out. This timeout interval is measured
  /// in seconds.
  set timeoutInterval$1(double value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setTimeoutInterval:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_hwm8nu(object$.ref.pointer, _sel_setTimeoutInterval_, value);
  }

  /// !
  /// @abstract The URL of the receiver.
  set URL$1(objc.NSURL? value) {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.setURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setURL_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// !
  /// @abstract Sets the timeout interval of the receiver.
  /// @discussion The timeout interval specifies the limit on the idle
  /// interval allotted to a request in the process of loading. The "idle
  /// interval" is defined as the period of time that has passed since the
  /// last instance of load activity occurred for a request that is in the
  /// process of loading. Hence, when an instance of load activity occurs
  /// (e.g. bytes are received from the network for a request), the idle
  /// interval for a request is reset to 0. If the idle interval ever
  /// becomes greater than or equal to the timeout interval, the request
  /// is considered to have timed out. This timeout interval is measured
  /// in seconds.
  double get timeoutInterval {
    objc.checkOsVersionInternal(
      'NSMutableURLRequest.timeoutInterval',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(object$.ref.pointer, _sel_timeoutInterval)
        : _objc_msgSend_1ukqyt8(object$.ref.pointer, _sel_timeoutInterval);
  }
}

enum NSHTTPCookieAcceptPolicy {
  NSHTTPCookieAcceptPolicyAlways(0),
  NSHTTPCookieAcceptPolicyNever(1),
  NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain(2);

  final int value;
  const NSHTTPCookieAcceptPolicy(this.value);

  static NSHTTPCookieAcceptPolicy fromValue(int value) => switch (value) {
    0 => NSHTTPCookieAcceptPolicyAlways,
    1 => NSHTTPCookieAcceptPolicyNever,
    2 => NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain,
    _ => throw ArgumentError(
      'Unknown value for NSHTTPCookieAcceptPolicy: $value',
    ),
  };
}

/// WARNING: NSHTTPCookieStorage is a stub. To generate bindings for this class, include
/// NSHTTPCookieStorage in your config's objc-interfaces list.
///
/// NSHTTPCookieStorage
extension type NSHTTPCookieStorage._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSHTTPCookieStorage] that points to the same underlying object as [other].
  NSHTTPCookieStorage.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSHTTPCookieStorage',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }

  /// Constructs a [NSHTTPCookieStorage] that wraps the given raw object pointer.
  NSHTTPCookieStorage.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSHTTPCookieStorage',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
  }
}

/// WARNING: NSProgressReporting is a stub. To generate bindings for this class, include
/// NSProgressReporting in your config's objc-protocols list.
///
/// NSProgressReporting
extension type NSProgressReporting._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSProgressReporting] that points to the same underlying object as [other].
  NSProgressReporting.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSProgressReporting] that wraps the given raw object pointer.
  NSProgressReporting.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

enum tls_protocol_version_t {
  tls_protocol_version_TLSv10(769),
  tls_protocol_version_TLSv11(770),
  tls_protocol_version_TLSv12(771),
  tls_protocol_version_TLSv13(772),
  tls_protocol_version_DTLSv10(-257),
  tls_protocol_version_DTLSv12(-259);

  final int value;
  const tls_protocol_version_t(this.value);

  static tls_protocol_version_t fromValue(int value) => switch (value) {
    769 => tls_protocol_version_TLSv10,
    770 => tls_protocol_version_TLSv11,
    771 => tls_protocol_version_TLSv12,
    772 => tls_protocol_version_TLSv13,
    -257 => tls_protocol_version_DTLSv10,
    -259 => tls_protocol_version_DTLSv12,
    _ => throw ArgumentError(
      'Unknown value for tls_protocol_version_t: $value',
    ),
  };
}

enum SSLProtocol {
  kSSLProtocolUnknown(0),
  kTLSProtocol1(4),
  kTLSProtocol11(7),
  kTLSProtocol12(8),
  kDTLSProtocol1(9),
  kTLSProtocol13(10),
  kDTLSProtocol12(11),
  kTLSProtocolMaxSupported(999),
  kSSLProtocol2(1),
  kSSLProtocol3(2),
  kSSLProtocol3Only(3),
  kTLSProtocol1Only(5),
  kSSLProtocolAll(6);

  final int value;
  const SSLProtocol(this.value);

  static SSLProtocol fromValue(int value) => switch (value) {
    0 => kSSLProtocolUnknown,
    4 => kTLSProtocol1,
    7 => kTLSProtocol11,
    8 => kTLSProtocol12,
    9 => kDTLSProtocol1,
    10 => kTLSProtocol13,
    11 => kDTLSProtocol12,
    999 => kTLSProtocolMaxSupported,
    1 => kSSLProtocol2,
    2 => kSSLProtocol3,
    3 => kSSLProtocol3Only,
    5 => kTLSProtocol1Only,
    6 => kSSLProtocolAll,
    _ => throw ArgumentError('Unknown value for SSLProtocol: $value'),
  };
}

late final _class_NSURLSession = objc.getClass("NSURLSession");
late final _sel_sharedSession = objc.registerName("sharedSession");
late final _class_NSURLSessionConfiguration = objc.getClass(
  "NSURLSessionConfiguration",
);
late final _sel_defaultSessionConfiguration = objc.registerName(
  "defaultSessionConfiguration",
);
late final _sel_ephemeralSessionConfiguration = objc.registerName(
  "ephemeralSessionConfiguration",
);
late final _sel_backgroundSessionConfigurationWithIdentifier_ = objc
    .registerName("backgroundSessionConfigurationWithIdentifier:");
late final _sel_identifier = objc.registerName("identifier");
late final _sel_requestCachePolicy = objc.registerName("requestCachePolicy");
late final _sel_setRequestCachePolicy_ = objc.registerName(
  "setRequestCachePolicy:",
);
late final _sel_timeoutIntervalForRequest = objc.registerName(
  "timeoutIntervalForRequest",
);
late final _sel_setTimeoutIntervalForRequest_ = objc.registerName(
  "setTimeoutIntervalForRequest:",
);
late final _sel_timeoutIntervalForResource = objc.registerName(
  "timeoutIntervalForResource",
);
late final _sel_setTimeoutIntervalForResource_ = objc.registerName(
  "setTimeoutIntervalForResource:",
);
late final _sel_waitsForConnectivity = objc.registerName(
  "waitsForConnectivity",
);
late final _sel_setWaitsForConnectivity_ = objc.registerName(
  "setWaitsForConnectivity:",
);
late final _sel_isDiscretionary = objc.registerName("isDiscretionary");
late final _sel_setDiscretionary_ = objc.registerName("setDiscretionary:");
late final _sel_sharedContainerIdentifier = objc.registerName(
  "sharedContainerIdentifier",
);
late final _sel_setSharedContainerIdentifier_ = objc.registerName(
  "setSharedContainerIdentifier:",
);
late final _sel_sessionSendsLaunchEvents = objc.registerName(
  "sessionSendsLaunchEvents",
);
late final _sel_setSessionSendsLaunchEvents_ = objc.registerName(
  "setSessionSendsLaunchEvents:",
);
late final _sel_connectionProxyDictionary = objc.registerName(
  "connectionProxyDictionary",
);
late final _sel_setConnectionProxyDictionary_ = objc.registerName(
  "setConnectionProxyDictionary:",
);
late final _sel_TLSMinimumSupportedProtocol = objc.registerName(
  "TLSMinimumSupportedProtocol",
);
final _objc_msgSend_cbopi9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedInt Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setTLSMinimumSupportedProtocol_ = objc.registerName(
  "setTLSMinimumSupportedProtocol:",
);
final _objc_msgSend_268k8x = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedInt,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_TLSMaximumSupportedProtocol = objc.registerName(
  "TLSMaximumSupportedProtocol",
);
late final _sel_setTLSMaximumSupportedProtocol_ = objc.registerName(
  "setTLSMaximumSupportedProtocol:",
);
late final _sel_TLSMinimumSupportedProtocolVersion = objc.registerName(
  "TLSMinimumSupportedProtocolVersion",
);
final _objc_msgSend_9jpwfb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Uint16 Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setTLSMinimumSupportedProtocolVersion_ = objc.registerName(
  "setTLSMinimumSupportedProtocolVersion:",
);
final _objc_msgSend_1mvuct7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Uint16,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_TLSMaximumSupportedProtocolVersion = objc.registerName(
  "TLSMaximumSupportedProtocolVersion",
);
late final _sel_setTLSMaximumSupportedProtocolVersion_ = objc.registerName(
  "setTLSMaximumSupportedProtocolVersion:",
);
late final _sel_HTTPShouldSetCookies = objc.registerName(
  "HTTPShouldSetCookies",
);
late final _sel_setHTTPShouldSetCookies_ = objc.registerName(
  "setHTTPShouldSetCookies:",
);
late final _sel_HTTPCookieAcceptPolicy = objc.registerName(
  "HTTPCookieAcceptPolicy",
);
final _objc_msgSend_104dkoq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setHTTPCookieAcceptPolicy_ = objc.registerName(
  "setHTTPCookieAcceptPolicy:",
);
final _objc_msgSend_3q55ys = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_HTTPAdditionalHeaders = objc.registerName(
  "HTTPAdditionalHeaders",
);
late final _sel_setHTTPAdditionalHeaders_ = objc.registerName(
  "setHTTPAdditionalHeaders:",
);
late final _sel_HTTPMaximumConnectionsPerHost = objc.registerName(
  "HTTPMaximumConnectionsPerHost",
);
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setHTTPMaximumConnectionsPerHost_ = objc.registerName(
  "setHTTPMaximumConnectionsPerHost:",
);
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_HTTPCookieStorage = objc.registerName("HTTPCookieStorage");
late final _sel_setHTTPCookieStorage_ = objc.registerName(
  "setHTTPCookieStorage:",
);

/// WARNING: NSURLCredentialStorage is a stub. To generate bindings for this class, include
/// NSURLCredentialStorage in your config's objc-interfaces list.
///
/// NSURLCredentialStorage
extension type NSURLCredentialStorage._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [NSURLCredentialStorage] that points to the same underlying object as [other].
  NSURLCredentialStorage.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [NSURLCredentialStorage] that wraps the given raw object pointer.
  NSURLCredentialStorage.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_URLCredentialStorage = objc.registerName(
  "URLCredentialStorage",
);
late final _sel_setURLCredentialStorage_ = objc.registerName(
  "setURLCredentialStorage:",
);
late final _sel_URLCache = objc.registerName("URLCache");
late final _sel_setURLCache_ = objc.registerName("setURLCache:");
late final _sel_shouldUseExtendedBackgroundIdleMode = objc.registerName(
  "shouldUseExtendedBackgroundIdleMode",
);
late final _sel_setShouldUseExtendedBackgroundIdleMode_ = objc.registerName(
  "setShouldUseExtendedBackgroundIdleMode:",
);
late final _sel_protocolClasses = objc.registerName("protocolClasses");
late final _sel_setProtocolClasses_ = objc.registerName("setProtocolClasses:");

/// !
/// @enum NSURLSessionMultipathServiceType
///
/// @discussion The NSURLSessionMultipathServiceType enum defines constants that
/// can be used to specify the multipath service type to associate an NSURLSession.  The
/// multipath service type determines whether multipath TCP should be attempted and the conditions
/// for creating and switching between subflows.  Using these service types requires the appropriate entitlement.  Any connection attempt will fail if the process does not have the required entitlement.
/// A primary interface is a generally less expensive interface in terms of both cost and power (such as WiFi or ethernet).  A secondary interface is more expensive (such as 3G or LTE).
///
/// @constant NSURLSessionMultipathServiceTypeNone Specifies that multipath tcp should not be used.  Connections will use a single flow.
/// This is the default value.  No entitlement is required to set this value.
///
/// @constant NSURLSessionMultipathServiceTypeHandover Specifies that a secondary subflow should only be used
/// when the primary subflow is not performing adequately.   Requires the com.apple.developer.networking.multipath entitlement.
///
/// @constant NSURLSessionMultipathServiceTypeInteractive Specifies that a secondary subflow should be used if the
/// primary subflow is not performing adequately (packet loss, high round trip times, bandwidth issues).  The secondary
/// subflow will be created more aggressively than with NSURLSessionMultipathServiceTypeHandover.  Requires the com.apple.developer.networking.multipath entitlement.
///
/// @constant NSURLSessionMultipathServiceTypeAggregate Specifies that multiple subflows across multiple interfaces should be
/// used for better bandwidth.  This mode is only available for experimentation on devices configured for development use.
/// It can be enabled in the Developer section of the Settings app.
enum NSURLSessionMultipathServiceType {
  /// None - no multipath (default)
  NSURLSessionMultipathServiceTypeNone(0),

  /// Handover - secondary flows brought up when primary flow is not performing adequately.
  NSURLSessionMultipathServiceTypeHandover(1),

  /// Interactive - secondary flows created more aggressively.
  NSURLSessionMultipathServiceTypeInteractive(2),

  /// Aggregate - multiple subflows used for greater bandwidth.
  NSURLSessionMultipathServiceTypeAggregate(3);

  final int value;
  const NSURLSessionMultipathServiceType(this.value);

  static NSURLSessionMultipathServiceType fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionMultipathServiceTypeNone,
        1 => NSURLSessionMultipathServiceTypeHandover,
        2 => NSURLSessionMultipathServiceTypeInteractive,
        3 => NSURLSessionMultipathServiceTypeAggregate,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionMultipathServiceType: $value',
        ),
      };
}

late final _sel_multipathServiceType = objc.registerName(
  "multipathServiceType",
);
final _objc_msgSend_1wxwnc0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setMultipathServiceType_ = objc.registerName(
  "setMultipathServiceType:",
);
final _objc_msgSend_1hx005a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_usesClassicLoadingMode = objc.registerName(
  "usesClassicLoadingMode",
);
late final _sel_setUsesClassicLoadingMode_ = objc.registerName(
  "setUsesClassicLoadingMode:",
);
late final _sel_enablesEarlyData = objc.registerName("enablesEarlyData");
late final _sel_setEnablesEarlyData_ = objc.registerName(
  "setEnablesEarlyData:",
);
late final _sel_backgroundSessionConfiguration_ = objc.registerName(
  "backgroundSessionConfiguration:",
);

/// NSURLSessionDeprecated
extension NSURLSessionDeprecated on NSURLSessionConfiguration {
  /// backgroundSessionConfiguration:
  static NSURLSessionConfiguration backgroundSessionConfiguration(
    objc.NSString identifier,
  ) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.backgroundSessionConfiguration:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSURLSessionConfiguration,
      _sel_backgroundSessionConfiguration_,
      identifier.ref.pointer,
    );
    return NSURLSessionConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }
}

/// Configuration options for an NSURLSession.  When a session is
/// created, a copy of the configuration object is made - you cannot
/// modify the configuration of a session after it has been created.
///
/// The shared session uses the global credential, cache and cookie
/// storage objects.
///
/// An ephemeral session has no persistent disk storage for cookies,
/// cache or credentials.
///
/// A background session can be used to perform networking operations
/// on behalf of a suspended application, within certain constraints.
extension type NSURLSessionConfiguration._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, objc.NSCopying {
  /// Constructs a [NSURLSessionConfiguration] that points to the same underlying object as [other].
  NSURLSessionConfiguration.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSURLSessionConfiguration] that wraps the given raw object pointer.
  NSURLSessionConfiguration.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLSessionConfiguration].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLSessionConfiguration,
  );

  /// alloc
  static NSURLSessionConfiguration alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSURLSessionConfiguration,
      _sel_alloc,
    );
    return NSURLSessionConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSURLSessionConfiguration allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLSessionConfiguration,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLSessionConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// backgroundSessionConfigurationWithIdentifier:
  static NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier(
    objc.NSString identifier,
  ) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSURLSessionConfiguration,
      _sel_backgroundSessionConfigurationWithIdentifier_,
      identifier.ref.pointer,
    );
    return NSURLSessionConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// defaultSessionConfiguration
  static NSURLSessionConfiguration getDefaultSessionConfiguration() {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.defaultSessionConfiguration',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _class_NSURLSessionConfiguration,
      _sel_defaultSessionConfiguration,
    );
    return NSURLSessionConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// ephemeralSessionConfiguration
  static NSURLSessionConfiguration getEphemeralSessionConfiguration() {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.ephemeralSessionConfiguration',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _class_NSURLSessionConfiguration,
      _sel_ephemeralSessionConfiguration,
    );
    return NSURLSessionConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// new
  static NSURLSessionConfiguration new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSURLSessionConfiguration,
      _sel_new,
    );
    return NSURLSessionConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NSURLSessionConfiguration constructed with the default `new` method.
  NSURLSessionConfiguration() : this.as(new$().object$);
}

extension NSURLSessionConfiguration$Methods on NSURLSessionConfiguration {
  /// Specifies additional headers which will be set on outgoing requests.
  /// Note that these headers are added to the request only if not already present.
  objc.NSDictionary? get HTTPAdditionalHeaders {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.HTTPAdditionalHeaders',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_HTTPAdditionalHeaders,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage.
  NSHTTPCookieAcceptPolicy get HTTPCookieAcceptPolicy {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.HTTPCookieAcceptPolicy',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_104dkoq(
      object$.ref.pointer,
      _sel_HTTPCookieAcceptPolicy,
    );
    return NSHTTPCookieAcceptPolicy.fromValue($ret);
  }

  /// The cookie storage object to use, or nil to indicate that no cookies should be handled
  NSHTTPCookieStorage? get HTTPCookieStorage {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.HTTPCookieStorage',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_HTTPCookieStorage,
    );
    return $ret.address == 0
        ? null
        : NSHTTPCookieStorage.fromPointer($ret, retain: true, release: true);
  }

  /// The maximum number of simultaneous persistent connections per host
  int get HTTPMaximumConnectionsPerHost {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.HTTPMaximumConnectionsPerHost',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_1hz7y9r(
      object$.ref.pointer,
      _sel_HTTPMaximumConnectionsPerHost,
    );
  }

  /// Allow the session to set cookies on requests
  bool get HTTPShouldSetCookies {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.HTTPShouldSetCookies',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_HTTPShouldSetCookies);
  }

  /// Allow the use of HTTP pipelining
  bool get HTTPShouldUsePipelining {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.HTTPShouldUsePipelining',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_HTTPShouldUsePipelining,
    );
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  SSLProtocol get TLSMaximumSupportedProtocol {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.TLSMaximumSupportedProtocol',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_cbopi9(
      object$.ref.pointer,
      _sel_TLSMaximumSupportedProtocol,
    );
    return SSLProtocol.fromValue($ret);
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  tls_protocol_version_t get TLSMaximumSupportedProtocolVersion {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.TLSMaximumSupportedProtocolVersion',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_9jpwfb(
      object$.ref.pointer,
      _sel_TLSMaximumSupportedProtocolVersion,
    );
    return tls_protocol_version_t.fromValue($ret);
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  SSLProtocol get TLSMinimumSupportedProtocol {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.TLSMinimumSupportedProtocol',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_cbopi9(
      object$.ref.pointer,
      _sel_TLSMinimumSupportedProtocol,
    );
    return SSLProtocol.fromValue($ret);
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  tls_protocol_version_t get TLSMinimumSupportedProtocolVersion {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.TLSMinimumSupportedProtocolVersion',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_9jpwfb(
      object$.ref.pointer,
      _sel_TLSMinimumSupportedProtocolVersion,
    );
    return tls_protocol_version_t.fromValue($ret);
  }

  /// The URL resource cache, or nil to indicate that no caching is to be performed
  NSURLCache? get URLCache {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.URLCache',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URLCache);
    return $ret.address == 0
        ? null
        : NSURLCache.fromPointer($ret, retain: true, release: true);
  }

  /// The credential storage object, or nil to indicate that no credential storage is to be used
  NSURLCredentialStorage? get URLCredentialStorage {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.URLCredentialStorage',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_URLCredentialStorage,
    );
    return $ret.address == 0
        ? null
        : NSURLCredentialStorage.fromPointer($ret, retain: true, release: true);
  }

  /// allow request to route over cellular.
  bool get allowsCellularAccess {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.allowsCellularAccess',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_allowsCellularAccess);
  }

  /// allow request to route over networks in constrained mode. Defaults to YES.
  bool get allowsConstrainedNetworkAccess {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.allowsConstrainedNetworkAccess',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsConstrainedNetworkAccess,
    );
  }

  /// allow request to route over expensive networks.  Defaults to YES.
  bool get allowsExpensiveNetworkAccess {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.allowsExpensiveNetworkAccess',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_allowsExpensiveNetworkAccess,
    );
  }

  /// The proxy dictionary, as described by <CFNetwork/CFHTTPStream.h>
  objc.NSDictionary? get connectionProxyDictionary {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.connectionProxyDictionary',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_connectionProxyDictionary,
    );
    return $ret.address == 0
        ? null
        : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// Enables HTTP/3 0-RTT early data transmission of safe requests (GET or HEAD
  /// requests).
  ///
  /// WARNING: Inclusion in TLS early data changes the security guarantees offered
  /// by TLS.
  ///
  /// Requests sent in early data are not covered by anti-replay security
  /// protections. Early data must be idempotent and the impact of adversarial
  /// replays must be carefully evaluated, as the data may be replayed. Early data
  /// also does not provide full forward secrecy; data transmitted is more
  /// susceptible to data breach and security compromise of the server, even if
  /// the breach happens after the data was transmitted.
  ///
  /// See Section 8 of RFC8446 for more details.
  ///
  /// https://datatracker.ietf.org/doc/html/rfc8446#section-8
  ///
  /// See RFC8470 for additional discussion and security considerations.
  ///
  /// https://datatracker.ietf.org/doc/html/rfc8470
  ///
  /// If these risks are acceptable for your use case, set this property to YES.
  /// If unsure, NO is the safest option.
  ///
  /// NOTE: Not supported in the classic loading mode.
  ///
  /// Defaults to NO.
  bool get enablesEarlyData {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.enablesEarlyData',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_enablesEarlyData);
  }

  /// identifier for the background session configuration
  objc.NSString? get identifier {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.identifier',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_identifier);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NSURLSessionConfiguration init() {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLSessionConfiguration.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allows background tasks to be scheduled at the discretion of the system for optimal performance.
  bool get isDiscretionary {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.isDiscretionary',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isDiscretionary);
  }

  /// multipath service type to use for connections.  The default is NSURLSessionMultipathServiceTypeNone
  NSURLSessionMultipathServiceType get multipathServiceType {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.multipathServiceType',
      iOS: (false, (11, 0, 0)),
      macOS: (true, null),
    );
    final $ret = _objc_msgSend_1wxwnc0(
      object$.ref.pointer,
      _sel_multipathServiceType,
    );
    return NSURLSessionMultipathServiceType.fromValue($ret);
  }

  /// type of service for requests.
  NSURLRequestNetworkServiceType get networkServiceType {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.networkServiceType',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_t4uaw1(
      object$.ref.pointer,
      _sel_networkServiceType,
    );
    return NSURLRequestNetworkServiceType.fromValue($ret);
  }

  /// An optional array of Class objects which subclass NSURLProtocol.
  /// The Class will be sent +canInitWithRequest: when determining if
  /// an instance of the class can be used for a given URL scheme.
  /// You should not use +[NSURLProtocol registerClass:], as that
  /// method will register your class with the default session rather
  /// than with an instance of NSURLSession.
  /// Custom NSURLProtocol subclasses are not available to background
  /// sessions.
  objc.NSArray? get protocolClasses {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.protocolClasses',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_protocolClasses,
    );
    return $ret.address == 0
        ? null
        : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// default cache policy for requests
  NSURLRequestCachePolicy get requestCachePolicy {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.requestCachePolicy',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_8jm3uo(
      object$.ref.pointer,
      _sel_requestCachePolicy,
    );
    return NSURLRequestCachePolicy.fromValue($ret);
  }

  /// requires requests from the session to be made with DNSSEC validation enabled. Defaults to NO.
  bool get requiresDNSSECValidation {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.requiresDNSSECValidation',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_requiresDNSSECValidation,
    );
  }

  /// Allows the app to be resumed or launched in the background when tasks in background sessions complete
  /// or when auth is required. This only applies to configurations created with +backgroundSessionConfigurationWithIdentifier:
  /// and the default value is YES.
  ///
  /// NOTE: macOS apps based on AppKit do not support background launch.
  bool get sessionSendsLaunchEvents {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.sessionSendsLaunchEvents',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_sessionSendsLaunchEvents,
    );
  }

  /// allow request to route over cellular.
  set allowsCellularAccess(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setAllowsCellularAccess:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsCellularAccess_,
      value,
    );
  }

  /// allow request to route over networks in constrained mode. Defaults to YES.
  set allowsConstrainedNetworkAccess(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setAllowsConstrainedNetworkAccess:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsConstrainedNetworkAccess_,
      value,
    );
  }

  /// allow request to route over expensive networks.  Defaults to YES.
  set allowsExpensiveNetworkAccess(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setAllowsExpensiveNetworkAccess:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setAllowsExpensiveNetworkAccess_,
      value,
    );
  }

  /// The proxy dictionary, as described by <CFNetwork/CFHTTPStream.h>
  set connectionProxyDictionary(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setConnectionProxyDictionary:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setConnectionProxyDictionary_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// allows background tasks to be scheduled at the discretion of the system for optimal performance.
  set isDiscretionary(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setDiscretionary:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setDiscretionary_, value);
  }

  /// Enables HTTP/3 0-RTT early data transmission of safe requests (GET or HEAD
  /// requests).
  ///
  /// WARNING: Inclusion in TLS early data changes the security guarantees offered
  /// by TLS.
  ///
  /// Requests sent in early data are not covered by anti-replay security
  /// protections. Early data must be idempotent and the impact of adversarial
  /// replays must be carefully evaluated, as the data may be replayed. Early data
  /// also does not provide full forward secrecy; data transmitted is more
  /// susceptible to data breach and security compromise of the server, even if
  /// the breach happens after the data was transmitted.
  ///
  /// See Section 8 of RFC8446 for more details.
  ///
  /// https://datatracker.ietf.org/doc/html/rfc8446#section-8
  ///
  /// See RFC8470 for additional discussion and security considerations.
  ///
  /// https://datatracker.ietf.org/doc/html/rfc8470
  ///
  /// If these risks are acceptable for your use case, set this property to YES.
  /// If unsure, NO is the safest option.
  ///
  /// NOTE: Not supported in the classic loading mode.
  ///
  /// Defaults to NO.
  set enablesEarlyData(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setEnablesEarlyData:',
      iOS: (false, (26, 0, 0)),
      macOS: (false, (26, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setEnablesEarlyData_,
      value,
    );
  }

  /// Specifies additional headers which will be set on outgoing requests.
  /// Note that these headers are added to the request only if not already present.
  set HTTPAdditionalHeaders(objc.NSDictionary? value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setHTTPAdditionalHeaders:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setHTTPAdditionalHeaders_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage.
  set HTTPCookieAcceptPolicy(NSHTTPCookieAcceptPolicy value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setHTTPCookieAcceptPolicy:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_3q55ys(
      object$.ref.pointer,
      _sel_setHTTPCookieAcceptPolicy_,
      value.value,
    );
  }

  /// The cookie storage object to use, or nil to indicate that no cookies should be handled
  set HTTPCookieStorage(NSHTTPCookieStorage? value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setHTTPCookieStorage:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setHTTPCookieStorage_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// The maximum number of simultaneous persistent connections per host
  set HTTPMaximumConnectionsPerHost(int value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setHTTPMaximumConnectionsPerHost:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_4sp4xj(
      object$.ref.pointer,
      _sel_setHTTPMaximumConnectionsPerHost_,
      value,
    );
  }

  /// Allow the session to set cookies on requests
  set HTTPShouldSetCookies(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setHTTPShouldSetCookies:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setHTTPShouldSetCookies_,
      value,
    );
  }

  /// Allow the use of HTTP pipelining
  set HTTPShouldUsePipelining(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setHTTPShouldUsePipelining:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setHTTPShouldUsePipelining_,
      value,
    );
  }

  /// multipath service type to use for connections.  The default is NSURLSessionMultipathServiceTypeNone
  set multipathServiceType(NSURLSessionMultipathServiceType value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setMultipathServiceType:',
      iOS: (false, (11, 0, 0)),
      macOS: (true, null),
    );
    _objc_msgSend_1hx005a(
      object$.ref.pointer,
      _sel_setMultipathServiceType_,
      value.value,
    );
  }

  /// type of service for requests.
  set networkServiceType(NSURLRequestNetworkServiceType value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setNetworkServiceType:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1mse4s1(
      object$.ref.pointer,
      _sel_setNetworkServiceType_,
      value.value,
    );
  }

  /// An optional array of Class objects which subclass NSURLProtocol.
  /// The Class will be sent +canInitWithRequest: when determining if
  /// an instance of the class can be used for a given URL scheme.
  /// You should not use +[NSURLProtocol registerClass:], as that
  /// method will register your class with the default session rather
  /// than with an instance of NSURLSession.
  /// Custom NSURLProtocol subclasses are not available to background
  /// sessions.
  set protocolClasses(objc.NSArray? value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setProtocolClasses:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setProtocolClasses_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// default cache policy for requests
  set requestCachePolicy(NSURLRequestCachePolicy value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setRequestCachePolicy:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1yjxuv2(
      object$.ref.pointer,
      _sel_setRequestCachePolicy_,
      value.value,
    );
  }

  /// requires requests from the session to be made with DNSSEC validation enabled. Defaults to NO.
  set requiresDNSSECValidation(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setRequiresDNSSECValidation:',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setRequiresDNSSECValidation_,
      value,
    );
  }

  /// Allows the app to be resumed or launched in the background when tasks in background sessions complete
  /// or when auth is required. This only applies to configurations created with +backgroundSessionConfigurationWithIdentifier:
  /// and the default value is YES.
  ///
  /// NOTE: macOS apps based on AppKit do not support background launch.
  set sessionSendsLaunchEvents(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setSessionSendsLaunchEvents:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setSessionSendsLaunchEvents_,
      value,
    );
  }

  /// The identifier of the shared data container into which files in background sessions should be downloaded.
  /// App extensions wishing to use background sessions *must* set this property to a valid container identifier, or
  /// all transfers in that session will fail with NSURLErrorBackgroundSessionRequiresSharedContainer.
  set sharedContainerIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setSharedContainerIdentifier:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setSharedContainerIdentifier_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setShouldUseExtendedBackgroundIdleMode:
  set shouldUseExtendedBackgroundIdleMode(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setShouldUseExtendedBackgroundIdleMode:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setShouldUseExtendedBackgroundIdleMode_,
      value,
    );
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  set TLSMaximumSupportedProtocol(SSLProtocol value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setTLSMaximumSupportedProtocol:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_268k8x(
      object$.ref.pointer,
      _sel_setTLSMaximumSupportedProtocol_,
      value.value,
    );
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  set TLSMaximumSupportedProtocolVersion(tls_protocol_version_t value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setTLSMaximumSupportedProtocolVersion:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1mvuct7(
      object$.ref.pointer,
      _sel_setTLSMaximumSupportedProtocolVersion_,
      value.value,
    );
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  set TLSMinimumSupportedProtocol(SSLProtocol value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setTLSMinimumSupportedProtocol:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_268k8x(
      object$.ref.pointer,
      _sel_setTLSMinimumSupportedProtocol_,
      value.value,
    );
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  set TLSMinimumSupportedProtocolVersion(tls_protocol_version_t value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setTLSMinimumSupportedProtocolVersion:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_1mvuct7(
      object$.ref.pointer,
      _sel_setTLSMinimumSupportedProtocolVersion_,
      value.value,
    );
  }

  /// default timeout for requests.  This will cause a timeout if no data is transmitted for the given timeout value, and is reset whenever data is transmitted.
  set timeoutIntervalForRequest(double value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setTimeoutIntervalForRequest:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_hwm8nu(
      object$.ref.pointer,
      _sel_setTimeoutIntervalForRequest_,
      value,
    );
  }

  /// default timeout for requests.  This will cause a timeout if a resource is not able to be retrieved within a given timeout.
  set timeoutIntervalForResource(double value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setTimeoutIntervalForResource:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_hwm8nu(
      object$.ref.pointer,
      _sel_setTimeoutIntervalForResource_,
      value,
    );
  }

  /// The URL resource cache, or nil to indicate that no caching is to be performed
  set URLCache(NSURLCache? value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setURLCache:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setURLCache_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// The credential storage object, or nil to indicate that no credential storage is to be used
  set URLCredentialStorage(NSURLCredentialStorage? value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setURLCredentialStorage:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setURLCredentialStorage_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Uses the classic network loader.
  ///
  /// NOTE: FTP and HTTP/1 pipelining are only supported in the classic loading mode.
  ///
  /// Defaults to YES. The default may be NO in a future OS update.
  set usesClassicLoadingMode(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setUsesClassicLoadingMode:',
      iOS: (false, (18, 4, 0)),
      macOS: (false, (15, 4, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setUsesClassicLoadingMode_,
      value,
    );
  }

  /// Causes tasks to wait for network connectivity to become available, rather
  /// than immediately failing with an error (such as NSURLErrorNotConnectedToInternet)
  /// when it is not. When waiting for connectivity, the timeoutIntervalForRequest
  /// property does not apply, but the timeoutIntervalForResource property does.
  ///
  /// Unsatisfactory connectivity (that requires waiting) includes cases where the
  /// device has limited or insufficient connectivity for a task (e.g., only has a
  /// cellular connection but the allowsCellularAccess property is NO, or requires
  /// a VPN connection in order to reach the desired host).
  ///
  /// Default value is NO. Ignored by background sessions, as background sessions
  /// always wait for connectivity.
  set waitsForConnectivity(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.setWaitsForConnectivity:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setWaitsForConnectivity_,
      value,
    );
  }

  /// The identifier of the shared data container into which files in background sessions should be downloaded.
  /// App extensions wishing to use background sessions *must* set this property to a valid container identifier, or
  /// all transfers in that session will fail with NSURLErrorBackgroundSessionRequiresSharedContainer.
  objc.NSString? get sharedContainerIdentifier {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.sharedContainerIdentifier',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_sharedContainerIdentifier,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// shouldUseExtendedBackgroundIdleMode
  bool get shouldUseExtendedBackgroundIdleMode {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.shouldUseExtendedBackgroundIdleMode',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_shouldUseExtendedBackgroundIdleMode,
    );
  }

  /// default timeout for requests.  This will cause a timeout if no data is transmitted for the given timeout value, and is reset whenever data is transmitted.
  double get timeoutIntervalForRequest {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.timeoutIntervalForRequest',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_timeoutIntervalForRequest,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_timeoutIntervalForRequest,
          );
  }

  /// default timeout for requests.  This will cause a timeout if a resource is not able to be retrieved within a given timeout.
  double get timeoutIntervalForResource {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.timeoutIntervalForResource',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            object$.ref.pointer,
            _sel_timeoutIntervalForResource,
          )
        : _objc_msgSend_1ukqyt8(
            object$.ref.pointer,
            _sel_timeoutIntervalForResource,
          );
  }

  /// Uses the classic network loader.
  ///
  /// NOTE: FTP and HTTP/1 pipelining are only supported in the classic loading mode.
  ///
  /// Defaults to YES. The default may be NO in a future OS update.
  bool get usesClassicLoadingMode {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.usesClassicLoadingMode',
      iOS: (false, (18, 4, 0)),
      macOS: (false, (15, 4, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_usesClassicLoadingMode,
    );
  }

  /// Causes tasks to wait for network connectivity to become available, rather
  /// than immediately failing with an error (such as NSURLErrorNotConnectedToInternet)
  /// when it is not. When waiting for connectivity, the timeoutIntervalForRequest
  /// property does not apply, but the timeoutIntervalForResource property does.
  ///
  /// Unsatisfactory connectivity (that requires waiting) includes cases where the
  /// device has limited or insufficient connectivity for a task (e.g., only has a
  /// cellular connection but the allowsCellularAccess property is NO, or requires
  /// a VPN connection in order to reach the desired host).
  ///
  /// Default value is NO. Ignored by background sessions, as background sessions
  /// always wait for connectivity.
  bool get waitsForConnectivity {
    objc.checkOsVersionInternal(
      'NSURLSessionConfiguration.waitsForConnectivity',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_waitsForConnectivity);
  }
}

late final _sel_sessionWithConfiguration_ = objc.registerName(
  "sessionWithConfiguration:",
);

/// WARNING: NSURLSessionDelegate is a stub. To generate bindings for this class, include
/// NSURLSessionDelegate in your config's objc-protocols list.
///
/// Messages related to the URL session as a whole
extension type NSURLSessionDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, objc.NSObjectProtocol {
  /// Constructs a [NSURLSessionDelegate] that points to the same underlying object as [other].
  NSURLSessionDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSURLSessionDelegate] that wraps the given raw object pointer.
  NSURLSessionDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _class_NSOperationQueue = objc.getClass("NSOperationQueue");
late final _sel_progress = objc.registerName("progress");

/// Construction methods for `objc.ObjCBlock<objc.NSProgress Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSProgress Function(ffi.Pointer<ffi.Void>)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSProgress Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSProgress Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSProgress Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSProgress Function(ffi.Pointer<ffi.Void>)>
  fromFunction(
    objc.NSProgress Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSProgress Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)
      >()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSProgress Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSProgress_ffiVoid$CallExtension
    on objc.ObjCBlock<objc.NSProgress Function(ffi.Pointer<ffi.Void>)> {
  objc.NSProgress call(ffi.Pointer<ffi.Void> arg0) =>
      objc.NSProgress.fromPointer(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                )
              >
            >()
            .asFunction<
              ffi.Pointer<objc.ObjCObjectImpl> Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
              )
            >()(ref.pointer, arg0),
        retain: true,
        release: true,
      );
}

/// WARNING: NSOperation is a stub. To generate bindings for this class, include
/// NSOperation in your config's objc-interfaces list.
///
/// NSOperation
extension type NSOperation._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSOperation] that points to the same underlying object as [other].
  NSOperation.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSOperation',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
  }

  /// Constructs a [NSOperation] that wraps the given raw object pointer.
  NSOperation.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSOperation',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
  }
}

late final _sel_addOperation_ = objc.registerName("addOperation:");
late final _sel_addOperations_waitUntilFinished_ = objc.registerName(
  "addOperations:waitUntilFinished:",
);
final _objc_msgSend_6p7ndb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newClosureBlock(_closureCallable, () => fn(), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(
    void Function() fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1pl9qdv(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) {
    (objc.getBlockClosure(block) as void Function())();
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function())();
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function()>>()
      .asFunction<void Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block) =>
      (objc.getBlockClosure(block) as void Function())();
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

late final _sel_addOperationWithBlock_ = objc.registerName(
  "addOperationWithBlock:",
);
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_addBarrierBlock_ = objc.registerName("addBarrierBlock:");
late final _sel_maxConcurrentOperationCount = objc.registerName(
  "maxConcurrentOperationCount",
);
late final _sel_setMaxConcurrentOperationCount_ = objc.registerName(
  "setMaxConcurrentOperationCount:",
);
late final _sel_isSuspended = objc.registerName("isSuspended");
late final _sel_setSuspended_ = objc.registerName("setSuspended:");
late final _sel_name = objc.registerName("name");
late final _sel_setName_ = objc.registerName("setName:");
late final _sel_qualityOfService = objc.registerName("qualityOfService");
final _objc_msgSend_oi8iq9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setQualityOfService_ = objc.registerName(
  "setQualityOfService:",
);
final _objc_msgSend_n2da1l = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_underlyingQueue = objc.registerName("underlyingQueue");
late final _sel_setUnderlyingQueue_ = objc.registerName("setUnderlyingQueue:");
late final _sel_cancelAllOperations = objc.registerName("cancelAllOperations");
late final _sel_waitUntilAllOperationsAreFinished = objc.registerName(
  "waitUntilAllOperationsAreFinished",
);
late final _sel_currentQueue = objc.registerName("currentQueue");
late final _sel_mainQueue = objc.registerName("mainQueue");
late final _sel_operations = objc.registerName("operations");
late final _sel_operationCount = objc.registerName("operationCount");

/// NSDeprecated
extension NSDeprecated on NSOperationQueue {
  /// operationCount
  int get operationCount {
    objc.checkOsVersionInternal(
      'NSOperationQueue.operationCount',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_operationCount);
  }

  /// These two functions are inherently a race condition and should be avoided if possible
  objc.NSArray get operations {
    objc.checkOsVersionInternal(
      'NSOperationQueue.operations',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_operations);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

/// NSOperationQueue
extension type NSOperationQueue._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, NSProgressReporting {
  /// Constructs a [NSOperationQueue] that points to the same underlying object as [other].
  NSOperationQueue.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [NSOperationQueue] that wraps the given raw object pointer.
  NSOperationQueue.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSOperationQueue].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSOperationQueue,
  );

  /// alloc
  static NSOperationQueue alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSOperationQueue, _sel_alloc);
    return NSOperationQueue.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSOperationQueue allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSOperationQueue,
      _sel_allocWithZone_,
      zone,
    );
    return NSOperationQueue.fromPointer($ret, retain: false, release: true);
  }

  /// currentQueue
  static NSOperationQueue? getCurrentQueue() {
    objc.checkOsVersionInternal(
      'NSOperationQueue.currentQueue',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      _class_NSOperationQueue,
      _sel_currentQueue,
    );
    return $ret.address == 0
        ? null
        : NSOperationQueue.fromPointer($ret, retain: true, release: true);
  }

  /// mainQueue
  static NSOperationQueue getMainQueue() {
    objc.checkOsVersionInternal(
      'NSOperationQueue.mainQueue',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSOperationQueue, _sel_mainQueue);
    return NSOperationQueue.fromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSOperationQueue new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSOperationQueue, _sel_new);
    return NSOperationQueue.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSOperationQueue constructed with the default `new` method.
  NSOperationQueue() : this.as(new$().object$);
}

extension NSOperationQueue$Methods on NSOperationQueue {
  /// @method addBarrierBlock:
  /// @param barrier      A block to execute
  /// @discussion         The `addBarrierBlock:` method executes the block when the NSOperationQueue has finished all enqueued operations and
  /// prevents any subsequent operations to be executed until the barrier has been completed. This acts similarly to the
  /// `dispatch_barrier_async` function.
  void addBarrierBlock(objc.ObjCBlock<ffi.Void Function()> barrier) {
    objc.checkOsVersionInternal(
      'NSOperationQueue.addBarrierBlock:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_addBarrierBlock_,
      barrier.ref.pointer,
    );
  }

  /// addOperation:
  void addOperation(NSOperation op) {
    objc.checkOsVersionInternal(
      'NSOperationQueue.addOperation:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_addOperation_,
      op.ref.pointer,
    );
  }

  /// addOperationWithBlock:
  void addOperationWithBlock(objc.ObjCBlock<ffi.Void Function()> block) {
    objc.checkOsVersionInternal(
      'NSOperationQueue.addOperationWithBlock:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_addOperationWithBlock_,
      block.ref.pointer,
    );
  }

  /// addOperations:waitUntilFinished:
  void addOperations(objc.NSArray ops, {required bool waitUntilFinished}) {
    objc.checkOsVersionInternal(
      'NSOperationQueue.addOperations:waitUntilFinished:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_6p7ndb(
      object$.ref.pointer,
      _sel_addOperations_waitUntilFinished_,
      ops.ref.pointer,
      waitUntilFinished,
    );
  }

  /// cancelAllOperations
  void cancelAllOperations() {
    objc.checkOsVersionInternal(
      'NSOperationQueue.cancelAllOperations',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_cancelAllOperations);
  }

  /// init
  NSOperationQueue init() {
    objc.checkOsVersionInternal(
      'NSOperationQueue.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSOperationQueue.fromPointer($ret, retain: false, release: true);
  }

  /// isSuspended
  bool get isSuspended {
    objc.checkOsVersionInternal(
      'NSOperationQueue.isSuspended',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isSuspended);
  }

  /// maxConcurrentOperationCount
  int get maxConcurrentOperationCount {
    objc.checkOsVersionInternal(
      'NSOperationQueue.maxConcurrentOperationCount',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_1hz7y9r(
      object$.ref.pointer,
      _sel_maxConcurrentOperationCount,
    );
  }

  /// name
  objc.NSString? get name {
    objc.checkOsVersionInternal(
      'NSOperationQueue.name',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_name);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// progress
  objc.NSProgress get progress {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_progress);
    return objc.NSProgress.fromPointer($ret, retain: true, release: true);
  }

  /// qualityOfService
  objc.NSQualityOfService get qualityOfService {
    objc.checkOsVersionInternal(
      'NSOperationQueue.qualityOfService',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_oi8iq9(
      object$.ref.pointer,
      _sel_qualityOfService,
    );
    return objc.NSQualityOfService.fromValue($ret);
  }

  /// setMaxConcurrentOperationCount:
  set maxConcurrentOperationCount(int value) {
    objc.checkOsVersionInternal(
      'NSOperationQueue.setMaxConcurrentOperationCount:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_4sp4xj(
      object$.ref.pointer,
      _sel_setMaxConcurrentOperationCount_,
      value,
    );
  }

  /// setName:
  set name(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSOperationQueue.setName:',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setName_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setQualityOfService:
  set qualityOfService(objc.NSQualityOfService value) {
    objc.checkOsVersionInternal(
      'NSOperationQueue.setQualityOfService:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_n2da1l(
      object$.ref.pointer,
      _sel_setQualityOfService_,
      value.value,
    );
  }

  /// setSuspended:
  set isSuspended(bool value) {
    objc.checkOsVersionInternal(
      'NSOperationQueue.setSuspended:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1s56lr9(object$.ref.pointer, _sel_setSuspended_, value);
  }

  /// actually retain
  set underlyingQueue(objc.NSObject? value) {
    objc.checkOsVersionInternal(
      'NSOperationQueue.setUnderlyingQueue:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setUnderlyingQueue_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// actually retain
  objc.NSObject? get underlyingQueue {
    objc.checkOsVersionInternal(
      'NSOperationQueue.underlyingQueue',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_underlyingQueue,
    );
    return $ret.address == 0
        ? null
        : objc.NSObject.fromPointer($ret, retain: true, release: true);
  }

  /// waitUntilAllOperationsAreFinished
  void waitUntilAllOperationsAreFinished() {
    objc.checkOsVersionInternal(
      'NSOperationQueue.waitUntilAllOperationsAreFinished',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1pl9qdv(
      object$.ref.pointer,
      _sel_waitUntilAllOperationsAreFinished,
    );
  }
}

late final _sel_sessionWithConfiguration_delegate_delegateQueue_ = objc
    .registerName("sessionWithConfiguration:delegate:delegateQueue:");
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_delegateQueue = objc.registerName("delegateQueue");
late final _sel_delegate = objc.registerName("delegate");
late final _sel_configuration = objc.registerName("configuration");
late final _sel_sessionDescription = objc.registerName("sessionDescription");
late final _sel_setSessionDescription_ = objc.registerName(
  "setSessionDescription:",
);
late final _sel_finishTasksAndInvalidate = objc.registerName(
  "finishTasksAndInvalidate",
);
late final _sel_invalidateAndCancel = objc.registerName("invalidateAndCancel");
late final _sel_resetWithCompletionHandler_ = objc.registerName(
  "resetWithCompletionHandler:",
);
late final _sel_flushWithCompletionHandler_ = objc.registerName(
  "flushWithCompletionHandler:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_NSArray_NSArray_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
  >
  fromFunction(
    void Function(objc.NSArray, objc.NSArray, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            objc.NSArray.fromPointer(arg0, retain: true, release: true),
            objc.NSArray.fromPointer(arg1, retain: true, release: true),
            objc.NSArray.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
  >
  listener(
    void Function(objc.NSArray, objc.NSArray, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        objc.NSArray.fromPointer(arg0, retain: false, release: true),
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
        objc.NSArray.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_r8gdi7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
  >
  blocking(
    void Function(objc.NSArray, objc.NSArray, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        objc.NSArray.fromPointer(arg0, retain: false, release: true),
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
        objc.NSArray.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        objc.NSArray.fromPointer(arg0, retain: false, release: true),
        objc.NSArray.fromPointer(arg1, retain: false, release: true),
        objc.NSArray.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_r8gdi7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)>`.
extension ObjCBlock_ffiVoid_NSArray_NSArray_NSArray$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)
        > {
  void call(objc.NSArray arg0, objc.NSArray arg1, objc.NSArray arg2) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_getTasksWithCompletionHandler_ = objc.registerName(
  "getTasksWithCompletionHandler:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSArray)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray)> fromFunction(
    void Function(objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(objc.NSArray.fromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray)> listener(
    void Function(objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(objc.NSArray.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSArray)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSArray)> blocking(
    void Function(objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(objc.NSArray.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) =>
          fn(objc.NSArray.fromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSArray)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSArray)>`.
extension ObjCBlock_ffiVoid_NSArray$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSArray)> {
  void call(objc.NSArray arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_getAllTasksWithCompletionHandler_ = objc.registerName(
  "getAllTasksWithCompletionHandler:",
);
late final _sel_dataTaskWithRequest_ = objc.registerName(
  "dataTaskWithRequest:",
);
late final _sel_dataTaskWithURL_ = objc.registerName("dataTaskWithURL:");

/// WARNING: NSURLSessionUploadTask is a stub. To generate bindings for this class, include
/// NSURLSessionUploadTask in your config's objc-interfaces list.
///
/// An NSURLSessionUploadTask does not currently provide any additional
/// functionality over an NSURLSessionDataTask.  All delegate messages
/// that may be sent referencing an NSURLSessionDataTask equally apply
/// to NSURLSessionUploadTasks.
extension type NSURLSessionUploadTask._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSURLSessionDataTask {
  /// Constructs a [NSURLSessionUploadTask] that points to the same underlying object as [other].
  NSURLSessionUploadTask.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLSessionUploadTask',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
  }

  /// Constructs a [NSURLSessionUploadTask] that wraps the given raw object pointer.
  NSURLSessionUploadTask.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLSessionUploadTask',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
  }
}

late final _sel_uploadTaskWithRequest_fromFile_ = objc.registerName(
  "uploadTaskWithRequest:fromFile:",
);
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_uploadTaskWithRequest_fromData_ = objc.registerName(
  "uploadTaskWithRequest:fromData:",
);
late final _sel_uploadTaskWithResumeData_ = objc.registerName(
  "uploadTaskWithResumeData:",
);
late final _sel_uploadTaskWithStreamedRequest_ = objc.registerName(
  "uploadTaskWithStreamedRequest:",
);
late final _class_NSURLSessionDownloadTask = objc.getClass(
  "NSURLSessionDownloadTask",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?)>`.
abstract final class ObjCBlock_ffiVoid_NSData {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSData?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?)> fromFunction(
    void Function(objc.NSData?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?)> listener(
    void Function(objc.NSData?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?)> blocking(
    void Function(objc.NSData?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?)>`.
extension ObjCBlock_ffiVoid_NSData$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?)> {
  void call(objc.NSData? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_cancelByProducingResumeData_ = objc.registerName(
  "cancelByProducingResumeData:",
);
late final _class_NSURLSessionTask = objc.getClass("NSURLSessionTask");
late final _sel_taskIdentifier = objc.registerName("taskIdentifier");
late final _sel_originalRequest = objc.registerName("originalRequest");
late final _sel_currentRequest = objc.registerName("currentRequest");
late final _class_NSURLResponse = objc.getClass("NSURLResponse");
late final _sel_initWithURL_MIMEType_expectedContentLength_textEncodingName_ =
    objc.registerName(
      "initWithURL:MIMEType:expectedContentLength:textEncodingName:",
    );
final _objc_msgSend_l9ppnx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_MIMEType = objc.registerName("MIMEType");
late final _sel_expectedContentLength = objc.registerName(
  "expectedContentLength",
);
final _objc_msgSend_1k101e3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.LongLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_textEncodingName = objc.registerName("textEncodingName");
late final _sel_suggestedFilename = objc.registerName("suggestedFilename");

/// NSURLResponse
extension type NSURLResponse._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSSecureCoding,
        objc.NSCopying {
  /// Constructs a [NSURLResponse] that points to the same underlying object as [other].
  NSURLResponse.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [NSURLResponse] that wraps the given raw object pointer.
  NSURLResponse.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLResponse].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLResponse,
  );

  /// alloc
  static NSURLResponse alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLResponse, _sel_alloc);
    return NSURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLResponse allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLResponse,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSURLResponse new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLResponse, _sel_new);
    return NSURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSURLResponse,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of NSURLResponse constructed with the default `new` method.
  NSURLResponse() : this.as(new$().object$);
}

extension NSURLResponse$Methods on NSURLResponse {
  /// !
  /// @abstract Returns the MIME type of the receiver.
  /// @discussion The MIME type is based on the information provided
  /// from an origin source. However, that value may be changed or
  /// corrected by a protocol implementation if it can be determined
  /// that the origin server or source reported the information
  /// incorrectly or imprecisely. An attempt to guess the MIME type may
  /// be made if the origin source did not report any such information.
  /// @result The MIME type of the receiver.
  objc.NSString? get MIMEType {
    objc.checkOsVersionInternal(
      'NSURLResponse.MIMEType',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_MIMEType);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the URL of the receiver.
  /// @result The URL of the receiver.
  objc.NSURL? get URL {
    objc.checkOsVersionInternal(
      'NSURLResponse.URL',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_URL);
    return $ret.address == 0
        ? null
        : objc.NSURL.fromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_encodeWithCoder_,
      coder.ref.pointer,
    );
  }

  /// !
  /// @abstract Returns the expected content length of the receiver.
  /// @discussion Some protocol implementations report a content length
  /// as part of delivering load metadata, but not all protocols
  /// guarantee the amount of data that will be delivered in actuality.
  /// Hence, this method returns an expected amount. Clients should use
  /// this value as an advisory, and should be prepared to deal with
  /// either more or less data.
  /// @result The expected content length of the receiver, or -1 if
  /// there is no expectation that can be arrived at regarding expected
  /// content length.
  int get expectedContentLength {
    objc.checkOsVersionInternal(
      'NSURLResponse.expectedContentLength',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return _objc_msgSend_1k101e3(
      object$.ref.pointer,
      _sel_expectedContentLength,
    );
  }

  /// init
  NSURLResponse init() {
    objc.checkOsVersionInternal(
      'NSURLResponse.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSURLResponse? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method initWithURL:MIMEType:expectedContentLength:textEncodingName:
  /// @abstract Initialize an NSURLResponse with the provided values.
  /// @param URL the URL
  /// @param MIMEType the MIME content type of the response
  /// @param length the expected content length of the associated data
  /// @param name the name of the text encoding for the associated data, if applicable, else nil
  /// @result The initialized NSURLResponse.
  /// @discussion This is the designated initializer for NSURLResponse.
  NSURLResponse initWithUrlAndMIMEType(
    objc.NSURL URL, {
    objc.NSString? MIMEType,
    required int length,
    objc.NSString? name,
  }) {
    objc.checkOsVersionInternal(
      'NSURLResponse.initWithURL:MIMEType:expectedContentLength:textEncodingName:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_l9ppnx(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_MIMEType_expectedContentLength_textEncodingName_,
      URL.ref.pointer,
      MIMEType?.ref.pointer ?? ffi.nullptr,
      length,
      name?.ref.pointer ?? ffi.nullptr,
    );
    return NSURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @abstract Returns a suggested filename if the resource were saved to disk.
  /// @discussion The method first checks if the server has specified a filename using the
  /// content disposition header. If no valid filename is specified using that mechanism,
  /// this method checks the last path component of the URL. If no valid filename can be
  /// obtained using the last path component, this method uses the URL's host as the filename.
  /// If the URL's host can't be converted to a valid filename, the filename "unknown" is used.
  /// In most cases, this method appends the proper file extension based on the MIME type.
  /// This method always returns a valid filename.
  /// @result A suggested filename to use if saving the resource to disk.
  objc.NSString? get suggestedFilename {
    objc.checkOsVersionInternal(
      'NSURLResponse.suggestedFilename',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_suggestedFilename,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the name of the text encoding of the receiver.
  /// @discussion This name will be the actual string reported by the
  /// origin source during the course of performing a protocol-specific
  /// URL load. Clients can inspect this string and convert it to an
  /// NSStringEncoding or CFStringEncoding using the methods and
  /// functions made available in the appropriate framework.
  /// @result The name of the text encoding of the receiver, or nil if no
  /// text encoding was specified.
  objc.NSString? get textEncodingName {
    objc.checkOsVersionInternal(
      'NSURLResponse.textEncodingName',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_textEncodingName,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_response = objc.registerName("response");

/// WARNING: NSURLSessionTaskDelegate is a stub. To generate bindings for this class, include
/// NSURLSessionTaskDelegate in your config's objc-protocols list.
///
/// Messages related to the operation of a specific task.
extension type NSURLSessionTaskDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, NSURLSessionDelegate {
  /// Constructs a [NSURLSessionTaskDelegate] that points to the same underlying object as [other].
  NSURLSessionTaskDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSURLSessionTaskDelegate] that wraps the given raw object pointer.
  NSURLSessionTaskDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _sel_setDelegate_ = objc.registerName("setDelegate:");
late final _sel_earliestBeginDate = objc.registerName("earliestBeginDate");
late final _sel_setEarliestBeginDate_ = objc.registerName(
  "setEarliestBeginDate:",
);
late final _sel_countOfBytesClientExpectsToSend = objc.registerName(
  "countOfBytesClientExpectsToSend",
);
final _objc_msgSend_pysgoz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int64 Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setCountOfBytesClientExpectsToSend_ = objc.registerName(
  "setCountOfBytesClientExpectsToSend:",
);
final _objc_msgSend_17gvxvj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int64,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_countOfBytesClientExpectsToReceive = objc.registerName(
  "countOfBytesClientExpectsToReceive",
);
late final _sel_setCountOfBytesClientExpectsToReceive_ = objc.registerName(
  "setCountOfBytesClientExpectsToReceive:",
);
late final _sel_countOfBytesSent = objc.registerName("countOfBytesSent");
late final _sel_countOfBytesReceived = objc.registerName(
  "countOfBytesReceived",
);
late final _sel_countOfBytesExpectedToSend = objc.registerName(
  "countOfBytesExpectedToSend",
);
late final _sel_countOfBytesExpectedToReceive = objc.registerName(
  "countOfBytesExpectedToReceive",
);
late final _sel_taskDescription = objc.registerName("taskDescription");
late final _sel_setTaskDescription_ = objc.registerName("setTaskDescription:");
late final _sel_cancel = objc.registerName("cancel");

enum NSURLSessionTaskState {
  /// The task is currently being serviced by the session
  NSURLSessionTaskStateRunning(0),
  NSURLSessionTaskStateSuspended(1),

  /// The task has been told to cancel.  The session will receive a URLSession:task:didCompleteWithError: message.
  NSURLSessionTaskStateCanceling(2),

  /// The task has completed and the session will receive no more delegate notifications
  NSURLSessionTaskStateCompleted(3);

  final int value;
  const NSURLSessionTaskState(this.value);

  static NSURLSessionTaskState fromValue(int value) => switch (value) {
    0 => NSURLSessionTaskStateRunning,
    1 => NSURLSessionTaskStateSuspended,
    2 => NSURLSessionTaskStateCanceling,
    3 => NSURLSessionTaskStateCompleted,
    _ => throw ArgumentError('Unknown value for NSURLSessionTaskState: $value'),
  };
}

late final _sel_state = objc.registerName("state");
final _objc_msgSend_1vze0g9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_error = objc.registerName("error");
late final _sel_suspend = objc.registerName("suspend");
late final _sel_resume = objc.registerName("resume");
late final _sel_priority = objc.registerName("priority");
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Float Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      double Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setPriority_ = objc.registerName("setPriority:");
final _objc_msgSend_v5hmet = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
      )
    >();
late final _sel_prefersIncrementalDelivery = objc.registerName(
  "prefersIncrementalDelivery",
);
late final _sel_setPrefersIncrementalDelivery_ = objc.registerName(
  "setPrefersIncrementalDelivery:",
);

/// NSURLSessionTask - a cancelable object that refers to the lifetime
/// of processing a given request.
extension type NSURLSessionTask._(objc.ObjCObject object$)
    implements
        objc.ObjCObject,
        objc.NSObject,
        objc.NSCopying,
        NSProgressReporting {
  /// Constructs a [NSURLSessionTask] that points to the same underlying object as [other].
  NSURLSessionTask.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLSessionTask',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSURLSessionTask] that wraps the given raw object pointer.
  NSURLSessionTask.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLSessionTask',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLSessionTask].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLSessionTask,
  );

  /// alloc
  static NSURLSessionTask alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLSessionTask, _sel_alloc);
    return NSURLSessionTask.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLSessionTask allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLSessionTask,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLSessionTask.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSURLSessionTask new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLSessionTask, _sel_new);
    return NSURLSessionTask.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSURLSessionTask constructed with the default `new` method.
  NSURLSessionTask() : this.as(new$().object$);
}

extension NSURLSessionTask$Methods on NSURLSessionTask {
  /// -cancel returns immediately, but marks a task as being canceled.
  /// The task will signal -URLSession:task:didCompleteWithError: with an
  /// error value of { NSURLErrorDomain, NSURLErrorCancelled }.  In some
  /// cases, the task may signal other work before it acknowledges the
  /// cancelation.  -cancel may be sent to a task that has been suspended.
  void cancel() {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.cancel',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_cancel);
  }

  /// countOfBytesClientExpectsToReceive
  int get countOfBytesClientExpectsToReceive {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.countOfBytesClientExpectsToReceive',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_pysgoz(
      object$.ref.pointer,
      _sel_countOfBytesClientExpectsToReceive,
    );
  }

  /// The number of bytes that the client expects (a best-guess upper-bound) will
  /// be sent and received by this task. These values are used by system scheduling
  /// policy. If unspecified, NSURLSessionTransferSizeUnknown is used.
  int get countOfBytesClientExpectsToSend {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.countOfBytesClientExpectsToSend',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    return _objc_msgSend_pysgoz(
      object$.ref.pointer,
      _sel_countOfBytesClientExpectsToSend,
    );
  }

  /// number of byte bytes we expect to receive, usually derived from the Content-Length header of an HTTP response.
  int get countOfBytesExpectedToReceive {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.countOfBytesExpectedToReceive',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_pysgoz(
      object$.ref.pointer,
      _sel_countOfBytesExpectedToReceive,
    );
  }

  /// number of body bytes we expect to send, derived from the Content-Length of the HTTP request
  int get countOfBytesExpectedToSend {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.countOfBytesExpectedToSend',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_pysgoz(
      object$.ref.pointer,
      _sel_countOfBytesExpectedToSend,
    );
  }

  /// number of body bytes already received
  int get countOfBytesReceived {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.countOfBytesReceived',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_pysgoz(object$.ref.pointer, _sel_countOfBytesReceived);
  }

  /// number of body bytes already sent
  int get countOfBytesSent {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.countOfBytesSent',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_pysgoz(object$.ref.pointer, _sel_countOfBytesSent);
  }

  /// may differ from originalRequest due to http server redirection
  NSURLRequest? get currentRequest {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.currentRequest',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_currentRequest,
    );
    return $ret.address == 0
        ? null
        : NSURLRequest.fromPointer($ret, retain: true, release: true);
  }

  /// Sets a task-specific delegate. Methods not implemented on this delegate will
  /// still be forwarded to the session delegate.
  ///
  /// Cannot be modified after task resumes. Not supported on background session.
  ///
  /// Delegate is strongly referenced until the task completes, after which it is
  /// reset to `nil`.
  NSURLSessionTaskDelegate? get delegate {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.delegate',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_delegate);
    return $ret.address == 0
        ? null
        : NSURLSessionTaskDelegate.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// Start the network load for this task no earlier than the specified date. If
  /// not specified, no start delay is used.
  ///
  /// Only applies to tasks created from background NSURLSession instances; has no
  /// effect for tasks created from other session types.
  objc.NSDate? get earliestBeginDate {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.earliestBeginDate',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_earliestBeginDate,
    );
    return $ret.address == 0
        ? null
        : objc.NSDate.fromPointer($ret, retain: true, release: true);
  }

  /// The error, if any, delivered via -URLSession:task:didCompleteWithError:
  /// This property will be nil in the event that no error occurred.
  objc.NSError? get error {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.error',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_error);
    return $ret.address == 0
        ? null
        : objc.NSError.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NSURLSessionTask init() {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLSessionTask.fromPointer($ret, retain: false, release: true);
  }

  /// may be nil if this is a stream task
  NSURLRequest? get originalRequest {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.originalRequest',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_originalRequest,
    );
    return $ret.address == 0
        ? null
        : NSURLRequest.fromPointer($ret, retain: true, release: true);
  }

  /// Provides a hint indicating if incremental delivery of a partial response body
  /// would be useful for the application, or if it cannot process the response
  /// until it is complete. Indicating that incremental delivery is not desired may
  /// improve task performance. For example, if a response cannot be decoded until
  /// the entire content is received, set this property to false.
  ///
  /// Defaults to true unless this task is created with completion-handler based
  /// convenience methods, or if it is a download task.
  bool get prefersIncrementalDelivery {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.prefersIncrementalDelivery',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    return _objc_msgSend_91o635(
      object$.ref.pointer,
      _sel_prefersIncrementalDelivery,
    );
  }

  /// Sets a scaling factor for the priority of the task. The scaling factor is a
  /// value between 0.0 and 1.0 (inclusive), where 0.0 is considered the lowest
  /// priority and 1.0 is considered the highest.
  ///
  /// The priority is a hint and not a hard requirement of task performance. The
  /// priority of a task may be changed using this API at any time, but not all
  /// protocols support this; in these cases, the last priority that took effect
  /// will be used.
  ///
  /// If no priority is specified, the task will operate with the default priority
  /// as defined by the constant NSURLSessionTaskPriorityDefault. Two additional
  /// priority levels are provided: NSURLSessionTaskPriorityLow and
  /// NSURLSessionTaskPriorityHigh, but use is not restricted to these.
  double get priority {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.priority',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(object$.ref.pointer, _sel_priority)
        : _objc_msgSend_2cgrxl(object$.ref.pointer, _sel_priority);
  }

  /// progress
  objc.NSProgress get progress {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_progress);
    return objc.NSProgress.fromPointer($ret, retain: true, release: true);
  }

  /// may be nil if no response has been received
  NSURLResponse? get response {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.response',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_response);
    return $ret.address == 0
        ? null
        : NSURLResponse.fromPointer($ret, retain: true, release: true);
  }

  /// resume
  void resume() {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.resume',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_resume);
  }

  /// setCountOfBytesClientExpectsToReceive:
  set countOfBytesClientExpectsToReceive(int value) {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.setCountOfBytesClientExpectsToReceive:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_17gvxvj(
      object$.ref.pointer,
      _sel_setCountOfBytesClientExpectsToReceive_,
      value,
    );
  }

  /// The number of bytes that the client expects (a best-guess upper-bound) will
  /// be sent and received by this task. These values are used by system scheduling
  /// policy. If unspecified, NSURLSessionTransferSizeUnknown is used.
  set countOfBytesClientExpectsToSend(int value) {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.setCountOfBytesClientExpectsToSend:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_17gvxvj(
      object$.ref.pointer,
      _sel_setCountOfBytesClientExpectsToSend_,
      value,
    );
  }

  /// Sets a task-specific delegate. Methods not implemented on this delegate will
  /// still be forwarded to the session delegate.
  ///
  /// Cannot be modified after task resumes. Not supported on background session.
  ///
  /// Delegate is strongly referenced until the task completes, after which it is
  /// reset to `nil`.
  set delegate(NSURLSessionTaskDelegate? value) {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.setDelegate:',
      iOS: (false, (15, 0, 0)),
      macOS: (false, (12, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setDelegate_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Start the network load for this task no earlier than the specified date. If
  /// not specified, no start delay is used.
  ///
  /// Only applies to tasks created from background NSURLSession instances; has no
  /// effect for tasks created from other session types.
  set earliestBeginDate(objc.NSDate? value) {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.setEarliestBeginDate:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setEarliestBeginDate_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Provides a hint indicating if incremental delivery of a partial response body
  /// would be useful for the application, or if it cannot process the response
  /// until it is complete. Indicating that incremental delivery is not desired may
  /// improve task performance. For example, if a response cannot be decoded until
  /// the entire content is received, set this property to false.
  ///
  /// Defaults to true unless this task is created with completion-handler based
  /// convenience methods, or if it is a download task.
  set prefersIncrementalDelivery(bool value) {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.setPrefersIncrementalDelivery:',
      iOS: (false, (14, 5, 0)),
      macOS: (false, (11, 3, 0)),
    );
    _objc_msgSend_1s56lr9(
      object$.ref.pointer,
      _sel_setPrefersIncrementalDelivery_,
      value,
    );
  }

  /// Sets a scaling factor for the priority of the task. The scaling factor is a
  /// value between 0.0 and 1.0 (inclusive), where 0.0 is considered the lowest
  /// priority and 1.0 is considered the highest.
  ///
  /// The priority is a hint and not a hard requirement of task performance. The
  /// priority of a task may be changed using this API at any time, but not all
  /// protocols support this; in these cases, the last priority that took effect
  /// will be used.
  ///
  /// If no priority is specified, the task will operate with the default priority
  /// as defined by the constant NSURLSessionTaskPriorityDefault. Two additional
  /// priority levels are provided: NSURLSessionTaskPriorityLow and
  /// NSURLSessionTaskPriorityHigh, but use is not restricted to these.
  set priority(double value) {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.setPriority:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_v5hmet(object$.ref.pointer, _sel_setPriority_, value);
  }

  /// The taskDescription property is available for the developer to
  /// provide a descriptive label for the task.
  set taskDescription(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.setTaskDescription:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setTaskDescription_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// The current state of the task within the session.
  NSURLSessionTaskState get state {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.state',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1vze0g9(object$.ref.pointer, _sel_state);
    return NSURLSessionTaskState.fromValue($ret);
  }

  /// Suspending a task will prevent the NSURLSession from continuing to
  /// load data.  There may still be delegate calls made on behalf of
  /// this task (for instance, to report data received while suspending)
  /// but no further transmissions will be made on behalf of the task
  /// until -resume is sent.  The timeout timer associated with the task
  /// will be disabled while a task is suspended. -suspend and -resume are
  /// nestable.
  void suspend() {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.suspend',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_suspend);
  }

  /// The taskDescription property is available for the developer to
  /// provide a descriptive label for the task.
  objc.NSString? get taskDescription {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.taskDescription',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_taskDescription,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// an identifier for this task, assigned by and unique to the owning session
  int get taskIdentifier {
    objc.checkOsVersionInternal(
      'NSURLSessionTask.taskIdentifier',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_taskIdentifier);
  }
}

/// NSURLSessionDownloadTask is a task that represents a download to
/// local storage.
extension type NSURLSessionDownloadTask._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSURLSessionTask {
  /// Constructs a [NSURLSessionDownloadTask] that points to the same underlying object as [other].
  NSURLSessionDownloadTask.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadTask',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSURLSessionDownloadTask] that wraps the given raw object pointer.
  NSURLSessionDownloadTask.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadTask',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLSessionDownloadTask].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLSessionDownloadTask,
  );

  /// alloc
  static NSURLSessionDownloadTask alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSURLSessionDownloadTask,
      _sel_alloc,
    );
    return NSURLSessionDownloadTask.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSURLSessionDownloadTask allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLSessionDownloadTask,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLSessionDownloadTask.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static NSURLSessionDownloadTask new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSURLSessionDownloadTask,
      _sel_new,
    );
    return NSURLSessionDownloadTask.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NSURLSessionDownloadTask constructed with the default `new` method.
  NSURLSessionDownloadTask() : this.as(new$().object$);
}

extension NSURLSessionDownloadTask$Methods on NSURLSessionDownloadTask {
  /// Cancel the download (and calls the superclass -cancel).  If
  /// conditions will allow for resuming the download in the future, the
  /// callback will be called with an opaque data blob, which may be used
  /// with -downloadTaskWithResumeData: to attempt to resume the download.
  /// If resume data cannot be created, the completion handler will be
  /// called with nil resumeData.
  void cancelByProducingResumeData(
    objc.ObjCBlock<ffi.Void Function(objc.NSData?)> completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadTask.cancelByProducingResumeData:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_cancelByProducingResumeData_,
      completionHandler.ref.pointer,
    );
  }

  /// init
  NSURLSessionDownloadTask init() {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadTask.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLSessionDownloadTask.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }
}

late final _sel_downloadTaskWithRequest_ = objc.registerName(
  "downloadTaskWithRequest:",
);
late final _sel_downloadTaskWithURL_ = objc.registerName(
  "downloadTaskWithURL:",
);
late final _sel_downloadTaskWithResumeData_ = objc.registerName(
  "downloadTaskWithResumeData:",
);

/// WARNING: NSURLSessionStreamTask is a stub. To generate bindings for this class, include
/// NSURLSessionStreamTask in your config's objc-interfaces list.
///
/// An NSURLSessionStreamTask provides an interface to perform reads
/// and writes to a TCP/IP stream created via NSURLSession.  This task
/// may be explicitly created from an NSURLSession, or created as a
/// result of the appropriate disposition response to a
/// -URLSession:dataTask:didReceiveResponse: delegate message.
///
/// NSURLSessionStreamTask can be used to perform asynchronous reads
/// and writes.  Reads and writes are enqueued and executed serially,
/// with the completion handler being invoked on the sessions delegate
/// queue.  If an error occurs, or the task is canceled, all
/// outstanding read and write calls will have their completion
/// handlers invoked with an appropriate error.
///
/// It is also possible to create NSInputStream and NSOutputStream
/// instances from an NSURLSessionTask by sending
/// -captureStreams to the task.  All outstanding reads and writes are
/// completed before the streams are created.  Once the streams are
/// delivered to the session delegate, the task is considered complete
/// and will receive no more messages.  These streams are
/// disassociated from the underlying session.
extension type NSURLSessionStreamTask._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSURLSessionTask {
  /// Constructs a [NSURLSessionStreamTask] that points to the same underlying object as [other].
  NSURLSessionStreamTask.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLSessionStreamTask',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }

  /// Constructs a [NSURLSessionStreamTask] that wraps the given raw object pointer.
  NSURLSessionStreamTask.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLSessionStreamTask',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
  }
}

late final _sel_streamTaskWithHostName_port_ = objc.registerName(
  "streamTaskWithHostName:port:",
);
final _objc_msgSend_9slupp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
      )
    >();

/// WARNING: NSNetService is a stub. To generate bindings for this class, include
/// NSNetService in your config's objc-interfaces list.
///
/// NSNetService
extension type NSNetService._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [NSNetService] that points to the same underlying object as [other].
  NSNetService.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [NSNetService] that wraps the given raw object pointer.
  NSNetService.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

late final _sel_streamTaskWithNetService_ = objc.registerName(
  "streamTaskWithNetService:",
);
late final _class_NSURLSessionWebSocketTask = objc.getClass(
  "NSURLSessionWebSocketTask",
);
late final _class_NSURLSessionWebSocketMessage = objc.getClass(
  "NSURLSessionWebSocketMessage",
);
late final _sel_initWithData_ = objc.registerName("initWithData:");
late final _sel_initWithString_ = objc.registerName("initWithString:");

enum NSURLSessionWebSocketMessageType {
  NSURLSessionWebSocketMessageTypeData(0),
  NSURLSessionWebSocketMessageTypeString(1);

  final int value;
  const NSURLSessionWebSocketMessageType(this.value);

  static NSURLSessionWebSocketMessageType fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionWebSocketMessageTypeData,
        1 => NSURLSessionWebSocketMessageTypeString,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionWebSocketMessageType: $value',
        ),
      };
}

late final _sel_type = objc.registerName("type");
final _objc_msgSend_1qouven = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_data = objc.registerName("data");
late final _sel_string = objc.registerName("string");

/// The client can create a WebSocket message object that will be passed to the send calls
/// and will be delivered from the receive calls. The message can be initialized with data or string.
/// If initialized with data, the string property will be nil and vice versa.
extension type NSURLSessionWebSocketMessage._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSURLSessionWebSocketMessage] that points to the same underlying object as [other].
  NSURLSessionWebSocketMessage.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketMessage',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSURLSessionWebSocketMessage] that wraps the given raw object pointer.
  NSURLSessionWebSocketMessage.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketMessage',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLSessionWebSocketMessage].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLSessionWebSocketMessage,
  );

  /// alloc
  static NSURLSessionWebSocketMessage alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSURLSessionWebSocketMessage,
      _sel_alloc,
    );
    return NSURLSessionWebSocketMessage.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSURLSessionWebSocketMessage allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLSessionWebSocketMessage,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLSessionWebSocketMessage.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static NSURLSessionWebSocketMessage new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSURLSessionWebSocketMessage,
      _sel_new,
    );
    return NSURLSessionWebSocketMessage.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NSURLSessionWebSocketMessage constructed with the default `new` method.
  NSURLSessionWebSocketMessage() : this.as(new$().object$);
}

extension NSURLSessionWebSocketMessage$Methods on NSURLSessionWebSocketMessage {
  /// data
  objc.NSData? get data {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketMessage.data',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_data);
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NSURLSessionWebSocketMessage init() {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketMessage.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLSessionWebSocketMessage.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Create a message with data type
  NSURLSessionWebSocketMessage initWithData(objc.NSData data) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketMessage.initWithData:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithData_,
      data.ref.pointer,
    );
    return NSURLSessionWebSocketMessage.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Create a message with string type
  NSURLSessionWebSocketMessage initWithString(objc.NSString string) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketMessage.initWithString:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithString_,
      string.ref.pointer,
    );
    return NSURLSessionWebSocketMessage.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// string
  objc.NSString? get string {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketMessage.string',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_string);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// type
  NSURLSessionWebSocketMessageType get type {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketMessage.type',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1qouven(object$.ref.pointer, _sel_type);
    return NSURLSessionWebSocketMessageType.fromValue($ret);
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunction(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> listener(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> blocking(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSError.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSError?)> {
  void call(objc.NSError? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_sendMessage_completionHandler_ = objc.registerName(
  "sendMessage:completionHandler:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
  >
  fromFunction(
    void Function(NSURLSessionWebSocketMessage?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ) => fn(
            arg0.address == 0
                ? null
                : NSURLSessionWebSocketMessage.fromPointer(
                    arg0,
                    retain: true,
                    release: true,
                  ),
            arg1.address == 0
                ? null
                : objc.NSError.fromPointer(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
  >
  listener(
    void Function(NSURLSessionWebSocketMessage?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSURLSessionWebSocketMessage.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
  >
  blocking(
    void Function(NSURLSessionWebSocketMessage?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSURLSessionWebSocketMessage.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
      ) => fn(
        arg0.address == 0
            ? null
            : NSURLSessionWebSocketMessage.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
        arg1.address == 0
            ? null
            : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_pfv6jd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
        > {
  void call(NSURLSessionWebSocketMessage? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_receiveMessageWithCompletionHandler_ = objc.registerName(
  "receiveMessageWithCompletionHandler:",
);
late final _sel_sendPingWithPongReceiveHandler_ = objc.registerName(
  "sendPingWithPongReceiveHandler:",
);

/// The WebSocket close codes follow the close codes given in the RFC
sealed class NSURLSessionWebSocketCloseCode {
  static const NSURLSessionWebSocketCloseCodeInvalid = 0;
  static const NSURLSessionWebSocketCloseCodeNormalClosure = 1000;
  static const NSURLSessionWebSocketCloseCodeGoingAway = 1001;
  static const NSURLSessionWebSocketCloseCodeProtocolError = 1002;
  static const NSURLSessionWebSocketCloseCodeUnsupportedData = 1003;
  static const NSURLSessionWebSocketCloseCodeNoStatusReceived = 1005;
  static const NSURLSessionWebSocketCloseCodeAbnormalClosure = 1006;
  static const NSURLSessionWebSocketCloseCodeInvalidFramePayloadData = 1007;
  static const NSURLSessionWebSocketCloseCodePolicyViolation = 1008;
  static const NSURLSessionWebSocketCloseCodeMessageTooBig = 1009;
  static const NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing = 1010;
  static const NSURLSessionWebSocketCloseCodeInternalServerError = 1011;
  static const NSURLSessionWebSocketCloseCodeTLSHandshakeFailure = 1015;
}

late final _sel_cancelWithCloseCode_reason_ = objc.registerName(
  "cancelWithCloseCode:reason:",
);
final _objc_msgSend_tqzk0b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_maximumMessageSize = objc.registerName("maximumMessageSize");
late final _sel_setMaximumMessageSize_ = objc.registerName(
  "setMaximumMessageSize:",
);
late final _sel_closeCode = objc.registerName("closeCode");
final _objc_msgSend_1rhk8uh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_closeReason = objc.registerName("closeReason");

/// A WebSocket task can be created with a ws or wss url. A client can also provide
/// a list of protocols it wishes to advertise during the WebSocket handshake phase.
/// Once the handshake is successfully completed the client will be notified through an optional delegate.
/// All reads and writes enqueued before the completion of the handshake will be queued up and
/// executed once the handshake succeeds. Before the handshake completes, the client can be called to handle
/// redirection or authentication using the same delegates as NSURLSessionTask. WebSocket task will also provide
/// support for cookies and will store cookies to the cookie storage on the session and will attach cookies to
/// outgoing HTTP handshake requests.
extension type NSURLSessionWebSocketTask._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSURLSessionTask {
  /// Constructs a [NSURLSessionWebSocketTask] that points to the same underlying object as [other].
  NSURLSessionWebSocketTask.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSURLSessionWebSocketTask] that wraps the given raw object pointer.
  NSURLSessionWebSocketTask.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLSessionWebSocketTask].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLSessionWebSocketTask,
  );

  /// alloc
  static NSURLSessionWebSocketTask alloc() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSURLSessionWebSocketTask,
      _sel_alloc,
    );
    return NSURLSessionWebSocketTask.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// allocWithZone:
  static NSURLSessionWebSocketTask allocWithZone(
    ffi.Pointer<objc.NSZone> zone,
  ) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLSessionWebSocketTask,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLSessionWebSocketTask.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// new
  static NSURLSessionWebSocketTask new$() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSURLSessionWebSocketTask,
      _sel_new,
    );
    return NSURLSessionWebSocketTask.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// Returns a new instance of NSURLSessionWebSocketTask constructed with the default `new` method.
  NSURLSessionWebSocketTask() : this.as(new$().object$);
}

extension NSURLSessionWebSocketTask$Methods on NSURLSessionWebSocketTask {
  /// Sends a close frame with the given closeCode. An optional reason can be provided while sending the close frame.
  /// Simply calling cancel on the task will result in a cancellation frame being sent without any reason.
  void cancelWithCloseCode(int closeCode, {objc.NSData? reason}) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask.cancelWithCloseCode:reason:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_tqzk0b(
      object$.ref.pointer,
      _sel_cancelWithCloseCode_reason_,
      closeCode,
      reason?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// A task can be queried for it's close code at any point. When the task is not closed, it will be set to NSURLSessionWebSocketCloseCodeInvalid
  int get closeCode {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask.closeCode',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_1rhk8uh(object$.ref.pointer, _sel_closeCode);
  }

  /// A task can be queried for it's close reason at any point. A nil value indicates no closeReason or that the task is still running
  objc.NSData? get closeReason {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask.closeReason',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_closeReason);
    return $ret.address == 0
        ? null
        : objc.NSData.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NSURLSessionWebSocketTask init() {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLSessionWebSocketTask.fromPointer(
      $ret,
      retain: false,
      release: true,
    );
  }

  /// The maximum number of bytes to be buffered before erroring out. This includes the sum of all bytes from continuation frames. Receive calls will error out if this value is reached
  int get maximumMessageSize {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask.maximumMessageSize',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_maximumMessageSize);
  }

  /// Reads a WebSocket message once all the frames of the message are available.
  /// If the maximumMessage size is hit while buffering the frames, the receiveMessage call will error out
  /// and all outstanding work will also fail resulting in the end of the task.
  void receiveMessageWithCompletionHandler(
    objc.ObjCBlock<
      ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)
    >
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask.receiveMessageWithCompletionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_receiveMessageWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// Sends a WebSocket message. If an error occurs, any outstanding work will also fail.
  /// Note that invocation of the completion handler does not
  /// guarantee that the remote side has received all the bytes, only
  /// that they have been written to the kernel.
  void sendMessage(
    NSURLSessionWebSocketMessage message, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSError?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask.sendMessage:completionHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_sendMessage_completionHandler_,
      message.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Sends a ping frame from the client side. The pongReceiveHandler is invoked when the client
  /// receives a pong from the server endpoint. If a connection is lost or an error occurs before receiving
  /// the pong from the endpoint, the pongReceiveHandler block will be invoked with an error.
  /// Note - the pongReceiveHandler will always be called in the order in which the pings were sent.
  void sendPingWithPongReceiveHandler(
    objc.ObjCBlock<ffi.Void Function(objc.NSError?)> pongReceiveHandler,
  ) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask.sendPingWithPongReceiveHandler:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_sendPingWithPongReceiveHandler_,
      pongReceiveHandler.ref.pointer,
    );
  }

  /// The maximum number of bytes to be buffered before erroring out. This includes the sum of all bytes from continuation frames. Receive calls will error out if this value is reached
  set maximumMessageSize(int value) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketTask.setMaximumMessageSize:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_4sp4xj(
      object$.ref.pointer,
      _sel_setMaximumMessageSize_,
      value,
    );
  }
}

late final _sel_webSocketTaskWithURL_ = objc.registerName(
  "webSocketTaskWithURL:",
);
late final _sel_webSocketTaskWithURL_protocols_ = objc.registerName(
  "webSocketTaskWithURL:protocols:",
);
late final _sel_webSocketTaskWithRequest_ = objc.registerName(
  "webSocketTaskWithRequest:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
  >
  fromFunction(
    void Function(objc.NSData?, NSURLResponse?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0.address == 0
                ? null
                : objc.NSData.fromPointer(arg0, retain: true, release: true),
            arg1.address == 0
                ? null
                : NSURLResponse.fromPointer(arg1, retain: true, release: true),
            arg2.address == 0
                ? null
                : objc.NSError.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
  >
  listener(
    void Function(objc.NSData?, NSURLResponse?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : NSURLResponse.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_r8gdi7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
  >
  blocking(
    void Function(objc.NSData?, NSURLResponse?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : NSURLResponse.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : NSURLResponse.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_r8gdi7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
        > {
  void call(objc.NSData? arg0, NSURLResponse? arg1, objc.NSError? arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
        arg2?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_dataTaskWithRequest_completionHandler_ = objc.registerName(
  "dataTaskWithRequest:completionHandler:",
);
final _objc_msgSend_r0bo0s = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_dataTaskWithURL_completionHandler_ = objc.registerName(
  "dataTaskWithURL:completionHandler:",
);
late final _sel_uploadTaskWithRequest_fromFile_completionHandler_ = objc
    .registerName("uploadTaskWithRequest:fromFile:completionHandler:");
final _objc_msgSend_2wiv66 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_uploadTaskWithRequest_fromData_completionHandler_ = objc
    .registerName("uploadTaskWithRequest:fromData:completionHandler:");
late final _sel_uploadTaskWithResumeData_completionHandler_ = objc.registerName(
  "uploadTaskWithResumeData:completionHandler:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
  >
  fromFunction(
    void Function(objc.NSURL?, NSURLResponse?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0.address == 0
                ? null
                : objc.NSURL.fromPointer(arg0, retain: true, release: true),
            arg1.address == 0
                ? null
                : NSURLResponse.fromPointer(arg1, retain: true, release: true),
            arg2.address == 0
                ? null
                : objc.NSError.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
  >
  listener(
    void Function(objc.NSURL?, NSURLResponse?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSURL.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : NSURLResponse.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_r8gdi7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
  >
  blocking(
    void Function(objc.NSURL?, NSURLResponse?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSURL.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : NSURLResponse.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObjectImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0.address == 0
            ? null
            : objc.NSURL.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0
            ? null
            : NSURLResponse.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_r8gdi7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
        > {
  void call(objc.NSURL? arg0, NSURLResponse? arg1, objc.NSError? arg2) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<objc.ObjCObjectImpl> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0?.ref.pointer ?? ffi.nullptr,
        arg1?.ref.pointer ?? ffi.nullptr,
        arg2?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_downloadTaskWithRequest_completionHandler_ = objc.registerName(
  "downloadTaskWithRequest:completionHandler:",
);
late final _sel_downloadTaskWithURL_completionHandler_ = objc.registerName(
  "downloadTaskWithURL:completionHandler:",
);
late final _sel_downloadTaskWithResumeData_completionHandler_ = objc
    .registerName("downloadTaskWithResumeData:completionHandler:");

/// NSURLSession convenience routines deliver results to
/// a completion handler block.  These convenience routines
/// are not available to NSURLSessions that are configured
/// as background sessions.
///
/// Task objects are always created in a suspended state and
/// must be sent the -resume message before they will execute.
extension NSURLSessionAsynchronousConvenience on NSURLSession {
  /// data task convenience methods.  These methods create tasks that
  /// bypass the normal delegate calls for response and data delivery,
  /// and provide a simple cancelable asynchronous interface to receiving
  /// data.  Errors will be returned in the NSURLErrorDomain,
  /// see <Foundation/NSURLError.h>.  The delegate, if any, will still be
  /// called for authentication challenges.
  NSURLSessionDataTask dataTaskWithRequest$1(
    NSURLRequest request, {
    required objc.ObjCBlock<
      ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.dataTaskWithRequest:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      object$.ref.pointer,
      _sel_dataTaskWithRequest_completionHandler_,
      request.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSURLSessionDataTask.fromPointer($ret, retain: true, release: true);
  }

  /// dataTaskWithURL:completionHandler:
  NSURLSessionDataTask dataTaskWithURL$1(
    objc.NSURL url, {
    required objc.ObjCBlock<
      ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.dataTaskWithURL:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      object$.ref.pointer,
      _sel_dataTaskWithURL_completionHandler_,
      url.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSURLSessionDataTask.fromPointer($ret, retain: true, release: true);
  }

  /// download task convenience methods.  When a download successfully
  /// completes, the NSURL will point to a file that must be read or
  /// copied during the invocation of the completion routine.  The file
  /// will be removed automatically.
  NSURLSessionDownloadTask downloadTaskWithRequest$1(
    NSURLRequest request, {
    required objc.ObjCBlock<
      ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.downloadTaskWithRequest:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      object$.ref.pointer,
      _sel_downloadTaskWithRequest_completionHandler_,
      request.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSURLSessionDownloadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// downloadTaskWithResumeData:completionHandler:
  NSURLSessionDownloadTask downloadTaskWithResumeData$1(
    objc.NSData resumeData, {
    required objc.ObjCBlock<
      ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.downloadTaskWithResumeData:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      object$.ref.pointer,
      _sel_downloadTaskWithResumeData_completionHandler_,
      resumeData.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSURLSessionDownloadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// downloadTaskWithURL:completionHandler:
  NSURLSessionDownloadTask downloadTaskWithURL$1(
    objc.NSURL url, {
    required objc.ObjCBlock<
      ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.downloadTaskWithURL:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      object$.ref.pointer,
      _sel_downloadTaskWithURL_completionHandler_,
      url.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSURLSessionDownloadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// uploadTaskWithRequest:fromData:completionHandler:
  NSURLSessionUploadTask uploadTaskWithRequest$2(
    NSURLRequest request, {
    objc.NSData? fromData,
    required objc.ObjCBlock<
      ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.uploadTaskWithRequest:fromData:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_2wiv66(
      object$.ref.pointer,
      _sel_uploadTaskWithRequest_fromData_completionHandler_,
      request.ref.pointer,
      fromData?.ref.pointer ?? ffi.nullptr,
      completionHandler.ref.pointer,
    );
    return NSURLSessionUploadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// upload convenience method.
  NSURLSessionUploadTask uploadTaskWithRequest$3(
    NSURLRequest request, {
    required objc.NSURL fromFile,
    required objc.ObjCBlock<
      ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.uploadTaskWithRequest:fromFile:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_2wiv66(
      object$.ref.pointer,
      _sel_uploadTaskWithRequest_fromFile_completionHandler_,
      request.ref.pointer,
      fromFile.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSURLSessionUploadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates a URLSessionUploadTask from a resume data blob. If resuming from an upload
  /// file, the file must still exist and be unmodified.
  ///
  /// - Parameter resumeData: Resume data blob from an incomplete upload, such as data returned by the cancelByProducingResumeData: method.
  /// - Parameter completionHandler: The completion handler to call when the load request is complete.
  /// - Returns: A new session upload task, or nil if the resumeData is invalid.
  NSURLSessionUploadTask uploadTaskWithResumeData$1(
    objc.NSData resumeData, {
    required objc.ObjCBlock<
      ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)
    >
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.uploadTaskWithResumeData:completionHandler:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      object$.ref.pointer,
      _sel_uploadTaskWithResumeData_completionHandler_,
      resumeData.ref.pointer,
      completionHandler.ref.pointer,
    );
    return NSURLSessionUploadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }
}

/// NSURLSession is a replacement API for NSURLConnection.  It provides
/// options that affect the policy of, and various aspects of the
/// mechanism by which NSURLRequest objects are retrieved from the
/// network.
///
/// An NSURLSession may be bound to a delegate object.  The delegate is
/// invoked for certain events during the lifetime of a session, such as
/// server authentication or determining whether a resource to be loaded
/// should be converted into a download.
///
/// NSURLSession instances are thread-safe.
///
/// The default NSURLSession uses a system provided delegate and is
/// appropriate to use in place of existing code that uses
/// +[NSURLConnection sendAsynchronousRequest:queue:completionHandler:]
///
/// An NSURLSession creates NSURLSessionTask objects which represent the
/// action of a resource being loaded.  These are analogous to
/// NSURLConnection objects but provide for more control and a unified
/// delegate model.
///
/// NSURLSessionTask objects are always created in a suspended state and
/// must be sent the -resume message before they will execute.
///
/// Subclasses of NSURLSessionTask are used to syntactically
/// differentiate between data and file downloads.
///
/// An NSURLSessionDataTask receives the resource as a series of calls to
/// the URLSession:dataTask:didReceiveData: delegate method.  This is type of
/// task most commonly associated with retrieving objects for immediate parsing
/// by the consumer.
///
/// An NSURLSessionUploadTask differs from an NSURLSessionDataTask
/// in how its instance is constructed.  Upload tasks are explicitly created
/// by referencing a file or data object to upload, or by utilizing the
/// -URLSession:task:needNewBodyStream: delegate message to supply an upload
/// body.
///
/// An NSURLSessionDownloadTask will directly write the response data to
/// a temporary file.  When completed, the delegate is sent
/// URLSession:downloadTask:didFinishDownloadingToURL: and given an opportunity
/// to move this file to a permanent location in its sandboxed container, or to
/// otherwise read the file. If canceled, an NSURLSessionDownloadTask can
/// produce a data blob that can be used to resume a download at a later
/// time.
///
/// Beginning with iOS 9 and Mac OS X 10.11, NSURLSessionStream is
/// available as a task type.  This allows for direct TCP/IP connection
/// to a given host and port with optional secure handshaking and
/// navigation of proxies.  Data tasks may also be upgraded to a
/// NSURLSessionStream task via the HTTP Upgrade: header and appropriate
/// use of the pipelining option of NSURLSessionConfiguration.  See RFC
/// 2817 and RFC 6455 for information about the Upgrade: header, and
/// comments below on turning data tasks into stream tasks.
///
/// An NSURLSessionWebSocketTask is a task that allows clients to connect to servers supporting
/// WebSocket. The task will perform the HTTP handshake to upgrade the connection
/// and once the WebSocket handshake is successful, the client can read and write
/// messages that will be framed using the WebSocket protocol by the framework.
extension type NSURLSession._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSURLSession] that points to the same underlying object as [other].
  NSURLSession.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLSession',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSURLSession] that wraps the given raw object pointer.
  NSURLSession.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLSession',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSURLSession].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSURLSession,
  );

  /// alloc
  static NSURLSession alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLSession, _sel_alloc);
    return NSURLSession.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLSession allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSURLSession,
      _sel_allocWithZone_,
      zone,
    );
    return NSURLSession.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSURLSession new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSURLSession, _sel_new);
    return NSURLSession.fromPointer($ret, retain: false, release: true);
  }

  /// Customization of NSURLSession occurs during creation of a new session.
  /// If you only need to use the convenience routines with custom
  /// configuration options it is not necessary to specify a delegate.
  /// If you do specify a delegate, the delegate will be retained until after
  /// the delegate has been sent the URLSession:didBecomeInvalidWithError: message.
  static NSURLSession sessionWithConfiguration(
    NSURLSessionConfiguration configuration,
  ) {
    objc.checkOsVersionInternal(
      'NSURLSession.sessionWithConfiguration:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSURLSession,
      _sel_sessionWithConfiguration_,
      configuration.ref.pointer,
    );
    return NSURLSession.fromPointer($ret, retain: true, release: true);
  }

  /// sessionWithConfiguration:delegate:delegateQueue:
  static NSURLSession sessionWithConfiguration$1(
    NSURLSessionConfiguration configuration, {
    NSURLSessionDelegate? delegate,
    NSOperationQueue? delegateQueue,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.sessionWithConfiguration:delegate:delegateQueue:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      _class_NSURLSession,
      _sel_sessionWithConfiguration_delegate_delegateQueue_,
      configuration.ref.pointer,
      delegate?.ref.pointer ?? ffi.nullptr,
      delegateQueue?.ref.pointer ?? ffi.nullptr,
    );
    return NSURLSession.fromPointer($ret, retain: true, release: true);
  }

  /// The shared session uses the currently set global NSURLCache,
  /// NSHTTPCookieStorage and NSURLCredentialStorage objects.
  static NSURLSession getSharedSession() {
    objc.checkOsVersionInternal(
      'NSURLSession.sharedSession',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSURLSession, _sel_sharedSession);
    return NSURLSession.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSURLSession constructed with the default `new` method.
  NSURLSession() : this.as(new$().object$);
}

extension NSURLSession$Methods on NSURLSession {
  /// configuration
  NSURLSessionConfiguration get configuration {
    objc.checkOsVersionInternal(
      'NSURLSession.configuration',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_configuration);
    return NSURLSessionConfiguration.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates a data task with the given request.  The request may have a body stream.
  NSURLSessionDataTask dataTaskWithRequest(NSURLRequest request) {
    objc.checkOsVersionInternal(
      'NSURLSession.dataTaskWithRequest:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_dataTaskWithRequest_,
      request.ref.pointer,
    );
    return NSURLSessionDataTask.fromPointer($ret, retain: true, release: true);
  }

  /// Creates a data task to retrieve the contents of the given URL.
  NSURLSessionDataTask dataTaskWithURL(objc.NSURL url) {
    objc.checkOsVersionInternal(
      'NSURLSession.dataTaskWithURL:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_dataTaskWithURL_,
      url.ref.pointer,
    );
    return NSURLSessionDataTask.fromPointer($ret, retain: true, release: true);
  }

  /// delegate
  NSURLSessionDelegate? get delegate {
    objc.checkOsVersionInternal(
      'NSURLSession.delegate',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_delegate);
    return $ret.address == 0
        ? null
        : NSURLSessionDelegate.fromPointer($ret, retain: true, release: true);
  }

  /// delegateQueue
  NSOperationQueue get delegateQueue {
    objc.checkOsVersionInternal(
      'NSURLSession.delegateQueue',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_delegateQueue);
    return NSOperationQueue.fromPointer($ret, retain: true, release: true);
  }

  /// Creates a download task with the given request.
  NSURLSessionDownloadTask downloadTaskWithRequest(NSURLRequest request) {
    objc.checkOsVersionInternal(
      'NSURLSession.downloadTaskWithRequest:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_downloadTaskWithRequest_,
      request.ref.pointer,
    );
    return NSURLSessionDownloadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates a download task with the resume data.  If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called.
  NSURLSessionDownloadTask downloadTaskWithResumeData(objc.NSData resumeData) {
    objc.checkOsVersionInternal(
      'NSURLSession.downloadTaskWithResumeData:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_downloadTaskWithResumeData_,
      resumeData.ref.pointer,
    );
    return NSURLSessionDownloadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates a download task to download the contents of the given URL.
  NSURLSessionDownloadTask downloadTaskWithURL(objc.NSURL url) {
    objc.checkOsVersionInternal(
      'NSURLSession.downloadTaskWithURL:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_downloadTaskWithURL_,
      url.ref.pointer,
    );
    return NSURLSessionDownloadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// -finishTasksAndInvalidate returns immediately and existing tasks will be allowed
  /// to run to completion.  New tasks may not be created.  The session
  /// will continue to make delegate callbacks until URLSession:didBecomeInvalidWithError:
  /// has been issued.
  ///
  /// -finishTasksAndInvalidate and -invalidateAndCancel do not
  /// have any effect on the shared session instance.
  ///
  /// When invalidating a background session, it is not safe to create another background
  /// session with the same identifier until URLSession:didBecomeInvalidWithError: has
  /// been issued.
  void finishTasksAndInvalidate() {
    objc.checkOsVersionInternal(
      'NSURLSession.finishTasksAndInvalidate',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_finishTasksAndInvalidate);
  }

  /// flush storage to disk and clear transient network caches.  Invokes completionHandler() on the delegate queue.
  void flushWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function()> completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'NSURLSession.flushWithCompletionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_flushWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// invokes completionHandler with all outstanding tasks.
  void getAllTasksWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(objc.NSArray)> completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'NSURLSession.getAllTasksWithCompletionHandler:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_getAllTasksWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// invokes completionHandler with outstanding data, upload and download tasks.
  void getTasksWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function(objc.NSArray, objc.NSArray, objc.NSArray)>
    completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'NSURLSession.getTasksWithCompletionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_getTasksWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// init
  NSURLSession init() {
    objc.checkOsVersionInternal(
      'NSURLSession.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSURLSession.fromPointer($ret, retain: false, release: true);
  }

  /// -invalidateAndCancel acts as -finishTasksAndInvalidate, but issues
  /// -cancel to all outstanding tasks for this session.  Note task
  /// cancellation is subject to the state of the task, and some tasks may
  /// have already have completed at the time they are sent -cancel.
  void invalidateAndCancel() {
    objc.checkOsVersionInternal(
      'NSURLSession.invalidateAndCancel',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_invalidateAndCancel);
  }

  /// empty all cookies, cache and credential stores, removes disk files, issues -flushWithCompletionHandler:. Invokes completionHandler() on the delegate queue.
  void resetWithCompletionHandler(
    objc.ObjCBlock<ffi.Void Function()> completionHandler,
  ) {
    objc.checkOsVersionInternal(
      'NSURLSession.resetWithCompletionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_f167m6(
      object$.ref.pointer,
      _sel_resetWithCompletionHandler_,
      completionHandler.ref.pointer,
    );
  }

  /// The sessionDescription property is available for the developer to
  /// provide a descriptive label for the session.
  objc.NSString? get sessionDescription {
    objc.checkOsVersionInternal(
      'NSURLSession.sessionDescription',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_sessionDescription,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// The sessionDescription property is available for the developer to
  /// provide a descriptive label for the session.
  set sessionDescription(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSURLSession.setSessionDescription:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setSessionDescription_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Creates a bidirectional stream task to a given host and port.
  NSURLSessionStreamTask streamTaskWithHostName(
    objc.NSString hostname, {
    required int port,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.streamTaskWithHostName:port:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_9slupp(
      object$.ref.pointer,
      _sel_streamTaskWithHostName_port_,
      hostname.ref.pointer,
      port,
    );
    return NSURLSessionStreamTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates a bidirectional stream task with an NSNetService to identify the endpoint.
  /// The NSNetService will be resolved before any IO completes.
  NSURLSessionStreamTask streamTaskWithNetService(NSNetService service) {
    objc.checkOsVersionInternal(
      'NSURLSession.streamTaskWithNetService:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_streamTaskWithNetService_,
      service.ref.pointer,
    );
    return NSURLSessionStreamTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates an upload task with the given request.  The body of the request is provided from the bodyData.
  NSURLSessionUploadTask uploadTaskWithRequest(
    NSURLRequest request, {
    required objc.NSData fromData,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.uploadTaskWithRequest:fromData:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_uploadTaskWithRequest_fromData_,
      request.ref.pointer,
      fromData.ref.pointer,
    );
    return NSURLSessionUploadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates an upload task with the given request.  The body of the request will be created from the file referenced by fileURL
  NSURLSessionUploadTask uploadTaskWithRequest$1(
    NSURLRequest request, {
    required objc.NSURL fromFile,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.uploadTaskWithRequest:fromFile:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_uploadTaskWithRequest_fromFile_,
      request.ref.pointer,
      fromFile.ref.pointer,
    );
    return NSURLSessionUploadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates an upload task from a resume data blob. Requires the server to support the latest resumable uploads
  /// Internet-Draft from the HTTP Working Group, found at
  /// https://datatracker.ietf.org/doc/draft-ietf-httpbis-resumable-upload/
  /// If resuming from an upload file, the file must still exist and be unmodified. If the upload cannot be successfully
  /// resumed, URLSession:task:didCompleteWithError: will be called.
  ///
  /// - Parameter resumeData: Resume data blob from an incomplete upload, such as data returned by the cancelByProducingResumeData: method.
  /// - Returns: A new session upload task, or nil if the resumeData is invalid.
  NSURLSessionUploadTask uploadTaskWithResumeData(objc.NSData resumeData) {
    objc.checkOsVersionInternal(
      'NSURLSession.uploadTaskWithResumeData:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_uploadTaskWithResumeData_,
      resumeData.ref.pointer,
    );
    return NSURLSessionUploadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates an upload task with the given request.  The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required.
  NSURLSessionUploadTask uploadTaskWithStreamedRequest(NSURLRequest request) {
    objc.checkOsVersionInternal(
      'NSURLSession.uploadTaskWithStreamedRequest:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_uploadTaskWithStreamedRequest_,
      request.ref.pointer,
    );
    return NSURLSessionUploadTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates a WebSocket task given the request. The request properties can be modified and will be used by the task during the HTTP handshake phase.
  /// Clients who want to add custom protocols can do so by directly adding headers with the key Sec-WebSocket-Protocol
  /// and a comma separated list of protocols they wish to negotiate with the server. The custom HTTP headers provided by the client will remain unchanged for the handshake with the server.
  NSURLSessionWebSocketTask webSocketTaskWithRequest(NSURLRequest request) {
    objc.checkOsVersionInternal(
      'NSURLSession.webSocketTaskWithRequest:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_webSocketTaskWithRequest_,
      request.ref.pointer,
    );
    return NSURLSessionWebSocketTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates a WebSocket task given the url. The given url must have a ws or wss scheme.
  NSURLSessionWebSocketTask webSocketTaskWithURL(objc.NSURL url) {
    objc.checkOsVersionInternal(
      'NSURLSession.webSocketTaskWithURL:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_webSocketTaskWithURL_,
      url.ref.pointer,
    );
    return NSURLSessionWebSocketTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }

  /// Creates a WebSocket task given the url and an array of protocols. The protocols will be used in the WebSocket handshake to
  /// negotiate a preferred protocol with the server
  /// Note - The protocol will not affect the WebSocket framing. More details on the protocol can be found by reading the WebSocket RFC
  NSURLSessionWebSocketTask webSocketTaskWithURL$1(
    objc.NSURL url, {
    required objc.NSArray protocols,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSession.webSocketTaskWithURL:protocols:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      object$.ref.pointer,
      _sel_webSocketTaskWithURL_protocols_,
      url.ref.pointer,
      protocols.ref.pointer,
    );
    return NSURLSessionWebSocketTask.fromPointer(
      $ret,
      retain: true,
      release: true,
    );
  }
}

/// Disposition options for various delegate messages
enum NSURLSessionDelayedRequestDisposition {
  /// Use the original request provided when the task was created; the request parameter is ignored.
  NSURLSessionDelayedRequestContinueLoading(0),

  /// Use the specified request, which may not be nil.
  NSURLSessionDelayedRequestUseNewRequest(1),

  /// Cancel the task; the request parameter is ignored.
  NSURLSessionDelayedRequestCancel(2);

  final int value;
  const NSURLSessionDelayedRequestDisposition(this.value);

  static NSURLSessionDelayedRequestDisposition fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionDelayedRequestContinueLoading,
        1 => NSURLSessionDelayedRequestUseNewRequest,
        2 => NSURLSessionDelayedRequestCancel,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionDelayedRequestDisposition: $value',
        ),
      };
}

enum NSURLSessionAuthChallengeDisposition {
  /// Use the specified credential, which may be nil
  NSURLSessionAuthChallengeUseCredential(0),

  /// Default handling for the challenge - as if this delegate were not implemented; the credential parameter is ignored.
  NSURLSessionAuthChallengePerformDefaultHandling(1),

  /// The entire request will be canceled; the credential parameter is ignored.
  NSURLSessionAuthChallengeCancelAuthenticationChallenge(2),

  /// This challenge is rejected and the next authentication protection space should be tried; the credential parameter is ignored.
  NSURLSessionAuthChallengeRejectProtectionSpace(3);

  final int value;
  const NSURLSessionAuthChallengeDisposition(this.value);

  static NSURLSessionAuthChallengeDisposition fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionAuthChallengeUseCredential,
        1 => NSURLSessionAuthChallengePerformDefaultHandling,
        2 => NSURLSessionAuthChallengeCancelAuthenticationChallenge,
        3 => NSURLSessionAuthChallengeRejectProtectionSpace,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionAuthChallengeDisposition: $value',
        ),
      };
}

enum NSURLSessionResponseDisposition {
  /// Cancel the load, this is the same as -[task cancel]
  NSURLSessionResponseCancel(0),

  /// Allow the load to continue
  NSURLSessionResponseAllow(1),

  /// Turn this request into a download
  NSURLSessionResponseBecomeDownload(2),

  /// Turn this task into a stream task
  NSURLSessionResponseBecomeStream(3);

  final int value;
  const NSURLSessionResponseDisposition(this.value);

  static NSURLSessionResponseDisposition fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionResponseCancel,
        1 => NSURLSessionResponseAllow,
        2 => NSURLSessionResponseBecomeDownload,
        3 => NSURLSessionResponseBecomeStream,
        _ => throw ArgumentError(
          'Unknown value for NSURLSessionResponseDisposition: $value',
        ),
      };
}

late final _protocol_NSURLSessionDataDelegate = objc.getProtocol(
  "NSURLSessionDataDelegate",
);
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCProtocolImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCProtocolImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionResponseDisposition {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> fromFunction(
    void Function(NSURLSessionResponseDisposition) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0) => fn(NSURLSessionResponseDisposition.fromValue(arg0)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> listener(
    void Function(NSURLSessionResponseDisposition) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0) => fn(NSURLSessionResponseDisposition.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_16sve1d(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long)> blocking(
    void Function(NSURLSessionResponseDisposition) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0) => fn(NSURLSessionResponseDisposition.fromValue(arg0)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0) => fn(NSURLSessionResponseDisposition.fromValue(arg0)),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_16sve1d(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(int))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Long arg0)>>()
      .asFunction<void Function(int)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
  ) => (objc.getBlockClosure(block) as void Function(int))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Long)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long)>`.
extension ObjCBlock_ffiVoid_NSURLSessionResponseDisposition$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long)> {
  void call(NSURLSessionResponseDisposition arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
        ref.pointer,
        arg0.value,
      );
}

late final _sel_URLSession_dataTask_didReceiveResponse_completionHandler_ = objc
    .registerName("URLSession:dataTask:didReceiveResponse:completionHandler:");
final _objc_msgSend_m7tls4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Long arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>
  fromFunction(
    void Function(NSURLSessionDelayedRequestDisposition, NSURLRequest?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionDelayedRequestDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLRequest.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> listener(
    void Function(NSURLSessionDelayedRequestDisposition, NSURLRequest?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionDelayedRequestDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLRequest.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1otpo83(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> blocking(
    void Function(NSURLSessionDelayedRequestDisposition, NSURLRequest?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionDelayedRequestDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLRequest.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionDelayedRequestDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLRequest.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1otpo83(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<void Function(int, ffi.Pointer<objc.ObjCObjectImpl>)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>`.
extension ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> {
  void call(NSURLSessionDelayedRequestDisposition arg0, NSURLRequest? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              int,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0.value, arg1?.ref.pointer ?? ffi.nullptr);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(ffi.Long)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ffi.Pointer<objc.ObjCBlockImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionDataTask.fromPointer(arg2, retain: true, release: true),
            NSURLResponse.fromPointer(arg3, retain: true, release: true),
            ObjCBlock_ffiVoid_NSURLSessionResponseDisposition.fromPointer(
              arg4,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSURLResponse.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_NSURLSessionResponseDisposition.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xx612k(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDataTask,
        NSURLResponse,
        objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSURLResponse.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_NSURLSessionResponseDisposition.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSURLResponse.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_NSURLSessionResponseDisposition.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_xx612k(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDataTask,
        NSURLResponse,
        objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(ffi.Long)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            NSURLResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionDataTask arg2,
    NSURLResponse arg3,
    objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
        arg4.ref.pointer,
      );
}

late final _sel_URLSession_dataTask_didBecomeDownloadTask_ = objc.registerName(
  "URLSession:dataTask:didBecomeDownloadTask:",
);
final _objc_msgSend_r8gdi7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _class_NSHTTPURLResponse = objc.getClass("NSHTTPURLResponse");
late final _sel_initWithURL_statusCode_HTTPVersion_headerFields_ = objc
    .registerName("initWithURL:statusCode:HTTPVersion:headerFields:");
final _objc_msgSend_xw7l5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_statusCode = objc.registerName("statusCode");
late final _sel_allHeaderFields = objc.registerName("allHeaderFields");
late final _sel_localizedStringForStatusCode_ = objc.registerName(
  "localizedStringForStatusCode:",
);
final _objc_msgSend_qugqlf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();

/// NSHTTPURLResponse
extension type NSHTTPURLResponse._(objc.ObjCObject object$)
    implements objc.ObjCObject, NSURLResponse {
  /// Constructs a [NSHTTPURLResponse] that points to the same underlying object as [other].
  NSHTTPURLResponse.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [NSHTTPURLResponse] that wraps the given raw object pointer.
  NSHTTPURLResponse.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSHTTPURLResponse].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSHTTPURLResponse,
  );

  /// alloc
  static NSHTTPURLResponse alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSHTTPURLResponse, _sel_alloc);
    return NSHTTPURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSHTTPURLResponse allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSHTTPURLResponse,
      _sel_allocWithZone_,
      zone,
    );
    return NSHTTPURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method localizedStringForStatusCode:
  /// @abstract Convenience method which returns a localized string
  /// corresponding to the status code for this response.
  /// @param statusCode the status code to use to produce a localized string.
  /// @result A localized string corresponding to the given status code.
  static objc.NSString localizedStringForStatusCode(int statusCode) {
    objc.checkOsVersionInternal(
      'NSHTTPURLResponse.localizedStringForStatusCode:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_qugqlf(
      _class_NSHTTPURLResponse,
      _sel_localizedStringForStatusCode_,
      statusCode,
    );
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// new
  static NSHTTPURLResponse new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSHTTPURLResponse, _sel_new);
    return NSHTTPURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
      _class_NSHTTPURLResponse,
      _sel_supportsSecureCoding,
    );
  }

  /// Returns a new instance of NSHTTPURLResponse constructed with the default `new` method.
  NSHTTPURLResponse() : this.as(new$().object$);
}

extension NSHTTPURLResponse$Methods on NSHTTPURLResponse {
  /// !
  /// @abstract Returns a dictionary containing all the HTTP header fields
  /// of the receiver.
  /// @discussion By examining this header dictionary, clients can see
  /// the "raw" header information which was reported to the protocol
  /// implementation by the HTTP server. This may be of use to
  /// sophisticated or special-purpose HTTP clients.
  /// @result A dictionary containing all the HTTP header fields of the
  /// receiver.
  objc.NSDictionary get allHeaderFields {
    objc.checkOsVersionInternal(
      'NSHTTPURLResponse.allHeaderFields',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.pointer,
      _sel_allHeaderFields,
    );
    return objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NSHTTPURLResponse init() {
    objc.checkOsVersionInternal(
      'NSHTTPURLResponse.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSHTTPURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  NSHTTPURLResponse? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : NSHTTPURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method initWithURL:MIMEType:expectedContentLength:textEncodingName:
  /// @abstract Initialize an NSURLResponse with the provided values.
  /// @param URL the URL
  /// @param MIMEType the MIME content type of the response
  /// @param length the expected content length of the associated data
  /// @param name the name of the text encoding for the associated data, if applicable, else nil
  /// @result The initialized NSURLResponse.
  /// @discussion This is the designated initializer for NSURLResponse.
  NSHTTPURLResponse initWithUrlAndMIMEType(
    objc.NSURL URL, {
    objc.NSString? MIMEType,
    required int length,
    objc.NSString? name,
  }) {
    objc.checkOsVersionInternal(
      'NSHTTPURLResponse.initWithURL:MIMEType:expectedContentLength:textEncodingName:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    final $ret = _objc_msgSend_l9ppnx(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_MIMEType_expectedContentLength_textEncodingName_,
      URL.ref.pointer,
      MIMEType?.ref.pointer ?? ffi.nullptr,
      length,
      name?.ref.pointer ?? ffi.nullptr,
    );
    return NSHTTPURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @method	initWithURL:statusCode:HTTPVersion:headerFields:
  /// @abstract initializer for NSHTTPURLResponse objects.
  /// @param 	url the URL from which the response was generated.
  /// @param	statusCode an HTTP status code.
  /// @param	HTTPVersion The version of the HTTP response as represented by the server.  This is typically represented as "HTTP/1.1".
  /// @param 	headerFields A dictionary representing the header keys and values of the server response.
  /// @result 	the instance of the object, or NULL if an error occurred during initialization.
  /// @discussion This API was introduced in Mac OS X 10.7.2 and iOS 5.0 and is not available prior to those releases.
  NSHTTPURLResponse? initWithURLAndStatusCode(
    objc.NSURL url, {
    required int statusCode,
    objc.NSString? HTTPVersion,
    objc.NSDictionary? headerFields,
  }) {
    objc.checkOsVersionInternal(
      'NSHTTPURLResponse.initWithURL:statusCode:HTTPVersion:headerFields:',
      iOS: (false, (5, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_xw7l5(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithURL_statusCode_HTTPVersion_headerFields_,
      url.ref.pointer,
      statusCode,
      HTTPVersion?.ref.pointer ?? ffi.nullptr,
      headerFields?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0
        ? null
        : NSHTTPURLResponse.fromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @abstract Returns the HTTP status code of the receiver.
  /// @result The HTTP status code of the receiver.
  int get statusCode {
    objc.checkOsVersionInternal(
      'NSHTTPURLResponse.statusCode',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 2, 0)),
    );
    return _objc_msgSend_1hz7y9r(object$.ref.pointer, _sel_statusCode);
  }

  /// !
  /// @method valueForHTTPHeaderField:
  /// @abstract Returns the value which corresponds to the given header
  /// field. Note that, in keeping with the HTTP RFC, HTTP header field
  /// names are case-insensitive.
  /// @param field the header field name to use for the lookup
  /// (case-insensitive).
  /// @result the value associated with the given header field, or nil if
  /// there is no value associated with the given header field.
  objc.NSString? valueForHTTPHeaderField(objc.NSString field) {
    objc.checkOsVersionInternal(
      'NSHTTPURLResponse.valueForHTTPHeaderField:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.pointer,
      _sel_valueForHTTPHeaderField_,
      field.ref.pointer,
    );
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionDownloadTask,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLSessionDownloadTask,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionDownloadTask,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLSessionDownloadTask,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionDownloadTask,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionDownloadTask,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLSessionDownloadTask,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionDataTask.fromPointer(arg2, retain: true, release: true),
            NSURLSessionDownloadTask.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionDownloadTask,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionDownloadTask,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDataTask,
        NSURLSessionDownloadTask,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionDownloadTask,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionDownloadTask,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDataTask,
        NSURLSessionDownloadTask,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionDownloadTask,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionDataTask arg2,
    NSURLSessionDownloadTask arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_URLSession_dataTask_didBecomeStreamTask_ = objc.registerName(
  "URLSession:dataTask:didBecomeStreamTask:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionStreamTask,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLSessionStreamTask,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionStreamTask,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLSessionStreamTask,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionStreamTask,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionStreamTask,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLSessionStreamTask,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionDataTask.fromPointer(arg2, retain: true, release: true),
            NSURLSessionStreamTask.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionStreamTask,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionStreamTask,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSURLSessionStreamTask.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDataTask,
        NSURLSessionStreamTask,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionStreamTask,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSURLSessionStreamTask,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSURLSessionStreamTask.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSURLSessionStreamTask.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDataTask,
        NSURLSessionStreamTask,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionStreamTask,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionDataTask arg2,
    NSURLSessionStreamTask arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_URLSession_dataTask_didReceiveData_ = objc.registerName(
  "URLSession:dataTask:didReceiveData:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, objc.NSData)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      objc.NSData,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          objc.NSData,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      objc.NSData,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          objc.NSData,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      objc.NSData,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      objc.NSData,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          objc.NSData,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionDataTask.fromPointer(arg2, retain: true, release: true),
            objc.NSData.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      objc.NSData,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      objc.NSData,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        objc.NSData.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDataTask,
        objc.NSData,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      objc.NSData,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      objc.NSData,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        objc.NSData.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        objc.NSData.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDataTask,
        objc.NSData,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, objc.NSData)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            objc.NSData,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionDataTask arg2,
    objc.NSData arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_URLSession_dataTask_willCacheResponse_completionHandler_ = objc
    .registerName("URLSession:dataTask:willCacheResponse:completionHandler:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSCachedURLResponse, objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSCachedURLResponse,
          objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ffi.Pointer<objc.ObjCBlockImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSCachedURLResponse,
          objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSCachedURLResponse,
          objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionDataTask.fromPointer(arg2, retain: true, release: true),
            NSCachedURLResponse.fromPointer(arg3, retain: true, release: true),
            ObjCBlock_ffiVoid_NSCachedURLResponse.fromPointer(
              arg4,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSCachedURLResponse.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_NSCachedURLResponse.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xx612k(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDataTask,
        NSCachedURLResponse,
        objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSCachedURLResponse.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_NSCachedURLResponse.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDataTask.fromPointer(arg2, retain: false, release: true),
        NSCachedURLResponse.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_NSCachedURLResponse.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_xx612k(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDataTask,
        NSCachedURLResponse,
        objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSCachedURLResponse, objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            NSCachedURLResponse,
            objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionDataTask arg2,
    NSCachedURLResponse arg3,
    objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
        arg4.ref.pointer,
      );
}

late final _sel_URLSession_didCreateTask_ = objc.registerName(
  "URLSession:didCreateTask:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionTask.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionTask arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_URLSession_task_willBeginDelayedRequest_completionHandler_ =
    objc.registerName(
      "URLSession:task:willBeginDelayedRequest:completionHandler:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ffi.Pointer<objc.ObjCBlockImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionTask.fromPointer(arg2, retain: true, release: true),
            NSURLRequest.fromPointer(arg3, retain: true, release: true),
            ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest.fromPointer(
              arg4,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSURLRequest.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xx612k(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        NSURLRequest,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSURLRequest.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSURLRequest.fromPointer(arg3, retain: false, release: true),
        ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_xx612k(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        NSURLRequest,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionTask arg2,
    NSURLRequest arg3,
    objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
        arg4.ref.pointer,
      );
}

late final _sel_URLSession_taskIsWaitingForConnectivity_ = objc.registerName(
  "URLSession:taskIsWaitingForConnectivity:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> fromFunction(
    void Function(NSURLRequest?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NSURLRequest.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> listener(
    void Function(NSURLRequest?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NSURLRequest.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> blocking(
    void Function(NSURLRequest?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NSURLRequest.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : NSURLRequest.fromPointer(arg0, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>`.
extension ObjCBlock_ffiVoid_NSURLRequest$CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> {
  void call(NSURLRequest? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_ =
    objc.registerName(
      "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:",
    );
final _objc_msgSend_e1wgee = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ffi.Pointer<objc.ObjCObjectImpl> arg4,
          ffi.Pointer<objc.ObjCBlockImpl> arg5,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCObjectImpl> arg4,
            ffi.Pointer<objc.ObjCBlockImpl> arg5,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionTask.fromPointer(arg2, retain: true, release: true),
            NSHTTPURLResponse.fromPointer(arg3, retain: true, release: true),
            NSURLRequest.fromPointer(arg4, retain: true, release: true),
            ObjCBlock_ffiVoid_NSURLRequest.fromPointer(
              arg5,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCObjectImpl> arg4,
        ffi.Pointer<objc.ObjCBlockImpl> arg5,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSHTTPURLResponse.fromPointer(arg3, retain: false, release: true),
        NSURLRequest.fromPointer(arg4, retain: false, release: true),
        ObjCBlock_ffiVoid_NSURLRequest.fromPointer(
          arg5,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_l2g8ke(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        NSHTTPURLResponse,
        NSURLRequest,
        objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCObjectImpl> arg4,
        ffi.Pointer<objc.ObjCBlockImpl> arg5,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSHTTPURLResponse.fromPointer(arg3, retain: false, release: true),
        NSURLRequest.fromPointer(arg4, retain: false, release: true),
        ObjCBlock_ffiVoid_NSURLRequest.fromPointer(
          arg5,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCObjectImpl> arg4,
        ffi.Pointer<objc.ObjCBlockImpl> arg5,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSHTTPURLResponse.fromPointer(arg3, retain: false, release: true),
        NSURLRequest.fromPointer(arg4, retain: false, release: true),
        ObjCBlock_ffiVoid_NSURLRequest.fromPointer(
          arg5,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_l2g8ke(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        NSHTTPURLResponse,
        NSURLRequest,
        objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
    ffi.Pointer<objc.ObjCBlockImpl> arg5,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3, arg4, arg5);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
    ffi.Pointer<objc.ObjCBlockImpl> arg5,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4, arg5);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
    ffi.Pointer<objc.ObjCBlockImpl> arg5,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCObjectImpl> arg4,
            ffi.Pointer<objc.ObjCBlockImpl> arg5,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4, arg5);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
    ffi.Pointer<objc.ObjCBlockImpl> arg5,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4, arg5);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionTask arg2,
    NSHTTPURLResponse arg3,
    NSURLRequest arg4,
    objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
                ffi.Pointer<objc.ObjCObjectImpl> arg4,
                ffi.Pointer<objc.ObjCBlockImpl> arg5,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
        arg4.ref.pointer,
        arg5.ref.pointer,
      );
}

/// WARNING: NSURLAuthenticationChallenge is a stub. To generate bindings for this class, include
/// NSURLAuthenticationChallenge in your config's objc-interfaces list.
///
/// NSURLAuthenticationChallenge
extension type NSURLAuthenticationChallenge._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [NSURLAuthenticationChallenge] that points to the same underlying object as [other].
  NSURLAuthenticationChallenge.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [NSURLAuthenticationChallenge] that wraps the given raw object pointer.
  NSURLAuthenticationChallenge.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

/// WARNING: NSURLCredential is a stub. To generate bindings for this class, include
/// NSURLCredential in your config's objc-interfaces list.
///
/// NSURLCredential
extension type NSURLCredential._(objc.ObjCObject object$)
    implements objc.ObjCObject {
  /// Constructs a [NSURLCredential] that points to the same underlying object as [other].
  NSURLCredential.as(objc.ObjCObject other) : object$ = other {}

  /// Constructs a [NSURLCredential] that wraps the given raw object pointer.
  NSURLCredential.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {}
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Long arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
  fromFunction(
    void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
    objc.newClosureBlock(
      _closureCallable,
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> listener(
    void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_n8yd09(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> blocking(
    void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (int arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        NSURLSessionAuthChallengeDisposition.fromValue(arg0),
        arg1.address == 0
            ? null
            : NSURLCredential.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_n8yd09(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<void Function(int, ffi.Pointer<objc.ObjCObjectImpl>)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    int arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(int, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>`.
extension ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> {
  void call(NSURLSessionAuthChallengeDisposition arg0, NSURLCredential? arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Long arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              int,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(ref.pointer, arg0.value, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_URLSession_task_didReceiveChallenge_completionHandler_ = objc
    .registerName("URLSession:task:didReceiveChallenge:completionHandler:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ffi.Pointer<objc.ObjCBlockImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionTask.fromPointer(arg2, retain: true, release: true),
            NSURLAuthenticationChallenge.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
            ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
              arg4,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xx612k(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_xx612k(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionTask arg2,
    NSURLAuthenticationChallenge arg3,
    objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
        arg4.ref.pointer,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>`.
abstract final class ObjCBlock_ffiVoid_NSInputStream {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> fromFunction(
    void Function(objc.NSInputStream?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSInputStream.fromPointer(arg0, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> listener(
    void Function(objc.NSInputStream?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSInputStream.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> blocking(
    void Function(objc.NSInputStream?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSInputStream.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0) => fn(
        arg0.address == 0
            ? null
            : objc.NSInputStream.fromPointer(
                arg0,
                retain: false,
                release: true,
              ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>`.
extension ObjCBlock_ffiVoid_NSInputStream$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> {
  void call(objc.NSInputStream? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_URLSession_task_needNewBodyStream_ = objc.registerName(
  "URLSession:task:needNewBodyStream:",
);
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCBlockImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionTask.fromPointer(arg2, retain: true, release: true),
            ObjCBlock_ffiVoid_NSInputStream.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_NSInputStream.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_NSInputStream.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        ObjCBlock_ffiVoid_NSInputStream.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_bklti2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionTask arg2,
    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_ =
    objc.registerName(
      "URLSession:task:needNewBodyStreamFromOffset:completionHandler:",
    );
final _objc_msgSend_9cddqw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Int64,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      ffi.Int64,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          ffi.Int64,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      ffi.Int64,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Int64 arg3,
          ffi.Pointer<objc.ObjCBlockImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          ffi.Int64,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      ffi.Int64,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          ffi.Int64,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            int arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionTask.fromPointer(arg2, retain: true, release: true),
            arg3,
            ObjCBlock_ffiVoid_NSInputStream.fromPointer(
              arg4,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      ffi.Int64,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        arg3,
        ObjCBlock_ffiVoid_NSInputStream.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_jyim80(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        ffi.Int64,
        objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      ffi.Int64,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        arg3,
        ObjCBlock_ffiVoid_NSInputStream.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        arg3,
        ObjCBlock_ffiVoid_NSInputStream.fromPointer(
          arg4,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_jyim80(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        ffi.Int64,
        objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Int64 arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Int64,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    ffi.Pointer<objc.ObjCBlockImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Int64,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            ffi.Int64,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionTask arg2,
    int arg3,
    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Int64 arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              int,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3,
        arg4.ref.pointer,
      );
}

late final _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_ =
    objc.registerName(
      "URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:",
    );
final _objc_msgSend_1modw1b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Int64,
          ffi.Int64,
          ffi.Int64,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        int,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, ffi.Int64, ffi.Int64)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          ffi.Int64,
          ffi.Int64,
          ffi.Int64,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Int64 arg3,
          ffi.Int64 arg4,
          ffi.Int64 arg5,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          ffi.Int64,
          ffi.Int64,
          ffi.Int64,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      int,
      int,
      int,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          ffi.Int64,
          ffi.Int64,
          ffi.Int64,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            int arg3,
            int arg4,
            int arg5,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionTask.fromPointer(arg2, retain: true, release: true),
            arg3,
            arg4,
            arg5,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      int,
      int,
      int,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        int arg4,
        int arg5,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        arg3,
        arg4,
        arg5,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_h68abb(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        ffi.Int64,
        ffi.Int64,
        ffi.Int64,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      int,
      int,
      int,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        int arg4,
        int arg5,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        arg3,
        arg4,
        arg5,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        int arg4,
        int arg5,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        arg3,
        arg4,
        arg5,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_h68abb(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        ffi.Int64,
        ffi.Int64,
        ffi.Int64,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
    int arg5,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          int,
          int,
        ))(arg0, arg1, arg2, arg3, arg4, arg5);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
    int arg5,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            int,
            int,
          ))(arg0, arg1, arg2, arg3, arg4, arg5);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
    int arg5,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Int64 arg3,
            ffi.Int64 arg4,
            ffi.Int64 arg5,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          int,
          int,
        )
      >()(arg0, arg1, arg2, arg3, arg4, arg5);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Int64,
              ffi.Int64,
              ffi.Int64,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
    int arg5,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            int,
            int,
          ))(arg0, arg1, arg2, arg3, arg4, arg5);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Int64,
              ffi.Int64,
              ffi.Int64,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, ffi.Int64, ffi.Int64)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionTask arg2,
    int arg3,
    int arg4,
    int arg5,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Int64 arg3,
                ffi.Int64 arg4,
                ffi.Int64 arg5,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              int,
              int,
              int,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3,
        arg4,
        arg5,
      );
}

late final _sel_URLSession_task_didReceiveInformationalResponse_ = objc
    .registerName("URLSession:task:didReceiveInformationalResponse:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionTask.fromPointer(arg2, retain: true, release: true),
            NSHTTPURLResponse.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSHTTPURLResponse.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        NSHTTPURLResponse,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSHTTPURLResponse.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSHTTPURLResponse.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        NSHTTPURLResponse,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionTask arg2,
    NSHTTPURLResponse arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

/// WARNING: NSURLSessionTaskMetrics is a stub. To generate bindings for this class, include
/// NSURLSessionTaskMetrics in your config's objc-interfaces list.
///
/// NSURLSessionTaskMetrics
extension type NSURLSessionTaskMetrics._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSURLSessionTaskMetrics] that points to the same underlying object as [other].
  NSURLSessionTaskMetrics.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSURLSessionTaskMetrics',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
  }

  /// Constructs a [NSURLSessionTaskMetrics] that wraps the given raw object pointer.
  NSURLSessionTaskMetrics.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSURLSessionTaskMetrics',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
  }
}

late final _sel_URLSession_task_didFinishCollectingMetrics_ = objc.registerName(
  "URLSession:task:didFinishCollectingMetrics:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLSessionTaskMetrics,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLSessionTaskMetrics,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLSessionTaskMetrics,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLSessionTaskMetrics,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLSessionTaskMetrics,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLSessionTaskMetrics,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLSessionTaskMetrics,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionTask.fromPointer(arg2, retain: true, release: true),
            NSURLSessionTaskMetrics.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLSessionTaskMetrics,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLSessionTaskMetrics,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSURLSessionTaskMetrics.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        NSURLSessionTaskMetrics,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLSessionTaskMetrics,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      NSURLSessionTaskMetrics,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSURLSessionTaskMetrics.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        NSURLSessionTaskMetrics.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        NSURLSessionTaskMetrics,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            NSURLSessionTaskMetrics,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionTask arg2,
    NSURLSessionTaskMetrics arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_URLSession_task_didCompleteWithError_ = objc.registerName(
  "URLSession:task:didCompleteWithError:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.NSError?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          objc.NSError?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.NSError?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          objc.NSError?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.NSError?,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          objc.NSError?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionTask.fromPointer(arg2, retain: true, release: true),
            arg3.address == 0
                ? null
                : objc.NSError.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.NSError?,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.NSError?,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionTask,
      objc.NSError?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionTask.fromPointer(arg2, retain: false, release: true),
        arg3.address == 0
            ? null
            : objc.NSError.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionTask,
        objc.NSError?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            objc.NSError?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionTask arg2,
    objc.NSError? arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_URLSession_didBecomeInvalidWithError_ = objc.registerName(
  "URLSession:didBecomeInvalidWithError:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            arg2.address == 0
                ? null
                : objc.NSError.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        arg2.address == 0
            ? null
            : objc.NSError.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_fjrv01(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    objc.NSError? arg2,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_URLSession_didReceiveChallenge_completionHandler_ = objc
    .registerName("URLSession:didReceiveChallenge:completionHandler:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCBlockImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLAuthenticationChallenge.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
              arg3,
              retain: true,
              release: true,
            ),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLAuthenticationChallenge.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.fromPointer(
          arg3,
          retain: false,
          release: true,
        ),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_bklti2(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLAuthenticationChallenge,
        objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCBlockImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLAuthenticationChallenge arg2,
    objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)> arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_URLSessionDidFinishEventsForBackgroundURLSession_ = objc
    .registerName("URLSessionDidFinishEventsForBackgroundURLSession:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSURLSession) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, NSURLSession.fromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, NSURLSession) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, NSURLSession) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_18v1jvf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
      >()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// Messages related to the operation of a task that delivers data
/// directly to the delegate.
extension type NSURLSessionDataDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, NSURLSessionTaskDelegate {
  /// Constructs a [NSURLSessionDataDelegate] that points to the same underlying object as [other].
  NSURLSessionDataDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSURLSessionDataDelegate] that wraps the given raw object pointer.
  NSURLSessionDataDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLSessionDataDelegate].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSURLSessionDataDelegate,
    );
  }
}

extension NSURLSessionDataDelegate$Methods on NSURLSessionDataDelegate {
  /// Notification that a data task has become a download task.  No
  /// future messages will be sent to the data task.
  void URLSession(
    NSURLSession session, {
    required NSURLSessionDataTask dataTask,
    required NSURLSessionDownloadTask didBecomeDownloadTask,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:dataTask:didBecomeDownloadTask:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_dataTask_didBecomeDownloadTask_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:dataTask:didBecomeDownloadTask:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_dataTask_didBecomeDownloadTask_,
      session.ref.pointer,
      dataTask.ref.pointer,
      didBecomeDownloadTask.ref.pointer,
    );
  }

  /// Notification that a data task has become a bidirectional stream
  /// task.  No future messages will be sent to the data task.  The newly
  /// created streamTask will carry the original request and response as
  /// properties.
  ///
  /// For requests that were pipelined, the stream object will only allow
  /// reading, and the object will immediately issue a
  /// -URLSession:writeClosedForStream:.  Pipelining can be disabled for
  /// all requests in a session, or by the NSURLRequest
  /// HTTPShouldUsePipelining property.
  ///
  /// The underlying connection is no longer considered part of the HTTP
  /// connection cache and won't count against the total number of
  /// connections per host.
  void URLSession$1(
    NSURLSession session, {
    required NSURLSessionDataTask dataTask,
    required NSURLSessionStreamTask didBecomeStreamTask,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:dataTask:didBecomeStreamTask:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_dataTask_didBecomeStreamTask_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:dataTask:didBecomeStreamTask:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_dataTask_didBecomeStreamTask_,
      session.ref.pointer,
      dataTask.ref.pointer,
      didBecomeStreamTask.ref.pointer,
    );
  }

  /// Sent when data is available for the delegate to consume.  As the
  /// data may be discontiguous, you should use
  /// [NSData enumerateByteRangesUsingBlock:] to access it.
  void URLSession$2(
    NSURLSession session, {
    required NSURLSessionDataTask dataTask,
    required objc.NSData didReceiveData,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:dataTask:didReceiveData:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_dataTask_didReceiveData_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:dataTask:didReceiveData:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_dataTask_didReceiveData_,
      session.ref.pointer,
      dataTask.ref.pointer,
      didReceiveData.ref.pointer,
    );
  }

  /// The task has received a response and no further messages will be
  /// received until the completion block is called. The disposition
  /// allows you to cancel a request or to turn a data task into a
  /// download task. This delegate message is optional - if you do not
  /// implement it, you can get the response as a property of the task.
  ///
  /// This method will not be called for background upload tasks (which cannot be converted to download tasks).
  void URLSession$3(
    NSURLSession session, {
    required NSURLSessionDataTask dataTask,
    required NSURLResponse didReceiveResponse,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:dataTask:didReceiveResponse:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_dataTask_didReceiveResponse_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:dataTask:didReceiveResponse:completionHandler:',
      );
    }
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_URLSession_dataTask_didReceiveResponse_completionHandler_,
      session.ref.pointer,
      dataTask.ref.pointer,
      didReceiveResponse.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Invoke the completion routine with a valid NSCachedURLResponse to
  /// allow the resulting data to be cached, or pass nil to prevent
  /// caching. Note that there is no guarantee that caching will be
  /// attempted for a given resource, and you should not rely on this
  /// message to receive the resource data.
  void URLSession$4(
    NSURLSession session, {
    required NSURLSessionDataTask dataTask,
    required NSCachedURLResponse willCacheResponse,
    required objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:dataTask:willCacheResponse:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_dataTask_willCacheResponse_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:dataTask:willCacheResponse:completionHandler:',
      );
    }
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_URLSession_dataTask_willCacheResponse_completionHandler_,
      session.ref.pointer,
      dataTask.ref.pointer,
      willCacheResponse.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// The last message a session receives.  A session will only become
  /// invalid because of a systemic error or when it has been
  /// explicitly invalidated, in which case the error parameter will be nil.
  void URLSession$5(
    NSURLSession session, {
    objc.NSError? didBecomeInvalidWithError,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:didBecomeInvalidWithError:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_didBecomeInvalidWithError_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:didBecomeInvalidWithError:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_URLSession_didBecomeInvalidWithError_,
      session.ref.pointer,
      didBecomeInvalidWithError?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Notification that a task has been created.  This method is the first message
  /// a task sends, providing a place to configure the task before it is resumed.
  ///
  /// This delegate callback is *NOT* dispatched to the delegate queue.  It is
  /// invoked synchronously before the task creation method returns.
  void URLSession$6(
    NSURLSession session, {
    required NSURLSessionTask didCreateTask,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:didCreateTask:',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_didCreateTask_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:didCreateTask:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_URLSession_didCreateTask_,
      session.ref.pointer,
      didCreateTask.ref.pointer,
    );
  }

  /// If implemented, when a connection level authentication challenge
  /// has occurred, this delegate will be given the opportunity to
  /// provide authentication credentials to the underlying
  /// connection. Some types of authentication will apply to more than
  /// one request on a given connection to a server (SSL Server Trust
  /// challenges).  If this delegate message is not implemented, the
  /// behavior will be to use the default handling, which may involve user
  /// interaction.
  void URLSession$7(
    NSURLSession session, {
    required NSURLAuthenticationChallenge didReceiveChallenge,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:didReceiveChallenge:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_didReceiveChallenge_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:didReceiveChallenge:completionHandler:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_URLSession_didReceiveChallenge_completionHandler_,
      session.ref.pointer,
      didReceiveChallenge.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Sent as the last message related to a specific task.  Error may be
  /// nil, which implies that no error occurred and this task is complete.
  void URLSession$8(
    NSURLSession session, {
    required NSURLSessionTask task,
    objc.NSError? didCompleteWithError,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:task:didCompleteWithError:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didCompleteWithError_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:task:didCompleteWithError:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_task_didCompleteWithError_,
      session.ref.pointer,
      task.ref.pointer,
      didCompleteWithError?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Sent when complete statistics information has been collected for the task.
  void URLSession$9(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSURLSessionTaskMetrics didFinishCollectingMetrics,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:task:didFinishCollectingMetrics:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didFinishCollectingMetrics_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:task:didFinishCollectingMetrics:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_task_didFinishCollectingMetrics_,
      session.ref.pointer,
      task.ref.pointer,
      didFinishCollectingMetrics.ref.pointer,
    );
  }

  /// The task has received a request specific authentication challenge.
  /// If this delegate is not implemented, the session specific authentication challenge
  /// will *NOT* be called and the behavior will be the same as using the default handling
  /// disposition.
  void URLSession$10(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSURLAuthenticationChallenge didReceiveChallenge,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:task:didReceiveChallenge:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveChallenge_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:task:didReceiveChallenge:completionHandler:',
      );
    }
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveChallenge_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      didReceiveChallenge.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Sent for each informational response received except 101 switching protocols.
  void URLSession$11(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSHTTPURLResponse didReceiveInformationalResponse,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:task:didReceiveInformationalResponse:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveInformationalResponse_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:task:didReceiveInformationalResponse:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveInformationalResponse_,
      session.ref.pointer,
      task.ref.pointer,
      didReceiveInformationalResponse.ref.pointer,
    );
  }

  /// Sent periodically to notify the delegate of upload progress.  This
  /// information is also available as properties of the task.
  void URLSession$12(
    NSURLSession session, {
    required NSURLSessionTask task,
    required int didSendBodyData,
    required int totalBytesSent,
    required int totalBytesExpectedToSend,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:',
      );
    }
    _objc_msgSend_1modw1b(
      object$.ref.pointer,
      _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      session.ref.pointer,
      task.ref.pointer,
      didSendBodyData,
      totalBytesSent,
      totalBytesExpectedToSend,
    );
  }

  /// Sent if a task requires a new, unopened body stream.  This may be
  /// necessary when authentication has failed for any request that
  /// involves a body stream.
  void URLSession$13(
    NSURLSession session, {
    required NSURLSessionTask task,
    required objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
    needNewBodyStream,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:task:needNewBodyStream:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStream_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:task:needNewBodyStream:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStream_,
      session.ref.pointer,
      task.ref.pointer,
      needNewBodyStream.ref.pointer,
    );
  }

  /// Tells the delegate if a task requires a new body stream starting from the given offset. This may be
  /// necessary when resuming a failed upload task.
  ///
  /// - Parameter session: The session containing the task that needs a new body stream from the given offset.
  /// - Parameter task: The task that needs a new body stream.
  /// - Parameter offset: The starting offset required for the body stream.
  /// - Parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
  void URLSession$14(
    NSURLSession session, {
    required NSURLSessionTask task,
    required int needNewBodyStreamFromOffset,
    required objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:task:needNewBodyStreamFromOffset:completionHandler:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:task:needNewBodyStreamFromOffset:completionHandler:',
      );
    }
    _objc_msgSend_9cddqw(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      needNewBodyStreamFromOffset,
      completionHandler.ref.pointer,
    );
  }

  /// Sent when the system is ready to begin work for a task with a delayed start
  /// time set (using the earliestBeginDate property). The completionHandler must
  /// be invoked in order for loading to proceed. The disposition provided to the
  /// completion handler continues the load with the original request provided to
  /// the task, replaces the request with the specified task, or cancels the task.
  /// If this delegate is not implemented, loading will proceed with the original
  /// request.
  ///
  /// Recommendation: only implement this delegate if tasks that have the
  /// earliestBeginDate property set may become stale and require alteration prior
  /// to starting the network load.
  ///
  /// If a new request is specified, the allowsExpensiveNetworkAccess,
  /// allowsConstrainedNetworkAccess, and allowsCellularAccess properties
  /// from the new request will not be used; the properties from the
  /// original request will continue to be used.
  ///
  /// Canceling the task is equivalent to calling the task's cancel method; the
  /// URLSession:task:didCompleteWithError: task delegate will be called with error
  /// NSURLErrorCancelled.
  void URLSession$15(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSURLRequest willBeginDelayedRequest,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:task:willBeginDelayedRequest:completionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:task:willBeginDelayedRequest:completionHandler:',
      );
    }
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      willBeginDelayedRequest.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// An HTTP request is attempting to perform a redirection to a different
  /// URL. You must invoke the completion routine to allow the
  /// redirection, allow the redirection with a modified request, or
  /// pass nil to the completionHandler to cause the body of the redirection
  /// response to be delivered as the payload of this request. The default
  /// is to follow redirections.
  ///
  /// For tasks in background sessions, redirections will always be followed and this method will not be called.
  void URLSession$16(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSHTTPURLResponse willPerformHTTPRedirection,
    required NSURLRequest newRequest,
    required objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:',
      );
    }
    _objc_msgSend_e1wgee(
      object$.ref.pointer,
      _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      willPerformHTTPRedirection.ref.pointer,
      newRequest.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Sent when a task cannot start the network loading process because the current
  /// network connectivity is not available or sufficient for the task's request.
  ///
  /// This delegate will be called at most one time per task, and is only called if
  /// the waitsForConnectivity property in the NSURLSessionConfiguration has been
  /// set to YES.
  ///
  /// This delegate callback will never be called for background sessions, because
  /// the waitForConnectivity property is ignored by those sessions.
  void URLSession$17(
    NSURLSession session, {
    required NSURLSessionTask taskIsWaitingForConnectivity,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSession:taskIsWaitingForConnectivity:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_taskIsWaitingForConnectivity_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSession:taskIsWaitingForConnectivity:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_URLSession_taskIsWaitingForConnectivity_,
      session.ref.pointer,
      taskIsWaitingForConnectivity.ref.pointer,
    );
  }

  /// If an application has received an
  /// -application:handleEventsForBackgroundURLSession:completionHandler:
  /// message, the session delegate will receive this message to indicate
  /// that all messages previously enqueued for this session have been
  /// delivered.  At this time it is safe to invoke the previously stored
  /// completion handler, or to begin any internal updates that will
  /// result in invoking the completion handler.
  void URLSessionDidFinishEventsForBackgroundURLSession(NSURLSession session) {
    objc.checkOsVersionInternal(
      'NSURLSessionDataDelegate.URLSessionDidFinishEventsForBackgroundURLSession:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDataDelegate',
        'URLSessionDidFinishEventsForBackgroundURLSession:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
      session.ref.pointer,
    );
  }
}

interface class NSURLSessionDataDelegate$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_NSURLSessionDataDelegate.cast());

  /// Builds an object that implements the NSURLSessionDataDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSURLSessionDataDelegate implement({
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
    URLSession_dataTask_didBecomeDownloadTask_,
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
    URLSession_dataTask_didBecomeStreamTask_,
    void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
    URLSession_dataTask_didReceiveData_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    URLSession_dataTask_didReceiveResponse_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )?
    URLSession_dataTask_willCacheResponse_completionHandler_,
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSURLSessionDataDelegate',
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeDownloadTask_.implement(
      builder,
      URLSession_dataTask_didBecomeDownloadTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeStreamTask_.implement(
      builder,
      URLSession_dataTask_didBecomeStreamTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveData_.implement(
      builder,
      URLSession_dataTask_didReceiveData_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveResponse_completionHandler_.implement(
      builder,
      URLSession_dataTask_didReceiveResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_willCacheResponse_completionHandler_.implement(
      builder,
      URLSession_dataTask_willCacheResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implement(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDataDelegate$Builder.URLSession_didCreateTask_.implement(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didCompleteWithError_.implement(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implement(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implement(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implement(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStream_.implement(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implement(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implement(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implement(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implement(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implement(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
    return NSURLSessionDataDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSURLSessionDataDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
    URLSession_dataTask_didBecomeDownloadTask_,
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
    URLSession_dataTask_didBecomeStreamTask_,
    void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
    URLSession_dataTask_didReceiveData_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    URLSession_dataTask_didReceiveResponse_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )?
    URLSession_dataTask_willCacheResponse_completionHandler_,
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeDownloadTask_.implement(
      builder,
      URLSession_dataTask_didBecomeDownloadTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeStreamTask_.implement(
      builder,
      URLSession_dataTask_didBecomeStreamTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveData_.implement(
      builder,
      URLSession_dataTask_didReceiveData_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveResponse_completionHandler_.implement(
      builder,
      URLSession_dataTask_didReceiveResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_willCacheResponse_completionHandler_.implement(
      builder,
      URLSession_dataTask_willCacheResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implement(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDataDelegate$Builder.URLSession_didCreateTask_.implement(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didCompleteWithError_.implement(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implement(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implement(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implement(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStream_.implement(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implement(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implement(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implement(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implement(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implement(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSURLSessionDataDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSURLSessionDataDelegate implementAsListener({
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
    URLSession_dataTask_didBecomeDownloadTask_,
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
    URLSession_dataTask_didBecomeStreamTask_,
    void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
    URLSession_dataTask_didReceiveData_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    URLSession_dataTask_didReceiveResponse_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )?
    URLSession_dataTask_willCacheResponse_completionHandler_,
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSURLSessionDataDelegate',
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeDownloadTask_.implementAsListener(
      builder,
      URLSession_dataTask_didBecomeDownloadTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeStreamTask_.implementAsListener(
      builder,
      URLSession_dataTask_didBecomeStreamTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveData_.implementAsListener(
      builder,
      URLSession_dataTask_didReceiveData_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveResponse_completionHandler_.implementAsListener(
      builder,
      URLSession_dataTask_didReceiveResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_willCacheResponse_completionHandler_.implementAsListener(
      builder,
      URLSession_dataTask_willCacheResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsListener(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didCreateTask_.implementAsListener(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsListener(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsListener(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsListener(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsListener(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsListener(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsListener(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
    return NSURLSessionDataDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSURLSessionDataDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
    URLSession_dataTask_didBecomeDownloadTask_,
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
    URLSession_dataTask_didBecomeStreamTask_,
    void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
    URLSession_dataTask_didReceiveData_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    URLSession_dataTask_didReceiveResponse_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )?
    URLSession_dataTask_willCacheResponse_completionHandler_,
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeDownloadTask_.implementAsListener(
      builder,
      URLSession_dataTask_didBecomeDownloadTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeStreamTask_.implementAsListener(
      builder,
      URLSession_dataTask_didBecomeStreamTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveData_.implementAsListener(
      builder,
      URLSession_dataTask_didReceiveData_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveResponse_completionHandler_.implementAsListener(
      builder,
      URLSession_dataTask_didReceiveResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_willCacheResponse_completionHandler_.implementAsListener(
      builder,
      URLSession_dataTask_willCacheResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsListener(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didCreateTask_.implementAsListener(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsListener(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsListener(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsListener(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsListener(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsListener(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsListener(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSURLSessionDataDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSURLSessionDataDelegate implementAsBlocking({
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
    URLSession_dataTask_didBecomeDownloadTask_,
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
    URLSession_dataTask_didBecomeStreamTask_,
    void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
    URLSession_dataTask_didReceiveData_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    URLSession_dataTask_didReceiveResponse_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )?
    URLSession_dataTask_willCacheResponse_completionHandler_,
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSURLSessionDataDelegate',
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeDownloadTask_.implementAsBlocking(
      builder,
      URLSession_dataTask_didBecomeDownloadTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeStreamTask_.implementAsBlocking(
      builder,
      URLSession_dataTask_didBecomeStreamTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveData_.implementAsBlocking(
      builder,
      URLSession_dataTask_didReceiveData_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveResponse_completionHandler_.implementAsBlocking(
      builder,
      URLSession_dataTask_didReceiveResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_willCacheResponse_completionHandler_.implementAsBlocking(
      builder,
      URLSession_dataTask_willCacheResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsBlocking(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didCreateTask_.implementAsBlocking(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsBlocking(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsBlocking(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsBlocking(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsBlocking(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsBlocking(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
    return NSURLSessionDataDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSURLSessionDataDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
    URLSession_dataTask_didBecomeDownloadTask_,
    void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
    URLSession_dataTask_didBecomeStreamTask_,
    void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
    URLSession_dataTask_didReceiveData_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSURLResponse,
      objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
    )?
    URLSession_dataTask_didReceiveResponse_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionDataTask,
      NSCachedURLResponse,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
    )?
    URLSession_dataTask_willCacheResponse_completionHandler_,
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeDownloadTask_.implementAsBlocking(
      builder,
      URLSession_dataTask_didBecomeDownloadTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didBecomeStreamTask_.implementAsBlocking(
      builder,
      URLSession_dataTask_didBecomeStreamTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveData_.implementAsBlocking(
      builder,
      URLSession_dataTask_didReceiveData_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_didReceiveResponse_completionHandler_.implementAsBlocking(
      builder,
      URLSession_dataTask_didReceiveResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_dataTask_willCacheResponse_completionHandler_.implementAsBlocking(
      builder,
      URLSession_dataTask_willCacheResponse_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsBlocking(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didCreateTask_.implementAsBlocking(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsBlocking(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsBlocking(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsBlocking(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsBlocking(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDataDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsBlocking(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
  }

  /// Notification that a data task has become a download task.  No
  /// future messages will be sent to the data task.
  static final URLSession_dataTask_didBecomeDownloadTask_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionDataTask,
          NSURLSessionDownloadTask,
        )
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_dataTask_didBecomeDownloadTask_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_dataTask_didBecomeDownloadTask_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionDownloadTask,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSURLSessionDownloadTask arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionDownloadTask,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSURLSessionDownloadTask arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionDownloadTask,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSURLSessionDownloadTask arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Notification that a data task has become a bidirectional stream
  /// task.  No future messages will be sent to the data task.  The newly
  /// created streamTask will carry the original request and response as
  /// properties.
  ///
  /// For requests that were pipelined, the stream object will only allow
  /// reading, and the object will immediately issue a
  /// -URLSession:writeClosedForStream:.  Pipelining can be disabled for
  /// all requests in a session, or by the NSURLRequest
  /// HTTPShouldUsePipelining property.
  ///
  /// The underlying connection is no longer considered part of the HTTP
  /// connection cache and won't count against the total number of
  /// connections per host.
  static final URLSession_dataTask_didBecomeStreamTask_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionDataTask,
          NSURLSessionStreamTask,
        )
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_dataTask_didBecomeStreamTask_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_dataTask_didBecomeStreamTask_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionStreamTask,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSURLSessionStreamTask arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionStreamTask,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSURLSessionStreamTask arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionStreamTask,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSURLSessionStreamTask arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent when data is available for the delegate to consume.  As the
  /// data may be discontiguous, you should use
  /// [NSData enumerateByteRangesUsingBlock:] to access it.
  static final URLSession_dataTask_didReceiveData_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_dataTask_didReceiveData_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_dataTask_didReceiveData_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionDataTask, objc.NSData) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                objc.NSData arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(NSURLSession, NSURLSessionDataTask, objc.NSData) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                objc.NSData arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(NSURLSession, NSURLSessionDataTask, objc.NSData) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                objc.NSData arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// The task has received a response and no further messages will be
  /// received until the completion block is called. The disposition
  /// allows you to cancel a request or to turn a data task into a
  /// download task. This delegate message is optional - if you do not
  /// implement it, you can get the response as a property of the task.
  ///
  /// This method will not be called for background upload tasks (which cannot be converted to download tasks).
  static final URLSession_dataTask_didReceiveResponse_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionDataTask,
          NSURLResponse,
          objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
        )
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_dataTask_didReceiveResponse_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_xx612k)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_dataTask_didReceiveResponse_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSURLResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSURLResponse arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSURLResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSURLResponse arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSURLResponse,
            objc.ObjCBlock<ffi.Void Function(ffi.Long)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSURLResponse arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// Invoke the completion routine with a valid NSCachedURLResponse to
  /// allow the resulting data to be cached, or pass nil to prevent
  /// caching. Note that there is no guarantee that caching will be
  /// attempted for a given resource, and you should not rely on this
  /// message to receive the resource data.
  static final URLSession_dataTask_willCacheResponse_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionDataTask,
          NSCachedURLResponse,
          objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
        )
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_dataTask_willCacheResponse_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_xx612k)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_dataTask_willCacheResponse_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSCachedURLResponse,
            objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSCachedURLResponse arg3,
                objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSCachedURLResponse,
            objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSCachedURLResponse arg3,
                objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionDataTask,
            NSCachedURLResponse,
            objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDataTask arg2,
                NSCachedURLResponse arg3,
                objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// The last message a session receives.  A session will only become
  /// invalid because of a systemic error or when it has been
  /// explicitly invalidated, in which case the error parameter will be nil.
  static final URLSession_didBecomeInvalidWithError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, objc.NSError?)
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_didBecomeInvalidWithError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_didBecomeInvalidWithError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// Notification that a task has been created.  This method is the first message
  /// a task sends, providing a place to configure the task before it is resumed.
  ///
  /// This delegate callback is *NOT* dispatched to the delegate queue.  It is
  /// invoked synchronously before the task creation method returns.
  static final URLSession_didCreateTask_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask)
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_didCreateTask_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_didCreateTask_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// If implemented, when a connection level authentication challenge
  /// has occurred, this delegate will be given the opportunity to
  /// provide authentication credentials to the underlying
  /// connection. Some types of authentication will apply to more than
  /// one request on a given connection to a server (SSL Server Trust
  /// challenges).  If this delegate message is not implemented, the
  /// behavior will be to use the default handling, which may involve user
  /// interaction.
  static final URLSession_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_didReceiveChallenge_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_didReceiveChallenge_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent as the last message related to a specific task.  Error may be
  /// nil, which implies that no error occurred and this task is complete.
  static final URLSession_task_didCompleteWithError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, objc.NSError?)
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_task_didCompleteWithError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_task_didCompleteWithError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent when complete statistics information has been collected for the task.
  static final URLSession_task_didFinishCollectingMetrics_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_task_didFinishCollectingMetrics_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_task_didFinishCollectingMetrics_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLSessionTaskMetrics arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLSessionTaskMetrics arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLSessionTaskMetrics arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// The task has received a request specific authentication challenge.
  /// If this delegate is not implemented, the session specific authentication challenge
  /// will *NOT* be called and the behavior will be the same as using the default handling
  /// disposition.
  static final URLSession_task_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_task_didReceiveChallenge_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_xx612k)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_task_didReceiveChallenge_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLAuthenticationChallenge arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLAuthenticationChallenge arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLAuthenticationChallenge arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// Sent for each informational response received except 101 switching protocols.
  static final URLSession_task_didReceiveInformationalResponse_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_task_didReceiveInformationalResponse_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_task_didReceiveInformationalResponse_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent periodically to notify the delegate of upload progress.  This
  /// information is also available as properties of the task.
  static final URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, int, int, int)
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_h68abb)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
      );

  /// Sent if a task requires a new, unopened body stream.  This may be
  /// necessary when authentication has failed for any request that
  /// involves a body stream.
  static final URLSession_task_needNewBodyStream_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_task_needNewBodyStream_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_task_needNewBodyStream_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Tells the delegate if a task requires a new body stream starting from the given offset. This may be
  /// necessary when resuming a failed upload task.
  ///
  /// - Parameter session: The session containing the task that needs a new body stream from the given offset.
  /// - Parameter task: The task that needs a new body stream.
  /// - Parameter offset: The starting offset required for the body stream.
  /// - Parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
  static final URLSession_task_needNewBodyStreamFromOffset_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          int,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Int64,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_jyim80)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            int,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            int,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            int,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// Sent when the system is ready to begin work for a task with a delayed start
  /// time set (using the earliestBeginDate property). The completionHandler must
  /// be invoked in order for loading to proceed. The disposition provided to the
  /// completion handler continues the load with the original request provided to
  /// the task, replaces the request with the specified task, or cancels the task.
  /// If this delegate is not implemented, loading will proceed with the original
  /// request.
  ///
  /// Recommendation: only implement this delegate if tasks that have the
  /// earliestBeginDate property set may become stale and require alteration prior
  /// to starting the network load.
  ///
  /// If a new request is specified, the allowsExpensiveNetworkAccess,
  /// allowsConstrainedNetworkAccess, and allowsCellularAccess properties
  /// from the new request will not be used; the properties from the
  /// original request will continue to be used.
  ///
  /// Canceling the task is equivalent to calling the task's cancel method; the
  /// URLSession:task:didCompleteWithError: task delegate will be called with error
  /// NSURLErrorCancelled.
  static final URLSession_task_willBeginDelayedRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
        )
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_xx612k)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLRequest arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLRequest arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLRequest arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// An HTTP request is attempting to perform a redirection to a different
  /// URL. You must invoke the completion routine to allow the
  /// redirection, allow the redirection with a modified request, or
  /// pass nil to the completionHandler to cause the body of the redirection
  /// response to be delivered as the payload of this request. The default
  /// is to follow redirections.
  ///
  /// For tasks in background sessions, redirections will always be followed and this method will not be called.
  static final URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
        )
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_l2g8ke)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
                NSURLRequest arg4,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
                NSURLRequest arg4,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
                NSURLRequest arg4,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
      );

  /// Sent when a task cannot start the network loading process because the current
  /// network connectivity is not available or sufficient for the task's request.
  ///
  /// This delegate will be called at most one time per task, and is only called if
  /// the waitsForConnectivity property in the NSURLSessionConfiguration has been
  /// set to YES.
  ///
  /// This delegate callback will never be called for background sessions, because
  /// the waitForConnectivity property is ignored by those sessions.
  static final URLSession_taskIsWaitingForConnectivity_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask)
      >(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSession_taskIsWaitingForConnectivity_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSession_taskIsWaitingForConnectivity_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// If an application has received an
  /// -application:handleEventsForBackgroundURLSession:completionHandler:
  /// message, the session delegate will receive this message to indicate
  /// that all messages previously enqueued for this session have been
  /// delivered.  At this time it is safe to invoke the previously stored
  /// completion handler, or to begin any internal updates that will
  /// result in invoking the completion handler.
  static final URLSessionDidFinishEventsForBackgroundURLSession_ =
      objc.ObjCProtocolListenableMethod<void Function(NSURLSession)>(
        _protocol_NSURLSessionDataDelegate,
        _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDataDelegate,
          _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession.fromFunction(
              (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1),
            ),
        (void Function(NSURLSession) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession.listener(
              (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1),
            ),
        (void Function(NSURLSession) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession.blocking(
              (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1),
            ),
      );
}

late final _protocol_NSURLSessionDownloadDelegate = objc.getProtocol(
  "NSURLSessionDownloadDelegate",
);
late final _sel_URLSession_downloadTask_didFinishDownloadingToURL_ = objc
    .registerName("URLSession:downloadTask:didFinishDownloadingToURL:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      objc.NSURL,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDownloadTask,
          objc.NSURL,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      objc.NSURL,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDownloadTask,
          objc.NSURL,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      objc.NSURL,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      objc.NSURL,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDownloadTask,
          objc.NSURL,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionDownloadTask.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            objc.NSURL.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      objc.NSURL,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      objc.NSURL,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        objc.NSURL.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDownloadTask,
        objc.NSURL,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      objc.NSURL,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      objc.NSURL,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        objc.NSURL.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        objc.NSURL.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDownloadTask,
        objc.NSURL,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDownloadTask,
            objc.NSURL,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionDownloadTask arg2,
    objc.NSURL arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3.ref.pointer,
      );
}

late final _sel_URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_ =
    objc.registerName(
      "URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:",
    );

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDownloadTask,
          ffi.Int64,
          ffi.Int64,
          ffi.Int64,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Int64 arg3,
          ffi.Int64 arg4,
          ffi.Int64 arg5,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDownloadTask,
          ffi.Int64,
          ffi.Int64,
          ffi.Int64,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      int,
      int,
      int,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDownloadTask,
          ffi.Int64,
          ffi.Int64,
          ffi.Int64,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            int arg3,
            int arg4,
            int arg5,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionDownloadTask.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            arg3,
            arg4,
            arg5,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      int,
      int,
      int,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        int arg4,
        int arg5,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3,
        arg4,
        arg5,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_h68abb(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDownloadTask,
        ffi.Int64,
        ffi.Int64,
        ffi.Int64,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      int,
      int,
      int,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        int arg4,
        int arg5,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3,
        arg4,
        arg5,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        int arg4,
        int arg5,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3,
        arg4,
        arg5,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_h68abb(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDownloadTask,
        ffi.Int64,
        ffi.Int64,
        ffi.Int64,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
    int arg5,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          int,
          int,
        ))(arg0, arg1, arg2, arg3, arg4, arg5);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
    int arg5,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            int,
            int,
          ))(arg0, arg1, arg2, arg3, arg4, arg5);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Int64,
      ffi.Int64,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
    int arg5,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Int64 arg3,
            ffi.Int64 arg4,
            ffi.Int64 arg5,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          int,
          int,
        )
      >()(arg0, arg1, arg2, arg3, arg4, arg5);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Int64,
              ffi.Int64,
              ffi.Int64,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
    int arg5,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            int,
            int,
          ))(arg0, arg1, arg2, arg3, arg4, arg5);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Int64,
              ffi.Int64,
              ffi.Int64,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDownloadTask,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionDownloadTask arg2,
    int arg3,
    int arg4,
    int arg5,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Int64 arg3,
                ffi.Int64 arg4,
                ffi.Int64 arg5,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              int,
              int,
              int,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3,
        arg4,
        arg5,
      );
}

late final _sel_URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_ =
    objc.registerName(
      "URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:",
    );
final _objc_msgSend_fm5719 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Int64,
          ffi.Int64,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      ffi.Int64,
      ffi.Int64,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDownloadTask,
          ffi.Int64,
          ffi.Int64,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      ffi.Int64,
      ffi.Int64,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Int64 arg3,
          ffi.Int64 arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDownloadTask,
          ffi.Int64,
          ffi.Int64,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      ffi.Int64,
      ffi.Int64,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      int,
      int,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDownloadTask,
          ffi.Int64,
          ffi.Int64,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            int arg3,
            int arg4,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionDownloadTask.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            arg3,
            arg4,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      ffi.Int64,
      ffi.Int64,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      int,
      int,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        int arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3,
        arg4,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_ly2579(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDownloadTask,
        ffi.Int64,
        ffi.Int64,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      ffi.Int64,
      ffi.Int64,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionDownloadTask,
      int,
      int,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        int arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3,
        arg4,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        int arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionDownloadTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3,
        arg4,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_ly2579(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionDownloadTask,
        ffi.Int64,
        ffi.Int64,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          int,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Int64,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Int64,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            int,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Int64,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Int64,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Int64,
      ffi.Int64,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Int64,
            ffi.Int64,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Int64 arg3,
            ffi.Int64 arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          int,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Int64,
              ffi.Int64,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    int arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            int,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Int64,
              ffi.Int64,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDownloadTask,
            ffi.Int64,
            ffi.Int64,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionDownloadTask arg2,
    int arg3,
    int arg4,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Int64 arg3,
            ffi.Int64 arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          int,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3, arg4);
}

/// Messages related to the operation of a task that writes data to a
/// file and notifies the delegate upon completion.
extension type NSURLSessionDownloadDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, NSURLSessionTaskDelegate {
  /// Constructs a [NSURLSessionDownloadDelegate] that points to the same underlying object as [other].
  NSURLSessionDownloadDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSURLSessionDownloadDelegate] that wraps the given raw object pointer.
  NSURLSessionDownloadDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLSessionDownloadDelegate].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSURLSessionDownloadDelegate,
    );
  }
}

extension NSURLSessionDownloadDelegate$Methods on NSURLSessionDownloadDelegate {
  /// The last message a session receives.  A session will only become
  /// invalid because of a systemic error or when it has been
  /// explicitly invalidated, in which case the error parameter will be nil.
  void URLSession$5(
    NSURLSession session, {
    objc.NSError? didBecomeInvalidWithError,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:didBecomeInvalidWithError:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_didBecomeInvalidWithError_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:didBecomeInvalidWithError:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_URLSession_didBecomeInvalidWithError_,
      session.ref.pointer,
      didBecomeInvalidWithError?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Notification that a task has been created.  This method is the first message
  /// a task sends, providing a place to configure the task before it is resumed.
  ///
  /// This delegate callback is *NOT* dispatched to the delegate queue.  It is
  /// invoked synchronously before the task creation method returns.
  void URLSession$6(
    NSURLSession session, {
    required NSURLSessionTask didCreateTask,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:didCreateTask:',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_didCreateTask_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:didCreateTask:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_URLSession_didCreateTask_,
      session.ref.pointer,
      didCreateTask.ref.pointer,
    );
  }

  /// If implemented, when a connection level authentication challenge
  /// has occurred, this delegate will be given the opportunity to
  /// provide authentication credentials to the underlying
  /// connection. Some types of authentication will apply to more than
  /// one request on a given connection to a server (SSL Server Trust
  /// challenges).  If this delegate message is not implemented, the
  /// behavior will be to use the default handling, which may involve user
  /// interaction.
  void URLSession$7(
    NSURLSession session, {
    required NSURLAuthenticationChallenge didReceiveChallenge,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:didReceiveChallenge:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_didReceiveChallenge_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:didReceiveChallenge:completionHandler:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_URLSession_didReceiveChallenge_completionHandler_,
      session.ref.pointer,
      didReceiveChallenge.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Sent when a download task that has completed a download.  The delegate should
  /// copy or move the file at the given location to a new location as it will be
  /// removed when the delegate message returns. URLSession:task:didCompleteWithError: will
  /// still be called.
  void URLSession(
    NSURLSession session, {
    required NSURLSessionDownloadTask downloadTask,
    required objc.NSURL didFinishDownloadingToURL,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:downloadTask:didFinishDownloadingToURL:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_downloadTask_didFinishDownloadingToURL_,
      session.ref.pointer,
      downloadTask.ref.pointer,
      didFinishDownloadingToURL.ref.pointer,
    );
  }

  /// Sent when a download has been resumed. If a download failed with an
  /// error, the -userInfo dictionary of the error will contain an
  /// NSURLSessionDownloadTaskResumeData key, whose value is the resume
  /// data.
  void URLSession$1(
    NSURLSession session, {
    required NSURLSessionDownloadTask downloadTask,
    required int didResumeAtOffset,
    required int expectedTotalBytes,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:',
      );
    }
    _objc_msgSend_fm5719(
      object$.ref.pointer,
      _sel_URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
      session.ref.pointer,
      downloadTask.ref.pointer,
      didResumeAtOffset,
      expectedTotalBytes,
    );
  }

  /// Sent periodically to notify the delegate of download progress.
  void URLSession$2(
    NSURLSession session, {
    required NSURLSessionDownloadTask downloadTask,
    required int didWriteData,
    required int totalBytesWritten,
    required int totalBytesExpectedToWrite,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:',
      );
    }
    _objc_msgSend_1modw1b(
      object$.ref.pointer,
      _sel_URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
      session.ref.pointer,
      downloadTask.ref.pointer,
      didWriteData,
      totalBytesWritten,
      totalBytesExpectedToWrite,
    );
  }

  /// Sent as the last message related to a specific task.  Error may be
  /// nil, which implies that no error occurred and this task is complete.
  void URLSession$8(
    NSURLSession session, {
    required NSURLSessionTask task,
    objc.NSError? didCompleteWithError,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:task:didCompleteWithError:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didCompleteWithError_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:task:didCompleteWithError:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_task_didCompleteWithError_,
      session.ref.pointer,
      task.ref.pointer,
      didCompleteWithError?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Sent when complete statistics information has been collected for the task.
  void URLSession$9(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSURLSessionTaskMetrics didFinishCollectingMetrics,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:task:didFinishCollectingMetrics:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didFinishCollectingMetrics_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:task:didFinishCollectingMetrics:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_task_didFinishCollectingMetrics_,
      session.ref.pointer,
      task.ref.pointer,
      didFinishCollectingMetrics.ref.pointer,
    );
  }

  /// The task has received a request specific authentication challenge.
  /// If this delegate is not implemented, the session specific authentication challenge
  /// will *NOT* be called and the behavior will be the same as using the default handling
  /// disposition.
  void URLSession$10(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSURLAuthenticationChallenge didReceiveChallenge,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:task:didReceiveChallenge:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveChallenge_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:task:didReceiveChallenge:completionHandler:',
      );
    }
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveChallenge_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      didReceiveChallenge.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Sent for each informational response received except 101 switching protocols.
  void URLSession$11(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSHTTPURLResponse didReceiveInformationalResponse,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:task:didReceiveInformationalResponse:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveInformationalResponse_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:task:didReceiveInformationalResponse:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveInformationalResponse_,
      session.ref.pointer,
      task.ref.pointer,
      didReceiveInformationalResponse.ref.pointer,
    );
  }

  /// Sent periodically to notify the delegate of upload progress.  This
  /// information is also available as properties of the task.
  void URLSession$12(
    NSURLSession session, {
    required NSURLSessionTask task,
    required int didSendBodyData,
    required int totalBytesSent,
    required int totalBytesExpectedToSend,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:',
      );
    }
    _objc_msgSend_1modw1b(
      object$.ref.pointer,
      _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      session.ref.pointer,
      task.ref.pointer,
      didSendBodyData,
      totalBytesSent,
      totalBytesExpectedToSend,
    );
  }

  /// Sent if a task requires a new, unopened body stream.  This may be
  /// necessary when authentication has failed for any request that
  /// involves a body stream.
  void URLSession$13(
    NSURLSession session, {
    required NSURLSessionTask task,
    required objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
    needNewBodyStream,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:task:needNewBodyStream:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStream_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:task:needNewBodyStream:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStream_,
      session.ref.pointer,
      task.ref.pointer,
      needNewBodyStream.ref.pointer,
    );
  }

  /// Tells the delegate if a task requires a new body stream starting from the given offset. This may be
  /// necessary when resuming a failed upload task.
  ///
  /// - Parameter session: The session containing the task that needs a new body stream from the given offset.
  /// - Parameter task: The task that needs a new body stream.
  /// - Parameter offset: The starting offset required for the body stream.
  /// - Parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
  void URLSession$14(
    NSURLSession session, {
    required NSURLSessionTask task,
    required int needNewBodyStreamFromOffset,
    required objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:task:needNewBodyStreamFromOffset:completionHandler:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:task:needNewBodyStreamFromOffset:completionHandler:',
      );
    }
    _objc_msgSend_9cddqw(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      needNewBodyStreamFromOffset,
      completionHandler.ref.pointer,
    );
  }

  /// Sent when the system is ready to begin work for a task with a delayed start
  /// time set (using the earliestBeginDate property). The completionHandler must
  /// be invoked in order for loading to proceed. The disposition provided to the
  /// completion handler continues the load with the original request provided to
  /// the task, replaces the request with the specified task, or cancels the task.
  /// If this delegate is not implemented, loading will proceed with the original
  /// request.
  ///
  /// Recommendation: only implement this delegate if tasks that have the
  /// earliestBeginDate property set may become stale and require alteration prior
  /// to starting the network load.
  ///
  /// If a new request is specified, the allowsExpensiveNetworkAccess,
  /// allowsConstrainedNetworkAccess, and allowsCellularAccess properties
  /// from the new request will not be used; the properties from the
  /// original request will continue to be used.
  ///
  /// Canceling the task is equivalent to calling the task's cancel method; the
  /// URLSession:task:didCompleteWithError: task delegate will be called with error
  /// NSURLErrorCancelled.
  void URLSession$15(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSURLRequest willBeginDelayedRequest,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:task:willBeginDelayedRequest:completionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:task:willBeginDelayedRequest:completionHandler:',
      );
    }
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      willBeginDelayedRequest.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// An HTTP request is attempting to perform a redirection to a different
  /// URL. You must invoke the completion routine to allow the
  /// redirection, allow the redirection with a modified request, or
  /// pass nil to the completionHandler to cause the body of the redirection
  /// response to be delivered as the payload of this request. The default
  /// is to follow redirections.
  ///
  /// For tasks in background sessions, redirections will always be followed and this method will not be called.
  void URLSession$16(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSHTTPURLResponse willPerformHTTPRedirection,
    required NSURLRequest newRequest,
    required objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:',
      );
    }
    _objc_msgSend_e1wgee(
      object$.ref.pointer,
      _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      willPerformHTTPRedirection.ref.pointer,
      newRequest.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Sent when a task cannot start the network loading process because the current
  /// network connectivity is not available or sufficient for the task's request.
  ///
  /// This delegate will be called at most one time per task, and is only called if
  /// the waitsForConnectivity property in the NSURLSessionConfiguration has been
  /// set to YES.
  ///
  /// This delegate callback will never be called for background sessions, because
  /// the waitForConnectivity property is ignored by those sessions.
  void URLSession$17(
    NSURLSession session, {
    required NSURLSessionTask taskIsWaitingForConnectivity,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSession:taskIsWaitingForConnectivity:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_taskIsWaitingForConnectivity_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSession:taskIsWaitingForConnectivity:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_URLSession_taskIsWaitingForConnectivity_,
      session.ref.pointer,
      taskIsWaitingForConnectivity.ref.pointer,
    );
  }

  /// If an application has received an
  /// -application:handleEventsForBackgroundURLSession:completionHandler:
  /// message, the session delegate will receive this message to indicate
  /// that all messages previously enqueued for this session have been
  /// delivered.  At this time it is safe to invoke the previously stored
  /// completion handler, or to begin any internal updates that will
  /// result in invoking the completion handler.
  void URLSessionDidFinishEventsForBackgroundURLSession(NSURLSession session) {
    objc.checkOsVersionInternal(
      'NSURLSessionDownloadDelegate.URLSessionDidFinishEventsForBackgroundURLSession:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionDownloadDelegate',
        'URLSessionDidFinishEventsForBackgroundURLSession:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
      session.ref.pointer,
    );
  }
}

interface class NSURLSessionDownloadDelegate$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_NSURLSessionDownloadDelegate.cast());

  /// Builds an object that implements the NSURLSessionDownloadDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSURLSessionDownloadDelegate implement({
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
    URLSession_downloadTask_didFinishDownloadingToURL_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
    URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
    URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSURLSessionDownloadDelegate',
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implement(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDownloadDelegate$Builder.URLSession_didCreateTask_.implement(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didFinishDownloadingToURL_.implement(
      builder,
      URLSession_downloadTask_didFinishDownloadingToURL_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_.implement(
      builder,
      URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_.implement(
      builder,
      URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didCompleteWithError_.implement(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implement(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implement(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implement(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStream_.implement(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implement(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implement(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implement(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implement(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implement(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
    return NSURLSessionDownloadDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSURLSessionDownloadDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
    URLSession_downloadTask_didFinishDownloadingToURL_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
    URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
    URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implement(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDownloadDelegate$Builder.URLSession_didCreateTask_.implement(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didFinishDownloadingToURL_.implement(
      builder,
      URLSession_downloadTask_didFinishDownloadingToURL_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_.implement(
      builder,
      URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_.implement(
      builder,
      URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didCompleteWithError_.implement(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implement(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implement(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implement(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStream_.implement(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implement(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implement(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implement(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implement(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implement(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSURLSessionDownloadDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSURLSessionDownloadDelegate implementAsListener({
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
    URLSession_downloadTask_didFinishDownloadingToURL_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
    URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
    URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSURLSessionDownloadDelegate',
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsListener(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didCreateTask_.implementAsListener(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didFinishDownloadingToURL_.implementAsListener(
      builder,
      URLSession_downloadTask_didFinishDownloadingToURL_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_.implementAsListener(
      builder,
      URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_.implementAsListener(
      builder,
      URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsListener(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsListener(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsListener(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsListener(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsListener(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsListener(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
    return NSURLSessionDownloadDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSURLSessionDownloadDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
    URLSession_downloadTask_didFinishDownloadingToURL_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
    URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
    URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsListener(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didCreateTask_.implementAsListener(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didFinishDownloadingToURL_.implementAsListener(
      builder,
      URLSession_downloadTask_didFinishDownloadingToURL_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_.implementAsListener(
      builder,
      URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_.implementAsListener(
      builder,
      URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsListener(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsListener(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsListener(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsListener(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsListener(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsListener(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSURLSessionDownloadDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSURLSessionDownloadDelegate implementAsBlocking({
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
    URLSession_downloadTask_didFinishDownloadingToURL_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
    URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
    URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSURLSessionDownloadDelegate',
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsBlocking(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didCreateTask_.implementAsBlocking(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didFinishDownloadingToURL_.implementAsBlocking(
      builder,
      URLSession_downloadTask_didFinishDownloadingToURL_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_.implementAsBlocking(
      builder,
      URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_.implementAsBlocking(
      builder,
      URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsBlocking(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsBlocking(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsBlocking(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsBlocking(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsBlocking(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
    return NSURLSessionDownloadDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSURLSessionDownloadDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
    URLSession_downloadTask_didFinishDownloadingToURL_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
    URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
    URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsBlocking(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didCreateTask_.implementAsBlocking(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didFinishDownloadingToURL_.implementAsBlocking(
      builder,
      URLSession_downloadTask_didFinishDownloadingToURL_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_.implementAsBlocking(
      builder,
      URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_.implementAsBlocking(
      builder,
      URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsBlocking(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsBlocking(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsBlocking(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsBlocking(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionDownloadDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsBlocking(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
  }

  /// The last message a session receives.  A session will only become
  /// invalid because of a systemic error or when it has been
  /// explicitly invalidated, in which case the error parameter will be nil.
  static final URLSession_didBecomeInvalidWithError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, objc.NSError?)
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_didBecomeInvalidWithError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_didBecomeInvalidWithError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// Notification that a task has been created.  This method is the first message
  /// a task sends, providing a place to configure the task before it is resumed.
  ///
  /// This delegate callback is *NOT* dispatched to the delegate queue.  It is
  /// invoked synchronously before the task creation method returns.
  static final URLSession_didCreateTask_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask)
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_didCreateTask_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_didCreateTask_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// If implemented, when a connection level authentication challenge
  /// has occurred, this delegate will be given the opportunity to
  /// provide authentication credentials to the underlying
  /// connection. Some types of authentication will apply to more than
  /// one request on a given connection to a server (SSL Server Trust
  /// challenges).  If this delegate message is not implemented, the
  /// behavior will be to use the default handling, which may involve user
  /// interaction.
  static final URLSession_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_didReceiveChallenge_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_didReceiveChallenge_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent when a download task that has completed a download.  The delegate should
  /// copy or move the file at the given location to a new location as it will be
  /// removed when the delegate message returns. URLSession:task:didCompleteWithError: will
  /// still be called.
  static final URLSession_downloadTask_didFinishDownloadingToURL_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_downloadTask_didFinishDownloadingToURL_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_downloadTask_didFinishDownloadingToURL_,
          isRequired: true,
          isInstanceMethod: true,
        ),
        (
          void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDownloadTask arg2,
                objc.NSURL arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDownloadTask arg2,
                objc.NSURL arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDownloadTask arg2,
                objc.NSURL arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent when a download has been resumed. If a download failed with an
  /// error, the -userInfo dictionary of the error will contain an
  /// NSURLSessionDownloadTaskResumeData key, whose value is the resume
  /// data.
  static final URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionDownloadTask, int, int)
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Int64,
                  ffi.Int64,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_ly2579)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(NSURLSession, NSURLSessionDownloadTask, int, int) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDownloadTask arg2,
                int arg3,
                int arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(NSURLSession, NSURLSessionDownloadTask, int, int) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDownloadTask arg2,
                int arg3,
                int arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(NSURLSession, NSURLSessionDownloadTask, int, int) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDownloadTask arg2,
                int arg3,
                int arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// Sent periodically to notify the delegate of download progress.
  static final URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_h68abb)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDownloadTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (
          void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDownloadTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (
          void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionDownloadTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
      );

  /// Sent as the last message related to a specific task.  Error may be
  /// nil, which implies that no error occurred and this task is complete.
  static final URLSession_task_didCompleteWithError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, objc.NSError?)
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_task_didCompleteWithError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_task_didCompleteWithError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent when complete statistics information has been collected for the task.
  static final URLSession_task_didFinishCollectingMetrics_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_task_didFinishCollectingMetrics_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_task_didFinishCollectingMetrics_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLSessionTaskMetrics arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLSessionTaskMetrics arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLSessionTaskMetrics arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// The task has received a request specific authentication challenge.
  /// If this delegate is not implemented, the session specific authentication challenge
  /// will *NOT* be called and the behavior will be the same as using the default handling
  /// disposition.
  static final URLSession_task_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_task_didReceiveChallenge_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_xx612k)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_task_didReceiveChallenge_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLAuthenticationChallenge arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLAuthenticationChallenge arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLAuthenticationChallenge arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// Sent for each informational response received except 101 switching protocols.
  static final URLSession_task_didReceiveInformationalResponse_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_task_didReceiveInformationalResponse_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_task_didReceiveInformationalResponse_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent periodically to notify the delegate of upload progress.  This
  /// information is also available as properties of the task.
  static final URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, int, int, int)
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_h68abb)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
      );

  /// Sent if a task requires a new, unopened body stream.  This may be
  /// necessary when authentication has failed for any request that
  /// involves a body stream.
  static final URLSession_task_needNewBodyStream_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_task_needNewBodyStream_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_task_needNewBodyStream_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Tells the delegate if a task requires a new body stream starting from the given offset. This may be
  /// necessary when resuming a failed upload task.
  ///
  /// - Parameter session: The session containing the task that needs a new body stream from the given offset.
  /// - Parameter task: The task that needs a new body stream.
  /// - Parameter offset: The starting offset required for the body stream.
  /// - Parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
  static final URLSession_task_needNewBodyStreamFromOffset_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          int,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Int64,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_jyim80)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            int,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            int,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            int,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// Sent when the system is ready to begin work for a task with a delayed start
  /// time set (using the earliestBeginDate property). The completionHandler must
  /// be invoked in order for loading to proceed. The disposition provided to the
  /// completion handler continues the load with the original request provided to
  /// the task, replaces the request with the specified task, or cancels the task.
  /// If this delegate is not implemented, loading will proceed with the original
  /// request.
  ///
  /// Recommendation: only implement this delegate if tasks that have the
  /// earliestBeginDate property set may become stale and require alteration prior
  /// to starting the network load.
  ///
  /// If a new request is specified, the allowsExpensiveNetworkAccess,
  /// allowsConstrainedNetworkAccess, and allowsCellularAccess properties
  /// from the new request will not be used; the properties from the
  /// original request will continue to be used.
  ///
  /// Canceling the task is equivalent to calling the task's cancel method; the
  /// URLSession:task:didCompleteWithError: task delegate will be called with error
  /// NSURLErrorCancelled.
  static final URLSession_task_willBeginDelayedRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
        )
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_xx612k)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLRequest arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLRequest arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLRequest arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// An HTTP request is attempting to perform a redirection to a different
  /// URL. You must invoke the completion routine to allow the
  /// redirection, allow the redirection with a modified request, or
  /// pass nil to the completionHandler to cause the body of the redirection
  /// response to be delivered as the payload of this request. The default
  /// is to follow redirections.
  ///
  /// For tasks in background sessions, redirections will always be followed and this method will not be called.
  static final URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
        )
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_l2g8ke)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
                NSURLRequest arg4,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
                NSURLRequest arg4,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
                NSURLRequest arg4,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
      );

  /// Sent when a task cannot start the network loading process because the current
  /// network connectivity is not available or sufficient for the task's request.
  ///
  /// This delegate will be called at most one time per task, and is only called if
  /// the waitsForConnectivity property in the NSURLSessionConfiguration has been
  /// set to YES.
  ///
  /// This delegate callback will never be called for background sessions, because
  /// the waitForConnectivity property is ignored by those sessions.
  static final URLSession_taskIsWaitingForConnectivity_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask)
      >(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSession_taskIsWaitingForConnectivity_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSession_taskIsWaitingForConnectivity_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// If an application has received an
  /// -application:handleEventsForBackgroundURLSession:completionHandler:
  /// message, the session delegate will receive this message to indicate
  /// that all messages previously enqueued for this session have been
  /// delivered.  At this time it is safe to invoke the previously stored
  /// completion handler, or to begin any internal updates that will
  /// result in invoking the completion handler.
  static final URLSessionDidFinishEventsForBackgroundURLSession_ =
      objc.ObjCProtocolListenableMethod<void Function(NSURLSession)>(
        _protocol_NSURLSessionDownloadDelegate,
        _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionDownloadDelegate,
          _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession.fromFunction(
              (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1),
            ),
        (void Function(NSURLSession) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession.listener(
              (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1),
            ),
        (void Function(NSURLSession) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession.blocking(
              (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1),
            ),
      );
}

late final _protocol_NSURLSessionWebSocketDelegate = objc.getProtocol(
  "NSURLSessionWebSocketDelegate",
);
late final _sel_URLSession_webSocketTask_didOpenWithProtocol_ = objc
    .registerName("URLSession:webSocketTask:didOpenWithProtocol:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      objc.NSString?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionWebSocketTask,
          objc.NSString?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      objc.NSString?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<objc.ObjCObjectImpl> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionWebSocketTask,
          objc.NSString?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      objc.NSString?,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      objc.NSString?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionWebSocketTask,
          objc.NSString?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionWebSocketTask.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            arg3.address == 0
                ? null
                : objc.NSString.fromPointer(arg3, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      objc.NSString?,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      objc.NSString?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionWebSocketTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3.address == 0
            ? null
            : objc.NSString.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionWebSocketTask,
        objc.NSString?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      objc.NSString?,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      objc.NSString?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionWebSocketTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3.address == 0
            ? null
            : objc.NSString.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        ffi.Pointer<objc.ObjCObjectImpl> arg3,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionWebSocketTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3.address == 0
            ? null
            : objc.NSString.fromPointer(arg3, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionWebSocketTask,
        objc.NSString?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<objc.ObjCObjectImpl> arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<objc.ObjCObjectImpl> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionWebSocketTask,
            objc.NSString?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionWebSocketTask arg2,
    objc.NSString? arg3,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Pointer<objc.ObjCObjectImpl> arg3,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3?.ref.pointer ?? ffi.nullptr,
      );
}

late final _sel_URLSession_webSocketTask_didCloseWithCode_reason_ = objc
    .registerName("URLSession:webSocketTask:didCloseWithCode:reason:");
final _objc_msgSend_d9bpjb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, ffi.Long, objc.NSData?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      ffi.Long,
      objc.NSData?,
    )
  >
  fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionWebSocketTask,
          ffi.Long,
          objc.NSData?,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      ffi.Long,
      objc.NSData?,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Long arg3,
          ffi.Pointer<objc.ObjCObjectImpl> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionWebSocketTask,
          ffi.Long,
          objc.NSData?,
        )
      >(
        objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
        retain: false,
        release: true,
      );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      ffi.Long,
      objc.NSData?,
    )
  >
  fromFunction(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      int,
      objc.NSData?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionWebSocketTask,
          ffi.Long,
          objc.NSData?,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            int arg3,
            ffi.Pointer<objc.ObjCObjectImpl> arg4,
          ) => fn(
            arg0,
            NSURLSession.fromPointer(arg1, retain: true, release: true),
            NSURLSessionWebSocketTask.fromPointer(
              arg2,
              retain: true,
              release: true,
            ),
            arg3,
            arg4.address == 0
                ? null
                : objc.NSData.fromPointer(arg4, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      ffi.Long,
      objc.NSData?,
    )
  >
  listener(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      int,
      objc.NSData?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        ffi.Pointer<objc.ObjCObjectImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionWebSocketTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3,
        arg4.address == 0
            ? null
            : objc.NSData.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1lx650f(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionWebSocketTask,
        ffi.Long,
        objc.NSData?,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      ffi.Long,
      objc.NSData?,
    )
  >
  blocking(
    void Function(
      ffi.Pointer<ffi.Void>,
      NSURLSession,
      NSURLSessionWebSocketTask,
      int,
      objc.NSData?,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        ffi.Pointer<objc.ObjCObjectImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionWebSocketTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3,
        arg4.address == 0
            ? null
            : objc.NSData.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
        int arg3,
        ffi.Pointer<objc.ObjCObjectImpl> arg4,
      ) => fn(
        arg0,
        NSURLSession.fromPointer(arg1, retain: false, release: true),
        NSURLSessionWebSocketTask.fromPointer(
          arg2,
          retain: false,
          release: true,
        ),
        arg3,
        arg4.address == 0
            ? null
            : objc.NSData.fromPointer(arg4, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_1lx650f(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        ffi.Pointer<ffi.Void>,
        NSURLSession,
        NSURLSessionWebSocketTask,
        ffi.Long,
        objc.NSData?,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Long,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Long,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Long arg3,
            ffi.Pointer<objc.ObjCObjectImpl> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          int,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    int arg3,
    ffi.Pointer<objc.ObjCObjectImpl> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            int,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Long,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, ffi.Long, objc.NSData?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionWebSocketTask,
            ffi.Long,
            objc.NSData?,
          )
        > {
  void call(
    ffi.Pointer<ffi.Void> arg0,
    NSURLSession arg1,
    NSURLSessionWebSocketTask arg2,
    int arg3,
    objc.NSData? arg4,
  ) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObjectImpl> arg1,
                ffi.Pointer<objc.ObjCObjectImpl> arg2,
                ffi.Long arg3,
                ffi.Pointer<objc.ObjCObjectImpl> arg4,
              )
            >
          >()
          .asFunction<
            void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              int,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >()(
        ref.pointer,
        arg0,
        arg1.ref.pointer,
        arg2.ref.pointer,
        arg3,
        arg4?.ref.pointer ?? ffi.nullptr,
      );
}

/// NSURLSessionWebSocketDelegate
extension type NSURLSessionWebSocketDelegate._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol, NSURLSessionTaskDelegate {
  /// Constructs a [NSURLSessionWebSocketDelegate] that points to the same underlying object as [other].
  NSURLSessionWebSocketDelegate.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSURLSessionWebSocketDelegate] that wraps the given raw object pointer.
  NSURLSessionWebSocketDelegate.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLSessionWebSocketDelegate].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(
      obj.ref.pointer,
      _sel_conformsToProtocol_,
      _protocol_NSURLSessionWebSocketDelegate,
    );
  }
}

extension NSURLSessionWebSocketDelegate$Methods
    on NSURLSessionWebSocketDelegate {
  /// The last message a session receives.  A session will only become
  /// invalid because of a systemic error or when it has been
  /// explicitly invalidated, in which case the error parameter will be nil.
  void URLSession$5(
    NSURLSession session, {
    objc.NSError? didBecomeInvalidWithError,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:didBecomeInvalidWithError:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_didBecomeInvalidWithError_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:didBecomeInvalidWithError:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_URLSession_didBecomeInvalidWithError_,
      session.ref.pointer,
      didBecomeInvalidWithError?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Notification that a task has been created.  This method is the first message
  /// a task sends, providing a place to configure the task before it is resumed.
  ///
  /// This delegate callback is *NOT* dispatched to the delegate queue.  It is
  /// invoked synchronously before the task creation method returns.
  void URLSession$6(
    NSURLSession session, {
    required NSURLSessionTask didCreateTask,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:didCreateTask:',
      iOS: (false, (16, 0, 0)),
      macOS: (false, (13, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_didCreateTask_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:didCreateTask:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_URLSession_didCreateTask_,
      session.ref.pointer,
      didCreateTask.ref.pointer,
    );
  }

  /// If implemented, when a connection level authentication challenge
  /// has occurred, this delegate will be given the opportunity to
  /// provide authentication credentials to the underlying
  /// connection. Some types of authentication will apply to more than
  /// one request on a given connection to a server (SSL Server Trust
  /// challenges).  If this delegate message is not implemented, the
  /// behavior will be to use the default handling, which may involve user
  /// interaction.
  void URLSession$7(
    NSURLSession session, {
    required NSURLAuthenticationChallenge didReceiveChallenge,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:didReceiveChallenge:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_didReceiveChallenge_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:didReceiveChallenge:completionHandler:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_URLSession_didReceiveChallenge_completionHandler_,
      session.ref.pointer,
      didReceiveChallenge.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Sent as the last message related to a specific task.  Error may be
  /// nil, which implies that no error occurred and this task is complete.
  void URLSession$8(
    NSURLSession session, {
    required NSURLSessionTask task,
    objc.NSError? didCompleteWithError,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:task:didCompleteWithError:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didCompleteWithError_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:task:didCompleteWithError:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_task_didCompleteWithError_,
      session.ref.pointer,
      task.ref.pointer,
      didCompleteWithError?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Sent when complete statistics information has been collected for the task.
  void URLSession$9(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSURLSessionTaskMetrics didFinishCollectingMetrics,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:task:didFinishCollectingMetrics:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didFinishCollectingMetrics_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:task:didFinishCollectingMetrics:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_task_didFinishCollectingMetrics_,
      session.ref.pointer,
      task.ref.pointer,
      didFinishCollectingMetrics.ref.pointer,
    );
  }

  /// The task has received a request specific authentication challenge.
  /// If this delegate is not implemented, the session specific authentication challenge
  /// will *NOT* be called and the behavior will be the same as using the default handling
  /// disposition.
  void URLSession$10(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSURLAuthenticationChallenge didReceiveChallenge,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:task:didReceiveChallenge:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveChallenge_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:task:didReceiveChallenge:completionHandler:',
      );
    }
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveChallenge_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      didReceiveChallenge.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Sent for each informational response received except 101 switching protocols.
  void URLSession$11(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSHTTPURLResponse didReceiveInformationalResponse,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:task:didReceiveInformationalResponse:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveInformationalResponse_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:task:didReceiveInformationalResponse:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_task_didReceiveInformationalResponse_,
      session.ref.pointer,
      task.ref.pointer,
      didReceiveInformationalResponse.ref.pointer,
    );
  }

  /// Sent periodically to notify the delegate of upload progress.  This
  /// information is also available as properties of the task.
  void URLSession$12(
    NSURLSession session, {
    required NSURLSessionTask task,
    required int didSendBodyData,
    required int totalBytesSent,
    required int totalBytesExpectedToSend,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:',
      );
    }
    _objc_msgSend_1modw1b(
      object$.ref.pointer,
      _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      session.ref.pointer,
      task.ref.pointer,
      didSendBodyData,
      totalBytesSent,
      totalBytesExpectedToSend,
    );
  }

  /// Sent if a task requires a new, unopened body stream.  This may be
  /// necessary when authentication has failed for any request that
  /// involves a body stream.
  void URLSession$13(
    NSURLSession session, {
    required NSURLSessionTask task,
    required objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
    needNewBodyStream,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:task:needNewBodyStream:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStream_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:task:needNewBodyStream:',
      );
    }
    _objc_msgSend_18qun1e(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStream_,
      session.ref.pointer,
      task.ref.pointer,
      needNewBodyStream.ref.pointer,
    );
  }

  /// Tells the delegate if a task requires a new body stream starting from the given offset. This may be
  /// necessary when resuming a failed upload task.
  ///
  /// - Parameter session: The session containing the task that needs a new body stream from the given offset.
  /// - Parameter task: The task that needs a new body stream.
  /// - Parameter offset: The starting offset required for the body stream.
  /// - Parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
  void URLSession$14(
    NSURLSession session, {
    required NSURLSessionTask task,
    required int needNewBodyStreamFromOffset,
    required objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:task:needNewBodyStreamFromOffset:completionHandler:',
      iOS: (false, (17, 0, 0)),
      macOS: (false, (14, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:task:needNewBodyStreamFromOffset:completionHandler:',
      );
    }
    _objc_msgSend_9cddqw(
      object$.ref.pointer,
      _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      needNewBodyStreamFromOffset,
      completionHandler.ref.pointer,
    );
  }

  /// Sent when the system is ready to begin work for a task with a delayed start
  /// time set (using the earliestBeginDate property). The completionHandler must
  /// be invoked in order for loading to proceed. The disposition provided to the
  /// completion handler continues the load with the original request provided to
  /// the task, replaces the request with the specified task, or cancels the task.
  /// If this delegate is not implemented, loading will proceed with the original
  /// request.
  ///
  /// Recommendation: only implement this delegate if tasks that have the
  /// earliestBeginDate property set may become stale and require alteration prior
  /// to starting the network load.
  ///
  /// If a new request is specified, the allowsExpensiveNetworkAccess,
  /// allowsConstrainedNetworkAccess, and allowsCellularAccess properties
  /// from the new request will not be used; the properties from the
  /// original request will continue to be used.
  ///
  /// Canceling the task is equivalent to calling the task's cancel method; the
  /// URLSession:task:didCompleteWithError: task delegate will be called with error
  /// NSURLErrorCancelled.
  void URLSession$15(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSURLRequest willBeginDelayedRequest,
    required objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>
    completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:task:willBeginDelayedRequest:completionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:task:willBeginDelayedRequest:completionHandler:',
      );
    }
    _objc_msgSend_m7tls4(
      object$.ref.pointer,
      _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      willBeginDelayedRequest.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// An HTTP request is attempting to perform a redirection to a different
  /// URL. You must invoke the completion routine to allow the
  /// redirection, allow the redirection with a modified request, or
  /// pass nil to the completionHandler to cause the body of the redirection
  /// response to be delivered as the payload of this request. The default
  /// is to follow redirections.
  ///
  /// For tasks in background sessions, redirections will always be followed and this method will not be called.
  void URLSession$16(
    NSURLSession session, {
    required NSURLSessionTask task,
    required NSHTTPURLResponse willPerformHTTPRedirection,
    required NSURLRequest newRequest,
    required objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 9, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:',
      );
    }
    _objc_msgSend_e1wgee(
      object$.ref.pointer,
      _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      session.ref.pointer,
      task.ref.pointer,
      willPerformHTTPRedirection.ref.pointer,
      newRequest.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// Sent when a task cannot start the network loading process because the current
  /// network connectivity is not available or sufficient for the task's request.
  ///
  /// This delegate will be called at most one time per task, and is only called if
  /// the waitsForConnectivity property in the NSURLSessionConfiguration has been
  /// set to YES.
  ///
  /// This delegate callback will never be called for background sessions, because
  /// the waitForConnectivity property is ignored by those sessions.
  void URLSession$17(
    NSURLSession session, {
    required NSURLSessionTask taskIsWaitingForConnectivity,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:taskIsWaitingForConnectivity:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_taskIsWaitingForConnectivity_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:taskIsWaitingForConnectivity:',
      );
    }
    _objc_msgSend_pfv6jd(
      object$.ref.pointer,
      _sel_URLSession_taskIsWaitingForConnectivity_,
      session.ref.pointer,
      taskIsWaitingForConnectivity.ref.pointer,
    );
  }

  /// Indicates that the WebSocket has received a close frame from the server endpoint.
  /// The close code and the close reason may be provided by the delegate if the server elects to send
  /// this information in the close frame
  void URLSession(
    NSURLSession session, {
    required NSURLSessionWebSocketTask webSocketTask,
    required int didCloseWithCode,
    objc.NSData? reason,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:webSocketTask:didCloseWithCode:reason:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_webSocketTask_didCloseWithCode_reason_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:webSocketTask:didCloseWithCode:reason:',
      );
    }
    _objc_msgSend_d9bpjb(
      object$.ref.pointer,
      _sel_URLSession_webSocketTask_didCloseWithCode_reason_,
      session.ref.pointer,
      webSocketTask.ref.pointer,
      didCloseWithCode,
      reason?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Indicates that the WebSocket handshake was successful and the connection has been upgraded to webSockets.
  /// It will also provide the protocol that is picked in the handshake. If the handshake fails, this delegate will not be invoked.
  void URLSession$1(
    NSURLSession session, {
    required NSURLSessionWebSocketTask webSocketTask,
    objc.NSString? didOpenWithProtocol,
  }) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSession:webSocketTask:didOpenWithProtocol:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSession_webSocketTask_didOpenWithProtocol_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSession:webSocketTask:didOpenWithProtocol:',
      );
    }
    _objc_msgSend_r8gdi7(
      object$.ref.pointer,
      _sel_URLSession_webSocketTask_didOpenWithProtocol_,
      session.ref.pointer,
      webSocketTask.ref.pointer,
      didOpenWithProtocol?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// If an application has received an
  /// -application:handleEventsForBackgroundURLSession:completionHandler:
  /// message, the session delegate will receive this message to indicate
  /// that all messages previously enqueued for this session have been
  /// delivered.  At this time it is safe to invoke the previously stored
  /// completion handler, or to begin any internal updates that will
  /// result in invoking the completion handler.
  void URLSessionDidFinishEventsForBackgroundURLSession(NSURLSession session) {
    objc.checkOsVersionInternal(
      'NSURLSessionWebSocketDelegate.URLSessionDidFinishEventsForBackgroundURLSession:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (11, 0, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSURLSessionWebSocketDelegate',
        'URLSessionDidFinishEventsForBackgroundURLSession:',
      );
    }
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
      session.ref.pointer,
    );
  }
}

interface class NSURLSessionWebSocketDelegate$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.fromPointer(_protocol_NSURLSessionWebSocketDelegate.cast());

  /// Builds an object that implements the NSURLSessionWebSocketDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSURLSessionWebSocketDelegate implement({
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, int, objc.NSData?)?
    URLSession_webSocketTask_didCloseWithCode_reason_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
    URLSession_webSocketTask_didOpenWithProtocol_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSURLSessionWebSocketDelegate',
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implement(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder.URLSession_didCreateTask_.implement(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didCompleteWithError_.implement(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implement(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implement(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implement(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStream_.implement(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implement(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implement(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implement(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implement(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didCloseWithCode_reason_.implement(
      builder,
      URLSession_webSocketTask_didCloseWithCode_reason_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didOpenWithProtocol_.implement(
      builder,
      URLSession_webSocketTask_didOpenWithProtocol_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implement(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
    return NSURLSessionWebSocketDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSURLSessionWebSocketDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, int, objc.NSData?)?
    URLSession_webSocketTask_didCloseWithCode_reason_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
    URLSession_webSocketTask_didOpenWithProtocol_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implement(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder.URLSession_didCreateTask_.implement(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didCompleteWithError_.implement(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implement(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implement(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implement(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implement(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStream_.implement(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implement(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implement(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implement(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implement(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didCloseWithCode_reason_.implement(
      builder,
      URLSession_webSocketTask_didCloseWithCode_reason_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didOpenWithProtocol_.implement(
      builder,
      URLSession_webSocketTask_didOpenWithProtocol_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implement(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSURLSessionWebSocketDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSURLSessionWebSocketDelegate implementAsListener({
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, int, objc.NSData?)?
    URLSession_webSocketTask_didCloseWithCode_reason_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
    URLSession_webSocketTask_didOpenWithProtocol_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSURLSessionWebSocketDelegate',
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsListener(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didCreateTask_.implementAsListener(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsListener(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsListener(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsListener(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsListener(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsListener(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didCloseWithCode_reason_.implementAsListener(
      builder,
      URLSession_webSocketTask_didCloseWithCode_reason_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didOpenWithProtocol_.implementAsListener(
      builder,
      URLSession_webSocketTask_didOpenWithProtocol_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsListener(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
    return NSURLSessionWebSocketDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSURLSessionWebSocketDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, int, objc.NSData?)?
    URLSession_webSocketTask_didCloseWithCode_reason_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
    URLSession_webSocketTask_didOpenWithProtocol_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsListener(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didCreateTask_.implementAsListener(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsListener(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsListener(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsListener(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsListener(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsListener(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsListener(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsListener(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsListener(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didCloseWithCode_reason_.implementAsListener(
      builder,
      URLSession_webSocketTask_didCloseWithCode_reason_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didOpenWithProtocol_.implementAsListener(
      builder,
      URLSession_webSocketTask_didOpenWithProtocol_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsListener(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSURLSessionWebSocketDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSURLSessionWebSocketDelegate implementAsBlocking({
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, int, objc.NSData?)?
    URLSession_webSocketTask_didCloseWithCode_reason_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
    URLSession_webSocketTask_didOpenWithProtocol_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(
      debugName: 'NSURLSessionWebSocketDelegate',
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsBlocking(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didCreateTask_.implementAsBlocking(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsBlocking(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsBlocking(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsBlocking(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsBlocking(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didCloseWithCode_reason_.implementAsBlocking(
      builder,
      URLSession_webSocketTask_didCloseWithCode_reason_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didOpenWithProtocol_.implementAsBlocking(
      builder,
      URLSession_webSocketTask_didOpenWithProtocol_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsBlocking(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
    return NSURLSessionWebSocketDelegate.as(
      builder.build(keepIsolateAlive: $keepIsolateAlive),
    );
  }

  /// Adds the implementation of the NSURLSessionWebSocketDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    void Function(NSURLSession, objc.NSError?)?
    URLSession_didBecomeInvalidWithError_,
    void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
    void Function(
      NSURLSession,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, objc.NSError?)?
    URLSession_task_didCompleteWithError_,
    void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)?
    URLSession_task_didFinishCollectingMetrics_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLAuthenticationChallenge,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
    )?
    URLSession_task_didReceiveChallenge_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)?
    URLSession_task_didReceiveInformationalResponse_,
    void Function(NSURLSession, NSURLSessionTask, int, int, int)?
    URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStream_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      int,
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
    )?
    URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
    )?
    URLSession_task_willBeginDelayedRequest_completionHandler_,
    void Function(
      NSURLSession,
      NSURLSessionTask,
      NSHTTPURLResponse,
      NSURLRequest,
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
    )?
    URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    void Function(NSURLSession, NSURLSessionTask)?
    URLSession_taskIsWaitingForConnectivity_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, int, objc.NSData?)?
    URLSession_webSocketTask_didCloseWithCode_reason_,
    void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
    URLSession_webSocketTask_didOpenWithProtocol_,
    void Function(NSURLSession)?
    URLSessionDidFinishEventsForBackgroundURLSession_,
    bool $keepIsolateAlive = true,
  }) {
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didBecomeInvalidWithError_.implementAsBlocking(
      builder,
      URLSession_didBecomeInvalidWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didCreateTask_.implementAsBlocking(
      builder,
      URLSession_didCreateTask_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didCompleteWithError_.implementAsBlocking(
      builder,
      URLSession_task_didCompleteWithError_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didFinishCollectingMetrics_.implementAsBlocking(
      builder,
      URLSession_task_didFinishCollectingMetrics_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveChallenge_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveChallenge_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didReceiveInformationalResponse_.implementAsBlocking(
      builder,
      URLSession_task_didReceiveInformationalResponse_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_.implementAsBlocking(
      builder,
      URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStream_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStream_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_needNewBodyStreamFromOffset_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willBeginDelayedRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willBeginDelayedRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_.implementAsBlocking(
      builder,
      URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_taskIsWaitingForConnectivity_.implementAsBlocking(
      builder,
      URLSession_taskIsWaitingForConnectivity_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didCloseWithCode_reason_.implementAsBlocking(
      builder,
      URLSession_webSocketTask_didCloseWithCode_reason_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSession_webSocketTask_didOpenWithProtocol_.implementAsBlocking(
      builder,
      URLSession_webSocketTask_didOpenWithProtocol_,
    );
    NSURLSessionWebSocketDelegate$Builder
        .URLSessionDidFinishEventsForBackgroundURLSession_.implementAsBlocking(
      builder,
      URLSessionDidFinishEventsForBackgroundURLSession_,
    );
    builder.addProtocol($protocol);
  }

  /// The last message a session receives.  A session will only become
  /// invalid because of a systemic error or when it has been
  /// explicitly invalidated, in which case the error parameter will be nil.
  static final URLSession_didBecomeInvalidWithError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, objc.NSError?)
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_didBecomeInvalidWithError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_didBecomeInvalidWithError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                objc.NSError? arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// Notification that a task has been created.  This method is the first message
  /// a task sends, providing a place to configure the task before it is resumed.
  ///
  /// This delegate callback is *NOT* dispatched to the delegate queue.  It is
  /// invoked synchronously before the task creation method returns.
  static final URLSession_didCreateTask_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask)
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_didCreateTask_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_didCreateTask_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// If implemented, when a connection level authentication challenge
  /// has occurred, this delegate will be given the opportunity to
  /// provide authentication credentials to the underlying
  /// connection. Some types of authentication will apply to more than
  /// one request on a given connection to a server (SSL Server Trust
  /// challenges).  If this delegate message is not implemented, the
  /// behavior will be to use the default handling, which may involve user
  /// interaction.
  static final URLSession_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_didReceiveChallenge_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_didReceiveChallenge_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLAuthenticationChallenge arg2,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent as the last message related to a specific task.  Error may be
  /// nil, which implies that no error occurred and this task is complete.
  static final URLSession_task_didCompleteWithError_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, objc.NSError?)
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_task_didCompleteWithError_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_task_didCompleteWithError_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.NSError? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent when complete statistics information has been collected for the task.
  static final URLSession_task_didFinishCollectingMetrics_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_task_didFinishCollectingMetrics_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_task_didFinishCollectingMetrics_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLSessionTaskMetrics arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLSessionTaskMetrics arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLSessionTaskMetrics arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// The task has received a request specific authentication challenge.
  /// If this delegate is not implemented, the session specific authentication challenge
  /// will *NOT* be called and the behavior will be the same as using the default handling
  /// disposition.
  static final URLSession_task_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
        )
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_task_didReceiveChallenge_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_xx612k)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_task_didReceiveChallenge_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLAuthenticationChallenge arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLAuthenticationChallenge arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLAuthenticationChallenge arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLCredential?)>
                arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// Sent for each informational response received except 101 switching protocols.
  static final URLSession_task_didReceiveInformationalResponse_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_task_didReceiveInformationalResponse_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_task_didReceiveInformationalResponse_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Sent periodically to notify the delegate of upload progress.  This
  /// information is also available as properties of the task.
  static final URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask, int, int, int)
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_h68abb)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                int arg4,
                int arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
      );

  /// Sent if a task requires a new, unopened body stream.  This may be
  /// necessary when authentication has failed for any request that
  /// involves a body stream.
  static final URLSession_task_needNewBodyStream_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_task_needNewBodyStream_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_bklti2)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_task_needNewBodyStream_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// Tells the delegate if a task requires a new body stream starting from the given offset. This may be
  /// necessary when resuming a failed upload task.
  ///
  /// - Parameter session: The session containing the task that needs a new body stream from the given offset.
  /// - Parameter task: The task that needs a new body stream.
  /// - Parameter offset: The starting offset required for the body stream.
  /// - Parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
  static final URLSession_task_needNewBodyStreamFromOffset_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          int,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
        )
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Int64,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_jyim80)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            int,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            int,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            int,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                int arg3,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// Sent when the system is ready to begin work for a task with a delayed start
  /// time set (using the earliestBeginDate property). The completionHandler must
  /// be invoked in order for loading to proceed. The disposition provided to the
  /// completion handler continues the load with the original request provided to
  /// the task, replaces the request with the specified task, or cancels the task.
  /// If this delegate is not implemented, loading will proceed with the original
  /// request.
  ///
  /// Recommendation: only implement this delegate if tasks that have the
  /// earliestBeginDate property set may become stale and require alteration prior
  /// to starting the network load.
  ///
  /// If a new request is specified, the allowsExpensiveNetworkAccess,
  /// allowsConstrainedNetworkAccess, and allowsCellularAccess properties
  /// from the new request will not be used; the properties from the
  /// original request will continue to be used.
  ///
  /// Canceling the task is equivalent to calling the task's cancel method; the
  /// URLSession:task:didCompleteWithError: task delegate will be called with error
  /// NSURLErrorCancelled.
  static final URLSession_task_willBeginDelayedRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
        )
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_xx612k)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLRequest arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLRequest arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSURLRequest arg3,
                objc.ObjCBlock<ffi.Void Function(ffi.Long, NSURLRequest?)> arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// An HTTP request is attempting to perform a redirection to a different
  /// URL. You must invoke the completion routine to allow the
  /// redirection, allow the redirection with a modified request, or
  /// pass nil to the completionHandler to cause the body of the redirection
  /// response to be delivered as the payload of this request. The default
  /// is to follow redirections.
  ///
  /// For tasks in background sessions, redirections will always be followed and this method will not be called.
  static final URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
        )
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_l2g8ke)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
                NSURLRequest arg4,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
                NSURLRequest arg4,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
                NSHTTPURLResponse arg3,
                NSURLRequest arg4,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5,
              ) => func(arg1, arg2, arg3, arg4, arg5),
            ),
      );

  /// Sent when a task cannot start the network loading process because the current
  /// network connectivity is not available or sufficient for the task's request.
  ///
  /// This delegate will be called at most one time per task, and is only called if
  /// the waitsForConnectivity property in the NSURLSessionConfiguration has been
  /// set to YES.
  ///
  /// This delegate callback will never be called for background sessions, because
  /// the waitForConnectivity property is ignored by those sessions.
  static final URLSession_taskIsWaitingForConnectivity_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionTask)
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_taskIsWaitingForConnectivity_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_fjrv01)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_taskIsWaitingForConnectivity_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
        (void Function(NSURLSession, NSURLSessionTask) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionTask arg2,
              ) => func(arg1, arg2),
            ),
      );

  /// Indicates that the WebSocket has received a close frame from the server endpoint.
  /// The close code and the close reason may be provided by the delegate if the server elects to send
  /// this information in the close frame
  static final URLSession_webSocketTask_didCloseWithCode_reason_ =
      objc.ObjCProtocolListenableMethod<
        void Function(
          NSURLSession,
          NSURLSessionWebSocketTask,
          int,
          objc.NSData?,
        )
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_webSocketTask_didCloseWithCode_reason_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Long,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1lx650f)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_webSocketTask_didCloseWithCode_reason_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(
            NSURLSession,
            NSURLSessionWebSocketTask,
            int,
            objc.NSData?,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionWebSocketTask arg2,
                int arg3,
                objc.NSData? arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionWebSocketTask,
            int,
            objc.NSData?,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionWebSocketTask arg2,
                int arg3,
                objc.NSData? arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
        (
          void Function(
            NSURLSession,
            NSURLSessionWebSocketTask,
            int,
            objc.NSData?,
          )
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionWebSocketTask arg2,
                int arg3,
                objc.NSData? arg4,
              ) => func(arg1, arg2, arg3, arg4),
            ),
      );

  /// Indicates that the WebSocket handshake was successful and the connection has been upgraded to webSockets.
  /// It will also provide the protocol that is picked in the handshake. If the handshake fails, this delegate will not be invoked.
  static final URLSession_webSocketTask_didOpenWithProtocol_ =
      objc.ObjCProtocolListenableMethod<
        void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)
      >(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSession_webSocketTask_didOpenWithProtocol_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_1tz5yf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSession_webSocketTask_didOpenWithProtocol_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (
          void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString.fromFunction(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionWebSocketTask arg2,
                objc.NSString? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString.listener(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionWebSocketTask arg2,
                objc.NSString? arg3,
              ) => func(arg1, arg2, arg3),
            ),
        (
          void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)
          func,
        ) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString.blocking(
              (
                ffi.Pointer<ffi.Void> _,
                NSURLSession arg1,
                NSURLSessionWebSocketTask arg2,
                objc.NSString? arg3,
              ) => func(arg1, arg2, arg3),
            ),
      );

  /// If an application has received an
  /// -application:handleEventsForBackgroundURLSession:completionHandler:
  /// message, the session delegate will receive this message to indicate
  /// that all messages previously enqueued for this session have been
  /// delivered.  At this time it is safe to invoke the previously stored
  /// completion handler, or to begin any internal updates that will
  /// result in invoking the completion handler.
  static final URLSessionDidFinishEventsForBackgroundURLSession_ =
      objc.ObjCProtocolListenableMethod<void Function(NSURLSession)>(
        _protocol_NSURLSessionWebSocketDelegate,
        _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
        ffi.Native.addressOf<
              ffi.NativeFunction<
                ffi.Void Function(
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                )
              >
            >(_NativeCupertinoHttp_protocolTrampoline_18v1jvf)
            .cast(),
        objc.getProtocolMethodSignature(
          _protocol_NSURLSessionWebSocketDelegate,
          _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
          isRequired: false,
          isInstanceMethod: true,
        ),
        (void Function(NSURLSession) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession.fromFunction(
              (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1),
            ),
        (void Function(NSURLSession) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession.listener(
              (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1),
            ),
        (void Function(NSURLSession) func) =>
            ObjCBlock_ffiVoid_ffiVoid_NSURLSession.blocking(
              (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1),
            ),
      );
}

/// WARNING: NSLocking is a stub. To generate bindings for this class, include
/// NSLocking in your config's objc-protocols list.
///
/// NSLocking
extension type NSLocking._(objc.ObjCProtocol object$)
    implements objc.ObjCProtocol {
  /// Constructs a [NSLocking] that points to the same underlying object as [other].
  NSLocking.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSLocking] that wraps the given raw object pointer.
  NSLocking.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCProtocol(other, retain: retain, release: release);
}

late final _class_NSCondition = objc.getClass("NSCondition");
late final _sel_wait = objc.registerName("wait");
late final _sel_waitUntilDate_ = objc.registerName("waitUntilDate:");
late final _sel_signal = objc.registerName("signal");
late final _sel_broadcast = objc.registerName("broadcast");
late final _sel_lock = objc.registerName("lock");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeCupertinoHttp_wrapBlockingBlock_ovsamd(
      raw,
      rawListener,
      objc.objCContext,
    );
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(
        arg0,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(
    arg0,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
      >()(ref.pointer, arg0);
}

late final _sel_unlock = objc.registerName("unlock");

/// NSCondition
extension type NSCondition._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject, NSLocking {
  /// Constructs a [NSCondition] that points to the same underlying object as [other].
  NSCondition.as(objc.ObjCObject other) : object$ = other {
    objc.checkOsVersionInternal(
      'NSCondition',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    assert(isA(object$));
  }

  /// Constructs a [NSCondition] that wraps the given raw object pointer.
  NSCondition.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    objc.checkOsVersionInternal(
      'NSCondition',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSCondition].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSCondition,
  );

  /// alloc
  static NSCondition alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSCondition, _sel_alloc);
    return NSCondition.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSCondition allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSCondition,
      _sel_allocWithZone_,
      zone,
    );
    return NSCondition.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSCondition new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSCondition, _sel_new);
    return NSCondition.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSCondition constructed with the default `new` method.
  NSCondition() : this.as(new$().object$);
}

extension NSCondition$Methods on NSCondition {
  /// broadcast
  void broadcast() {
    objc.checkOsVersionInternal(
      'NSCondition.broadcast',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_broadcast);
  }

  /// init
  NSCondition init() {
    objc.checkOsVersionInternal(
      'NSCondition.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSCondition.fromPointer($ret, retain: false, release: true);
  }

  /// lock
  void lock() {
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_lock);
  }

  /// name
  objc.NSString? get name {
    objc.checkOsVersionInternal(
      'NSCondition.name',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_name);
    return $ret.address == 0
        ? null
        : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// setName:
  set name(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSCondition.setName:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setName_,
      value?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// signal
  void signal() {
    objc.checkOsVersionInternal(
      'NSCondition.signal',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_signal);
  }

  /// unlock
  void unlock() {
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_unlock);
  }

  /// wait
  void wait() {
    objc.checkOsVersionInternal(
      'NSCondition.wait',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_wait);
  }

  /// waitUntilDate:
  bool waitUntilDate(objc.NSDate limit) {
    objc.checkOsVersionInternal(
      'NSCondition.waitUntilDate:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 5, 0)),
    );
    return _objc_msgSend_19nvye5(
      object$.ref.pointer,
      _sel_waitUntilDate_,
      limit.ref.pointer,
    );
  }
}

enum NSOperationQueuePriority {
  NSOperationQueuePriorityVeryLow(-8),
  NSOperationQueuePriorityLow(-4),
  NSOperationQueuePriorityNormal(0),
  NSOperationQueuePriorityHigh(4),
  NSOperationQueuePriorityVeryHigh(8);

  final int value;
  const NSOperationQueuePriority(this.value);

  static NSOperationQueuePriority fromValue(int value) => switch (value) {
    -8 => NSOperationQueuePriorityVeryLow,
    -4 => NSOperationQueuePriorityLow,
    0 => NSOperationQueuePriorityNormal,
    4 => NSOperationQueuePriorityHigh,
    8 => NSOperationQueuePriorityVeryHigh,
    _ => throw ArgumentError(
      'Unknown value for NSOperationQueuePriority: $value',
    ),
  };
}
