// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart' as pkg_ffi;

/// Bindings for the Foundation URL Loading System and supporting libraries.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class NativeCupertinoHttp {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeCupertinoHttp(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeCupertinoHttp.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ObjCSel> _registerName1(String name) {
    final cstr = name.toNativeUtf8();
    final sel = _sel_registerName(cstr.cast());
    pkg_ffi.calloc.free(cstr);
    return sel;
  }

  ffi.Pointer<ObjCSel> _sel_registerName(
    ffi.Pointer<ffi.Char> str,
  ) {
    return __sel_registerName(
      str,
    );
  }

  late final __sel_registerNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCSel> Function(
              ffi.Pointer<ffi.Char>)>>('sel_registerName');
  late final __sel_registerName = __sel_registerNamePtr
      .asFunction<ffi.Pointer<ObjCSel> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ObjCObject> _getClass1(String name) {
    final cstr = name.toNativeUtf8();
    final clazz = _objc_getClass(cstr.cast());
    pkg_ffi.calloc.free(cstr);
    return clazz;
  }

  ffi.Pointer<ObjCObject> _objc_getClass(
    ffi.Pointer<ffi.Char> str,
  ) {
    return __objc_getClass(
      str,
    );
  }

  late final __objc_getClassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ffi.Char>)>>('objc_getClass');
  late final __objc_getClass = __objc_getClassPtr
      .asFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ObjCObject> _objc_retain(
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_retain(
      value,
    );
  }

  late final __objc_retainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>)>>('objc_retain');
  late final __objc_retain = __objc_retainPtr
      .asFunction<ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>)>();

  void _objc_release(
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_release(
      value,
    );
  }

  late final __objc_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ObjCObject>)>>(
          'objc_release');
  late final __objc_release =
      __objc_releasePtr.asFunction<void Function(ffi.Pointer<ObjCObject>)>();

  late final _objc_releaseFinalizer1 =
      ffi.NativeFinalizer(__objc_releasePtr.cast());
  late final _class_NSArray1 = _getClass1("NSArray");
  bool _objc_msgSend_0(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> clazz,
  ) {
    return __objc_msgSend_0(
      obj,
      sel,
      clazz,
    );
  }

  late final __objc_msgSend_0Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_0 = __objc_msgSend_0Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_isKindOfClass_1 = _registerName1("isKindOfClass:");
  late final _class_NSObject1 = _getClass1("NSObject");
  late final _sel_load1 = _registerName1("load");
  void _objc_msgSend_1(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_1(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_1 = __objc_msgSend_1Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_initialize1 = _registerName1("initialize");
  late final _sel_init1 = _registerName1("init");
  instancetype _objc_msgSend_2(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_2(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_2Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_2 = __objc_msgSend_2Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_new1 = _registerName1("new");
  late final _sel_allocWithZone_1 = _registerName1("allocWithZone:");
  instancetype _objc_msgSend_3(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_NSZone> zone,
  ) {
    return __objc_msgSend_3(
      obj,
      sel,
      zone,
    );
  }

  late final __objc_msgSend_3Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_NSZone>)>>('objc_msgSend');
  late final __objc_msgSend_3 = __objc_msgSend_3Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_NSZone>)>();

  late final _sel_alloc1 = _registerName1("alloc");
  late final _sel_dealloc1 = _registerName1("dealloc");
  late final _sel_finalize1 = _registerName1("finalize");
  late final _sel_copy1 = _registerName1("copy");
  late final _sel_mutableCopy1 = _registerName1("mutableCopy");
  late final _sel_copyWithZone_1 = _registerName1("copyWithZone:");
  late final _sel_mutableCopyWithZone_1 =
      _registerName1("mutableCopyWithZone:");
  late final _sel_instancesRespondToSelector_1 =
      _registerName1("instancesRespondToSelector:");
  bool _objc_msgSend_4(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_4(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_4 = __objc_msgSend_4Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _class_Protocol1 = _getClass1("Protocol");
  late final _sel_conformsToProtocol_1 = _registerName1("conformsToProtocol:");
  bool _objc_msgSend_5(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> protocol,
  ) {
    return __objc_msgSend_5(
      obj,
      sel,
      protocol,
    );
  }

  late final __objc_msgSend_5Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_5 = __objc_msgSend_5Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_methodForSelector_1 = _registerName1("methodForSelector:");
  IMP _objc_msgSend_6(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_6(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_6Ptr = _lookup<
      ffi.NativeFunction<
          IMP Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_6 = __objc_msgSend_6Ptr.asFunction<
      IMP Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _sel_instanceMethodForSelector_1 =
      _registerName1("instanceMethodForSelector:");
  late final _sel_doesNotRecognizeSelector_1 =
      _registerName1("doesNotRecognizeSelector:");
  void _objc_msgSend_7(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_7(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_7Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_7 = __objc_msgSend_7Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCSel>)>();

  late final _sel_forwardingTargetForSelector_1 =
      _registerName1("forwardingTargetForSelector:");
  ffi.Pointer<ObjCObject> _objc_msgSend_8(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_8(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_8 = __objc_msgSend_8Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>();

  late final _class_NSInvocation1 = _getClass1("NSInvocation");
  late final _sel_forwardInvocation_1 = _registerName1("forwardInvocation:");
  void _objc_msgSend_9(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anInvocation,
  ) {
    return __objc_msgSend_9(
      obj,
      sel,
      anInvocation,
    );
  }

  late final __objc_msgSend_9Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_9 = __objc_msgSend_9Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _class_NSMethodSignature1 = _getClass1("NSMethodSignature");
  late final _sel_methodSignatureForSelector_1 =
      _registerName1("methodSignatureForSelector:");
  ffi.Pointer<ObjCObject> _objc_msgSend_10(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCSel> aSelector,
  ) {
    return __objc_msgSend_10(
      obj,
      sel,
      aSelector,
    );
  }

  late final __objc_msgSend_10Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_10 = __objc_msgSend_10Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCSel>)>();

  late final _sel_instanceMethodSignatureForSelector_1 =
      _registerName1("instanceMethodSignatureForSelector:");
  late final _sel_allowsWeakReference1 = _registerName1("allowsWeakReference");
  bool _objc_msgSend_11(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_11(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_11Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_11 = __objc_msgSend_11Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_retainWeakReference1 = _registerName1("retainWeakReference");
  late final _sel_isSubclassOfClass_1 = _registerName1("isSubclassOfClass:");
  late final _sel_resolveClassMethod_1 = _registerName1("resolveClassMethod:");
  late final _sel_resolveInstanceMethod_1 =
      _registerName1("resolveInstanceMethod:");
  late final _sel_hash1 = _registerName1("hash");
  int _objc_msgSend_12(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_12(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_12Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_12 = __objc_msgSend_12Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_superclass1 = _registerName1("superclass");
  late final _sel_class1 = _registerName1("class");
  late final _class_NSString1 = _getClass1("NSString");
  late final _sel_length1 = _registerName1("length");
  late final _sel_characterAtIndex_1 = _registerName1("characterAtIndex:");
  int _objc_msgSend_13(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int index,
  ) {
    return __objc_msgSend_13(
      obj,
      sel,
      index,
    );
  }

  late final __objc_msgSend_13Ptr = _lookup<
      ffi.NativeFunction<
          unichar Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_13 = __objc_msgSend_13Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _class_NSCoder1 = _getClass1("NSCoder");
  late final _sel_initWithCoder_1 = _registerName1("initWithCoder:");
  instancetype _objc_msgSend_14(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> coder,
  ) {
    return __objc_msgSend_14(
      obj,
      sel,
      coder,
    );
  }

  late final __objc_msgSend_14Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_14 = __objc_msgSend_14Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _class_NSCharacterSet1 = _getClass1("NSCharacterSet");
  late final _sel_controlCharacterSet1 = _registerName1("controlCharacterSet");
  ffi.Pointer<ObjCObject> _objc_msgSend_15(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_15(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_15Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_15 = __objc_msgSend_15Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_whitespaceCharacterSet1 =
      _registerName1("whitespaceCharacterSet");
  late final _sel_whitespaceAndNewlineCharacterSet1 =
      _registerName1("whitespaceAndNewlineCharacterSet");
  late final _sel_decimalDigitCharacterSet1 =
      _registerName1("decimalDigitCharacterSet");
  late final _sel_letterCharacterSet1 = _registerName1("letterCharacterSet");
  late final _sel_lowercaseLetterCharacterSet1 =
      _registerName1("lowercaseLetterCharacterSet");
  late final _sel_uppercaseLetterCharacterSet1 =
      _registerName1("uppercaseLetterCharacterSet");
  late final _sel_nonBaseCharacterSet1 = _registerName1("nonBaseCharacterSet");
  late final _sel_alphanumericCharacterSet1 =
      _registerName1("alphanumericCharacterSet");
  late final _sel_decomposableCharacterSet1 =
      _registerName1("decomposableCharacterSet");
  late final _sel_illegalCharacterSet1 = _registerName1("illegalCharacterSet");
  late final _sel_punctuationCharacterSet1 =
      _registerName1("punctuationCharacterSet");
  late final _sel_capitalizedLetterCharacterSet1 =
      _registerName1("capitalizedLetterCharacterSet");
  late final _sel_symbolCharacterSet1 = _registerName1("symbolCharacterSet");
  late final _sel_newlineCharacterSet1 = _registerName1("newlineCharacterSet");
  late final _sel_characterSetWithRange_1 =
      _registerName1("characterSetWithRange:");
  ffi.Pointer<ObjCObject> _objc_msgSend_16(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange aRange,
  ) {
    return __objc_msgSend_16(
      obj,
      sel,
      aRange,
    );
  }

  late final __objc_msgSend_16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_16 = __objc_msgSend_16Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange)>();

  late final _sel_characterSetWithCharactersInString_1 =
      _registerName1("characterSetWithCharactersInString:");
  ffi.Pointer<ObjCObject> _objc_msgSend_17(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> aString,
  ) {
    return __objc_msgSend_17(
      obj,
      sel,
      aString,
    );
  }

  late final __objc_msgSend_17Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_17 = __objc_msgSend_17Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSData1 = _getClass1("NSData");
  late final _sel_bytes1 = _registerName1("bytes");
  ffi.Pointer<ffi.Void> _objc_msgSend_18(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_18(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_18Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_18 = __objc_msgSend_18Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_description1 = _registerName1("description");
  ffi.Pointer<ObjCObject> _objc_msgSend_19(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_19(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_19Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_19 = __objc_msgSend_19Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_getBytes_length_1 = _registerName1("getBytes:length:");
  void _objc_msgSend_20(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> buffer,
    int length,
  ) {
    return __objc_msgSend_20(
      obj,
      sel,
      buffer,
      length,
    );
  }

  late final __objc_msgSend_20Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>, NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_20 = __objc_msgSend_20Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, int)>();

  late final _sel_getBytes_range_1 = _registerName1("getBytes:range:");
  void _objc_msgSend_21(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> buffer,
    NSRange range,
  ) {
    return __objc_msgSend_21(
      obj,
      sel,
      buffer,
      range,
    );
  }

  late final __objc_msgSend_21Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_21 = __objc_msgSend_21Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, NSRange)>();

  late final _sel_isEqualToData_1 = _registerName1("isEqualToData:");
  bool _objc_msgSend_22(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> other,
  ) {
    return __objc_msgSend_22(
      obj,
      sel,
      other,
    );
  }

  late final __objc_msgSend_22Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_22 = __objc_msgSend_22Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_subdataWithRange_1 = _registerName1("subdataWithRange:");
  ffi.Pointer<ObjCObject> _objc_msgSend_23(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
  ) {
    return __objc_msgSend_23(
      obj,
      sel,
      range,
    );
  }

  late final __objc_msgSend_23Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_23 = __objc_msgSend_23Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange)>();

  late final _sel_writeToFile_atomically_1 =
      _registerName1("writeToFile:atomically:");
  bool _objc_msgSend_24(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool useAuxiliaryFile,
  ) {
    return __objc_msgSend_24(
      obj,
      sel,
      path,
      useAuxiliaryFile,
    );
  }

  late final __objc_msgSend_24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_24 = __objc_msgSend_24Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _class_NSURL1 = _getClass1("NSURL");
  late final _sel_initWithScheme_host_path_1 =
      _registerName1("initWithScheme:host:path:");
  instancetype _objc_msgSend_25(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> scheme,
    ffi.Pointer<ObjCObject> host,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_25(
      obj,
      sel,
      scheme,
      host,
      path,
    );
  }

  late final __objc_msgSend_25Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_25 = __objc_msgSend_25Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initFileURLWithPath_isDirectory_relativeToURL_1 =
      _registerName1("initFileURLWithPath:isDirectory:relativeToURL:");
  instancetype _objc_msgSend_26(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool isDir,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_26(
      obj,
      sel,
      path,
      isDir,
      baseURL,
    );
  }

  late final __objc_msgSend_26Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_26 = __objc_msgSend_26Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool, ffi.Pointer<ObjCObject>)>();

  late final _sel_initFileURLWithPath_relativeToURL_1 =
      _registerName1("initFileURLWithPath:relativeToURL:");
  instancetype _objc_msgSend_27(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_27(
      obj,
      sel,
      path,
      baseURL,
    );
  }

  late final __objc_msgSend_27Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_27 = __objc_msgSend_27Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_initFileURLWithPath_isDirectory_1 =
      _registerName1("initFileURLWithPath:isDirectory:");
  instancetype _objc_msgSend_28(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool isDir,
  ) {
    return __objc_msgSend_28(
      obj,
      sel,
      path,
      isDir,
    );
  }

  late final __objc_msgSend_28Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_28 = __objc_msgSend_28Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_initFileURLWithPath_1 =
      _registerName1("initFileURLWithPath:");
  instancetype _objc_msgSend_29(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_29(
      obj,
      sel,
      path,
    );
  }

  late final __objc_msgSend_29Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_29 = __objc_msgSend_29Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_fileURLWithPath_isDirectory_relativeToURL_1 =
      _registerName1("fileURLWithPath:isDirectory:relativeToURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_30(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool isDir,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_30(
      obj,
      sel,
      path,
      isDir,
      baseURL,
    );
  }

  late final __objc_msgSend_30Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_30 = __objc_msgSend_30Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          bool,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_fileURLWithPath_relativeToURL_1 =
      _registerName1("fileURLWithPath:relativeToURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_31(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_31(
      obj,
      sel,
      path,
      baseURL,
    );
  }

  late final __objc_msgSend_31Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_31 = __objc_msgSend_31Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_fileURLWithPath_isDirectory_1 =
      _registerName1("fileURLWithPath:isDirectory:");
  ffi.Pointer<ObjCObject> _objc_msgSend_32(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    bool isDir,
  ) {
    return __objc_msgSend_32(
      obj,
      sel,
      path,
      isDir,
    );
  }

  late final __objc_msgSend_32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_32 = __objc_msgSend_32Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_fileURLWithPath_1 = _registerName1("fileURLWithPath:");
  ffi.Pointer<ObjCObject> _objc_msgSend_33(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_33(
      obj,
      sel,
      path,
    );
  }

  late final __objc_msgSend_33Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_33 = __objc_msgSend_33Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL_1 =
      _registerName1(
          "initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:");
  instancetype _objc_msgSend_34(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> path,
    bool isDir,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_34(
      obj,
      sel,
      path,
      isDir,
      baseURL,
    );
  }

  late final __objc_msgSend_34Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_34 = __objc_msgSend_34Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>, bool, ffi.Pointer<ObjCObject>)>();

  late final _sel_fileURLWithFileSystemRepresentation_isDirectory_relativeToURL_1 =
      _registerName1(
          "fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_35(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> path,
    bool isDir,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_35(
      obj,
      sel,
      path,
      isDir,
      baseURL,
    );
  }

  late final __objc_msgSend_35Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>,
              ffi.Bool,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_35 = __objc_msgSend_35Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>,
          bool,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithString_1 = _registerName1("initWithString:");
  late final _sel_initWithString_relativeToURL_1 =
      _registerName1("initWithString:relativeToURL:");
  late final _sel_URLWithString_1 = _registerName1("URLWithString:");
  late final _sel_URLWithString_relativeToURL_1 =
      _registerName1("URLWithString:relativeToURL:");
  late final _sel_initWithDataRepresentation_relativeToURL_1 =
      _registerName1("initWithDataRepresentation:relativeToURL:");
  instancetype _objc_msgSend_36(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_36(
      obj,
      sel,
      data,
      baseURL,
    );
  }

  late final __objc_msgSend_36Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_36 = __objc_msgSend_36Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_URLWithDataRepresentation_relativeToURL_1 =
      _registerName1("URLWithDataRepresentation:relativeToURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_37(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_37(
      obj,
      sel,
      data,
      baseURL,
    );
  }

  late final __objc_msgSend_37Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_37 = __objc_msgSend_37Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initAbsoluteURLWithDataRepresentation_relativeToURL_1 =
      _registerName1("initAbsoluteURLWithDataRepresentation:relativeToURL:");
  late final _sel_absoluteURLWithDataRepresentation_relativeToURL_1 =
      _registerName1("absoluteURLWithDataRepresentation:relativeToURL:");
  late final _sel_dataRepresentation1 = _registerName1("dataRepresentation");
  ffi.Pointer<ObjCObject> _objc_msgSend_38(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_38(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_38Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_38 = __objc_msgSend_38Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_absoluteString1 = _registerName1("absoluteString");
  late final _sel_relativeString1 = _registerName1("relativeString");
  late final _sel_baseURL1 = _registerName1("baseURL");
  ffi.Pointer<ObjCObject> _objc_msgSend_39(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_39(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_39Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_39 = __objc_msgSend_39Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_absoluteURL1 = _registerName1("absoluteURL");
  late final _sel_scheme1 = _registerName1("scheme");
  late final _sel_resourceSpecifier1 = _registerName1("resourceSpecifier");
  late final _sel_host1 = _registerName1("host");
  late final _class_NSNumber1 = _getClass1("NSNumber");
  late final _class_NSValue1 = _getClass1("NSValue");
  late final _sel_getValue_size_1 = _registerName1("getValue:size:");
  late final _sel_objCType1 = _registerName1("objCType");
  ffi.Pointer<ffi.Char> _objc_msgSend_40(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_40(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_40Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_40 = __objc_msgSend_40Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_initWithBytes_objCType_1 =
      _registerName1("initWithBytes:objCType:");
  instancetype _objc_msgSend_41(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> value,
    ffi.Pointer<ffi.Char> type,
  ) {
    return __objc_msgSend_41(
      obj,
      sel,
      value,
      type,
    );
  }

  late final __objc_msgSend_41Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>>('objc_msgSend');
  late final __objc_msgSend_41 = __objc_msgSend_41Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>();

  late final _sel_initWithChar_1 = _registerName1("initWithChar:");
  ffi.Pointer<ObjCObject> _objc_msgSend_42(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_42(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_42Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Char)>>('objc_msgSend');
  late final __objc_msgSend_42 = __objc_msgSend_42Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithUnsignedChar_1 =
      _registerName1("initWithUnsignedChar:");
  ffi.Pointer<ObjCObject> _objc_msgSend_43(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_43(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_43Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedChar)>>('objc_msgSend');
  late final __objc_msgSend_43 = __objc_msgSend_43Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithShort_1 = _registerName1("initWithShort:");
  ffi.Pointer<ObjCObject> _objc_msgSend_44(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_44(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_44Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Short)>>('objc_msgSend');
  late final __objc_msgSend_44 = __objc_msgSend_44Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithUnsignedShort_1 =
      _registerName1("initWithUnsignedShort:");
  ffi.Pointer<ObjCObject> _objc_msgSend_45(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_45(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_45Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedShort)>>('objc_msgSend');
  late final __objc_msgSend_45 = __objc_msgSend_45Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithInt_1 = _registerName1("initWithInt:");
  ffi.Pointer<ObjCObject> _objc_msgSend_46(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_46(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_46Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Int)>>('objc_msgSend');
  late final __objc_msgSend_46 = __objc_msgSend_46Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithUnsignedInt_1 =
      _registerName1("initWithUnsignedInt:");
  ffi.Pointer<ObjCObject> _objc_msgSend_47(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_47(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_47Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedInt)>>('objc_msgSend');
  late final __objc_msgSend_47 = __objc_msgSend_47Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithLong_1 = _registerName1("initWithLong:");
  ffi.Pointer<ObjCObject> _objc_msgSend_48(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_48(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Long)>>('objc_msgSend');
  late final __objc_msgSend_48 = __objc_msgSend_48Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithUnsignedLong_1 =
      _registerName1("initWithUnsignedLong:");
  ffi.Pointer<ObjCObject> _objc_msgSend_49(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_49(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_49Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLong)>>('objc_msgSend');
  late final __objc_msgSend_49 = __objc_msgSend_49Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithLongLong_1 = _registerName1("initWithLongLong:");
  ffi.Pointer<ObjCObject> _objc_msgSend_50(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_50(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_50Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.LongLong)>>('objc_msgSend');
  late final __objc_msgSend_50 = __objc_msgSend_50Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithUnsignedLongLong_1 =
      _registerName1("initWithUnsignedLongLong:");
  ffi.Pointer<ObjCObject> _objc_msgSend_51(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_51(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_51Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.UnsignedLongLong)>>('objc_msgSend');
  late final __objc_msgSend_51 = __objc_msgSend_51Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithFloat_1 = _registerName1("initWithFloat:");
  ffi.Pointer<ObjCObject> _objc_msgSend_52(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    double value,
  ) {
    return __objc_msgSend_52(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_52Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Float)>>('objc_msgSend');
  late final __objc_msgSend_52 = __objc_msgSend_52Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, double)>();

  late final _sel_initWithDouble_1 = _registerName1("initWithDouble:");
  ffi.Pointer<ObjCObject> _objc_msgSend_53(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    double value,
  ) {
    return __objc_msgSend_53(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_53Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Double)>>('objc_msgSend');
  late final __objc_msgSend_53 = __objc_msgSend_53Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, double)>();

  late final _sel_initWithBool_1 = _registerName1("initWithBool:");
  ffi.Pointer<ObjCObject> _objc_msgSend_54(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    bool value,
  ) {
    return __objc_msgSend_54(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_54Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_54 = __objc_msgSend_54Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, bool)>();

  late final _sel_initWithInteger_1 = _registerName1("initWithInteger:");
  late final _sel_initWithUnsignedInteger_1 =
      _registerName1("initWithUnsignedInteger:");
  late final _sel_charValue1 = _registerName1("charValue");
  int _objc_msgSend_55(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_55(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_55Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Char Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_55 = __objc_msgSend_55Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_unsignedCharValue1 = _registerName1("unsignedCharValue");
  int _objc_msgSend_56(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_56(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_56Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedChar Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_56 = __objc_msgSend_56Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_shortValue1 = _registerName1("shortValue");
  int _objc_msgSend_57(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_57(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_57Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Short Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_57 = __objc_msgSend_57Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_unsignedShortValue1 = _registerName1("unsignedShortValue");
  int _objc_msgSend_58(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_58(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_58Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedShort Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_58 = __objc_msgSend_58Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_intValue1 = _registerName1("intValue");
  int _objc_msgSend_59(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_59(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_59Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_59 = __objc_msgSend_59Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_unsignedIntValue1 = _registerName1("unsignedIntValue");
  int _objc_msgSend_60(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_60(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_60Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_60 = __objc_msgSend_60Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_longValue1 = _registerName1("longValue");
  int _objc_msgSend_61(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_61(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_61Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_61 = __objc_msgSend_61Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_unsignedLongValue1 = _registerName1("unsignedLongValue");
  late final _sel_longLongValue1 = _registerName1("longLongValue");
  int _objc_msgSend_62(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_62(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_62Ptr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_62 = __objc_msgSend_62Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_unsignedLongLongValue1 =
      _registerName1("unsignedLongLongValue");
  int _objc_msgSend_63(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_63(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_63Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_63 = __objc_msgSend_63Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_floatValue1 = _registerName1("floatValue");
  double _objc_msgSend_64(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_64(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_64 = __objc_msgSend_64Ptr.asFunction<
      double Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_doubleValue1 = _registerName1("doubleValue");
  double _objc_msgSend_65(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_65(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_65Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_65 = __objc_msgSend_65Ptr.asFunction<
      double Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_boolValue1 = _registerName1("boolValue");
  late final _sel_integerValue1 = _registerName1("integerValue");
  late final _sel_unsignedIntegerValue1 =
      _registerName1("unsignedIntegerValue");
  late final _sel_stringValue1 = _registerName1("stringValue");
  late final _sel_compare_1 = _registerName1("compare:");
  int _objc_msgSend_66(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> otherNumber,
  ) {
    return __objc_msgSend_66(
      obj,
      sel,
      otherNumber,
    );
  }

  late final __objc_msgSend_66Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_66 = __objc_msgSend_66Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_isEqualToNumber_1 = _registerName1("isEqualToNumber:");
  bool _objc_msgSend_67(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> number,
  ) {
    return __objc_msgSend_67(
      obj,
      sel,
      number,
    );
  }

  late final __objc_msgSend_67Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_67 = __objc_msgSend_67Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_descriptionWithLocale_1 =
      _registerName1("descriptionWithLocale:");
  ffi.Pointer<ObjCObject> _objc_msgSend_68(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> locale,
  ) {
    return __objc_msgSend_68(
      obj,
      sel,
      locale,
    );
  }

  late final __objc_msgSend_68Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_68 = __objc_msgSend_68Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_port1 = _registerName1("port");
  ffi.Pointer<ObjCObject> _objc_msgSend_69(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_69(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_69Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_69 = __objc_msgSend_69Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_user1 = _registerName1("user");
  late final _sel_password1 = _registerName1("password");
  late final _sel_path1 = _registerName1("path");
  late final _sel_fragment1 = _registerName1("fragment");
  late final _sel_parameterString1 = _registerName1("parameterString");
  late final _sel_query1 = _registerName1("query");
  late final _sel_relativePath1 = _registerName1("relativePath");
  late final _sel_hasDirectoryPath1 = _registerName1("hasDirectoryPath");
  late final _sel_getFileSystemRepresentation_maxLength_1 =
      _registerName1("getFileSystemRepresentation:maxLength:");
  bool _objc_msgSend_70(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> buffer,
    int maxBufferLength,
  ) {
    return __objc_msgSend_70(
      obj,
      sel,
      buffer,
      maxBufferLength,
    );
  }

  late final __objc_msgSend_70Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>, NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_70 = __objc_msgSend_70Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Char>, int)>();

  late final _sel_fileSystemRepresentation1 =
      _registerName1("fileSystemRepresentation");
  late final _sel_isFileURL1 = _registerName1("isFileURL");
  late final _sel_standardizedURL1 = _registerName1("standardizedURL");
  late final _class_NSError1 = _getClass1("NSError");
  late final _class_NSDictionary1 = _getClass1("NSDictionary");
  late final _sel_count1 = _registerName1("count");
  late final _sel_objectForKey_1 = _registerName1("objectForKey:");
  ffi.Pointer<ObjCObject> _objc_msgSend_71(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> aKey,
  ) {
    return __objc_msgSend_71(
      obj,
      sel,
      aKey,
    );
  }

  late final __objc_msgSend_71Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_71 = __objc_msgSend_71Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_allKeys1 = _registerName1("allKeys");
  ffi.Pointer<ObjCObject> _objc_msgSend_72(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_72(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_72Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_72 = __objc_msgSend_72Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_allKeysForObject_1 = _registerName1("allKeysForObject:");
  ffi.Pointer<ObjCObject> _objc_msgSend_73(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anObject,
  ) {
    return __objc_msgSend_73(
      obj,
      sel,
      anObject,
    );
  }

  late final __objc_msgSend_73Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_73 = __objc_msgSend_73Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_allValues1 = _registerName1("allValues");
  late final _sel_descriptionInStringsFileFormat1 =
      _registerName1("descriptionInStringsFileFormat");
  late final _sel_descriptionWithLocale_indent_1 =
      _registerName1("descriptionWithLocale:indent:");
  ffi.Pointer<ObjCObject> _objc_msgSend_74(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> locale,
    int level,
  ) {
    return __objc_msgSend_74(
      obj,
      sel,
      locale,
      level,
    );
  }

  late final __objc_msgSend_74Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_74 = __objc_msgSend_74Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, int)>();

  late final _sel_isEqualToDictionary_1 =
      _registerName1("isEqualToDictionary:");
  bool _objc_msgSend_75(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> otherDictionary,
  ) {
    return __objc_msgSend_75(
      obj,
      sel,
      otherDictionary,
    );
  }

  late final __objc_msgSend_75Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_75 = __objc_msgSend_75Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_getObjects_andKeys_1 = _registerName1("getObjects:andKeys:");
  void _objc_msgSend_76(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Pointer<ObjCObject>> objects,
    ffi.Pointer<ffi.Pointer<ObjCObject>> keys,
  ) {
    return __objc_msgSend_76(
      obj,
      sel,
      objects,
      keys,
    );
  }

  late final __objc_msgSend_76Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_76 = __objc_msgSend_76Ptr.asFunction<
      void Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_dictionaryWithContentsOfFile_1 =
      _registerName1("dictionaryWithContentsOfFile:");
  ffi.Pointer<ObjCObject> _objc_msgSend_77(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_77(
      obj,
      sel,
      path,
    );
  }

  late final __objc_msgSend_77Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_77 = __objc_msgSend_77Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_dictionaryWithContentsOfURL_1 =
      _registerName1("dictionaryWithContentsOfURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_78(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
  ) {
    return __objc_msgSend_78(
      obj,
      sel,
      url,
    );
  }

  late final __objc_msgSend_78Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_78 = __objc_msgSend_78Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithContentsOfFile_1 =
      _registerName1("initWithContentsOfFile:");
  late final _sel_initWithContentsOfURL_1 =
      _registerName1("initWithContentsOfURL:");
  late final _sel_writeToURL_atomically_1 =
      _registerName1("writeToURL:atomically:");
  bool _objc_msgSend_79(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    bool atomically,
  ) {
    return __objc_msgSend_79(
      obj,
      sel,
      url,
      atomically,
    );
  }

  late final __objc_msgSend_79Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_79 = __objc_msgSend_79Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_dictionary1 = _registerName1("dictionary");
  late final _sel_dictionaryWithObject_forKey_1 =
      _registerName1("dictionaryWithObject:forKey:");
  instancetype _objc_msgSend_80(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> object,
    ffi.Pointer<ObjCObject> key,
  ) {
    return __objc_msgSend_80(
      obj,
      sel,
      object,
      key,
    );
  }

  late final __objc_msgSend_80Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_80 = __objc_msgSend_80Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_dictionaryWithObjects_forKeys_count_1 =
      _registerName1("dictionaryWithObjects:forKeys:count:");
  instancetype _objc_msgSend_81(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Pointer<ObjCObject>> objects,
    ffi.Pointer<ffi.Pointer<ObjCObject>> keys,
    int cnt,
  ) {
    return __objc_msgSend_81(
      obj,
      sel,
      objects,
      keys,
      cnt,
    );
  }

  late final __objc_msgSend_81Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>,
              NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_81 = __objc_msgSend_81Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>,
          int)>();

  late final _sel_dictionaryWithObjectsAndKeys_1 =
      _registerName1("dictionaryWithObjectsAndKeys:");
  late final _sel_dictionaryWithDictionary_1 =
      _registerName1("dictionaryWithDictionary:");
  instancetype _objc_msgSend_82(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> dict,
  ) {
    return __objc_msgSend_82(
      obj,
      sel,
      dict,
    );
  }

  late final __objc_msgSend_82Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_82 = __objc_msgSend_82Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_dictionaryWithObjects_forKeys_1 =
      _registerName1("dictionaryWithObjects:forKeys:");
  instancetype _objc_msgSend_83(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> objects,
    ffi.Pointer<ObjCObject> keys,
  ) {
    return __objc_msgSend_83(
      obj,
      sel,
      objects,
      keys,
    );
  }

  late final __objc_msgSend_83Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_83 = __objc_msgSend_83Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithObjectsAndKeys_1 =
      _registerName1("initWithObjectsAndKeys:");
  late final _sel_initWithDictionary_1 = _registerName1("initWithDictionary:");
  late final _sel_initWithDictionary_copyItems_1 =
      _registerName1("initWithDictionary:copyItems:");
  instancetype _objc_msgSend_84(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> otherDictionary,
    bool flag,
  ) {
    return __objc_msgSend_84(
      obj,
      sel,
      otherDictionary,
      flag,
    );
  }

  late final __objc_msgSend_84Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_84 = __objc_msgSend_84Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_initWithObjects_forKeys_1 =
      _registerName1("initWithObjects:forKeys:");
  late final _sel_initWithContentsOfURL_error_1 =
      _registerName1("initWithContentsOfURL:error:");
  ffi.Pointer<ObjCObject> _objc_msgSend_85(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_85(
      obj,
      sel,
      url,
      error,
    );
  }

  late final __objc_msgSend_85Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_85 = __objc_msgSend_85Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_dictionaryWithContentsOfURL_error_1 =
      _registerName1("dictionaryWithContentsOfURL:error:");
  late final _sel_sharedKeySetForKeys_1 =
      _registerName1("sharedKeySetForKeys:");
  ffi.Pointer<ObjCObject> _objc_msgSend_86(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> keys,
  ) {
    return __objc_msgSend_86(
      obj,
      sel,
      keys,
    );
  }

  late final __objc_msgSend_86Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_86 = __objc_msgSend_86Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_countByEnumeratingWithState_objects_count_1 =
      _registerName1("countByEnumeratingWithState:objects:count:");
  int _objc_msgSend_87(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<NSFastEnumerationState> state,
    ffi.Pointer<ffi.Pointer<ObjCObject>> buffer,
    int len,
  ) {
    return __objc_msgSend_87(
      obj,
      sel,
      state,
      buffer,
      len,
    );
  }

  late final __objc_msgSend_87Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<NSFastEnumerationState>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>,
              NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_87 = __objc_msgSend_87Ptr.asFunction<
      int Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<NSFastEnumerationState>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>,
          int)>();

  late final _sel_initWithDomain_code_userInfo_1 =
      _registerName1("initWithDomain:code:userInfo:");
  instancetype _objc_msgSend_88(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSErrorDomain domain,
    int code,
    ffi.Pointer<ObjCObject> dict,
  ) {
    return __objc_msgSend_88(
      obj,
      sel,
      domain,
      code,
      dict,
    );
  }

  late final __objc_msgSend_88Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              NSErrorDomain,
              NSInteger,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_88 = __objc_msgSend_88Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          NSErrorDomain, int, ffi.Pointer<ObjCObject>)>();

  late final _sel_errorWithDomain_code_userInfo_1 =
      _registerName1("errorWithDomain:code:userInfo:");
  late final _sel_domain1 = _registerName1("domain");
  late final _sel_code1 = _registerName1("code");
  late final _sel_userInfo1 = _registerName1("userInfo");
  ffi.Pointer<ObjCObject> _objc_msgSend_89(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_89(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_89Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_89 = __objc_msgSend_89Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_localizedDescription1 =
      _registerName1("localizedDescription");
  late final _sel_localizedFailureReason1 =
      _registerName1("localizedFailureReason");
  late final _sel_localizedRecoverySuggestion1 =
      _registerName1("localizedRecoverySuggestion");
  late final _sel_localizedRecoveryOptions1 =
      _registerName1("localizedRecoveryOptions");
  late final _sel_recoveryAttempter1 = _registerName1("recoveryAttempter");
  late final _sel_helpAnchor1 = _registerName1("helpAnchor");
  late final _sel_underlyingErrors1 = _registerName1("underlyingErrors");
  ffi.Pointer<_ObjCBlockDesc> _newBlockDesc1() {
    final d =
        pkg_ffi.calloc.allocate<_ObjCBlockDesc>(ffi.sizeOf<_ObjCBlockDesc>());
    d.ref.size = ffi.sizeOf<_ObjCBlock>();
    return d;
  }

  late final _objc_block_desc1 = _newBlockDesc1();
  late final _objc_concrete_global_block1 =
      _lookup<ffi.Void>('_NSConcreteGlobalBlock');
  ffi.Pointer<_ObjCBlock> _newBlock1(
      ffi.Pointer<ffi.Void> invoke, ffi.Pointer<ffi.Void> target) {
    final b = pkg_ffi.calloc.allocate<_ObjCBlock>(ffi.sizeOf<_ObjCBlock>());
    b.ref.isa = _objc_concrete_global_block1;
    b.ref.invoke = invoke;
    b.ref.target = target;
    b.ref.descriptor = _objc_block_desc1;
    return b;
  }

  late final _sel_setUserInfoValueProviderForDomain_provider_1 =
      _registerName1("setUserInfoValueProviderForDomain:provider:");
  void _objc_msgSend_90(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSErrorDomain errorDomain,
    ffi.Pointer<_ObjCBlock> provider,
  ) {
    return __objc_msgSend_90(
      obj,
      sel,
      errorDomain,
      provider,
    );
  }

  late final __objc_msgSend_90Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSErrorDomain, ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_90 = __objc_msgSend_90Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          NSErrorDomain, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_userInfoValueProviderForDomain_1 =
      _registerName1("userInfoValueProviderForDomain:");
  ffi.Pointer<_ObjCBlock> _objc_msgSend_91(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> err,
    NSErrorUserInfoKey userInfoKey,
    NSErrorDomain errorDomain,
  ) {
    return __objc_msgSend_91(
      obj,
      sel,
      err,
      userInfoKey,
      errorDomain,
    );
  }

  late final __objc_msgSend_91Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<_ObjCBlock> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              NSErrorUserInfoKey,
              NSErrorDomain)>>('objc_msgSend');
  late final __objc_msgSend_91 = __objc_msgSend_91Ptr.asFunction<
      ffi.Pointer<_ObjCBlock> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          NSErrorUserInfoKey,
          NSErrorDomain)>();

  late final _sel_checkResourceIsReachableAndReturnError_1 =
      _registerName1("checkResourceIsReachableAndReturnError:");
  bool _objc_msgSend_92(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_92(
      obj,
      sel,
      error,
    );
  }

  late final __objc_msgSend_92Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_92 = __objc_msgSend_92Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_isFileReferenceURL1 = _registerName1("isFileReferenceURL");
  late final _sel_fileReferenceURL1 = _registerName1("fileReferenceURL");
  late final _sel_filePathURL1 = _registerName1("filePathURL");
  late final _sel_getResourceValue_forKey_error_1 =
      _registerName1("getResourceValue:forKey:error:");
  bool _objc_msgSend_93(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Pointer<ObjCObject>> value,
    NSURLResourceKey key,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_93(
      obj,
      sel,
      value,
      key,
      error,
    );
  }

  late final __objc_msgSend_93Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>,
              NSURLResourceKey,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_93 = __objc_msgSend_93Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>,
          NSURLResourceKey,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_resourceValuesForKeys_error_1 =
      _registerName1("resourceValuesForKeys:error:");
  ffi.Pointer<ObjCObject> _objc_msgSend_94(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> keys,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_94(
      obj,
      sel,
      keys,
      error,
    );
  }

  late final __objc_msgSend_94Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_94 = __objc_msgSend_94Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_setResourceValue_forKey_error_1 =
      _registerName1("setResourceValue:forKey:error:");
  bool _objc_msgSend_95(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
    NSURLResourceKey key,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_95(
      obj,
      sel,
      value,
      key,
      error,
    );
  }

  late final __objc_msgSend_95Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              NSURLResourceKey,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_95 = __objc_msgSend_95Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          NSURLResourceKey,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_setResourceValues_error_1 =
      _registerName1("setResourceValues:error:");
  bool _objc_msgSend_96(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> keyedValues,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_96(
      obj,
      sel,
      keyedValues,
      error,
    );
  }

  late final __objc_msgSend_96Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_96 = __objc_msgSend_96Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_removeCachedResourceValueForKey_1 =
      _registerName1("removeCachedResourceValueForKey:");
  void _objc_msgSend_97(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSURLResourceKey key,
  ) {
    return __objc_msgSend_97(
      obj,
      sel,
      key,
    );
  }

  late final __objc_msgSend_97Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSURLResourceKey)>>('objc_msgSend');
  late final __objc_msgSend_97 = __objc_msgSend_97Ptr.asFunction<
      void Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSURLResourceKey)>();

  late final _sel_removeAllCachedResourceValues1 =
      _registerName1("removeAllCachedResourceValues");
  late final _sel_setTemporaryResourceValue_forKey_1 =
      _registerName1("setTemporaryResourceValue:forKey:");
  void _objc_msgSend_98(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
    NSURLResourceKey key,
  ) {
    return __objc_msgSend_98(
      obj,
      sel,
      value,
      key,
    );
  }

  late final __objc_msgSend_98Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, NSURLResourceKey)>>('objc_msgSend');
  late final __objc_msgSend_98 = __objc_msgSend_98Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, NSURLResourceKey)>();

  late final _sel_bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error_1 =
      _registerName1(
          "bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error:");
  ffi.Pointer<ObjCObject> _objc_msgSend_99(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int options,
    ffi.Pointer<ObjCObject> keys,
    ffi.Pointer<ObjCObject> relativeURL,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_99(
      obj,
      sel,
      options,
      keys,
      relativeURL,
      error,
    );
  }

  late final __objc_msgSend_99Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Int32,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_99 = __objc_msgSend_99Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          int,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_1 =
      _registerName1(
          "initByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:");
  instancetype _objc_msgSend_100(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> bookmarkData,
    int options,
    ffi.Pointer<ObjCObject> relativeURL,
    ffi.Pointer<ffi.Bool> isStale,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_100(
      obj,
      sel,
      bookmarkData,
      options,
      relativeURL,
      isStale,
      error,
    );
  }

  late final __objc_msgSend_100Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Bool>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_100 = __objc_msgSend_100Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Bool>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_1 =
      _registerName1(
          "URLByResolvingBookmarkData:options:relativeToURL:bookmarkDataIsStale:error:");
  late final _sel_resourceValuesForKeys_fromBookmarkData_1 =
      _registerName1("resourceValuesForKeys:fromBookmarkData:");
  ffi.Pointer<ObjCObject> _objc_msgSend_101(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> keys,
    ffi.Pointer<ObjCObject> bookmarkData,
  ) {
    return __objc_msgSend_101(
      obj,
      sel,
      keys,
      bookmarkData,
    );
  }

  late final __objc_msgSend_101Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_101 = __objc_msgSend_101Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_writeBookmarkData_toURL_options_error_1 =
      _registerName1("writeBookmarkData:toURL:options:error:");
  bool _objc_msgSend_102(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> bookmarkData,
    ffi.Pointer<ObjCObject> bookmarkFileURL,
    int options,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_102(
      obj,
      sel,
      bookmarkData,
      bookmarkFileURL,
      options,
      error,
    );
  }

  late final __objc_msgSend_102Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              NSURLBookmarkFileCreationOptions,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_102 = __objc_msgSend_102Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_bookmarkDataWithContentsOfURL_error_1 =
      _registerName1("bookmarkDataWithContentsOfURL:error:");
  ffi.Pointer<ObjCObject> _objc_msgSend_103(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> bookmarkFileURL,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_103(
      obj,
      sel,
      bookmarkFileURL,
      error,
    );
  }

  late final __objc_msgSend_103Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_103 = __objc_msgSend_103Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_URLByResolvingAliasFileAtURL_options_error_1 =
      _registerName1("URLByResolvingAliasFileAtURL:options:error:");
  instancetype _objc_msgSend_104(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    int options,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_104(
      obj,
      sel,
      url,
      options,
      error,
    );
  }

  late final __objc_msgSend_104Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_104 = __objc_msgSend_104Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_startAccessingSecurityScopedResource1 =
      _registerName1("startAccessingSecurityScopedResource");
  late final _sel_stopAccessingSecurityScopedResource1 =
      _registerName1("stopAccessingSecurityScopedResource");
  late final _sel_getPromisedItemResourceValue_forKey_error_1 =
      _registerName1("getPromisedItemResourceValue:forKey:error:");
  late final _sel_promisedItemResourceValuesForKeys_error_1 =
      _registerName1("promisedItemResourceValuesForKeys:error:");
  late final _sel_checkPromisedItemIsReachableAndReturnError_1 =
      _registerName1("checkPromisedItemIsReachableAndReturnError:");
  late final _sel_fileURLWithPathComponents_1 =
      _registerName1("fileURLWithPathComponents:");
  ffi.Pointer<ObjCObject> _objc_msgSend_105(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> components,
  ) {
    return __objc_msgSend_105(
      obj,
      sel,
      components,
    );
  }

  late final __objc_msgSend_105Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_105 = __objc_msgSend_105Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_pathComponents1 = _registerName1("pathComponents");
  late final _sel_lastPathComponent1 = _registerName1("lastPathComponent");
  late final _sel_pathExtension1 = _registerName1("pathExtension");
  late final _sel_URLByAppendingPathComponent_1 =
      _registerName1("URLByAppendingPathComponent:");
  late final _sel_URLByAppendingPathComponent_isDirectory_1 =
      _registerName1("URLByAppendingPathComponent:isDirectory:");
  late final _sel_URLByDeletingLastPathComponent1 =
      _registerName1("URLByDeletingLastPathComponent");
  late final _sel_URLByAppendingPathExtension_1 =
      _registerName1("URLByAppendingPathExtension:");
  late final _sel_URLByDeletingPathExtension1 =
      _registerName1("URLByDeletingPathExtension");
  late final _sel_URLByStandardizingPath1 =
      _registerName1("URLByStandardizingPath");
  late final _sel_URLByResolvingSymlinksInPath1 =
      _registerName1("URLByResolvingSymlinksInPath");
  late final _sel_resourceDataUsingCache_1 =
      _registerName1("resourceDataUsingCache:");
  ffi.Pointer<ObjCObject> _objc_msgSend_106(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    bool shouldUseCache,
  ) {
    return __objc_msgSend_106(
      obj,
      sel,
      shouldUseCache,
    );
  }

  late final __objc_msgSend_106Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_106 = __objc_msgSend_106Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, bool)>();

  late final _sel_loadResourceDataNotifyingClient_usingCache_1 =
      _registerName1("loadResourceDataNotifyingClient:usingCache:");
  void _objc_msgSend_107(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> client,
    bool shouldUseCache,
  ) {
    return __objc_msgSend_107(
      obj,
      sel,
      client,
      shouldUseCache,
    );
  }

  late final __objc_msgSend_107Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_107 = __objc_msgSend_107Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_propertyForKey_1 = _registerName1("propertyForKey:");
  late final _sel_setResourceData_1 = _registerName1("setResourceData:");
  late final _sel_setProperty_forKey_1 = _registerName1("setProperty:forKey:");
  bool _objc_msgSend_108(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> property,
    ffi.Pointer<ObjCObject> propertyKey,
  ) {
    return __objc_msgSend_108(
      obj,
      sel,
      property,
      propertyKey,
    );
  }

  late final __objc_msgSend_108Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_108 = __objc_msgSend_108Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSURLHandle1 = _getClass1("NSURLHandle");
  late final _sel_registerURLHandleClass_1 =
      _registerName1("registerURLHandleClass:");
  void _objc_msgSend_109(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anURLHandleSubclass,
  ) {
    return __objc_msgSend_109(
      obj,
      sel,
      anURLHandleSubclass,
    );
  }

  late final __objc_msgSend_109Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_109 = __objc_msgSend_109Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_URLHandleClassForURL_1 =
      _registerName1("URLHandleClassForURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_110(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anURL,
  ) {
    return __objc_msgSend_110(
      obj,
      sel,
      anURL,
    );
  }

  late final __objc_msgSend_110Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_110 = __objc_msgSend_110Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_status1 = _registerName1("status");
  int _objc_msgSend_111(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_111(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_111Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_111 = __objc_msgSend_111Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_failureReason1 = _registerName1("failureReason");
  late final _sel_addClient_1 = _registerName1("addClient:");
  late final _sel_removeClient_1 = _registerName1("removeClient:");
  late final _sel_loadInBackground1 = _registerName1("loadInBackground");
  late final _sel_cancelLoadInBackground1 =
      _registerName1("cancelLoadInBackground");
  late final _sel_resourceData1 = _registerName1("resourceData");
  late final _sel_availableResourceData1 =
      _registerName1("availableResourceData");
  late final _sel_expectedResourceDataSize1 =
      _registerName1("expectedResourceDataSize");
  late final _sel_flushCachedData1 = _registerName1("flushCachedData");
  late final _sel_backgroundLoadDidFailWithReason_1 =
      _registerName1("backgroundLoadDidFailWithReason:");
  late final _sel_didLoadBytes_loadComplete_1 =
      _registerName1("didLoadBytes:loadComplete:");
  void _objc_msgSend_112(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> newBytes,
    bool yorn,
  ) {
    return __objc_msgSend_112(
      obj,
      sel,
      newBytes,
      yorn,
    );
  }

  late final __objc_msgSend_112Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_112 = __objc_msgSend_112Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_canInitWithURL_1 = _registerName1("canInitWithURL:");
  bool _objc_msgSend_113(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anURL,
  ) {
    return __objc_msgSend_113(
      obj,
      sel,
      anURL,
    );
  }

  late final __objc_msgSend_113Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_113 = __objc_msgSend_113Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_cachedHandleForURL_1 = _registerName1("cachedHandleForURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_114(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anURL,
  ) {
    return __objc_msgSend_114(
      obj,
      sel,
      anURL,
    );
  }

  late final __objc_msgSend_114Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_114 = __objc_msgSend_114Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithURL_cached_1 = _registerName1("initWithURL:cached:");
  ffi.Pointer<ObjCObject> _objc_msgSend_115(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anURL,
    bool willCache,
  ) {
    return __objc_msgSend_115(
      obj,
      sel,
      anURL,
      willCache,
    );
  }

  late final __objc_msgSend_115Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_115 = __objc_msgSend_115Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_propertyForKeyIfAvailable_1 =
      _registerName1("propertyForKeyIfAvailable:");
  late final _sel_writeProperty_forKey_1 =
      _registerName1("writeProperty:forKey:");
  late final _sel_writeData_1 = _registerName1("writeData:");
  late final _sel_loadInForeground1 = _registerName1("loadInForeground");
  late final _sel_beginLoadInBackground1 =
      _registerName1("beginLoadInBackground");
  late final _sel_endLoadInBackground1 = _registerName1("endLoadInBackground");
  late final _sel_URLHandleUsingCache_1 =
      _registerName1("URLHandleUsingCache:");
  ffi.Pointer<ObjCObject> _objc_msgSend_116(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    bool shouldUseCache,
  ) {
    return __objc_msgSend_116(
      obj,
      sel,
      shouldUseCache,
    );
  }

  late final __objc_msgSend_116Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_116 = __objc_msgSend_116Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, bool)>();

  late final _sel_writeToFile_options_error_1 =
      _registerName1("writeToFile:options:error:");
  bool _objc_msgSend_117(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    int writeOptionsMask,
    ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr,
  ) {
    return __objc_msgSend_117(
      obj,
      sel,
      path,
      writeOptionsMask,
      errorPtr,
    );
  }

  late final __objc_msgSend_117Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_117 = __objc_msgSend_117Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_writeToURL_options_error_1 =
      _registerName1("writeToURL:options:error:");
  bool _objc_msgSend_118(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    int writeOptionsMask,
    ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr,
  ) {
    return __objc_msgSend_118(
      obj,
      sel,
      url,
      writeOptionsMask,
      errorPtr,
    );
  }

  late final __objc_msgSend_118Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_118 = __objc_msgSend_118Ptr.asFunction<
      bool Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_rangeOfData_options_range_1 =
      _registerName1("rangeOfData:options:range:");
  NSRange _objc_msgSend_119(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> dataToFind,
    int mask,
    NSRange searchRange,
  ) {
    return __objc_msgSend_119(
      obj,
      sel,
      dataToFind,
      mask,
      searchRange,
    );
  }

  late final __objc_msgSend_119Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Int32, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_119 = __objc_msgSend_119Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int, NSRange)>();

  late final _sel_enumerateByteRangesUsingBlock_1 =
      _registerName1("enumerateByteRangesUsingBlock:");
  void _objc_msgSend_120(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_120(
      obj,
      sel,
      block,
    );
  }

  late final __objc_msgSend_120Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_120 = __objc_msgSend_120Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_data1 = _registerName1("data");
  late final _sel_dataWithBytes_length_1 =
      _registerName1("dataWithBytes:length:");
  instancetype _objc_msgSend_121(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> bytes,
    int length,
  ) {
    return __objc_msgSend_121(
      obj,
      sel,
      bytes,
      length,
    );
  }

  late final __objc_msgSend_121Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>, NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_121 = __objc_msgSend_121Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, int)>();

  late final _sel_dataWithBytesNoCopy_length_1 =
      _registerName1("dataWithBytesNoCopy:length:");
  late final _sel_dataWithBytesNoCopy_length_freeWhenDone_1 =
      _registerName1("dataWithBytesNoCopy:length:freeWhenDone:");
  instancetype _objc_msgSend_122(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> bytes,
    int length,
    bool b,
  ) {
    return __objc_msgSend_122(
      obj,
      sel,
      bytes,
      length,
      b,
    );
  }

  late final __objc_msgSend_122Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>, NSUInteger, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_122 = __objc_msgSend_122Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, int, bool)>();

  late final _sel_dataWithContentsOfFile_options_error_1 =
      _registerName1("dataWithContentsOfFile:options:error:");
  instancetype _objc_msgSend_123(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
    int readOptionsMask,
    ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr,
  ) {
    return __objc_msgSend_123(
      obj,
      sel,
      path,
      readOptionsMask,
      errorPtr,
    );
  }

  late final __objc_msgSend_123Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_123 = __objc_msgSend_123Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_dataWithContentsOfURL_options_error_1 =
      _registerName1("dataWithContentsOfURL:options:error:");
  instancetype _objc_msgSend_124(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    int readOptionsMask,
    ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr,
  ) {
    return __objc_msgSend_124(
      obj,
      sel,
      url,
      readOptionsMask,
      errorPtr,
    );
  }

  late final __objc_msgSend_124Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_124 = __objc_msgSend_124Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_dataWithContentsOfFile_1 =
      _registerName1("dataWithContentsOfFile:");
  late final _sel_dataWithContentsOfURL_1 =
      _registerName1("dataWithContentsOfURL:");
  late final _sel_initWithBytes_length_1 =
      _registerName1("initWithBytes:length:");
  late final _sel_initWithBytesNoCopy_length_1 =
      _registerName1("initWithBytesNoCopy:length:");
  late final _sel_initWithBytesNoCopy_length_freeWhenDone_1 =
      _registerName1("initWithBytesNoCopy:length:freeWhenDone:");
  late final _sel_initWithBytesNoCopy_length_deallocator_1 =
      _registerName1("initWithBytesNoCopy:length:deallocator:");
  instancetype _objc_msgSend_125(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> bytes,
    int length,
    ffi.Pointer<_ObjCBlock> deallocator,
  ) {
    return __objc_msgSend_125(
      obj,
      sel,
      bytes,
      length,
      deallocator,
    );
  }

  late final __objc_msgSend_125Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>,
              NSUInteger,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_125 = __objc_msgSend_125Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_initWithContentsOfFile_options_error_1 =
      _registerName1("initWithContentsOfFile:options:error:");
  late final _sel_initWithContentsOfURL_options_error_1 =
      _registerName1("initWithContentsOfURL:options:error:");
  late final _sel_initWithData_1 = _registerName1("initWithData:");
  instancetype _objc_msgSend_126(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
  ) {
    return __objc_msgSend_126(
      obj,
      sel,
      data,
    );
  }

  late final __objc_msgSend_126Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_126 = __objc_msgSend_126Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_dataWithData_1 = _registerName1("dataWithData:");
  late final _sel_initWithBase64EncodedString_options_1 =
      _registerName1("initWithBase64EncodedString:options:");
  instancetype _objc_msgSend_127(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> base64String,
    int options,
  ) {
    return __objc_msgSend_127(
      obj,
      sel,
      base64String,
      options,
    );
  }

  late final __objc_msgSend_127Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_127 = __objc_msgSend_127Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  late final _sel_base64EncodedStringWithOptions_1 =
      _registerName1("base64EncodedStringWithOptions:");
  ffi.Pointer<ObjCObject> _objc_msgSend_128(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int options,
  ) {
    return __objc_msgSend_128(
      obj,
      sel,
      options,
    );
  }

  late final __objc_msgSend_128Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_128 = __objc_msgSend_128Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithBase64EncodedData_options_1 =
      _registerName1("initWithBase64EncodedData:options:");
  instancetype _objc_msgSend_129(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> base64Data,
    int options,
  ) {
    return __objc_msgSend_129(
      obj,
      sel,
      base64Data,
      options,
    );
  }

  late final __objc_msgSend_129Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_129 = __objc_msgSend_129Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  late final _sel_base64EncodedDataWithOptions_1 =
      _registerName1("base64EncodedDataWithOptions:");
  ffi.Pointer<ObjCObject> _objc_msgSend_130(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int options,
  ) {
    return __objc_msgSend_130(
      obj,
      sel,
      options,
    );
  }

  late final __objc_msgSend_130Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_130 = __objc_msgSend_130Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_decompressedDataUsingAlgorithm_error_1 =
      _registerName1("decompressedDataUsingAlgorithm:error:");
  instancetype _objc_msgSend_131(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int algorithm,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_131(
      obj,
      sel,
      algorithm,
      error,
    );
  }

  late final __objc_msgSend_131Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_131 = __objc_msgSend_131Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_compressedDataUsingAlgorithm_error_1 =
      _registerName1("compressedDataUsingAlgorithm:error:");
  late final _sel_getBytes_1 = _registerName1("getBytes:");
  void _objc_msgSend_132(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Void> buffer,
  ) {
    return __objc_msgSend_132(
      obj,
      sel,
      buffer,
    );
  }

  late final __objc_msgSend_132Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>)>>('objc_msgSend');
  late final __objc_msgSend_132 = __objc_msgSend_132Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>)>();

  late final _sel_dataWithContentsOfMappedFile_1 =
      _registerName1("dataWithContentsOfMappedFile:");
  late final _sel_initWithContentsOfMappedFile_1 =
      _registerName1("initWithContentsOfMappedFile:");
  late final _sel_initWithBase64Encoding_1 =
      _registerName1("initWithBase64Encoding:");
  late final _sel_base64Encoding1 = _registerName1("base64Encoding");
  late final _sel_characterSetWithBitmapRepresentation_1 =
      _registerName1("characterSetWithBitmapRepresentation:");
  ffi.Pointer<ObjCObject> _objc_msgSend_133(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
  ) {
    return __objc_msgSend_133(
      obj,
      sel,
      data,
    );
  }

  late final __objc_msgSend_133Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_133 = __objc_msgSend_133Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_characterSetWithContentsOfFile_1 =
      _registerName1("characterSetWithContentsOfFile:");
  late final _sel_characterIsMember_1 = _registerName1("characterIsMember:");
  bool _objc_msgSend_134(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int aCharacter,
  ) {
    return __objc_msgSend_134(
      obj,
      sel,
      aCharacter,
    );
  }

  late final __objc_msgSend_134Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              unichar)>>('objc_msgSend');
  late final __objc_msgSend_134 = __objc_msgSend_134Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_bitmapRepresentation1 =
      _registerName1("bitmapRepresentation");
  late final _sel_invertedSet1 = _registerName1("invertedSet");
  late final _sel_longCharacterIsMember_1 =
      _registerName1("longCharacterIsMember:");
  bool _objc_msgSend_135(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int theLongChar,
  ) {
    return __objc_msgSend_135(
      obj,
      sel,
      theLongChar,
    );
  }

  late final __objc_msgSend_135Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              UTF32Char)>>('objc_msgSend');
  late final __objc_msgSend_135 = __objc_msgSend_135Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_isSupersetOfSet_1 = _registerName1("isSupersetOfSet:");
  bool _objc_msgSend_136(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> theOtherSet,
  ) {
    return __objc_msgSend_136(
      obj,
      sel,
      theOtherSet,
    );
  }

  late final __objc_msgSend_136Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_136 = __objc_msgSend_136Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_hasMemberInPlane_1 = _registerName1("hasMemberInPlane:");
  bool _objc_msgSend_137(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int thePlane,
  ) {
    return __objc_msgSend_137(
      obj,
      sel,
      thePlane,
    );
  }

  late final __objc_msgSend_137Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Uint8)>>('objc_msgSend');
  late final __objc_msgSend_137 = __objc_msgSend_137Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_URLUserAllowedCharacterSet1 =
      _registerName1("URLUserAllowedCharacterSet");
  late final _sel_URLPasswordAllowedCharacterSet1 =
      _registerName1("URLPasswordAllowedCharacterSet");
  late final _sel_URLHostAllowedCharacterSet1 =
      _registerName1("URLHostAllowedCharacterSet");
  late final _sel_URLPathAllowedCharacterSet1 =
      _registerName1("URLPathAllowedCharacterSet");
  late final _sel_URLQueryAllowedCharacterSet1 =
      _registerName1("URLQueryAllowedCharacterSet");
  late final _sel_URLFragmentAllowedCharacterSet1 =
      _registerName1("URLFragmentAllowedCharacterSet");
  late final _sel_stringByAddingPercentEncodingWithAllowedCharacters_1 =
      _registerName1("stringByAddingPercentEncodingWithAllowedCharacters:");
  ffi.Pointer<ObjCObject> _objc_msgSend_138(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> allowedCharacters,
  ) {
    return __objc_msgSend_138(
      obj,
      sel,
      allowedCharacters,
    );
  }

  late final __objc_msgSend_138Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_138 = __objc_msgSend_138Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_stringByRemovingPercentEncoding1 =
      _registerName1("stringByRemovingPercentEncoding");
  late final _sel_stringByAddingPercentEscapesUsingEncoding_1 =
      _registerName1("stringByAddingPercentEscapesUsingEncoding:");
  ffi.Pointer<ObjCObject> _objc_msgSend_139(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int enc,
  ) {
    return __objc_msgSend_139(
      obj,
      sel,
      enc,
    );
  }

  late final __objc_msgSend_139Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, NSStringEncoding)>>('objc_msgSend');
  late final __objc_msgSend_139 = __objc_msgSend_139Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_stringByReplacingPercentEscapesUsingEncoding_1 =
      _registerName1("stringByReplacingPercentEscapesUsingEncoding:");
  late final _sel_stringWithCString_encoding_1 =
      _registerName1("stringWithCString:encoding:");
  ffi.Pointer<ObjCObject> _objc_msgSend_140(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Char> cString,
    int enc,
  ) {
    return __objc_msgSend_140(
      obj,
      sel,
      cString,
      enc,
    );
  }

  late final __objc_msgSend_140Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('objc_msgSend');
  late final __objc_msgSend_140 = __objc_msgSend_140Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ffi.Char>, int)>();

  late final _sel_UTF8String1 = _registerName1("UTF8String");
  late final _sel_debugDescription1 = _registerName1("debugDescription");
  late final _sel_URL_resourceDataDidBecomeAvailable_1 =
      _registerName1("URL:resourceDataDidBecomeAvailable:");
  void _objc_msgSend_141(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> sender,
    ffi.Pointer<ObjCObject> newBytes,
  ) {
    return __objc_msgSend_141(
      obj,
      sel,
      sender,
      newBytes,
    );
  }

  late final __objc_msgSend_141Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_141 = __objc_msgSend_141Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_URLResourceDidFinishLoading_1 =
      _registerName1("URLResourceDidFinishLoading:");
  void _objc_msgSend_142(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> sender,
  ) {
    return __objc_msgSend_142(
      obj,
      sel,
      sender,
    );
  }

  late final __objc_msgSend_142Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_142 = __objc_msgSend_142Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_URLResourceDidCancelLoading_1 =
      _registerName1("URLResourceDidCancelLoading:");
  late final _sel_URL_resourceDidFailLoadingWithReason_1 =
      _registerName1("URL:resourceDidFailLoadingWithReason:");
  void _objc_msgSend_143(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> sender,
    ffi.Pointer<ObjCObject> reason,
  ) {
    return __objc_msgSend_143(
      obj,
      sel,
      sender,
      reason,
    );
  }

  late final __objc_msgSend_143Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_143 = __objc_msgSend_143Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo_1 =
      _registerName1(
          "attemptRecoveryFromError:optionIndex:delegate:didRecoverSelector:contextInfo:");
  void _objc_msgSend_144(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> error,
    int recoveryOptionIndex,
    ffi.Pointer<ObjCObject> delegate,
    ffi.Pointer<ObjCSel> didRecoverSelector,
    ffi.Pointer<ffi.Void> contextInfo,
  ) {
    return __objc_msgSend_144(
      obj,
      sel,
      error,
      recoveryOptionIndex,
      delegate,
      didRecoverSelector,
      contextInfo,
    );
  }

  late final __objc_msgSend_144Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              NSUInteger,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Void>)>>('objc_msgSend');
  late final __objc_msgSend_144 = __objc_msgSend_144Ptr.asFunction<
      void Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Void>)>();

  late final _sel_attemptRecoveryFromError_optionIndex_1 =
      _registerName1("attemptRecoveryFromError:optionIndex:");
  bool _objc_msgSend_145(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> error,
    int recoveryOptionIndex,
  ) {
    return __objc_msgSend_145(
      obj,
      sel,
      error,
      recoveryOptionIndex,
    );
  }

  late final __objc_msgSend_145Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_145 = __objc_msgSend_145Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  late final _sel_objectAtIndex_1 = _registerName1("objectAtIndex:");
  ffi.Pointer<ObjCObject> _objc_msgSend_146(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int index,
  ) {
    return __objc_msgSend_146(
      obj,
      sel,
      index,
    );
  }

  late final __objc_msgSend_146Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_146 = __objc_msgSend_146Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_initWithObjects_count_1 =
      _registerName1("initWithObjects:count:");
  instancetype _objc_msgSend_147(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Pointer<ObjCObject>> objects,
    int cnt,
  ) {
    return __objc_msgSend_147(
      obj,
      sel,
      objects,
      cnt,
    );
  }

  late final __objc_msgSend_147Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>,
              NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_147 = __objc_msgSend_147Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>, int)>();

  late final _sel_arrayByAddingObject_1 =
      _registerName1("arrayByAddingObject:");
  late final _sel_arrayByAddingObjectsFromArray_1 =
      _registerName1("arrayByAddingObjectsFromArray:");
  ffi.Pointer<ObjCObject> _objc_msgSend_148(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> otherArray,
  ) {
    return __objc_msgSend_148(
      obj,
      sel,
      otherArray,
    );
  }

  late final __objc_msgSend_148Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_148 = __objc_msgSend_148Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_componentsJoinedByString_1 =
      _registerName1("componentsJoinedByString:");
  ffi.Pointer<ObjCObject> _objc_msgSend_149(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> separator,
  ) {
    return __objc_msgSend_149(
      obj,
      sel,
      separator,
    );
  }

  late final __objc_msgSend_149Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_149 = __objc_msgSend_149Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_containsObject_1 = _registerName1("containsObject:");
  late final _sel_firstObjectCommonWithArray_1 =
      _registerName1("firstObjectCommonWithArray:");
  late final _sel_getObjects_range_1 = _registerName1("getObjects:range:");
  void _objc_msgSend_150(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Pointer<ObjCObject>> objects,
    NSRange range,
  ) {
    return __objc_msgSend_150(
      obj,
      sel,
      objects,
      range,
    );
  }

  late final __objc_msgSend_150Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_150 = __objc_msgSend_150Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>, NSRange)>();

  late final _sel_indexOfObject_1 = _registerName1("indexOfObject:");
  int _objc_msgSend_151(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anObject,
  ) {
    return __objc_msgSend_151(
      obj,
      sel,
      anObject,
    );
  }

  late final __objc_msgSend_151Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_151 = __objc_msgSend_151Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_indexOfObject_inRange_1 =
      _registerName1("indexOfObject:inRange:");
  int _objc_msgSend_152(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anObject,
    NSRange range,
  ) {
    return __objc_msgSend_152(
      obj,
      sel,
      anObject,
      range,
    );
  }

  late final __objc_msgSend_152Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_152 = __objc_msgSend_152Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, NSRange)>();

  late final _sel_indexOfObjectIdenticalTo_1 =
      _registerName1("indexOfObjectIdenticalTo:");
  late final _sel_indexOfObjectIdenticalTo_inRange_1 =
      _registerName1("indexOfObjectIdenticalTo:inRange:");
  late final _sel_isEqualToArray_1 = _registerName1("isEqualToArray:");
  bool _objc_msgSend_153(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> otherArray,
  ) {
    return __objc_msgSend_153(
      obj,
      sel,
      otherArray,
    );
  }

  late final __objc_msgSend_153Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_153 = __objc_msgSend_153Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_firstObject1 = _registerName1("firstObject");
  late final _sel_lastObject1 = _registerName1("lastObject");
  late final _sel_array1 = _registerName1("array");
  late final _sel_arrayWithObject_1 = _registerName1("arrayWithObject:");
  late final _sel_arrayWithObjects_count_1 =
      _registerName1("arrayWithObjects:count:");
  late final _sel_arrayWithObjects_1 = _registerName1("arrayWithObjects:");
  late final _sel_arrayWithArray_1 = _registerName1("arrayWithArray:");
  late final _sel_initWithObjects_1 = _registerName1("initWithObjects:");
  late final _sel_initWithArray_1 = _registerName1("initWithArray:");
  late final _sel_initWithArray_copyItems_1 =
      _registerName1("initWithArray:copyItems:");
  instancetype _objc_msgSend_154(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> array,
    bool flag,
  ) {
    return __objc_msgSend_154(
      obj,
      sel,
      array,
      flag,
    );
  }

  late final __objc_msgSend_154Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_154 = __objc_msgSend_154Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  ffi.Pointer<ObjCObject> _objc_msgSend_155(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_155(
      obj,
      sel,
      url,
      error,
    );
  }

  late final __objc_msgSend_155Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_155 = __objc_msgSend_155Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_arrayWithContentsOfURL_error_1 =
      _registerName1("arrayWithContentsOfURL:error:");
  late final _sel_getObjects_1 = _registerName1("getObjects:");
  void _objc_msgSend_156(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ffi.Pointer<ObjCObject>> objects,
  ) {
    return __objc_msgSend_156(
      obj,
      sel,
      objects,
    );
  }

  late final __objc_msgSend_156Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_156 = __objc_msgSend_156Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_arrayWithContentsOfFile_1 =
      _registerName1("arrayWithContentsOfFile:");
  ffi.Pointer<ObjCObject> _objc_msgSend_157(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_157(
      obj,
      sel,
      path,
    );
  }

  late final __objc_msgSend_157Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_157 = __objc_msgSend_157Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_arrayWithContentsOfURL_1 =
      _registerName1("arrayWithContentsOfURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_158(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
  ) {
    return __objc_msgSend_158(
      obj,
      sel,
      url,
    );
  }

  late final __objc_msgSend_158Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_158 = __objc_msgSend_158Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSMutableArray1 = _getClass1("NSMutableArray");
  late final _sel_addObject_1 = _registerName1("addObject:");
  late final _sel_insertObject_atIndex_1 =
      _registerName1("insertObject:atIndex:");
  void _objc_msgSend_159(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anObject,
    int index,
  ) {
    return __objc_msgSend_159(
      obj,
      sel,
      anObject,
      index,
    );
  }

  late final __objc_msgSend_159Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_159 = __objc_msgSend_159Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  late final _sel_removeLastObject1 = _registerName1("removeLastObject");
  late final _sel_removeObjectAtIndex_1 =
      _registerName1("removeObjectAtIndex:");
  void _objc_msgSend_160(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int index,
  ) {
    return __objc_msgSend_160(
      obj,
      sel,
      index,
    );
  }

  late final __objc_msgSend_160Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_160 = __objc_msgSend_160Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_replaceObjectAtIndex_withObject_1 =
      _registerName1("replaceObjectAtIndex:withObject:");
  void _objc_msgSend_161(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int index,
    ffi.Pointer<ObjCObject> anObject,
  ) {
    return __objc_msgSend_161(
      obj,
      sel,
      index,
      anObject,
    );
  }

  late final __objc_msgSend_161Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSUInteger, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_161 = __objc_msgSend_161Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithCapacity_1 = _registerName1("initWithCapacity:");
  late final _sel_addObjectsFromArray_1 =
      _registerName1("addObjectsFromArray:");
  void _objc_msgSend_162(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> otherArray,
  ) {
    return __objc_msgSend_162(
      obj,
      sel,
      otherArray,
    );
  }

  late final __objc_msgSend_162Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_162 = __objc_msgSend_162Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_exchangeObjectAtIndex_withObjectAtIndex_1 =
      _registerName1("exchangeObjectAtIndex:withObjectAtIndex:");
  void _objc_msgSend_163(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int idx1,
    int idx2,
  ) {
    return __objc_msgSend_163(
      obj,
      sel,
      idx1,
      idx2,
    );
  }

  late final __objc_msgSend_163Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSUInteger, NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_163 = __objc_msgSend_163Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int, int)>();

  late final _sel_removeAllObjects1 = _registerName1("removeAllObjects");
  late final _sel_removeObject_inRange_1 =
      _registerName1("removeObject:inRange:");
  void _objc_msgSend_164(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anObject,
    NSRange range,
  ) {
    return __objc_msgSend_164(
      obj,
      sel,
      anObject,
      range,
    );
  }

  late final __objc_msgSend_164Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_164 = __objc_msgSend_164Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, NSRange)>();

  late final _sel_removeObject_1 = _registerName1("removeObject:");
  late final _sel_removeObjectIdenticalTo_inRange_1 =
      _registerName1("removeObjectIdenticalTo:inRange:");
  late final _sel_removeObjectIdenticalTo_1 =
      _registerName1("removeObjectIdenticalTo:");
  late final _sel_removeObjectsFromIndices_numIndices_1 =
      _registerName1("removeObjectsFromIndices:numIndices:");
  void _objc_msgSend_165(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<NSUInteger> indices,
    int cnt,
  ) {
    return __objc_msgSend_165(
      obj,
      sel,
      indices,
      cnt,
    );
  }

  late final __objc_msgSend_165Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<NSUInteger>, NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_165 = __objc_msgSend_165Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<NSUInteger>, int)>();

  late final _sel_removeObjectsInArray_1 =
      _registerName1("removeObjectsInArray:");
  late final _sel_removeObjectsInRange_1 =
      _registerName1("removeObjectsInRange:");
  void _objc_msgSend_166(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
  ) {
    return __objc_msgSend_166(
      obj,
      sel,
      range,
    );
  }

  late final __objc_msgSend_166Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange)>>('objc_msgSend');
  late final __objc_msgSend_166 = __objc_msgSend_166Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange)>();

  late final _sel_replaceObjectsInRange_withObjectsFromArray_range_1 =
      _registerName1("replaceObjectsInRange:withObjectsFromArray:range:");
  void _objc_msgSend_167(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    ffi.Pointer<ObjCObject> otherArray,
    NSRange otherRange,
  ) {
    return __objc_msgSend_167(
      obj,
      sel,
      range,
      otherArray,
      otherRange,
    );
  }

  late final __objc_msgSend_167Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange, ffi.Pointer<ObjCObject>, NSRange)>>('objc_msgSend');
  late final __objc_msgSend_167 = __objc_msgSend_167Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange,
          ffi.Pointer<ObjCObject>, NSRange)>();

  late final _sel_replaceObjectsInRange_withObjectsFromArray_1 =
      _registerName1("replaceObjectsInRange:withObjectsFromArray:");
  void _objc_msgSend_168(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    ffi.Pointer<ObjCObject> otherArray,
  ) {
    return __objc_msgSend_168(
      obj,
      sel,
      range,
      otherArray,
    );
  }

  late final __objc_msgSend_168Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_168 = __objc_msgSend_168Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_setArray_1 = _registerName1("setArray:");
  late final _sel_sortUsingFunction_context_1 =
      _registerName1("sortUsingFunction:context:");
  void _objc_msgSend_169(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<
            ffi.NativeFunction<
                NSInteger Function(ffi.Pointer<ObjCObject>,
                    ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Void>)>>
        compare,
    ffi.Pointer<ffi.Void> context,
  ) {
    return __objc_msgSend_169(
      obj,
      sel,
      compare,
      context,
    );
  }

  late final __objc_msgSend_169Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      NSInteger Function(ffi.Pointer<ObjCObject>,
                          ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Void>)>>('objc_msgSend');
  late final __objc_msgSend_169 = __objc_msgSend_169Ptr.asFunction<
      void Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<
              ffi.NativeFunction<
                  NSInteger Function(ffi.Pointer<ObjCObject>,
                      ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Void>)>>,
          ffi.Pointer<ffi.Void>)>();

  late final _sel_sortUsingSelector_1 = _registerName1("sortUsingSelector:");
  late final _class_NSIndexSet1 = _getClass1("NSIndexSet");
  late final _sel_indexSet1 = _registerName1("indexSet");
  late final _sel_indexSetWithIndex_1 = _registerName1("indexSetWithIndex:");
  late final _sel_indexSetWithIndexesInRange_1 =
      _registerName1("indexSetWithIndexesInRange:");
  instancetype _objc_msgSend_170(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
  ) {
    return __objc_msgSend_170(
      obj,
      sel,
      range,
    );
  }

  late final __objc_msgSend_170Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange)>>('objc_msgSend');
  late final __objc_msgSend_170 = __objc_msgSend_170Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange)>();

  late final _sel_initWithIndexesInRange_1 =
      _registerName1("initWithIndexesInRange:");
  late final _sel_initWithIndexSet_1 = _registerName1("initWithIndexSet:");
  instancetype _objc_msgSend_171(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> indexSet,
  ) {
    return __objc_msgSend_171(
      obj,
      sel,
      indexSet,
    );
  }

  late final __objc_msgSend_171Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_171 = __objc_msgSend_171Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithIndex_1 = _registerName1("initWithIndex:");
  late final _sel_isEqualToIndexSet_1 = _registerName1("isEqualToIndexSet:");
  bool _objc_msgSend_172(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> indexSet,
  ) {
    return __objc_msgSend_172(
      obj,
      sel,
      indexSet,
    );
  }

  late final __objc_msgSend_172Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_172 = __objc_msgSend_172Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_firstIndex1 = _registerName1("firstIndex");
  late final _sel_lastIndex1 = _registerName1("lastIndex");
  late final _sel_indexGreaterThanIndex_1 =
      _registerName1("indexGreaterThanIndex:");
  int _objc_msgSend_173(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_173(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_173Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_173 = __objc_msgSend_173Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_indexLessThanIndex_1 = _registerName1("indexLessThanIndex:");
  late final _sel_indexGreaterThanOrEqualToIndex_1 =
      _registerName1("indexGreaterThanOrEqualToIndex:");
  late final _sel_indexLessThanOrEqualToIndex_1 =
      _registerName1("indexLessThanOrEqualToIndex:");
  late final _sel_getIndexes_maxCount_inIndexRange_1 =
      _registerName1("getIndexes:maxCount:inIndexRange:");
  int _objc_msgSend_174(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<NSUInteger> indexBuffer,
    int bufferSize,
    NSRangePointer range,
  ) {
    return __objc_msgSend_174(
      obj,
      sel,
      indexBuffer,
      bufferSize,
      range,
    );
  }

  late final __objc_msgSend_174Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<NSUInteger>,
              NSUInteger,
              NSRangePointer)>>('objc_msgSend');
  late final __objc_msgSend_174 = __objc_msgSend_174Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<NSUInteger>, int, NSRangePointer)>();

  late final _sel_countOfIndexesInRange_1 =
      _registerName1("countOfIndexesInRange:");
  int _objc_msgSend_175(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
  ) {
    return __objc_msgSend_175(
      obj,
      sel,
      range,
    );
  }

  late final __objc_msgSend_175Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange)>>('objc_msgSend');
  late final __objc_msgSend_175 = __objc_msgSend_175Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange)>();

  late final _sel_containsIndex_1 = _registerName1("containsIndex:");
  bool _objc_msgSend_176(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_176(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_176Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_176 = __objc_msgSend_176Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_containsIndexesInRange_1 =
      _registerName1("containsIndexesInRange:");
  bool _objc_msgSend_177(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
  ) {
    return __objc_msgSend_177(
      obj,
      sel,
      range,
    );
  }

  late final __objc_msgSend_177Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange)>>('objc_msgSend');
  late final __objc_msgSend_177 = __objc_msgSend_177Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange)>();

  late final _sel_containsIndexes_1 = _registerName1("containsIndexes:");
  late final _sel_intersectsIndexesInRange_1 =
      _registerName1("intersectsIndexesInRange:");
  late final _sel_enumerateIndexesUsingBlock_1 =
      _registerName1("enumerateIndexesUsingBlock:");
  void _objc_msgSend_178(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_178(
      obj,
      sel,
      block,
    );
  }

  late final __objc_msgSend_178Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_178 = __objc_msgSend_178Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_enumerateIndexesWithOptions_usingBlock_1 =
      _registerName1("enumerateIndexesWithOptions:usingBlock:");
  void _objc_msgSend_179(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int opts,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_179(
      obj,
      sel,
      opts,
      block,
    );
  }

  late final __objc_msgSend_179Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32, ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_179 = __objc_msgSend_179Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_enumerateIndexesInRange_options_usingBlock_1 =
      _registerName1("enumerateIndexesInRange:options:usingBlock:");
  void _objc_msgSend_180(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    int opts,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_180(
      obj,
      sel,
      range,
      opts,
      block,
    );
  }

  late final __objc_msgSend_180Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange, ffi.Int32, ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_180 = __objc_msgSend_180Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange, int,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_indexPassingTest_1 = _registerName1("indexPassingTest:");
  int _objc_msgSend_181(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> predicate,
  ) {
    return __objc_msgSend_181(
      obj,
      sel,
      predicate,
    );
  }

  late final __objc_msgSend_181Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_181 = __objc_msgSend_181Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_indexWithOptions_passingTest_1 =
      _registerName1("indexWithOptions:passingTest:");
  int _objc_msgSend_182(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int opts,
    ffi.Pointer<_ObjCBlock> predicate,
  ) {
    return __objc_msgSend_182(
      obj,
      sel,
      opts,
      predicate,
    );
  }

  late final __objc_msgSend_182Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32, ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_182 = __objc_msgSend_182Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_indexInRange_options_passingTest_1 =
      _registerName1("indexInRange:options:passingTest:");
  int _objc_msgSend_183(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    int opts,
    ffi.Pointer<_ObjCBlock> predicate,
  ) {
    return __objc_msgSend_183(
      obj,
      sel,
      range,
      opts,
      predicate,
    );
  }

  late final __objc_msgSend_183Ptr = _lookup<
      ffi.NativeFunction<
          NSUInteger Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange, ffi.Int32, ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_183 = __objc_msgSend_183Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange, int,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_indexesPassingTest_1 = _registerName1("indexesPassingTest:");
  ffi.Pointer<ObjCObject> _objc_msgSend_184(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> predicate,
  ) {
    return __objc_msgSend_184(
      obj,
      sel,
      predicate,
    );
  }

  late final __objc_msgSend_184Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_184 = __objc_msgSend_184Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_indexesWithOptions_passingTest_1 =
      _registerName1("indexesWithOptions:passingTest:");
  ffi.Pointer<ObjCObject> _objc_msgSend_185(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int opts,
    ffi.Pointer<_ObjCBlock> predicate,
  ) {
    return __objc_msgSend_185(
      obj,
      sel,
      opts,
      predicate,
    );
  }

  late final __objc_msgSend_185Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Int32,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_185 = __objc_msgSend_185Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, int, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_indexesInRange_options_passingTest_1 =
      _registerName1("indexesInRange:options:passingTest:");
  ffi.Pointer<ObjCObject> _objc_msgSend_186(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    int opts,
    ffi.Pointer<_ObjCBlock> predicate,
  ) {
    return __objc_msgSend_186(
      obj,
      sel,
      range,
      opts,
      predicate,
    );
  }

  late final __objc_msgSend_186Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              NSRange,
              ffi.Int32,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_186 = __objc_msgSend_186Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, NSRange, int, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_enumerateRangesUsingBlock_1 =
      _registerName1("enumerateRangesUsingBlock:");
  void _objc_msgSend_187(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_187(
      obj,
      sel,
      block,
    );
  }

  late final __objc_msgSend_187Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_187 = __objc_msgSend_187Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_enumerateRangesWithOptions_usingBlock_1 =
      _registerName1("enumerateRangesWithOptions:usingBlock:");
  void _objc_msgSend_188(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int opts,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_188(
      obj,
      sel,
      opts,
      block,
    );
  }

  late final __objc_msgSend_188Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32, ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_188 = __objc_msgSend_188Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_enumerateRangesInRange_options_usingBlock_1 =
      _registerName1("enumerateRangesInRange:options:usingBlock:");
  void _objc_msgSend_189(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    int opts,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_189(
      obj,
      sel,
      range,
      opts,
      block,
    );
  }

  late final __objc_msgSend_189Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange, ffi.Int32, ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_189 = __objc_msgSend_189Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange, int,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_insertObjects_atIndexes_1 =
      _registerName1("insertObjects:atIndexes:");
  void _objc_msgSend_190(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> objects,
    ffi.Pointer<ObjCObject> indexes,
  ) {
    return __objc_msgSend_190(
      obj,
      sel,
      objects,
      indexes,
    );
  }

  late final __objc_msgSend_190Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_190 = __objc_msgSend_190Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_removeObjectsAtIndexes_1 =
      _registerName1("removeObjectsAtIndexes:");
  void _objc_msgSend_191(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> indexes,
  ) {
    return __objc_msgSend_191(
      obj,
      sel,
      indexes,
    );
  }

  late final __objc_msgSend_191Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_191 = __objc_msgSend_191Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_replaceObjectsAtIndexes_withObjects_1 =
      _registerName1("replaceObjectsAtIndexes:withObjects:");
  void _objc_msgSend_192(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> indexes,
    ffi.Pointer<ObjCObject> objects,
  ) {
    return __objc_msgSend_192(
      obj,
      sel,
      indexes,
      objects,
    );
  }

  late final __objc_msgSend_192Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_192 = __objc_msgSend_192Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_setObject_atIndexedSubscript_1 =
      _registerName1("setObject:atIndexedSubscript:");
  late final _sel_sortUsingComparator_1 =
      _registerName1("sortUsingComparator:");
  void _objc_msgSend_193(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSComparator cmptr,
  ) {
    return __objc_msgSend_193(
      obj,
      sel,
      cmptr,
    );
  }

  late final __objc_msgSend_193Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSComparator)>>('objc_msgSend');
  late final __objc_msgSend_193 = __objc_msgSend_193Ptr.asFunction<
      void Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSComparator)>();

  late final _sel_sortWithOptions_usingComparator_1 =
      _registerName1("sortWithOptions:usingComparator:");
  void _objc_msgSend_194(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int opts,
    NSComparator cmptr,
  ) {
    return __objc_msgSend_194(
      obj,
      sel,
      opts,
      cmptr,
    );
  }

  late final __objc_msgSend_194Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32, NSComparator)>>('objc_msgSend');
  late final __objc_msgSend_194 = __objc_msgSend_194Ptr.asFunction<
      void Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int, NSComparator)>();

  late final _sel_arrayWithCapacity_1 = _registerName1("arrayWithCapacity:");
  ffi.Pointer<ObjCObject> _objc_msgSend_195(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_195(
      obj,
      sel,
      path,
    );
  }

  late final __objc_msgSend_195Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_195 = __objc_msgSend_195Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  ffi.Pointer<ObjCObject> _objc_msgSend_196(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
  ) {
    return __objc_msgSend_196(
      obj,
      sel,
      url,
    );
  }

  late final __objc_msgSend_196Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_196 = __objc_msgSend_196Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_applyDifference_1 = _registerName1("applyDifference:");
  late final _class_NSMutableData1 = _getClass1("NSMutableData");
  late final _sel_mutableBytes1 = _registerName1("mutableBytes");
  late final _sel_setLength_1 = _registerName1("setLength:");
  void _objc_msgSend_197(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_197(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_197Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_197 = __objc_msgSend_197Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_appendBytes_length_1 = _registerName1("appendBytes:length:");
  late final _sel_appendData_1 = _registerName1("appendData:");
  void _objc_msgSend_198(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> other,
  ) {
    return __objc_msgSend_198(
      obj,
      sel,
      other,
    );
  }

  late final __objc_msgSend_198Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_198 = __objc_msgSend_198Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_increaseLengthBy_1 = _registerName1("increaseLengthBy:");
  late final _sel_replaceBytesInRange_withBytes_1 =
      _registerName1("replaceBytesInRange:withBytes:");
  void _objc_msgSend_199(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    ffi.Pointer<ffi.Void> bytes,
  ) {
    return __objc_msgSend_199(
      obj,
      sel,
      range,
      bytes,
    );
  }

  late final __objc_msgSend_199Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange, ffi.Pointer<ffi.Void>)>>('objc_msgSend');
  late final __objc_msgSend_199 = __objc_msgSend_199Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange,
          ffi.Pointer<ffi.Void>)>();

  late final _sel_resetBytesInRange_1 = _registerName1("resetBytesInRange:");
  late final _sel_setData_1 = _registerName1("setData:");
  late final _sel_replaceBytesInRange_withBytes_length_1 =
      _registerName1("replaceBytesInRange:withBytes:length:");
  void _objc_msgSend_200(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    NSRange range,
    ffi.Pointer<ffi.Void> replacementBytes,
    int replacementLength,
  ) {
    return __objc_msgSend_200(
      obj,
      sel,
      range,
      replacementBytes,
      replacementLength,
    );
  }

  late final __objc_msgSend_200Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSRange, ffi.Pointer<ffi.Void>, NSUInteger)>>('objc_msgSend');
  late final __objc_msgSend_200 = __objc_msgSend_200Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, NSRange,
          ffi.Pointer<ffi.Void>, int)>();

  late final _sel_dataWithCapacity_1 = _registerName1("dataWithCapacity:");
  late final _sel_dataWithLength_1 = _registerName1("dataWithLength:");
  late final _sel_initWithLength_1 = _registerName1("initWithLength:");
  late final _sel_decompressUsingAlgorithm_error_1 =
      _registerName1("decompressUsingAlgorithm:error:");
  bool _objc_msgSend_201(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int algorithm,
    ffi.Pointer<ffi.Pointer<ObjCObject>> error,
  ) {
    return __objc_msgSend_201(
      obj,
      sel,
      algorithm,
      error,
    );
  }

  late final __objc_msgSend_201Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Int32,
              ffi.Pointer<ffi.Pointer<ObjCObject>>)>>('objc_msgSend');
  late final __objc_msgSend_201 = __objc_msgSend_201Ptr.asFunction<
      bool Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int,
          ffi.Pointer<ffi.Pointer<ObjCObject>>)>();

  late final _sel_compressUsingAlgorithm_error_1 =
      _registerName1("compressUsingAlgorithm:error:");
  late final _class_NSPurgeableData1 = _getClass1("NSPurgeableData");
  late final _class_NSMutableDictionary1 = _getClass1("NSMutableDictionary");
  late final _sel_removeObjectForKey_1 = _registerName1("removeObjectForKey:");
  late final _sel_setObject_forKey_1 = _registerName1("setObject:forKey:");
  void _objc_msgSend_202(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> anObject,
    ffi.Pointer<ObjCObject> aKey,
  ) {
    return __objc_msgSend_202(
      obj,
      sel,
      anObject,
      aKey,
    );
  }

  late final __objc_msgSend_202Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_202 = __objc_msgSend_202Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_addEntriesFromDictionary_1 =
      _registerName1("addEntriesFromDictionary:");
  void _objc_msgSend_203(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> otherDictionary,
  ) {
    return __objc_msgSend_203(
      obj,
      sel,
      otherDictionary,
    );
  }

  late final __objc_msgSend_203Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_203 = __objc_msgSend_203Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_removeObjectsForKeys_1 =
      _registerName1("removeObjectsForKeys:");
  late final _sel_setDictionary_1 = _registerName1("setDictionary:");
  late final _sel_setObject_forKeyedSubscript_1 =
      _registerName1("setObject:forKeyedSubscript:");
  late final _sel_dictionaryWithCapacity_1 =
      _registerName1("dictionaryWithCapacity:");
  ffi.Pointer<ObjCObject> _objc_msgSend_204(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> path,
  ) {
    return __objc_msgSend_204(
      obj,
      sel,
      path,
    );
  }

  late final __objc_msgSend_204Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_204 = __objc_msgSend_204Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  ffi.Pointer<ObjCObject> _objc_msgSend_205(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
  ) {
    return __objc_msgSend_205(
      obj,
      sel,
      url,
    );
  }

  late final __objc_msgSend_205Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_205 = __objc_msgSend_205Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_dictionaryWithSharedKeySet_1 =
      _registerName1("dictionaryWithSharedKeySet:");
  ffi.Pointer<ObjCObject> _objc_msgSend_206(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> keyset,
  ) {
    return __objc_msgSend_206(
      obj,
      sel,
      keyset,
    );
  }

  late final __objc_msgSend_206Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_206 = __objc_msgSend_206Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSURLRequest1 = _getClass1("NSURLRequest");
  late final _sel_requestWithURL_1 = _registerName1("requestWithURL:");
  late final _sel_supportsSecureCoding1 =
      _registerName1("supportsSecureCoding");
  late final _sel_requestWithURL_cachePolicy_timeoutInterval_1 =
      _registerName1("requestWithURL:cachePolicy:timeoutInterval:");
  instancetype _objc_msgSend_207(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> URL,
    int cachePolicy,
    double timeoutInterval,
  ) {
    return __objc_msgSend_207(
      obj,
      sel,
      URL,
      cachePolicy,
      timeoutInterval,
    );
  }

  late final __objc_msgSend_207Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Int32,
              NSTimeInterval)>>('objc_msgSend');
  late final __objc_msgSend_207 = __objc_msgSend_207Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int, double)>();

  late final _sel_initWithURL_1 = _registerName1("initWithURL:");
  late final _sel_initWithURL_cachePolicy_timeoutInterval_1 =
      _registerName1("initWithURL:cachePolicy:timeoutInterval:");
  late final _sel_URL1 = _registerName1("URL");
  late final _sel_cachePolicy1 = _registerName1("cachePolicy");
  int _objc_msgSend_208(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_208(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_208Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_208 = __objc_msgSend_208Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_timeoutInterval1 = _registerName1("timeoutInterval");
  late final _sel_mainDocumentURL1 = _registerName1("mainDocumentURL");
  late final _sel_networkServiceType1 = _registerName1("networkServiceType");
  int _objc_msgSend_209(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_209(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_209Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_209 = __objc_msgSend_209Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_allowsCellularAccess1 =
      _registerName1("allowsCellularAccess");
  late final _sel_allowsExpensiveNetworkAccess1 =
      _registerName1("allowsExpensiveNetworkAccess");
  late final _sel_allowsConstrainedNetworkAccess1 =
      _registerName1("allowsConstrainedNetworkAccess");
  late final _sel_assumesHTTP3Capable1 = _registerName1("assumesHTTP3Capable");
  late final _sel_HTTPMethod1 = _registerName1("HTTPMethod");
  late final _sel_allHTTPHeaderFields1 = _registerName1("allHTTPHeaderFields");
  late final _sel_valueForHTTPHeaderField_1 =
      _registerName1("valueForHTTPHeaderField:");
  late final _sel_HTTPBody1 = _registerName1("HTTPBody");
  late final _class_NSInputStream1 = _getClass1("NSInputStream");
  late final _sel_HTTPBodyStream1 = _registerName1("HTTPBodyStream");
  ffi.Pointer<ObjCObject> _objc_msgSend_210(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_210(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_210Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_210 = __objc_msgSend_210Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_HTTPShouldHandleCookies1 =
      _registerName1("HTTPShouldHandleCookies");
  late final _sel_HTTPShouldUsePipelining1 =
      _registerName1("HTTPShouldUsePipelining");
  late final _class_NSMutableURLRequest1 = _getClass1("NSMutableURLRequest");
  late final _sel_setURL_1 = _registerName1("setURL:");
  void _objc_msgSend_211(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_211(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_211Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_211 = __objc_msgSend_211Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_setCachePolicy_1 = _registerName1("setCachePolicy:");
  void _objc_msgSend_212(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_212(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_212Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_212 = __objc_msgSend_212Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_setTimeoutInterval_1 = _registerName1("setTimeoutInterval:");
  void _objc_msgSend_213(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    double value,
  ) {
    return __objc_msgSend_213(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_213Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSTimeInterval)>>('objc_msgSend');
  late final __objc_msgSend_213 = __objc_msgSend_213Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, double)>();

  late final _sel_setMainDocumentURL_1 = _registerName1("setMainDocumentURL:");
  late final _sel_setNetworkServiceType_1 =
      _registerName1("setNetworkServiceType:");
  void _objc_msgSend_214(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_214(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_214Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_214 = __objc_msgSend_214Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_setAllowsCellularAccess_1 =
      _registerName1("setAllowsCellularAccess:");
  void _objc_msgSend_215(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    bool value,
  ) {
    return __objc_msgSend_215(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_215Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_215 = __objc_msgSend_215Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, bool)>();

  late final _sel_setAllowsExpensiveNetworkAccess_1 =
      _registerName1("setAllowsExpensiveNetworkAccess:");
  late final _sel_setAllowsConstrainedNetworkAccess_1 =
      _registerName1("setAllowsConstrainedNetworkAccess:");
  late final _sel_setAssumesHTTP3Capable_1 =
      _registerName1("setAssumesHTTP3Capable:");
  late final _sel_setHTTPMethod_1 = _registerName1("setHTTPMethod:");
  void _objc_msgSend_216(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_216(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_216Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_216 = __objc_msgSend_216Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_setAllHTTPHeaderFields_1 =
      _registerName1("setAllHTTPHeaderFields:");
  void _objc_msgSend_217(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_217(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_217Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_217 = __objc_msgSend_217Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_setValue_forHTTPHeaderField_1 =
      _registerName1("setValue:forHTTPHeaderField:");
  void _objc_msgSend_218(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
    ffi.Pointer<ObjCObject> field,
  ) {
    return __objc_msgSend_218(
      obj,
      sel,
      value,
      field,
    );
  }

  late final __objc_msgSend_218Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_218 = __objc_msgSend_218Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_addValue_forHTTPHeaderField_1 =
      _registerName1("addValue:forHTTPHeaderField:");
  late final _sel_setHTTPBody_1 = _registerName1("setHTTPBody:");
  void _objc_msgSend_219(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_219(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_219Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_219 = __objc_msgSend_219Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_setHTTPBodyStream_1 = _registerName1("setHTTPBodyStream:");
  void _objc_msgSend_220(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_220(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_220Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_220 = __objc_msgSend_220Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_setHTTPShouldHandleCookies_1 =
      _registerName1("setHTTPShouldHandleCookies:");
  late final _sel_setHTTPShouldUsePipelining_1 =
      _registerName1("setHTTPShouldUsePipelining:");

  /// -1LL
  late final ffi.Pointer<ffi.Int64> _NSURLSessionTransferSizeUnknown =
      _lookup<ffi.Int64>('NSURLSessionTransferSizeUnknown');

  int get NSURLSessionTransferSizeUnknown =>
      _NSURLSessionTransferSizeUnknown.value;

  set NSURLSessionTransferSizeUnknown(int value) =>
      _NSURLSessionTransferSizeUnknown.value = value;

  late final _class_NSURLSession1 = _getClass1("NSURLSession");
  late final _sel_sharedSession1 = _registerName1("sharedSession");
  ffi.Pointer<ObjCObject> _objc_msgSend_221(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_221(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_221Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_221 = __objc_msgSend_221Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _class_NSURLSessionConfiguration1 =
      _getClass1("NSURLSessionConfiguration");
  late final _sel_defaultSessionConfiguration1 =
      _registerName1("defaultSessionConfiguration");
  ffi.Pointer<ObjCObject> _objc_msgSend_222(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_222(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_222Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_222 = __objc_msgSend_222Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_ephemeralSessionConfiguration1 =
      _registerName1("ephemeralSessionConfiguration");
  late final _sel_backgroundSessionConfigurationWithIdentifier_1 =
      _registerName1("backgroundSessionConfigurationWithIdentifier:");
  ffi.Pointer<ObjCObject> _objc_msgSend_223(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> identifier,
  ) {
    return __objc_msgSend_223(
      obj,
      sel,
      identifier,
    );
  }

  late final __objc_msgSend_223Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_223 = __objc_msgSend_223Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_identifier1 = _registerName1("identifier");
  late final _sel_requestCachePolicy1 = _registerName1("requestCachePolicy");
  late final _sel_setRequestCachePolicy_1 =
      _registerName1("setRequestCachePolicy:");
  late final _sel_timeoutIntervalForRequest1 =
      _registerName1("timeoutIntervalForRequest");
  late final _sel_setTimeoutIntervalForRequest_1 =
      _registerName1("setTimeoutIntervalForRequest:");
  late final _sel_timeoutIntervalForResource1 =
      _registerName1("timeoutIntervalForResource");
  late final _sel_setTimeoutIntervalForResource_1 =
      _registerName1("setTimeoutIntervalForResource:");
  late final _sel_waitsForConnectivity1 =
      _registerName1("waitsForConnectivity");
  late final _sel_setWaitsForConnectivity_1 =
      _registerName1("setWaitsForConnectivity:");
  late final _sel_isDiscretionary1 = _registerName1("isDiscretionary");
  late final _sel_setDiscretionary_1 = _registerName1("setDiscretionary:");
  late final _sel_sharedContainerIdentifier1 =
      _registerName1("sharedContainerIdentifier");
  late final _sel_setSharedContainerIdentifier_1 =
      _registerName1("setSharedContainerIdentifier:");
  late final _sel_sessionSendsLaunchEvents1 =
      _registerName1("sessionSendsLaunchEvents");
  late final _sel_setSessionSendsLaunchEvents_1 =
      _registerName1("setSessionSendsLaunchEvents:");
  late final _sel_connectionProxyDictionary1 =
      _registerName1("connectionProxyDictionary");
  late final _sel_setConnectionProxyDictionary_1 =
      _registerName1("setConnectionProxyDictionary:");
  late final _sel_TLSMinimumSupportedProtocol1 =
      _registerName1("TLSMinimumSupportedProtocol");
  int _objc_msgSend_224(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_224(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_224Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_224 = __objc_msgSend_224Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setTLSMinimumSupportedProtocol_1 =
      _registerName1("setTLSMinimumSupportedProtocol:");
  void _objc_msgSend_225(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_225(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_225Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_225 = __objc_msgSend_225Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_TLSMaximumSupportedProtocol1 =
      _registerName1("TLSMaximumSupportedProtocol");
  late final _sel_setTLSMaximumSupportedProtocol_1 =
      _registerName1("setTLSMaximumSupportedProtocol:");
  late final _sel_TLSMinimumSupportedProtocolVersion1 =
      _registerName1("TLSMinimumSupportedProtocolVersion");
  int _objc_msgSend_226(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_226(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_226Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_226 = __objc_msgSend_226Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setTLSMinimumSupportedProtocolVersion_1 =
      _registerName1("setTLSMinimumSupportedProtocolVersion:");
  void _objc_msgSend_227(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_227(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_227Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_227 = __objc_msgSend_227Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_TLSMaximumSupportedProtocolVersion1 =
      _registerName1("TLSMaximumSupportedProtocolVersion");
  late final _sel_setTLSMaximumSupportedProtocolVersion_1 =
      _registerName1("setTLSMaximumSupportedProtocolVersion:");
  late final _sel_HTTPShouldSetCookies1 =
      _registerName1("HTTPShouldSetCookies");
  late final _sel_setHTTPShouldSetCookies_1 =
      _registerName1("setHTTPShouldSetCookies:");
  late final _sel_HTTPCookieAcceptPolicy1 =
      _registerName1("HTTPCookieAcceptPolicy");
  int _objc_msgSend_228(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_228(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_228Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_228 = __objc_msgSend_228Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setHTTPCookieAcceptPolicy_1 =
      _registerName1("setHTTPCookieAcceptPolicy:");
  void _objc_msgSend_229(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_229(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_229Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_229 = __objc_msgSend_229Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_HTTPAdditionalHeaders1 =
      _registerName1("HTTPAdditionalHeaders");
  late final _sel_setHTTPAdditionalHeaders_1 =
      _registerName1("setHTTPAdditionalHeaders:");
  late final _sel_HTTPMaximumConnectionsPerHost1 =
      _registerName1("HTTPMaximumConnectionsPerHost");
  late final _sel_setHTTPMaximumConnectionsPerHost_1 =
      _registerName1("setHTTPMaximumConnectionsPerHost:");
  void _objc_msgSend_230(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_230(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_230Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSInteger)>>('objc_msgSend');
  late final __objc_msgSend_230 = __objc_msgSend_230Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _class_NSHTTPCookieStorage1 = _getClass1("NSHTTPCookieStorage");
  late final _sel_sharedHTTPCookieStorage1 =
      _registerName1("sharedHTTPCookieStorage");
  ffi.Pointer<ObjCObject> _objc_msgSend_231(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_231(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_231Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_231 = __objc_msgSend_231Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_sharedCookieStorageForGroupContainerIdentifier_1 =
      _registerName1("sharedCookieStorageForGroupContainerIdentifier:");
  ffi.Pointer<ObjCObject> _objc_msgSend_232(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> identifier,
  ) {
    return __objc_msgSend_232(
      obj,
      sel,
      identifier,
    );
  }

  late final __objc_msgSend_232Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_232 = __objc_msgSend_232Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_cookies1 = _registerName1("cookies");
  late final _class_NSHTTPCookie1 = _getClass1("NSHTTPCookie");
  late final _sel_setCookie_1 = _registerName1("setCookie:");
  void _objc_msgSend_233(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> cookie,
  ) {
    return __objc_msgSend_233(
      obj,
      sel,
      cookie,
    );
  }

  late final __objc_msgSend_233Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_233 = __objc_msgSend_233Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_deleteCookie_1 = _registerName1("deleteCookie:");
  late final _class_NSDate1 = _getClass1("NSDate");
  late final _sel_timeIntervalSinceReferenceDate1 =
      _registerName1("timeIntervalSinceReferenceDate");
  late final _sel_initWithTimeIntervalSinceReferenceDate_1 =
      _registerName1("initWithTimeIntervalSinceReferenceDate:");
  instancetype _objc_msgSend_234(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    double ti,
  ) {
    return __objc_msgSend_234(
      obj,
      sel,
      ti,
    );
  }

  late final __objc_msgSend_234Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              NSTimeInterval)>>('objc_msgSend');
  late final __objc_msgSend_234 = __objc_msgSend_234Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, double)>();

  late final _sel_removeCookiesSinceDate_1 =
      _registerName1("removeCookiesSinceDate:");
  void _objc_msgSend_235(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> date,
  ) {
    return __objc_msgSend_235(
      obj,
      sel,
      date,
    );
  }

  late final __objc_msgSend_235Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_235 = __objc_msgSend_235Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_cookiesForURL_1 = _registerName1("cookiesForURL:");
  late final _sel_setCookies_forURL_mainDocumentURL_1 =
      _registerName1("setCookies:forURL:mainDocumentURL:");
  void _objc_msgSend_236(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> cookies,
    ffi.Pointer<ObjCObject> URL,
    ffi.Pointer<ObjCObject> mainDocumentURL,
  ) {
    return __objc_msgSend_236(
      obj,
      sel,
      cookies,
      URL,
      mainDocumentURL,
    );
  }

  late final __objc_msgSend_236Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_236 = __objc_msgSend_236Ptr.asFunction<
      void Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_cookieAcceptPolicy1 = _registerName1("cookieAcceptPolicy");
  late final _sel_setCookieAcceptPolicy_1 =
      _registerName1("setCookieAcceptPolicy:");
  late final _sel_sortedCookiesUsingDescriptors_1 =
      _registerName1("sortedCookiesUsingDescriptors:");
  late final _class_NSURLSessionTask1 = _getClass1("NSURLSessionTask");
  late final _sel_taskIdentifier1 = _registerName1("taskIdentifier");
  late final _sel_originalRequest1 = _registerName1("originalRequest");
  ffi.Pointer<ObjCObject> _objc_msgSend_237(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_237(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_237Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_237 = __objc_msgSend_237Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_currentRequest1 = _registerName1("currentRequest");
  late final _class_NSURLResponse1 = _getClass1("NSURLResponse");
  late final _sel_initWithURL_MIMEType_expectedContentLength_textEncodingName_1 =
      _registerName1(
          "initWithURL:MIMEType:expectedContentLength:textEncodingName:");
  instancetype _objc_msgSend_238(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> URL,
    ffi.Pointer<ObjCObject> MIMEType,
    int length,
    ffi.Pointer<ObjCObject> name,
  ) {
    return __objc_msgSend_238(
      obj,
      sel,
      URL,
      MIMEType,
      length,
      name,
    );
  }

  late final __objc_msgSend_238Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              NSInteger,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_238 = __objc_msgSend_238Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_MIMEType1 = _registerName1("MIMEType");
  late final _sel_expectedContentLength1 =
      _registerName1("expectedContentLength");
  late final _sel_textEncodingName1 = _registerName1("textEncodingName");
  late final _sel_suggestedFilename1 = _registerName1("suggestedFilename");
  late final _sel_response1 = _registerName1("response");
  ffi.Pointer<ObjCObject> _objc_msgSend_239(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_239(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_239Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_239 = __objc_msgSend_239Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _class_NSProgress1 = _getClass1("NSProgress");
  late final _sel_currentProgress1 = _registerName1("currentProgress");
  ffi.Pointer<ObjCObject> _objc_msgSend_240(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_240(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_240Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_240 = __objc_msgSend_240Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_progressWithTotalUnitCount_1 =
      _registerName1("progressWithTotalUnitCount:");
  ffi.Pointer<ObjCObject> _objc_msgSend_241(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int unitCount,
  ) {
    return __objc_msgSend_241(
      obj,
      sel,
      unitCount,
    );
  }

  late final __objc_msgSend_241Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Int64)>>('objc_msgSend');
  late final __objc_msgSend_241 = __objc_msgSend_241Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_discreteProgressWithTotalUnitCount_1 =
      _registerName1("discreteProgressWithTotalUnitCount:");
  late final _sel_progressWithTotalUnitCount_parent_pendingUnitCount_1 =
      _registerName1("progressWithTotalUnitCount:parent:pendingUnitCount:");
  ffi.Pointer<ObjCObject> _objc_msgSend_242(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int unitCount,
    ffi.Pointer<ObjCObject> parent,
    int portionOfParentTotalUnitCount,
  ) {
    return __objc_msgSend_242(
      obj,
      sel,
      unitCount,
      parent,
      portionOfParentTotalUnitCount,
    );
  }

  late final __objc_msgSend_242Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Int64,
              ffi.Pointer<ObjCObject>,
              ffi.Int64)>>('objc_msgSend');
  late final __objc_msgSend_242 = __objc_msgSend_242Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, int, ffi.Pointer<ObjCObject>, int)>();

  late final _sel_initWithParent_userInfo_1 =
      _registerName1("initWithParent:userInfo:");
  instancetype _objc_msgSend_243(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> parentProgressOrNil,
    ffi.Pointer<ObjCObject> userInfoOrNil,
  ) {
    return __objc_msgSend_243(
      obj,
      sel,
      parentProgressOrNil,
      userInfoOrNil,
    );
  }

  late final __objc_msgSend_243Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_243 = __objc_msgSend_243Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_becomeCurrentWithPendingUnitCount_1 =
      _registerName1("becomeCurrentWithPendingUnitCount:");
  void _objc_msgSend_244(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int unitCount,
  ) {
    return __objc_msgSend_244(
      obj,
      sel,
      unitCount,
    );
  }

  late final __objc_msgSend_244Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int64)>>('objc_msgSend');
  late final __objc_msgSend_244 = __objc_msgSend_244Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_performAsCurrentWithPendingUnitCount_usingBlock_1 =
      _registerName1("performAsCurrentWithPendingUnitCount:usingBlock:");
  void _objc_msgSend_245(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int unitCount,
    ffi.Pointer<_ObjCBlock> work,
  ) {
    return __objc_msgSend_245(
      obj,
      sel,
      unitCount,
      work,
    );
  }

  late final __objc_msgSend_245Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int64, ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_245 = __objc_msgSend_245Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_resignCurrent1 = _registerName1("resignCurrent");
  late final _sel_addChild_withPendingUnitCount_1 =
      _registerName1("addChild:withPendingUnitCount:");
  void _objc_msgSend_246(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> child,
    int inUnitCount,
  ) {
    return __objc_msgSend_246(
      obj,
      sel,
      child,
      inUnitCount,
    );
  }

  late final __objc_msgSend_246Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Int64)>>('objc_msgSend');
  late final __objc_msgSend_246 = __objc_msgSend_246Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, int)>();

  late final _sel_totalUnitCount1 = _registerName1("totalUnitCount");
  int _objc_msgSend_247(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_247(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_247Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_247 = __objc_msgSend_247Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setTotalUnitCount_1 = _registerName1("setTotalUnitCount:");
  void _objc_msgSend_248(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_248(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_248Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int64)>>('objc_msgSend');
  late final __objc_msgSend_248 = __objc_msgSend_248Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_completedUnitCount1 = _registerName1("completedUnitCount");
  late final _sel_setCompletedUnitCount_1 =
      _registerName1("setCompletedUnitCount:");
  late final _sel_setLocalizedDescription_1 =
      _registerName1("setLocalizedDescription:");
  late final _sel_localizedAdditionalDescription1 =
      _registerName1("localizedAdditionalDescription");
  late final _sel_setLocalizedAdditionalDescription_1 =
      _registerName1("setLocalizedAdditionalDescription:");
  late final _sel_isCancellable1 = _registerName1("isCancellable");
  late final _sel_setCancellable_1 = _registerName1("setCancellable:");
  late final _sel_isPausable1 = _registerName1("isPausable");
  late final _sel_setPausable_1 = _registerName1("setPausable:");
  late final _sel_isCancelled1 = _registerName1("isCancelled");
  late final _sel_isPaused1 = _registerName1("isPaused");
  late final _sel_cancellationHandler1 = _registerName1("cancellationHandler");
  ffi.Pointer<_ObjCBlock> _objc_msgSend_249(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_249(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_249Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<_ObjCBlock> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_249 = __objc_msgSend_249Ptr.asFunction<
      ffi.Pointer<_ObjCBlock> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setCancellationHandler_1 =
      _registerName1("setCancellationHandler:");
  void _objc_msgSend_250(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> value,
  ) {
    return __objc_msgSend_250(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_250Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_250 = __objc_msgSend_250Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_pausingHandler1 = _registerName1("pausingHandler");
  late final _sel_setPausingHandler_1 = _registerName1("setPausingHandler:");
  late final _sel_resumingHandler1 = _registerName1("resumingHandler");
  late final _sel_setResumingHandler_1 = _registerName1("setResumingHandler:");
  late final _sel_setUserInfoObject_forKey_1 =
      _registerName1("setUserInfoObject:forKey:");
  late final _sel_isIndeterminate1 = _registerName1("isIndeterminate");
  late final _sel_fractionCompleted1 = _registerName1("fractionCompleted");
  late final _sel_isFinished1 = _registerName1("isFinished");
  late final _sel_cancel1 = _registerName1("cancel");
  late final _sel_pause1 = _registerName1("pause");
  late final _sel_resume1 = _registerName1("resume");
  late final _sel_kind1 = _registerName1("kind");
  late final _sel_setKind_1 = _registerName1("setKind:");
  late final _sel_estimatedTimeRemaining1 =
      _registerName1("estimatedTimeRemaining");
  late final _sel_setEstimatedTimeRemaining_1 =
      _registerName1("setEstimatedTimeRemaining:");
  void _objc_msgSend_251(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_251(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_251Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_251 = __objc_msgSend_251Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_throughput1 = _registerName1("throughput");
  late final _sel_setThroughput_1 = _registerName1("setThroughput:");
  late final _sel_fileOperationKind1 = _registerName1("fileOperationKind");
  late final _sel_setFileOperationKind_1 =
      _registerName1("setFileOperationKind:");
  late final _sel_fileURL1 = _registerName1("fileURL");
  late final _sel_setFileURL_1 = _registerName1("setFileURL:");
  late final _sel_fileTotalCount1 = _registerName1("fileTotalCount");
  late final _sel_setFileTotalCount_1 = _registerName1("setFileTotalCount:");
  late final _sel_fileCompletedCount1 = _registerName1("fileCompletedCount");
  late final _sel_setFileCompletedCount_1 =
      _registerName1("setFileCompletedCount:");
  late final _sel_publish1 = _registerName1("publish");
  late final _sel_unpublish1 = _registerName1("unpublish");
  late final _sel_addSubscriberForFileURL_withPublishingHandler_1 =
      _registerName1("addSubscriberForFileURL:withPublishingHandler:");
  ffi.Pointer<ObjCObject> _objc_msgSend_252(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    NSProgressPublishingHandler publishingHandler,
  ) {
    return __objc_msgSend_252(
      obj,
      sel,
      url,
      publishingHandler,
    );
  }

  late final __objc_msgSend_252Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              NSProgressPublishingHandler)>>('objc_msgSend');
  late final __objc_msgSend_252 = __objc_msgSend_252Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          NSProgressPublishingHandler)>();

  late final _sel_removeSubscriber_1 = _registerName1("removeSubscriber:");
  late final _sel_isOld1 = _registerName1("isOld");
  late final _sel_progress1 = _registerName1("progress");
  late final _sel_earliestBeginDate1 = _registerName1("earliestBeginDate");
  ffi.Pointer<ObjCObject> _objc_msgSend_253(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_253(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_253Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_253 = __objc_msgSend_253Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setEarliestBeginDate_1 =
      _registerName1("setEarliestBeginDate:");
  void _objc_msgSend_254(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_254(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_254Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_254 = __objc_msgSend_254Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_countOfBytesClientExpectsToSend1 =
      _registerName1("countOfBytesClientExpectsToSend");
  late final _sel_setCountOfBytesClientExpectsToSend_1 =
      _registerName1("setCountOfBytesClientExpectsToSend:");
  late final _sel_countOfBytesClientExpectsToReceive1 =
      _registerName1("countOfBytesClientExpectsToReceive");
  late final _sel_setCountOfBytesClientExpectsToReceive_1 =
      _registerName1("setCountOfBytesClientExpectsToReceive:");
  late final _sel_countOfBytesReceived1 =
      _registerName1("countOfBytesReceived");
  late final _sel_countOfBytesSent1 = _registerName1("countOfBytesSent");
  late final _sel_countOfBytesExpectedToSend1 =
      _registerName1("countOfBytesExpectedToSend");
  late final _sel_countOfBytesExpectedToReceive1 =
      _registerName1("countOfBytesExpectedToReceive");
  late final _sel_taskDescription1 = _registerName1("taskDescription");
  late final _sel_setTaskDescription_1 = _registerName1("setTaskDescription:");
  late final _sel_state1 = _registerName1("state");
  int _objc_msgSend_255(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_255(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_255Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_255 = __objc_msgSend_255Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_error1 = _registerName1("error");
  ffi.Pointer<ObjCObject> _objc_msgSend_256(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_256(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_256 = __objc_msgSend_256Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_suspend1 = _registerName1("suspend");
  late final _sel_priority1 = _registerName1("priority");
  late final _sel_setPriority_1 = _registerName1("setPriority:");
  void _objc_msgSend_257(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    double value,
  ) {
    return __objc_msgSend_257(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_257Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Float)>>('objc_msgSend');
  late final __objc_msgSend_257 = __objc_msgSend_257Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, double)>();

  late final _sel_prefersIncrementalDelivery1 =
      _registerName1("prefersIncrementalDelivery");
  late final _sel_setPrefersIncrementalDelivery_1 =
      _registerName1("setPrefersIncrementalDelivery:");
  late final _sel_storeCookies_forTask_1 =
      _registerName1("storeCookies:forTask:");
  void _objc_msgSend_258(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> cookies,
    ffi.Pointer<ObjCObject> task,
  ) {
    return __objc_msgSend_258(
      obj,
      sel,
      cookies,
      task,
    );
  }

  late final __objc_msgSend_258Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_258 = __objc_msgSend_258Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_getCookiesForTask_completionHandler_1 =
      _registerName1("getCookiesForTask:completionHandler:");
  void _objc_msgSend_259(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> task,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_259(
      obj,
      sel,
      task,
      completionHandler,
    );
  }

  late final __objc_msgSend_259Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_259 = __objc_msgSend_259Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_HTTPCookieStorage1 = _registerName1("HTTPCookieStorage");
  late final _sel_setHTTPCookieStorage_1 =
      _registerName1("setHTTPCookieStorage:");
  void _objc_msgSend_260(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_260(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_260Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_260 = __objc_msgSend_260Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _class_NSURLCredentialStorage1 =
      _getClass1("NSURLCredentialStorage");
  late final _sel_URLCredentialStorage1 =
      _registerName1("URLCredentialStorage");
  ffi.Pointer<ObjCObject> _objc_msgSend_261(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_261(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_261Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_261 = __objc_msgSend_261Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setURLCredentialStorage_1 =
      _registerName1("setURLCredentialStorage:");
  void _objc_msgSend_262(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_262(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_262Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_262 = __objc_msgSend_262Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _class_NSURLCache1 = _getClass1("NSURLCache");
  late final _sel_URLCache1 = _registerName1("URLCache");
  ffi.Pointer<ObjCObject> _objc_msgSend_263(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_263(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_263Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_263 = __objc_msgSend_263Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setURLCache_1 = _registerName1("setURLCache:");
  void _objc_msgSend_264(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_264(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_264Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_264 = __objc_msgSend_264Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_shouldUseExtendedBackgroundIdleMode1 =
      _registerName1("shouldUseExtendedBackgroundIdleMode");
  late final _sel_setShouldUseExtendedBackgroundIdleMode_1 =
      _registerName1("setShouldUseExtendedBackgroundIdleMode:");
  late final _sel_protocolClasses1 = _registerName1("protocolClasses");
  late final _sel_setProtocolClasses_1 = _registerName1("setProtocolClasses:");
  void _objc_msgSend_265(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_265(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_265Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_265 = __objc_msgSend_265Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_multipathServiceType1 =
      _registerName1("multipathServiceType");
  int _objc_msgSend_266(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_266(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_266Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_266 = __objc_msgSend_266Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setMultipathServiceType_1 =
      _registerName1("setMultipathServiceType:");
  void _objc_msgSend_267(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_267(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_267Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_267 = __objc_msgSend_267Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_backgroundSessionConfiguration_1 =
      _registerName1("backgroundSessionConfiguration:");
  late final _sel_sessionWithConfiguration_1 =
      _registerName1("sessionWithConfiguration:");
  ffi.Pointer<ObjCObject> _objc_msgSend_268(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> configuration,
  ) {
    return __objc_msgSend_268(
      obj,
      sel,
      configuration,
    );
  }

  late final __objc_msgSend_268Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_268 = __objc_msgSend_268Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSOperationQueue1 = _getClass1("NSOperationQueue");
  late final _class_NSOperation1 = _getClass1("NSOperation");
  late final _sel_start1 = _registerName1("start");
  late final _sel_main1 = _registerName1("main");
  late final _sel_isExecuting1 = _registerName1("isExecuting");
  late final _sel_isConcurrent1 = _registerName1("isConcurrent");
  late final _sel_isAsynchronous1 = _registerName1("isAsynchronous");
  late final _sel_isReady1 = _registerName1("isReady");
  late final _sel_addDependency_1 = _registerName1("addDependency:");
  void _objc_msgSend_269(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> op,
  ) {
    return __objc_msgSend_269(
      obj,
      sel,
      op,
    );
  }

  late final __objc_msgSend_269Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_269 = __objc_msgSend_269Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_removeDependency_1 = _registerName1("removeDependency:");
  late final _sel_dependencies1 = _registerName1("dependencies");
  late final _sel_queuePriority1 = _registerName1("queuePriority");
  int _objc_msgSend_270(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_270(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_270Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_270 = __objc_msgSend_270Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setQueuePriority_1 = _registerName1("setQueuePriority:");
  void _objc_msgSend_271(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_271(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_271Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_271 = __objc_msgSend_271Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_completionBlock1 = _registerName1("completionBlock");
  late final _sel_setCompletionBlock_1 = _registerName1("setCompletionBlock:");
  late final _sel_waitUntilFinished1 = _registerName1("waitUntilFinished");
  late final _sel_threadPriority1 = _registerName1("threadPriority");
  late final _sel_setThreadPriority_1 = _registerName1("setThreadPriority:");
  late final _sel_qualityOfService1 = _registerName1("qualityOfService");
  int _objc_msgSend_272(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_272(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_272Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_272 = __objc_msgSend_272Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setQualityOfService_1 =
      _registerName1("setQualityOfService:");
  void _objc_msgSend_273(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int value,
  ) {
    return __objc_msgSend_273(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_273Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_273 = __objc_msgSend_273Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_name1 = _registerName1("name");
  late final _sel_setName_1 = _registerName1("setName:");
  late final _sel_addOperation_1 = _registerName1("addOperation:");
  late final _sel_addOperations_waitUntilFinished_1 =
      _registerName1("addOperations:waitUntilFinished:");
  void _objc_msgSend_274(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> ops,
    bool wait,
  ) {
    return __objc_msgSend_274(
      obj,
      sel,
      ops,
      wait,
    );
  }

  late final __objc_msgSend_274Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>, ffi.Bool)>>('objc_msgSend');
  late final __objc_msgSend_274 = __objc_msgSend_274Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, bool)>();

  late final _sel_addOperationWithBlock_1 =
      _registerName1("addOperationWithBlock:");
  void _objc_msgSend_275(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_275(
      obj,
      sel,
      block,
    );
  }

  late final __objc_msgSend_275Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_275 = __objc_msgSend_275Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_addBarrierBlock_1 = _registerName1("addBarrierBlock:");
  late final _sel_maxConcurrentOperationCount1 =
      _registerName1("maxConcurrentOperationCount");
  late final _sel_setMaxConcurrentOperationCount_1 =
      _registerName1("setMaxConcurrentOperationCount:");
  late final _sel_isSuspended1 = _registerName1("isSuspended");
  late final _sel_setSuspended_1 = _registerName1("setSuspended:");
  late final _sel_underlyingQueue1 = _registerName1("underlyingQueue");
  dispatch_queue_t _objc_msgSend_276(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_276(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_276Ptr = _lookup<
      ffi.NativeFunction<
          dispatch_queue_t Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_276 = __objc_msgSend_276Ptr.asFunction<
      dispatch_queue_t Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_setUnderlyingQueue_1 = _registerName1("setUnderlyingQueue:");
  void _objc_msgSend_277(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    dispatch_queue_t value,
  ) {
    return __objc_msgSend_277(
      obj,
      sel,
      value,
    );
  }

  late final __objc_msgSend_277Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              dispatch_queue_t)>>('objc_msgSend');
  late final __objc_msgSend_277 = __objc_msgSend_277Ptr.asFunction<
      void Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, dispatch_queue_t)>();

  late final _sel_cancelAllOperations1 = _registerName1("cancelAllOperations");
  late final _sel_waitUntilAllOperationsAreFinished1 =
      _registerName1("waitUntilAllOperationsAreFinished");
  late final _sel_currentQueue1 = _registerName1("currentQueue");
  ffi.Pointer<ObjCObject> _objc_msgSend_278(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_278(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_278Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_278 = __objc_msgSend_278Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_mainQueue1 = _registerName1("mainQueue");
  late final _sel_operations1 = _registerName1("operations");
  late final _sel_operationCount1 = _registerName1("operationCount");
  late final _sel_sessionWithConfiguration_delegate_delegateQueue_1 =
      _registerName1("sessionWithConfiguration:delegate:delegateQueue:");
  ffi.Pointer<ObjCObject> _objc_msgSend_279(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> configuration,
    ffi.Pointer<ObjCObject> delegate,
    ffi.Pointer<ObjCObject> queue,
  ) {
    return __objc_msgSend_279(
      obj,
      sel,
      configuration,
      delegate,
      queue,
    );
  }

  late final __objc_msgSend_279Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_279 = __objc_msgSend_279Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_delegateQueue1 = _registerName1("delegateQueue");
  late final _sel_delegate1 = _registerName1("delegate");
  late final _sel_configuration1 = _registerName1("configuration");
  late final _sel_sessionDescription1 = _registerName1("sessionDescription");
  late final _sel_setSessionDescription_1 =
      _registerName1("setSessionDescription:");
  late final _sel_finishTasksAndInvalidate1 =
      _registerName1("finishTasksAndInvalidate");
  late final _sel_invalidateAndCancel1 = _registerName1("invalidateAndCancel");
  late final _sel_resetWithCompletionHandler_1 =
      _registerName1("resetWithCompletionHandler:");
  late final _sel_flushWithCompletionHandler_1 =
      _registerName1("flushWithCompletionHandler:");
  late final _sel_getTasksWithCompletionHandler_1 =
      _registerName1("getTasksWithCompletionHandler:");
  void _objc_msgSend_280(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_280(
      obj,
      sel,
      completionHandler,
    );
  }

  late final __objc_msgSend_280Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_280 = __objc_msgSend_280Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_getAllTasksWithCompletionHandler_1 =
      _registerName1("getAllTasksWithCompletionHandler:");
  void _objc_msgSend_281(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_281(
      obj,
      sel,
      completionHandler,
    );
  }

  late final __objc_msgSend_281Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_281 = __objc_msgSend_281Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _class_NSURLSessionDataTask1 = _getClass1("NSURLSessionDataTask");
  late final _sel_dataTaskWithRequest_1 =
      _registerName1("dataTaskWithRequest:");
  ffi.Pointer<ObjCObject> _objc_msgSend_282(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
  ) {
    return __objc_msgSend_282(
      obj,
      sel,
      request,
    );
  }

  late final __objc_msgSend_282Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_282 = __objc_msgSend_282Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_dataTaskWithURL_1 = _registerName1("dataTaskWithURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_283(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
  ) {
    return __objc_msgSend_283(
      obj,
      sel,
      url,
    );
  }

  late final __objc_msgSend_283Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_283 = __objc_msgSend_283Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSURLSessionUploadTask1 =
      _getClass1("NSURLSessionUploadTask");
  late final _sel_uploadTaskWithRequest_fromFile_1 =
      _registerName1("uploadTaskWithRequest:fromFile:");
  ffi.Pointer<ObjCObject> _objc_msgSend_284(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
    ffi.Pointer<ObjCObject> fileURL,
  ) {
    return __objc_msgSend_284(
      obj,
      sel,
      request,
      fileURL,
    );
  }

  late final __objc_msgSend_284Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_284 = __objc_msgSend_284Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_uploadTaskWithRequest_fromData_1 =
      _registerName1("uploadTaskWithRequest:fromData:");
  ffi.Pointer<ObjCObject> _objc_msgSend_285(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
    ffi.Pointer<ObjCObject> bodyData,
  ) {
    return __objc_msgSend_285(
      obj,
      sel,
      request,
      bodyData,
    );
  }

  late final __objc_msgSend_285Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_285 = __objc_msgSend_285Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_uploadTaskWithStreamedRequest_1 =
      _registerName1("uploadTaskWithStreamedRequest:");
  ffi.Pointer<ObjCObject> _objc_msgSend_286(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
  ) {
    return __objc_msgSend_286(
      obj,
      sel,
      request,
    );
  }

  late final __objc_msgSend_286Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_286 = __objc_msgSend_286Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSURLSessionDownloadTask1 =
      _getClass1("NSURLSessionDownloadTask");
  late final _sel_cancelByProducingResumeData_1 =
      _registerName1("cancelByProducingResumeData:");
  void _objc_msgSend_287(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_287(
      obj,
      sel,
      completionHandler,
    );
  }

  late final __objc_msgSend_287Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_287 = __objc_msgSend_287Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_downloadTaskWithRequest_1 =
      _registerName1("downloadTaskWithRequest:");
  ffi.Pointer<ObjCObject> _objc_msgSend_288(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
  ) {
    return __objc_msgSend_288(
      obj,
      sel,
      request,
    );
  }

  late final __objc_msgSend_288Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_288 = __objc_msgSend_288Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_downloadTaskWithURL_1 =
      _registerName1("downloadTaskWithURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_289(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
  ) {
    return __objc_msgSend_289(
      obj,
      sel,
      url,
    );
  }

  late final __objc_msgSend_289Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_289 = __objc_msgSend_289Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_downloadTaskWithResumeData_1 =
      _registerName1("downloadTaskWithResumeData:");
  ffi.Pointer<ObjCObject> _objc_msgSend_290(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> resumeData,
  ) {
    return __objc_msgSend_290(
      obj,
      sel,
      resumeData,
    );
  }

  late final __objc_msgSend_290Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_290 = __objc_msgSend_290Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSURLSessionStreamTask1 =
      _getClass1("NSURLSessionStreamTask");
  late final _sel_readDataOfMinLength_maxLength_timeout_completionHandler_1 =
      _registerName1(
          "readDataOfMinLength:maxLength:timeout:completionHandler:");
  void _objc_msgSend_291(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int minBytes,
    int maxBytes,
    double timeout,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_291(
      obj,
      sel,
      minBytes,
      maxBytes,
      timeout,
      completionHandler,
    );
  }

  late final __objc_msgSend_291Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              NSUInteger,
              NSUInteger,
              NSTimeInterval,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_291 = __objc_msgSend_291Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int, int,
          double, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_writeData_timeout_completionHandler_1 =
      _registerName1("writeData:timeout:completionHandler:");
  void _objc_msgSend_292(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> data,
    double timeout,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_292(
      obj,
      sel,
      data,
      timeout,
      completionHandler,
    );
  }

  late final __objc_msgSend_292Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              NSTimeInterval,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_292 = __objc_msgSend_292Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, double, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_captureStreams1 = _registerName1("captureStreams");
  late final _sel_closeWrite1 = _registerName1("closeWrite");
  late final _sel_closeRead1 = _registerName1("closeRead");
  late final _sel_startSecureConnection1 =
      _registerName1("startSecureConnection");
  late final _sel_stopSecureConnection1 =
      _registerName1("stopSecureConnection");
  late final _sel_streamTaskWithHostName_port_1 =
      _registerName1("streamTaskWithHostName:port:");
  ffi.Pointer<ObjCObject> _objc_msgSend_293(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> hostname,
    int port,
  ) {
    return __objc_msgSend_293(
      obj,
      sel,
      hostname,
      port,
    );
  }

  late final __objc_msgSend_293Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              NSInteger)>>('objc_msgSend');
  late final __objc_msgSend_293 = __objc_msgSend_293Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>, int)>();

  late final _class_NSNetService1 = _getClass1("NSNetService");
  late final _sel_streamTaskWithNetService_1 =
      _registerName1("streamTaskWithNetService:");
  ffi.Pointer<ObjCObject> _objc_msgSend_294(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> service,
  ) {
    return __objc_msgSend_294(
      obj,
      sel,
      service,
    );
  }

  late final __objc_msgSend_294Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_294 = __objc_msgSend_294Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _class_NSURLSessionWebSocketTask1 =
      _getClass1("NSURLSessionWebSocketTask");
  late final _class_NSURLSessionWebSocketMessage1 =
      _getClass1("NSURLSessionWebSocketMessage");
  late final _sel_type1 = _registerName1("type");
  int _objc_msgSend_295(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_295(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_295Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_295 = __objc_msgSend_295Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_string1 = _registerName1("string");
  late final _sel_sendMessage_completionHandler_1 =
      _registerName1("sendMessage:completionHandler:");
  void _objc_msgSend_296(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> message,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_296(
      obj,
      sel,
      message,
      completionHandler,
    );
  }

  late final __objc_msgSend_296Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_296 = __objc_msgSend_296Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<_ObjCBlock>)>();

  late final _sel_receiveMessageWithCompletionHandler_1 =
      _registerName1("receiveMessageWithCompletionHandler:");
  void _objc_msgSend_297(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_297(
      obj,
      sel,
      completionHandler,
    );
  }

  late final __objc_msgSend_297Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_297 = __objc_msgSend_297Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_sendPingWithPongReceiveHandler_1 =
      _registerName1("sendPingWithPongReceiveHandler:");
  void _objc_msgSend_298(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> pongReceiveHandler,
  ) {
    return __objc_msgSend_298(
      obj,
      sel,
      pongReceiveHandler,
    );
  }

  late final __objc_msgSend_298Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_298 = __objc_msgSend_298Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_cancelWithCloseCode_reason_1 =
      _registerName1("cancelWithCloseCode:reason:");
  void _objc_msgSend_299(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int closeCode,
    ffi.Pointer<ObjCObject> reason,
  ) {
    return __objc_msgSend_299(
      obj,
      sel,
      closeCode,
      reason,
    );
  }

  late final __objc_msgSend_299Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_299 = __objc_msgSend_299Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_maximumMessageSize1 = _registerName1("maximumMessageSize");
  late final _sel_setMaximumMessageSize_1 =
      _registerName1("setMaximumMessageSize:");
  late final _sel_closeCode1 = _registerName1("closeCode");
  int _objc_msgSend_300(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_300(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_300Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_300 = __objc_msgSend_300Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_closeReason1 = _registerName1("closeReason");
  late final _sel_webSocketTaskWithURL_1 =
      _registerName1("webSocketTaskWithURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_301(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
  ) {
    return __objc_msgSend_301(
      obj,
      sel,
      url,
    );
  }

  late final __objc_msgSend_301Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_301 = __objc_msgSend_301Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_webSocketTaskWithURL_protocols_1 =
      _registerName1("webSocketTaskWithURL:protocols:");
  ffi.Pointer<ObjCObject> _objc_msgSend_302(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    ffi.Pointer<ObjCObject> protocols,
  ) {
    return __objc_msgSend_302(
      obj,
      sel,
      url,
      protocols,
    );
  }

  late final __objc_msgSend_302Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_302 = __objc_msgSend_302Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_webSocketTaskWithRequest_1 =
      _registerName1("webSocketTaskWithRequest:");
  ffi.Pointer<ObjCObject> _objc_msgSend_303(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
  ) {
    return __objc_msgSend_303(
      obj,
      sel,
      request,
    );
  }

  late final __objc_msgSend_303Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_303 = __objc_msgSend_303Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_dataTaskWithRequest_completionHandler_1 =
      _registerName1("dataTaskWithRequest:completionHandler:");
  ffi.Pointer<ObjCObject> _objc_msgSend_304(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_304(
      obj,
      sel,
      request,
      completionHandler,
    );
  }

  late final __objc_msgSend_304Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_304 = __objc_msgSend_304Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_dataTaskWithURL_completionHandler_1 =
      _registerName1("dataTaskWithURL:completionHandler:");
  ffi.Pointer<ObjCObject> _objc_msgSend_305(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_305(
      obj,
      sel,
      url,
      completionHandler,
    );
  }

  late final __objc_msgSend_305Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_305 = __objc_msgSend_305Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_uploadTaskWithRequest_fromFile_completionHandler_1 =
      _registerName1("uploadTaskWithRequest:fromFile:completionHandler:");
  ffi.Pointer<ObjCObject> _objc_msgSend_306(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
    ffi.Pointer<ObjCObject> fileURL,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_306(
      obj,
      sel,
      request,
      fileURL,
      completionHandler,
    );
  }

  late final __objc_msgSend_306Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_306 = __objc_msgSend_306Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_uploadTaskWithRequest_fromData_completionHandler_1 =
      _registerName1("uploadTaskWithRequest:fromData:completionHandler:");
  ffi.Pointer<ObjCObject> _objc_msgSend_307(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
    ffi.Pointer<ObjCObject> bodyData,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_307(
      obj,
      sel,
      request,
      bodyData,
      completionHandler,
    );
  }

  late final __objc_msgSend_307Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_307 = __objc_msgSend_307Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_downloadTaskWithRequest_completionHandler_1 =
      _registerName1("downloadTaskWithRequest:completionHandler:");
  ffi.Pointer<ObjCObject> _objc_msgSend_308(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_308(
      obj,
      sel,
      request,
      completionHandler,
    );
  }

  late final __objc_msgSend_308Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_308 = __objc_msgSend_308Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_downloadTaskWithURL_completionHandler_1 =
      _registerName1("downloadTaskWithURL:completionHandler:");
  ffi.Pointer<ObjCObject> _objc_msgSend_309(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_309(
      obj,
      sel,
      url,
      completionHandler,
    );
  }

  late final __objc_msgSend_309Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_309 = __objc_msgSend_309Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_downloadTaskWithResumeData_completionHandler_1 =
      _registerName1("downloadTaskWithResumeData:completionHandler:");
  ffi.Pointer<ObjCObject> _objc_msgSend_310(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> resumeData,
    ffi.Pointer<_ObjCBlock> completionHandler,
  ) {
    return __objc_msgSend_310(
      obj,
      sel,
      resumeData,
      completionHandler,
    );
  }

  late final __objc_msgSend_310Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_310 = __objc_msgSend_310Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<_ObjCBlock>)>();

  late final ffi.Pointer<ffi.Float> _NSURLSessionTaskPriorityDefault =
      _lookup<ffi.Float>('NSURLSessionTaskPriorityDefault');

  double get NSURLSessionTaskPriorityDefault =>
      _NSURLSessionTaskPriorityDefault.value;

  set NSURLSessionTaskPriorityDefault(double value) =>
      _NSURLSessionTaskPriorityDefault.value = value;

  late final ffi.Pointer<ffi.Float> _NSURLSessionTaskPriorityLow =
      _lookup<ffi.Float>('NSURLSessionTaskPriorityLow');

  double get NSURLSessionTaskPriorityLow => _NSURLSessionTaskPriorityLow.value;

  set NSURLSessionTaskPriorityLow(double value) =>
      _NSURLSessionTaskPriorityLow.value = value;

  late final ffi.Pointer<ffi.Float> _NSURLSessionTaskPriorityHigh =
      _lookup<ffi.Float>('NSURLSessionTaskPriorityHigh');

  double get NSURLSessionTaskPriorityHigh =>
      _NSURLSessionTaskPriorityHigh.value;

  set NSURLSessionTaskPriorityHigh(double value) =>
      _NSURLSessionTaskPriorityHigh.value = value;

  /// Key in the userInfo dictionary of an NSError received during a failed download.
  late final ffi.Pointer<ffi.Pointer<ObjCObject>>
      _NSURLSessionDownloadTaskResumeData =
      _lookup<ffi.Pointer<ObjCObject>>('NSURLSessionDownloadTaskResumeData');

  ffi.Pointer<ObjCObject> get NSURLSessionDownloadTaskResumeData =>
      _NSURLSessionDownloadTaskResumeData.value;

  set NSURLSessionDownloadTaskResumeData(ffi.Pointer<ObjCObject> value) =>
      _NSURLSessionDownloadTaskResumeData.value = value;

  late final _class_NSURLSessionTaskTransactionMetrics1 =
      _getClass1("NSURLSessionTaskTransactionMetrics");
  late final _sel_request1 = _registerName1("request");
  late final _sel_fetchStartDate1 = _registerName1("fetchStartDate");
  late final _sel_domainLookupStartDate1 =
      _registerName1("domainLookupStartDate");
  late final _sel_domainLookupEndDate1 = _registerName1("domainLookupEndDate");
  late final _sel_connectStartDate1 = _registerName1("connectStartDate");
  late final _sel_secureConnectionStartDate1 =
      _registerName1("secureConnectionStartDate");
  late final _sel_secureConnectionEndDate1 =
      _registerName1("secureConnectionEndDate");
  late final _sel_connectEndDate1 = _registerName1("connectEndDate");
  late final _sel_requestStartDate1 = _registerName1("requestStartDate");
  late final _sel_requestEndDate1 = _registerName1("requestEndDate");
  late final _sel_responseStartDate1 = _registerName1("responseStartDate");
  late final _sel_responseEndDate1 = _registerName1("responseEndDate");
  late final _sel_networkProtocolName1 = _registerName1("networkProtocolName");
  late final _sel_isProxyConnection1 = _registerName1("isProxyConnection");
  late final _sel_isReusedConnection1 = _registerName1("isReusedConnection");
  late final _sel_resourceFetchType1 = _registerName1("resourceFetchType");
  int _objc_msgSend_311(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_311(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_311Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_311 = __objc_msgSend_311Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_countOfRequestHeaderBytesSent1 =
      _registerName1("countOfRequestHeaderBytesSent");
  late final _sel_countOfRequestBodyBytesSent1 =
      _registerName1("countOfRequestBodyBytesSent");
  late final _sel_countOfRequestBodyBytesBeforeEncoding1 =
      _registerName1("countOfRequestBodyBytesBeforeEncoding");
  late final _sel_countOfResponseHeaderBytesReceived1 =
      _registerName1("countOfResponseHeaderBytesReceived");
  late final _sel_countOfResponseBodyBytesReceived1 =
      _registerName1("countOfResponseBodyBytesReceived");
  late final _sel_countOfResponseBodyBytesAfterDecoding1 =
      _registerName1("countOfResponseBodyBytesAfterDecoding");
  late final _sel_localAddress1 = _registerName1("localAddress");
  late final _sel_localPort1 = _registerName1("localPort");
  late final _sel_remoteAddress1 = _registerName1("remoteAddress");
  late final _sel_remotePort1 = _registerName1("remotePort");
  late final _sel_negotiatedTLSProtocolVersion1 =
      _registerName1("negotiatedTLSProtocolVersion");
  late final _sel_negotiatedTLSCipherSuite1 =
      _registerName1("negotiatedTLSCipherSuite");
  late final _sel_isCellular1 = _registerName1("isCellular");
  late final _sel_isExpensive1 = _registerName1("isExpensive");
  late final _sel_isConstrained1 = _registerName1("isConstrained");
  late final _sel_isMultipath1 = _registerName1("isMultipath");
  late final _sel_domainResolutionProtocol1 =
      _registerName1("domainResolutionProtocol");
  int _objc_msgSend_312(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_312(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_312Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_312 = __objc_msgSend_312Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _class_NSURLSessionTaskMetrics1 =
      _getClass1("NSURLSessionTaskMetrics");
  late final _sel_transactionMetrics1 = _registerName1("transactionMetrics");
  late final _class_NSDateInterval1 = _getClass1("NSDateInterval");
  late final _sel_taskInterval1 = _registerName1("taskInterval");
  ffi.Pointer<ObjCObject> _objc_msgSend_313(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_313(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_313Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_313 = __objc_msgSend_313Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_redirectCount1 = _registerName1("redirectCount");

  /// A string constant for the "file" URL scheme. If you are using this to compare to a URL's scheme to see if it is a file URL, you should instead use the NSURL fileURL property -- the fileURL property is much faster.
  late final ffi.Pointer<ffi.Pointer<ObjCObject>> _NSURLFileScheme =
      _lookup<ffi.Pointer<ObjCObject>>('NSURLFileScheme');

  ffi.Pointer<ObjCObject> get NSURLFileScheme => _NSURLFileScheme.value;

  set NSURLFileScheme(ffi.Pointer<ObjCObject> value) =>
      _NSURLFileScheme.value = value;

  /// Key for the resource properties that have not been set after setResourceValues:error: returns an error, returned as an array of of strings.
  late final ffi.Pointer<NSURLResourceKey> _NSURLKeysOfUnsetValuesKey =
      _lookup<NSURLResourceKey>('NSURLKeysOfUnsetValuesKey');

  NSURLResourceKey get NSURLKeysOfUnsetValuesKey =>
      _NSURLKeysOfUnsetValuesKey.value;

  set NSURLKeysOfUnsetValuesKey(NSURLResourceKey value) =>
      _NSURLKeysOfUnsetValuesKey.value = value;

  /// The resource name provided by the file system (Read-write, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLNameKey =
      _lookup<NSURLResourceKey>('NSURLNameKey');

  NSURLResourceKey get NSURLNameKey => _NSURLNameKey.value;

  set NSURLNameKey(NSURLResourceKey value) => _NSURLNameKey.value = value;

  /// Localized or extension-hidden name as displayed to users (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLocalizedNameKey =
      _lookup<NSURLResourceKey>('NSURLLocalizedNameKey');

  NSURLResourceKey get NSURLLocalizedNameKey => _NSURLLocalizedNameKey.value;

  set NSURLLocalizedNameKey(NSURLResourceKey value) =>
      _NSURLLocalizedNameKey.value = value;

  /// True for regular files (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsRegularFileKey =
      _lookup<NSURLResourceKey>('NSURLIsRegularFileKey');

  NSURLResourceKey get NSURLIsRegularFileKey => _NSURLIsRegularFileKey.value;

  set NSURLIsRegularFileKey(NSURLResourceKey value) =>
      _NSURLIsRegularFileKey.value = value;

  /// True for directories (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsDirectoryKey =
      _lookup<NSURLResourceKey>('NSURLIsDirectoryKey');

  NSURLResourceKey get NSURLIsDirectoryKey => _NSURLIsDirectoryKey.value;

  set NSURLIsDirectoryKey(NSURLResourceKey value) =>
      _NSURLIsDirectoryKey.value = value;

  /// True for symlinks (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsSymbolicLinkKey =
      _lookup<NSURLResourceKey>('NSURLIsSymbolicLinkKey');

  NSURLResourceKey get NSURLIsSymbolicLinkKey => _NSURLIsSymbolicLinkKey.value;

  set NSURLIsSymbolicLinkKey(NSURLResourceKey value) =>
      _NSURLIsSymbolicLinkKey.value = value;

  /// True for the root directory of a volume (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsVolumeKey =
      _lookup<NSURLResourceKey>('NSURLIsVolumeKey');

  NSURLResourceKey get NSURLIsVolumeKey => _NSURLIsVolumeKey.value;

  set NSURLIsVolumeKey(NSURLResourceKey value) =>
      _NSURLIsVolumeKey.value = value;

  /// True for packaged directories (Read-only 10_6 and 10_7, read-write 10_8, value type boolean NSNumber). Note: You can only set or clear this property on directories; if you try to set this property on non-directory objects, the property is ignored. If the directory is a package for some other reason (extension type, etc), setting this property to false will have no effect.
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsPackageKey =
      _lookup<NSURLResourceKey>('NSURLIsPackageKey');

  NSURLResourceKey get NSURLIsPackageKey => _NSURLIsPackageKey.value;

  set NSURLIsPackageKey(NSURLResourceKey value) =>
      _NSURLIsPackageKey.value = value;

  /// True if resource is an application (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsApplicationKey =
      _lookup<NSURLResourceKey>('NSURLIsApplicationKey');

  NSURLResourceKey get NSURLIsApplicationKey => _NSURLIsApplicationKey.value;

  set NSURLIsApplicationKey(NSURLResourceKey value) =>
      _NSURLIsApplicationKey.value = value;

  /// True if the resource is scriptable. Only applies to applications (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLApplicationIsScriptableKey =
      _lookup<NSURLResourceKey>('NSURLApplicationIsScriptableKey');

  NSURLResourceKey get NSURLApplicationIsScriptableKey =>
      _NSURLApplicationIsScriptableKey.value;

  set NSURLApplicationIsScriptableKey(NSURLResourceKey value) =>
      _NSURLApplicationIsScriptableKey.value = value;

  /// True for system-immutable resources (Read-write, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsSystemImmutableKey =
      _lookup<NSURLResourceKey>('NSURLIsSystemImmutableKey');

  NSURLResourceKey get NSURLIsSystemImmutableKey =>
      _NSURLIsSystemImmutableKey.value;

  set NSURLIsSystemImmutableKey(NSURLResourceKey value) =>
      _NSURLIsSystemImmutableKey.value = value;

  /// True for user-immutable resources (Read-write, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsUserImmutableKey =
      _lookup<NSURLResourceKey>('NSURLIsUserImmutableKey');

  NSURLResourceKey get NSURLIsUserImmutableKey =>
      _NSURLIsUserImmutableKey.value;

  set NSURLIsUserImmutableKey(NSURLResourceKey value) =>
      _NSURLIsUserImmutableKey.value = value;

  /// True for resources normally not displayed to users (Read-write, value type boolean NSNumber). Note: If the resource is a hidden because its name starts with a period, setting this property to false will not change the property.
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsHiddenKey =
      _lookup<NSURLResourceKey>('NSURLIsHiddenKey');

  NSURLResourceKey get NSURLIsHiddenKey => _NSURLIsHiddenKey.value;

  set NSURLIsHiddenKey(NSURLResourceKey value) =>
      _NSURLIsHiddenKey.value = value;

  /// True for resources whose filename extension is removed from the localized name property (Read-write, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLHasHiddenExtensionKey =
      _lookup<NSURLResourceKey>('NSURLHasHiddenExtensionKey');

  NSURLResourceKey get NSURLHasHiddenExtensionKey =>
      _NSURLHasHiddenExtensionKey.value;

  set NSURLHasHiddenExtensionKey(NSURLResourceKey value) =>
      _NSURLHasHiddenExtensionKey.value = value;

  /// The date the resource was created (Read-write, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLCreationDateKey =
      _lookup<NSURLResourceKey>('NSURLCreationDateKey');

  NSURLResourceKey get NSURLCreationDateKey => _NSURLCreationDateKey.value;

  set NSURLCreationDateKey(NSURLResourceKey value) =>
      _NSURLCreationDateKey.value = value;

  /// The date the resource was last accessed (Read-write, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLContentAccessDateKey =
      _lookup<NSURLResourceKey>('NSURLContentAccessDateKey');

  NSURLResourceKey get NSURLContentAccessDateKey =>
      _NSURLContentAccessDateKey.value;

  set NSURLContentAccessDateKey(NSURLResourceKey value) =>
      _NSURLContentAccessDateKey.value = value;

  /// The time the resource content was last modified (Read-write, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLContentModificationDateKey =
      _lookup<NSURLResourceKey>('NSURLContentModificationDateKey');

  NSURLResourceKey get NSURLContentModificationDateKey =>
      _NSURLContentModificationDateKey.value;

  set NSURLContentModificationDateKey(NSURLResourceKey value) =>
      _NSURLContentModificationDateKey.value = value;

  /// The time the resource's attributes were last modified (Read-only, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLAttributeModificationDateKey =
      _lookup<NSURLResourceKey>('NSURLAttributeModificationDateKey');

  NSURLResourceKey get NSURLAttributeModificationDateKey =>
      _NSURLAttributeModificationDateKey.value;

  set NSURLAttributeModificationDateKey(NSURLResourceKey value) =>
      _NSURLAttributeModificationDateKey.value = value;

  /// Number of hard links to the resource (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLinkCountKey =
      _lookup<NSURLResourceKey>('NSURLLinkCountKey');

  NSURLResourceKey get NSURLLinkCountKey => _NSURLLinkCountKey.value;

  set NSURLLinkCountKey(NSURLResourceKey value) =>
      _NSURLLinkCountKey.value = value;

  /// The resource's parent directory, if any (Read-only, value type NSURL)
  late final ffi.Pointer<NSURLResourceKey> _NSURLParentDirectoryURLKey =
      _lookup<NSURLResourceKey>('NSURLParentDirectoryURLKey');

  NSURLResourceKey get NSURLParentDirectoryURLKey =>
      _NSURLParentDirectoryURLKey.value;

  set NSURLParentDirectoryURLKey(NSURLResourceKey value) =>
      _NSURLParentDirectoryURLKey.value = value;

  /// URL of the volume on which the resource is stored (Read-only, value type NSURL)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeURLKey =
      _lookup<NSURLResourceKey>('NSURLVolumeURLKey');

  NSURLResourceKey get NSURLVolumeURLKey => _NSURLVolumeURLKey.value;

  set NSURLVolumeURLKey(NSURLResourceKey value) =>
      _NSURLVolumeURLKey.value = value;

  /// Uniform type identifier (UTI) for the resource (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLTypeIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLTypeIdentifierKey');

  NSURLResourceKey get NSURLTypeIdentifierKey => _NSURLTypeIdentifierKey.value;

  set NSURLTypeIdentifierKey(NSURLResourceKey value) =>
      _NSURLTypeIdentifierKey.value = value;

  /// File type (UTType) for the resource (Read-only, value type UTType)
  late final ffi.Pointer<NSURLResourceKey> _NSURLContentTypeKey =
      _lookup<NSURLResourceKey>('NSURLContentTypeKey');

  NSURLResourceKey get NSURLContentTypeKey => _NSURLContentTypeKey.value;

  set NSURLContentTypeKey(NSURLResourceKey value) =>
      _NSURLContentTypeKey.value = value;

  /// User-visible type or "kind" description (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLocalizedTypeDescriptionKey =
      _lookup<NSURLResourceKey>('NSURLLocalizedTypeDescriptionKey');

  NSURLResourceKey get NSURLLocalizedTypeDescriptionKey =>
      _NSURLLocalizedTypeDescriptionKey.value;

  set NSURLLocalizedTypeDescriptionKey(NSURLResourceKey value) =>
      _NSURLLocalizedTypeDescriptionKey.value = value;

  /// The label number assigned to the resource (Read-write, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLabelNumberKey =
      _lookup<NSURLResourceKey>('NSURLLabelNumberKey');

  NSURLResourceKey get NSURLLabelNumberKey => _NSURLLabelNumberKey.value;

  set NSURLLabelNumberKey(NSURLResourceKey value) =>
      _NSURLLabelNumberKey.value = value;

  /// The color of the assigned label (Read-only, value type NSColor)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLabelColorKey =
      _lookup<NSURLResourceKey>('NSURLLabelColorKey');

  NSURLResourceKey get NSURLLabelColorKey => _NSURLLabelColorKey.value;

  set NSURLLabelColorKey(NSURLResourceKey value) =>
      _NSURLLabelColorKey.value = value;

  /// The user-visible label text (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLocalizedLabelKey =
      _lookup<NSURLResourceKey>('NSURLLocalizedLabelKey');

  NSURLResourceKey get NSURLLocalizedLabelKey => _NSURLLocalizedLabelKey.value;

  set NSURLLocalizedLabelKey(NSURLResourceKey value) =>
      _NSURLLocalizedLabelKey.value = value;

  /// The icon normally displayed for the resource (Read-only, value type NSImage)
  late final ffi.Pointer<NSURLResourceKey> _NSURLEffectiveIconKey =
      _lookup<NSURLResourceKey>('NSURLEffectiveIconKey');

  NSURLResourceKey get NSURLEffectiveIconKey => _NSURLEffectiveIconKey.value;

  set NSURLEffectiveIconKey(NSURLResourceKey value) =>
      _NSURLEffectiveIconKey.value = value;

  /// The custom icon assigned to the resource, if any (Currently not implemented, value type NSImage)
  late final ffi.Pointer<NSURLResourceKey> _NSURLCustomIconKey =
      _lookup<NSURLResourceKey>('NSURLCustomIconKey');

  NSURLResourceKey get NSURLCustomIconKey => _NSURLCustomIconKey.value;

  set NSURLCustomIconKey(NSURLResourceKey value) =>
      _NSURLCustomIconKey.value = value;

  /// An identifier which can be used to compare two file system objects for equality using -isEqual (i.e, two object identifiers are equal if they have the same file system path or if the paths are linked to same inode on the same file system). This identifier is not persistent across system restarts. (Read-only, value type id <NSCopying, NSCoding, NSSecureCoding, NSObject>)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileResourceIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLFileResourceIdentifierKey');

  NSURLResourceKey get NSURLFileResourceIdentifierKey =>
      _NSURLFileResourceIdentifierKey.value;

  set NSURLFileResourceIdentifierKey(NSURLResourceKey value) =>
      _NSURLFileResourceIdentifierKey.value = value;

  /// An identifier that can be used to identify the volume the file system object is on. Other objects on the same volume will have the same volume identifier and can be compared using for equality using -isEqual. This identifier is not persistent across system restarts. (Read-only, value type id <NSCopying, NSCoding, NSSecureCoding, NSObject>)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIdentifierKey');

  NSURLResourceKey get NSURLVolumeIdentifierKey =>
      _NSURLVolumeIdentifierKey.value;

  set NSURLVolumeIdentifierKey(NSURLResourceKey value) =>
      _NSURLVolumeIdentifierKey.value = value;

  /// The optimal block size when reading or writing this file's data, or nil if not available. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLPreferredIOBlockSizeKey =
      _lookup<NSURLResourceKey>('NSURLPreferredIOBlockSizeKey');

  NSURLResourceKey get NSURLPreferredIOBlockSizeKey =>
      _NSURLPreferredIOBlockSizeKey.value;

  set NSURLPreferredIOBlockSizeKey(NSURLResourceKey value) =>
      _NSURLPreferredIOBlockSizeKey.value = value;

  /// true if this process (as determined by EUID) can read the resource. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsReadableKey =
      _lookup<NSURLResourceKey>('NSURLIsReadableKey');

  NSURLResourceKey get NSURLIsReadableKey => _NSURLIsReadableKey.value;

  set NSURLIsReadableKey(NSURLResourceKey value) =>
      _NSURLIsReadableKey.value = value;

  /// true if this process (as determined by EUID) can write to the resource. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsWritableKey =
      _lookup<NSURLResourceKey>('NSURLIsWritableKey');

  NSURLResourceKey get NSURLIsWritableKey => _NSURLIsWritableKey.value;

  set NSURLIsWritableKey(NSURLResourceKey value) =>
      _NSURLIsWritableKey.value = value;

  /// true if this process (as determined by EUID) can execute a file resource or search a directory resource. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsExecutableKey =
      _lookup<NSURLResourceKey>('NSURLIsExecutableKey');

  NSURLResourceKey get NSURLIsExecutableKey => _NSURLIsExecutableKey.value;

  set NSURLIsExecutableKey(NSURLResourceKey value) =>
      _NSURLIsExecutableKey.value = value;

  /// The file system object's security information encapsulated in a NSFileSecurity object. (Read-write, Value type NSFileSecurity)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileSecurityKey =
      _lookup<NSURLResourceKey>('NSURLFileSecurityKey');

  NSURLResourceKey get NSURLFileSecurityKey => _NSURLFileSecurityKey.value;

  set NSURLFileSecurityKey(NSURLResourceKey value) =>
      _NSURLFileSecurityKey.value = value;

  /// true if resource should be excluded from backups, false otherwise (Read-write, value type boolean NSNumber). This property is only useful for excluding cache and other application support files which are not needed in a backup. Some operations commonly made to user documents will cause this property to be reset to false and so this property should not be used on user documents.
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsExcludedFromBackupKey =
      _lookup<NSURLResourceKey>('NSURLIsExcludedFromBackupKey');

  NSURLResourceKey get NSURLIsExcludedFromBackupKey =>
      _NSURLIsExcludedFromBackupKey.value;

  set NSURLIsExcludedFromBackupKey(NSURLResourceKey value) =>
      _NSURLIsExcludedFromBackupKey.value = value;

  /// The array of Tag names (Read-write, value type NSArray of NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLTagNamesKey =
      _lookup<NSURLResourceKey>('NSURLTagNamesKey');

  NSURLResourceKey get NSURLTagNamesKey => _NSURLTagNamesKey.value;

  set NSURLTagNamesKey(NSURLResourceKey value) =>
      _NSURLTagNamesKey.value = value;

  /// the URL's path as a file system path (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLPathKey =
      _lookup<NSURLResourceKey>('NSURLPathKey');

  NSURLResourceKey get NSURLPathKey => _NSURLPathKey.value;

  set NSURLPathKey(NSURLResourceKey value) => _NSURLPathKey.value = value;

  /// the URL's path as a canonical absolute file system path (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLCanonicalPathKey =
      _lookup<NSURLResourceKey>('NSURLCanonicalPathKey');

  NSURLResourceKey get NSURLCanonicalPathKey => _NSURLCanonicalPathKey.value;

  set NSURLCanonicalPathKey(NSURLResourceKey value) =>
      _NSURLCanonicalPathKey.value = value;

  /// true if this URL is a file system trigger directory. Traversing or opening a file system trigger will cause an attempt to mount a file system on the trigger directory. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsMountTriggerKey =
      _lookup<NSURLResourceKey>('NSURLIsMountTriggerKey');

  NSURLResourceKey get NSURLIsMountTriggerKey => _NSURLIsMountTriggerKey.value;

  set NSURLIsMountTriggerKey(NSURLResourceKey value) =>
      _NSURLIsMountTriggerKey.value = value;

  /// An opaque generation identifier which can be compared using isEqual: to determine if the data in a document has been modified. For URLs which refer to the same file inode, the generation identifier will change when the data in the file's data fork is changed (changes to extended attributes or other file system metadata do not change the generation identifier). For URLs which refer to the same directory inode, the generation identifier will change when direct children of that directory are added, removed or renamed (changes to the data of the direct children of that directory will not change the generation identifier). The generation identifier is persistent across system restarts. The generation identifier is tied to a specific document on a specific volume and is not transferred when the document is copied to another volume. This property is not supported by all volumes. (Read-only, value type id <NSCopying, NSCoding, NSSecureCoding, NSObject>)
  late final ffi.Pointer<NSURLResourceKey> _NSURLGenerationIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLGenerationIdentifierKey');

  NSURLResourceKey get NSURLGenerationIdentifierKey =>
      _NSURLGenerationIdentifierKey.value;

  set NSURLGenerationIdentifierKey(NSURLResourceKey value) =>
      _NSURLGenerationIdentifierKey.value = value;

  /// The document identifier -- a value assigned by the kernel to a document (which can be either a file or directory) and is used to identify the document regardless of where it gets moved on a volume. The document identifier survives "safe save” operations; i.e it is sticky to the path it was assigned to (-replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error: is the preferred safe-save API). The document identifier is persistent across system restarts. The document identifier is not transferred when the file is copied. Document identifiers are only unique within a single volume. This property is not supported by all volumes. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLDocumentIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLDocumentIdentifierKey');

  NSURLResourceKey get NSURLDocumentIdentifierKey =>
      _NSURLDocumentIdentifierKey.value;

  set NSURLDocumentIdentifierKey(NSURLResourceKey value) =>
      _NSURLDocumentIdentifierKey.value = value;

  /// The date the resource was created, or renamed into or within its parent directory. Note that inconsistent behavior may be observed when this attribute is requested on hard-linked items. This property is not supported by all volumes. (Read-only before macOS 10.15, iOS 13.0, watchOS 6.0, and tvOS 13.0; Read-write after, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLAddedToDirectoryDateKey =
      _lookup<NSURLResourceKey>('NSURLAddedToDirectoryDateKey');

  NSURLResourceKey get NSURLAddedToDirectoryDateKey =>
      _NSURLAddedToDirectoryDateKey.value;

  set NSURLAddedToDirectoryDateKey(NSURLResourceKey value) =>
      _NSURLAddedToDirectoryDateKey.value = value;

  /// The quarantine properties as defined in LSQuarantine.h. To remove quarantine information from a file, pass NSNull as the value when setting this property. (Read-write, value type NSDictionary)
  late final ffi.Pointer<NSURLResourceKey> _NSURLQuarantinePropertiesKey =
      _lookup<NSURLResourceKey>('NSURLQuarantinePropertiesKey');

  NSURLResourceKey get NSURLQuarantinePropertiesKey =>
      _NSURLQuarantinePropertiesKey.value;

  set NSURLQuarantinePropertiesKey(NSURLResourceKey value) =>
      _NSURLQuarantinePropertiesKey.value = value;

  /// Returns the file system object type. (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileResourceTypeKey =
      _lookup<NSURLResourceKey>('NSURLFileResourceTypeKey');

  NSURLResourceKey get NSURLFileResourceTypeKey =>
      _NSURLFileResourceTypeKey.value;

  set NSURLFileResourceTypeKey(NSURLResourceKey value) =>
      _NSURLFileResourceTypeKey.value = value;

  /// A 64-bit value assigned by APFS that identifies a file's content data stream. Only cloned files and their originals can have the same identifier. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileContentIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLFileContentIdentifierKey');

  NSURLResourceKey get NSURLFileContentIdentifierKey =>
      _NSURLFileContentIdentifierKey.value;

  set NSURLFileContentIdentifierKey(NSURLResourceKey value) =>
      _NSURLFileContentIdentifierKey.value = value;

  /// True for cloned files and their originals that may share all, some, or no data blocks. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLMayShareFileContentKey =
      _lookup<NSURLResourceKey>('NSURLMayShareFileContentKey');

  NSURLResourceKey get NSURLMayShareFileContentKey =>
      _NSURLMayShareFileContentKey.value;

  set NSURLMayShareFileContentKey(NSURLResourceKey value) =>
      _NSURLMayShareFileContentKey.value = value;

  /// True if the file has extended attributes. False guarantees there are none. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLMayHaveExtendedAttributesKey =
      _lookup<NSURLResourceKey>('NSURLMayHaveExtendedAttributesKey');

  NSURLResourceKey get NSURLMayHaveExtendedAttributesKey =>
      _NSURLMayHaveExtendedAttributesKey.value;

  set NSURLMayHaveExtendedAttributesKey(NSURLResourceKey value) =>
      _NSURLMayHaveExtendedAttributesKey.value = value;

  /// True if the file can be deleted by the file system when asked to free space. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsPurgeableKey =
      _lookup<NSURLResourceKey>('NSURLIsPurgeableKey');

  NSURLResourceKey get NSURLIsPurgeableKey => _NSURLIsPurgeableKey.value;

  set NSURLIsPurgeableKey(NSURLResourceKey value) =>
      _NSURLIsPurgeableKey.value = value;

  /// True if the file has sparse regions. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsSparseKey =
      _lookup<NSURLResourceKey>('NSURLIsSparseKey');

  NSURLResourceKey get NSURLIsSparseKey => _NSURLIsSparseKey.value;

  set NSURLIsSparseKey(NSURLResourceKey value) =>
      _NSURLIsSparseKey.value = value;

  /// The file system object type values returned for the NSURLFileResourceTypeKey
  late final ffi.Pointer<NSURLFileResourceType>
      _NSURLFileResourceTypeNamedPipe =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeNamedPipe');

  NSURLFileResourceType get NSURLFileResourceTypeNamedPipe =>
      _NSURLFileResourceTypeNamedPipe.value;

  set NSURLFileResourceTypeNamedPipe(NSURLFileResourceType value) =>
      _NSURLFileResourceTypeNamedPipe.value = value;

  late final ffi.Pointer<NSURLFileResourceType>
      _NSURLFileResourceTypeCharacterSpecial =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeCharacterSpecial');

  NSURLFileResourceType get NSURLFileResourceTypeCharacterSpecial =>
      _NSURLFileResourceTypeCharacterSpecial.value;

  set NSURLFileResourceTypeCharacterSpecial(NSURLFileResourceType value) =>
      _NSURLFileResourceTypeCharacterSpecial.value = value;

  late final ffi.Pointer<NSURLFileResourceType>
      _NSURLFileResourceTypeDirectory =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeDirectory');

  NSURLFileResourceType get NSURLFileResourceTypeDirectory =>
      _NSURLFileResourceTypeDirectory.value;

  set NSURLFileResourceTypeDirectory(NSURLFileResourceType value) =>
      _NSURLFileResourceTypeDirectory.value = value;

  late final ffi.Pointer<NSURLFileResourceType>
      _NSURLFileResourceTypeBlockSpecial =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeBlockSpecial');

  NSURLFileResourceType get NSURLFileResourceTypeBlockSpecial =>
      _NSURLFileResourceTypeBlockSpecial.value;

  set NSURLFileResourceTypeBlockSpecial(NSURLFileResourceType value) =>
      _NSURLFileResourceTypeBlockSpecial.value = value;

  late final ffi.Pointer<NSURLFileResourceType> _NSURLFileResourceTypeRegular =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeRegular');

  NSURLFileResourceType get NSURLFileResourceTypeRegular =>
      _NSURLFileResourceTypeRegular.value;

  set NSURLFileResourceTypeRegular(NSURLFileResourceType value) =>
      _NSURLFileResourceTypeRegular.value = value;

  late final ffi.Pointer<NSURLFileResourceType>
      _NSURLFileResourceTypeSymbolicLink =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeSymbolicLink');

  NSURLFileResourceType get NSURLFileResourceTypeSymbolicLink =>
      _NSURLFileResourceTypeSymbolicLink.value;

  set NSURLFileResourceTypeSymbolicLink(NSURLFileResourceType value) =>
      _NSURLFileResourceTypeSymbolicLink.value = value;

  late final ffi.Pointer<NSURLFileResourceType> _NSURLFileResourceTypeSocket =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeSocket');

  NSURLFileResourceType get NSURLFileResourceTypeSocket =>
      _NSURLFileResourceTypeSocket.value;

  set NSURLFileResourceTypeSocket(NSURLFileResourceType value) =>
      _NSURLFileResourceTypeSocket.value = value;

  late final ffi.Pointer<NSURLFileResourceType> _NSURLFileResourceTypeUnknown =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeUnknown');

  NSURLFileResourceType get NSURLFileResourceTypeUnknown =>
      _NSURLFileResourceTypeUnknown.value;

  set NSURLFileResourceTypeUnknown(NSURLFileResourceType value) =>
      _NSURLFileResourceTypeUnknown.value = value;

  /// dictionary of NSImage/UIImage objects keyed by size
  late final ffi.Pointer<NSURLResourceKey> _NSURLThumbnailDictionaryKey =
      _lookup<NSURLResourceKey>('NSURLThumbnailDictionaryKey');

  NSURLResourceKey get NSURLThumbnailDictionaryKey =>
      _NSURLThumbnailDictionaryKey.value;

  set NSURLThumbnailDictionaryKey(NSURLResourceKey value) =>
      _NSURLThumbnailDictionaryKey.value = value;

  /// returns all thumbnails as a single NSImage
  late final ffi.Pointer<NSURLResourceKey> _NSURLThumbnailKey =
      _lookup<NSURLResourceKey>('NSURLThumbnailKey');

  NSURLResourceKey get NSURLThumbnailKey => _NSURLThumbnailKey.value;

  set NSURLThumbnailKey(NSURLResourceKey value) =>
      _NSURLThumbnailKey.value = value;

  /// size key for a 1024 x 1024 thumbnail image
  late final ffi.Pointer<NSURLThumbnailDictionaryItem>
      _NSThumbnail1024x1024SizeKey =
      _lookup<NSURLThumbnailDictionaryItem>('NSThumbnail1024x1024SizeKey');

  NSURLThumbnailDictionaryItem get NSThumbnail1024x1024SizeKey =>
      _NSThumbnail1024x1024SizeKey.value;

  set NSThumbnail1024x1024SizeKey(NSURLThumbnailDictionaryItem value) =>
      _NSThumbnail1024x1024SizeKey.value = value;

  /// Total file size in bytes (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileSizeKey =
      _lookup<NSURLResourceKey>('NSURLFileSizeKey');

  NSURLResourceKey get NSURLFileSizeKey => _NSURLFileSizeKey.value;

  set NSURLFileSizeKey(NSURLResourceKey value) =>
      _NSURLFileSizeKey.value = value;

  /// Total size allocated on disk for the file in bytes (number of blocks times block size) (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileAllocatedSizeKey =
      _lookup<NSURLResourceKey>('NSURLFileAllocatedSizeKey');

  NSURLResourceKey get NSURLFileAllocatedSizeKey =>
      _NSURLFileAllocatedSizeKey.value;

  set NSURLFileAllocatedSizeKey(NSURLResourceKey value) =>
      _NSURLFileAllocatedSizeKey.value = value;

  /// Total displayable size of the file in bytes (this may include space used by metadata), or nil if not available. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLTotalFileSizeKey =
      _lookup<NSURLResourceKey>('NSURLTotalFileSizeKey');

  NSURLResourceKey get NSURLTotalFileSizeKey => _NSURLTotalFileSizeKey.value;

  set NSURLTotalFileSizeKey(NSURLResourceKey value) =>
      _NSURLTotalFileSizeKey.value = value;

  /// Total allocated size of the file in bytes (this may include space used by metadata), or nil if not available. This can be less than the value returned by NSURLTotalFileSizeKey if the resource is compressed. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLTotalFileAllocatedSizeKey =
      _lookup<NSURLResourceKey>('NSURLTotalFileAllocatedSizeKey');

  NSURLResourceKey get NSURLTotalFileAllocatedSizeKey =>
      _NSURLTotalFileAllocatedSizeKey.value;

  set NSURLTotalFileAllocatedSizeKey(NSURLResourceKey value) =>
      _NSURLTotalFileAllocatedSizeKey.value = value;

  /// true if the resource is a Finder alias file or a symlink, false otherwise ( Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsAliasFileKey =
      _lookup<NSURLResourceKey>('NSURLIsAliasFileKey');

  NSURLResourceKey get NSURLIsAliasFileKey => _NSURLIsAliasFileKey.value;

  set NSURLIsAliasFileKey(NSURLResourceKey value) =>
      _NSURLIsAliasFileKey.value = value;

  /// The protection level for this file
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileProtectionKey =
      _lookup<NSURLResourceKey>('NSURLFileProtectionKey');

  NSURLResourceKey get NSURLFileProtectionKey => _NSURLFileProtectionKey.value;

  set NSURLFileProtectionKey(NSURLResourceKey value) =>
      _NSURLFileProtectionKey.value = value;

  /// The file has no special protections associated with it. It can be read from or written to at any time.
  late final ffi.Pointer<NSURLFileProtectionType> _NSURLFileProtectionNone =
      _lookup<NSURLFileProtectionType>('NSURLFileProtectionNone');

  NSURLFileProtectionType get NSURLFileProtectionNone =>
      _NSURLFileProtectionNone.value;

  set NSURLFileProtectionNone(NSURLFileProtectionType value) =>
      _NSURLFileProtectionNone.value = value;

  /// The file is stored in an encrypted format on disk and cannot be read from or written to while the device is locked or booting.
  late final ffi.Pointer<NSURLFileProtectionType> _NSURLFileProtectionComplete =
      _lookup<NSURLFileProtectionType>('NSURLFileProtectionComplete');

  NSURLFileProtectionType get NSURLFileProtectionComplete =>
      _NSURLFileProtectionComplete.value;

  set NSURLFileProtectionComplete(NSURLFileProtectionType value) =>
      _NSURLFileProtectionComplete.value = value;

  /// The file is stored in an encrypted format on disk. Files can be created while the device is locked, but once closed, cannot be opened again until the device is unlocked. If the file is opened when unlocked, you may continue to access the file normally, even if the user locks the device. There is a small performance penalty when the file is created and opened, though not when being written to or read from. This can be mitigated by changing the file protection to NSURLFileProtectionComplete when the device is unlocked.
  late final ffi.Pointer<NSURLFileProtectionType>
      _NSURLFileProtectionCompleteUnlessOpen =
      _lookup<NSURLFileProtectionType>('NSURLFileProtectionCompleteUnlessOpen');

  NSURLFileProtectionType get NSURLFileProtectionCompleteUnlessOpen =>
      _NSURLFileProtectionCompleteUnlessOpen.value;

  set NSURLFileProtectionCompleteUnlessOpen(NSURLFileProtectionType value) =>
      _NSURLFileProtectionCompleteUnlessOpen.value = value;

  /// The file is stored in an encrypted format on disk and cannot be accessed until after the device has booted. After the user unlocks the device for the first time, your app can access the file and continue to access it even if the user subsequently locks the device.
  late final ffi.Pointer<NSURLFileProtectionType>
      _NSURLFileProtectionCompleteUntilFirstUserAuthentication =
      _lookup<NSURLFileProtectionType>(
          'NSURLFileProtectionCompleteUntilFirstUserAuthentication');

  NSURLFileProtectionType
      get NSURLFileProtectionCompleteUntilFirstUserAuthentication =>
          _NSURLFileProtectionCompleteUntilFirstUserAuthentication.value;

  set NSURLFileProtectionCompleteUntilFirstUserAuthentication(
          NSURLFileProtectionType value) =>
      _NSURLFileProtectionCompleteUntilFirstUserAuthentication.value = value;

  /// The user-visible volume format (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeLocalizedFormatDescriptionKey =
      _lookup<NSURLResourceKey>('NSURLVolumeLocalizedFormatDescriptionKey');

  NSURLResourceKey get NSURLVolumeLocalizedFormatDescriptionKey =>
      _NSURLVolumeLocalizedFormatDescriptionKey.value;

  set NSURLVolumeLocalizedFormatDescriptionKey(NSURLResourceKey value) =>
      _NSURLVolumeLocalizedFormatDescriptionKey.value = value;

  /// Total volume capacity in bytes (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeTotalCapacityKey =
      _lookup<NSURLResourceKey>('NSURLVolumeTotalCapacityKey');

  NSURLResourceKey get NSURLVolumeTotalCapacityKey =>
      _NSURLVolumeTotalCapacityKey.value;

  set NSURLVolumeTotalCapacityKey(NSURLResourceKey value) =>
      _NSURLVolumeTotalCapacityKey.value = value;

  /// Total free space in bytes (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeAvailableCapacityKey =
      _lookup<NSURLResourceKey>('NSURLVolumeAvailableCapacityKey');

  NSURLResourceKey get NSURLVolumeAvailableCapacityKey =>
      _NSURLVolumeAvailableCapacityKey.value;

  set NSURLVolumeAvailableCapacityKey(NSURLResourceKey value) =>
      _NSURLVolumeAvailableCapacityKey.value = value;

  /// Total number of resources on the volume (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeResourceCountKey =
      _lookup<NSURLResourceKey>('NSURLVolumeResourceCountKey');

  NSURLResourceKey get NSURLVolumeResourceCountKey =>
      _NSURLVolumeResourceCountKey.value;

  set NSURLVolumeResourceCountKey(NSURLResourceKey value) =>
      _NSURLVolumeResourceCountKey.value = value;

  /// true if the volume format supports persistent object identifiers and can look up file system objects by their IDs (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsPersistentIDsKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsPersistentIDsKey');

  NSURLResourceKey get NSURLVolumeSupportsPersistentIDsKey =>
      _NSURLVolumeSupportsPersistentIDsKey.value;

  set NSURLVolumeSupportsPersistentIDsKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsPersistentIDsKey.value = value;

  /// true if the volume format supports symbolic links (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsSymbolicLinksKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsSymbolicLinksKey');

  NSURLResourceKey get NSURLVolumeSupportsSymbolicLinksKey =>
      _NSURLVolumeSupportsSymbolicLinksKey.value;

  set NSURLVolumeSupportsSymbolicLinksKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsSymbolicLinksKey.value = value;

  /// true if the volume format supports hard links (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsHardLinksKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsHardLinksKey');

  NSURLResourceKey get NSURLVolumeSupportsHardLinksKey =>
      _NSURLVolumeSupportsHardLinksKey.value;

  set NSURLVolumeSupportsHardLinksKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsHardLinksKey.value = value;

  /// true if the volume format supports a journal used to speed recovery in case of unplanned restart (such as a power outage or crash). This does not necessarily mean the volume is actively using a journal. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsJournalingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsJournalingKey');

  NSURLResourceKey get NSURLVolumeSupportsJournalingKey =>
      _NSURLVolumeSupportsJournalingKey.value;

  set NSURLVolumeSupportsJournalingKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsJournalingKey.value = value;

  /// true if the volume is currently using a journal for speedy recovery after an unplanned restart. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsJournalingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsJournalingKey');

  NSURLResourceKey get NSURLVolumeIsJournalingKey =>
      _NSURLVolumeIsJournalingKey.value;

  set NSURLVolumeIsJournalingKey(NSURLResourceKey value) =>
      _NSURLVolumeIsJournalingKey.value = value;

  /// true if the volume format supports sparse files, that is, files which can have 'holes' that have never been written to, and thus do not consume space on disk. A sparse file may have an allocated size on disk that is less than its logical length (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsSparseFilesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsSparseFilesKey');

  NSURLResourceKey get NSURLVolumeSupportsSparseFilesKey =>
      _NSURLVolumeSupportsSparseFilesKey.value;

  set NSURLVolumeSupportsSparseFilesKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsSparseFilesKey.value = value;

  /// For security reasons, parts of a file (runs) that have never been written to must appear to contain zeroes. true if the volume keeps track of allocated but unwritten runs of a file so that it can substitute zeroes without actually writing zeroes to the media. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsZeroRunsKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsZeroRunsKey');

  NSURLResourceKey get NSURLVolumeSupportsZeroRunsKey =>
      _NSURLVolumeSupportsZeroRunsKey.value;

  set NSURLVolumeSupportsZeroRunsKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsZeroRunsKey.value = value;

  /// true if the volume format treats upper and lower case characters in file and directory names as different. Otherwise an upper case character is equivalent to a lower case character, and you can't have two names that differ solely in the case of the characters. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsCaseSensitiveNamesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsCaseSensitiveNamesKey');

  NSURLResourceKey get NSURLVolumeSupportsCaseSensitiveNamesKey =>
      _NSURLVolumeSupportsCaseSensitiveNamesKey.value;

  set NSURLVolumeSupportsCaseSensitiveNamesKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsCaseSensitiveNamesKey.value = value;

  /// true if the volume format preserves the case of file and directory names.  Otherwise the volume may change the case of some characters (typically making them all upper or all lower case). (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsCasePreservedNamesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsCasePreservedNamesKey');

  NSURLResourceKey get NSURLVolumeSupportsCasePreservedNamesKey =>
      _NSURLVolumeSupportsCasePreservedNamesKey.value;

  set NSURLVolumeSupportsCasePreservedNamesKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsCasePreservedNamesKey.value = value;

  /// true if the volume supports reliable storage of times for the root directory. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsRootDirectoryDatesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsRootDirectoryDatesKey');

  NSURLResourceKey get NSURLVolumeSupportsRootDirectoryDatesKey =>
      _NSURLVolumeSupportsRootDirectoryDatesKey.value;

  set NSURLVolumeSupportsRootDirectoryDatesKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsRootDirectoryDatesKey.value = value;

  /// true if the volume supports returning volume size values (NSURLVolumeTotalCapacityKey and NSURLVolumeAvailableCapacityKey). (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsVolumeSizesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsVolumeSizesKey');

  NSURLResourceKey get NSURLVolumeSupportsVolumeSizesKey =>
      _NSURLVolumeSupportsVolumeSizesKey.value;

  set NSURLVolumeSupportsVolumeSizesKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsVolumeSizesKey.value = value;

  /// true if the volume can be renamed. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsRenamingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsRenamingKey');

  NSURLResourceKey get NSURLVolumeSupportsRenamingKey =>
      _NSURLVolumeSupportsRenamingKey.value;

  set NSURLVolumeSupportsRenamingKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsRenamingKey.value = value;

  /// true if the volume implements whole-file flock(2) style advisory locks, and the O_EXLOCK and O_SHLOCK flags of the open(2) call. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsAdvisoryFileLockingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsAdvisoryFileLockingKey');

  NSURLResourceKey get NSURLVolumeSupportsAdvisoryFileLockingKey =>
      _NSURLVolumeSupportsAdvisoryFileLockingKey.value;

  set NSURLVolumeSupportsAdvisoryFileLockingKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsAdvisoryFileLockingKey.value = value;

  /// true if the volume implements extended security (ACLs). (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsExtendedSecurityKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsExtendedSecurityKey');

  NSURLResourceKey get NSURLVolumeSupportsExtendedSecurityKey =>
      _NSURLVolumeSupportsExtendedSecurityKey.value;

  set NSURLVolumeSupportsExtendedSecurityKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsExtendedSecurityKey.value = value;

  /// true if the volume should be visible via the GUI (i.e., appear on the Desktop as a separate volume). (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsBrowsableKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsBrowsableKey');

  NSURLResourceKey get NSURLVolumeIsBrowsableKey =>
      _NSURLVolumeIsBrowsableKey.value;

  set NSURLVolumeIsBrowsableKey(NSURLResourceKey value) =>
      _NSURLVolumeIsBrowsableKey.value = value;

  /// The largest file size (in bytes) supported by this file system, or nil if this cannot be determined. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeMaximumFileSizeKey =
      _lookup<NSURLResourceKey>('NSURLVolumeMaximumFileSizeKey');

  NSURLResourceKey get NSURLVolumeMaximumFileSizeKey =>
      _NSURLVolumeMaximumFileSizeKey.value;

  set NSURLVolumeMaximumFileSizeKey(NSURLResourceKey value) =>
      _NSURLVolumeMaximumFileSizeKey.value = value;

  /// true if the volume's media is ejectable from the drive mechanism under software control. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsEjectableKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsEjectableKey');

  NSURLResourceKey get NSURLVolumeIsEjectableKey =>
      _NSURLVolumeIsEjectableKey.value;

  set NSURLVolumeIsEjectableKey(NSURLResourceKey value) =>
      _NSURLVolumeIsEjectableKey.value = value;

  /// true if the volume's media is removable from the drive mechanism. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsRemovableKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsRemovableKey');

  NSURLResourceKey get NSURLVolumeIsRemovableKey =>
      _NSURLVolumeIsRemovableKey.value;

  set NSURLVolumeIsRemovableKey(NSURLResourceKey value) =>
      _NSURLVolumeIsRemovableKey.value = value;

  /// true if the volume's device is connected to an internal bus, false if connected to an external bus, or nil if not available. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsInternalKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsInternalKey');

  NSURLResourceKey get NSURLVolumeIsInternalKey =>
      _NSURLVolumeIsInternalKey.value;

  set NSURLVolumeIsInternalKey(NSURLResourceKey value) =>
      _NSURLVolumeIsInternalKey.value = value;

  /// true if the volume is automounted. Note: do not mistake this with the functionality provided by kCFURLVolumeSupportsBrowsingKey. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsAutomountedKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsAutomountedKey');

  NSURLResourceKey get NSURLVolumeIsAutomountedKey =>
      _NSURLVolumeIsAutomountedKey.value;

  set NSURLVolumeIsAutomountedKey(NSURLResourceKey value) =>
      _NSURLVolumeIsAutomountedKey.value = value;

  /// true if the volume is stored on a local device. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsLocalKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsLocalKey');

  NSURLResourceKey get NSURLVolumeIsLocalKey => _NSURLVolumeIsLocalKey.value;

  set NSURLVolumeIsLocalKey(NSURLResourceKey value) =>
      _NSURLVolumeIsLocalKey.value = value;

  /// true if the volume is read-only. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsReadOnlyKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsReadOnlyKey');

  NSURLResourceKey get NSURLVolumeIsReadOnlyKey =>
      _NSURLVolumeIsReadOnlyKey.value;

  set NSURLVolumeIsReadOnlyKey(NSURLResourceKey value) =>
      _NSURLVolumeIsReadOnlyKey.value = value;

  /// The volume's creation date, or nil if this cannot be determined. (Read-only, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeCreationDateKey =
      _lookup<NSURLResourceKey>('NSURLVolumeCreationDateKey');

  NSURLResourceKey get NSURLVolumeCreationDateKey =>
      _NSURLVolumeCreationDateKey.value;

  set NSURLVolumeCreationDateKey(NSURLResourceKey value) =>
      _NSURLVolumeCreationDateKey.value = value;

  /// The NSURL needed to remount a network volume, or nil if not available. (Read-only, value type NSURL)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeURLForRemountingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeURLForRemountingKey');

  NSURLResourceKey get NSURLVolumeURLForRemountingKey =>
      _NSURLVolumeURLForRemountingKey.value;

  set NSURLVolumeURLForRemountingKey(NSURLResourceKey value) =>
      _NSURLVolumeURLForRemountingKey.value = value;

  /// The volume's persistent UUID as a string, or nil if a persistent UUID is not available for the volume. (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeUUIDStringKey =
      _lookup<NSURLResourceKey>('NSURLVolumeUUIDStringKey');

  NSURLResourceKey get NSURLVolumeUUIDStringKey =>
      _NSURLVolumeUUIDStringKey.value;

  set NSURLVolumeUUIDStringKey(NSURLResourceKey value) =>
      _NSURLVolumeUUIDStringKey.value = value;

  /// The name of the volume (Read-write if NSURLVolumeSupportsRenamingKey is YES, otherwise read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeNameKey =
      _lookup<NSURLResourceKey>('NSURLVolumeNameKey');

  NSURLResourceKey get NSURLVolumeNameKey => _NSURLVolumeNameKey.value;

  set NSURLVolumeNameKey(NSURLResourceKey value) =>
      _NSURLVolumeNameKey.value = value;

  /// The user-presentable name of the volume (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeLocalizedNameKey =
      _lookup<NSURLResourceKey>('NSURLVolumeLocalizedNameKey');

  NSURLResourceKey get NSURLVolumeLocalizedNameKey =>
      _NSURLVolumeLocalizedNameKey.value;

  set NSURLVolumeLocalizedNameKey(NSURLResourceKey value) =>
      _NSURLVolumeLocalizedNameKey.value = value;

  /// true if the volume is encrypted. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsEncryptedKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsEncryptedKey');

  NSURLResourceKey get NSURLVolumeIsEncryptedKey =>
      _NSURLVolumeIsEncryptedKey.value;

  set NSURLVolumeIsEncryptedKey(NSURLResourceKey value) =>
      _NSURLVolumeIsEncryptedKey.value = value;

  /// true if the volume is the root filesystem. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsRootFileSystemKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsRootFileSystemKey');

  NSURLResourceKey get NSURLVolumeIsRootFileSystemKey =>
      _NSURLVolumeIsRootFileSystemKey.value;

  set NSURLVolumeIsRootFileSystemKey(NSURLResourceKey value) =>
      _NSURLVolumeIsRootFileSystemKey.value = value;

  /// true if the volume supports transparent decompression of compressed files using decmpfs. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsCompressionKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsCompressionKey');

  NSURLResourceKey get NSURLVolumeSupportsCompressionKey =>
      _NSURLVolumeSupportsCompressionKey.value;

  set NSURLVolumeSupportsCompressionKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsCompressionKey.value = value;

  /// true if the volume supports clonefile(2) (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsFileCloningKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsFileCloningKey');

  NSURLResourceKey get NSURLVolumeSupportsFileCloningKey =>
      _NSURLVolumeSupportsFileCloningKey.value;

  set NSURLVolumeSupportsFileCloningKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsFileCloningKey.value = value;

  /// true if the volume supports renamex_np(2)'s RENAME_SWAP option (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsSwapRenamingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsSwapRenamingKey');

  NSURLResourceKey get NSURLVolumeSupportsSwapRenamingKey =>
      _NSURLVolumeSupportsSwapRenamingKey.value;

  set NSURLVolumeSupportsSwapRenamingKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsSwapRenamingKey.value = value;

  /// true if the volume supports renamex_np(2)'s RENAME_EXCL option (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsExclusiveRenamingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsExclusiveRenamingKey');

  NSURLResourceKey get NSURLVolumeSupportsExclusiveRenamingKey =>
      _NSURLVolumeSupportsExclusiveRenamingKey.value;

  set NSURLVolumeSupportsExclusiveRenamingKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsExclusiveRenamingKey.value = value;

  /// true if the volume supports making files immutable with the NSURLIsUserImmutableKey or NSURLIsSystemImmutableKey properties (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsImmutableFilesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsImmutableFilesKey');

  NSURLResourceKey get NSURLVolumeSupportsImmutableFilesKey =>
      _NSURLVolumeSupportsImmutableFilesKey.value;

  set NSURLVolumeSupportsImmutableFilesKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsImmutableFilesKey.value = value;

  /// true if the volume supports setting POSIX access permissions with the NSURLFileSecurityKey property (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsAccessPermissionsKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsAccessPermissionsKey');

  NSURLResourceKey get NSURLVolumeSupportsAccessPermissionsKey =>
      _NSURLVolumeSupportsAccessPermissionsKey.value;

  set NSURLVolumeSupportsAccessPermissionsKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsAccessPermissionsKey.value = value;

  /// True if the volume supports the File Protection attribute (see NSURLFileProtectionKey). (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsFileProtectionKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsFileProtectionKey');

  NSURLResourceKey get NSURLVolumeSupportsFileProtectionKey =>
      _NSURLVolumeSupportsFileProtectionKey.value;

  set NSURLVolumeSupportsFileProtectionKey(NSURLResourceKey value) =>
      _NSURLVolumeSupportsFileProtectionKey.value = value;

  /// (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeAvailableCapacityForImportantUsageKey =
      _lookup<NSURLResourceKey>(
          'NSURLVolumeAvailableCapacityForImportantUsageKey');

  NSURLResourceKey get NSURLVolumeAvailableCapacityForImportantUsageKey =>
      _NSURLVolumeAvailableCapacityForImportantUsageKey.value;

  set NSURLVolumeAvailableCapacityForImportantUsageKey(
          NSURLResourceKey value) =>
      _NSURLVolumeAvailableCapacityForImportantUsageKey.value = value;

  /// (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeAvailableCapacityForOpportunisticUsageKey =
      _lookup<NSURLResourceKey>(
          'NSURLVolumeAvailableCapacityForOpportunisticUsageKey');

  NSURLResourceKey get NSURLVolumeAvailableCapacityForOpportunisticUsageKey =>
      _NSURLVolumeAvailableCapacityForOpportunisticUsageKey.value;

  set NSURLVolumeAvailableCapacityForOpportunisticUsageKey(
          NSURLResourceKey value) =>
      _NSURLVolumeAvailableCapacityForOpportunisticUsageKey.value = value;

  /// true if this item is synced to the cloud, false if it is only a local file. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsUbiquitousItemKey =
      _lookup<NSURLResourceKey>('NSURLIsUbiquitousItemKey');

  NSURLResourceKey get NSURLIsUbiquitousItemKey =>
      _NSURLIsUbiquitousItemKey.value;

  set NSURLIsUbiquitousItemKey(NSURLResourceKey value) =>
      _NSURLIsUbiquitousItemKey.value = value;

  /// true if this item has conflicts outstanding. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemHasUnresolvedConflictsKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemHasUnresolvedConflictsKey');

  NSURLResourceKey get NSURLUbiquitousItemHasUnresolvedConflictsKey =>
      _NSURLUbiquitousItemHasUnresolvedConflictsKey.value;

  set NSURLUbiquitousItemHasUnresolvedConflictsKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemHasUnresolvedConflictsKey.value = value;

  /// equivalent to NSURLUbiquitousItemDownloadingStatusKey == NSURLUbiquitousItemDownloadingStatusCurrent. Has never behaved as documented in earlier releases, hence deprecated.  (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLUbiquitousItemIsDownloadedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsDownloadedKey');

  NSURLResourceKey get NSURLUbiquitousItemIsDownloadedKey =>
      _NSURLUbiquitousItemIsDownloadedKey.value;

  set NSURLUbiquitousItemIsDownloadedKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemIsDownloadedKey.value = value;

  /// true if data is being downloaded for this item. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemIsDownloadingKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsDownloadingKey');

  NSURLResourceKey get NSURLUbiquitousItemIsDownloadingKey =>
      _NSURLUbiquitousItemIsDownloadingKey.value;

  set NSURLUbiquitousItemIsDownloadingKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemIsDownloadingKey.value = value;

  /// true if there is data present in the cloud for this item. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLUbiquitousItemIsUploadedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsUploadedKey');

  NSURLResourceKey get NSURLUbiquitousItemIsUploadedKey =>
      _NSURLUbiquitousItemIsUploadedKey.value;

  set NSURLUbiquitousItemIsUploadedKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemIsUploadedKey.value = value;

  /// true if data is being uploaded for this item. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLUbiquitousItemIsUploadingKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsUploadingKey');

  NSURLResourceKey get NSURLUbiquitousItemIsUploadingKey =>
      _NSURLUbiquitousItemIsUploadingKey.value;

  set NSURLUbiquitousItemIsUploadingKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemIsUploadingKey.value = value;

  /// Use NSMetadataQuery and NSMetadataUbiquitousItemPercentDownloadedKey on NSMetadataItem instead
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemPercentDownloadedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemPercentDownloadedKey');

  NSURLResourceKey get NSURLUbiquitousItemPercentDownloadedKey =>
      _NSURLUbiquitousItemPercentDownloadedKey.value;

  set NSURLUbiquitousItemPercentDownloadedKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemPercentDownloadedKey.value = value;

  /// Use NSMetadataQuery and NSMetadataUbiquitousItemPercentUploadedKey on NSMetadataItem instead
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemPercentUploadedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemPercentUploadedKey');

  NSURLResourceKey get NSURLUbiquitousItemPercentUploadedKey =>
      _NSURLUbiquitousItemPercentUploadedKey.value;

  set NSURLUbiquitousItemPercentUploadedKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemPercentUploadedKey.value = value;

  /// returns the download status of this item. (Read-only, value type NSString). Possible values below.
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemDownloadingStatusKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemDownloadingStatusKey');

  NSURLResourceKey get NSURLUbiquitousItemDownloadingStatusKey =>
      _NSURLUbiquitousItemDownloadingStatusKey.value;

  set NSURLUbiquitousItemDownloadingStatusKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemDownloadingStatusKey.value = value;

  /// returns the error when downloading the item from iCloud failed, see the NSUbiquitousFile section in FoundationErrors.h (Read-only, value type NSError)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemDownloadingErrorKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemDownloadingErrorKey');

  NSURLResourceKey get NSURLUbiquitousItemDownloadingErrorKey =>
      _NSURLUbiquitousItemDownloadingErrorKey.value;

  set NSURLUbiquitousItemDownloadingErrorKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemDownloadingErrorKey.value = value;

  /// returns the error when uploading the item to iCloud failed, see the NSUbiquitousFile section in FoundationErrors.h (Read-only, value type NSError)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemUploadingErrorKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemUploadingErrorKey');

  NSURLResourceKey get NSURLUbiquitousItemUploadingErrorKey =>
      _NSURLUbiquitousItemUploadingErrorKey.value;

  set NSURLUbiquitousItemUploadingErrorKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemUploadingErrorKey.value = value;

  /// returns whether a download of this item has already been requested with an API like -startDownloadingUbiquitousItemAtURL:error: (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemDownloadRequestedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemDownloadRequestedKey');

  NSURLResourceKey get NSURLUbiquitousItemDownloadRequestedKey =>
      _NSURLUbiquitousItemDownloadRequestedKey.value;

  set NSURLUbiquitousItemDownloadRequestedKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemDownloadRequestedKey.value = value;

  /// returns the name of this item's container as displayed to users.
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemContainerDisplayNameKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemContainerDisplayNameKey');

  NSURLResourceKey get NSURLUbiquitousItemContainerDisplayNameKey =>
      _NSURLUbiquitousItemContainerDisplayNameKey.value;

  set NSURLUbiquitousItemContainerDisplayNameKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemContainerDisplayNameKey.value = value;

  /// true if the item is excluded from sync, which means it is locally on disk but won't be available on the server. An excluded item is no longer ubiquitous. (Read-write, value type boolean NSNumber
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemIsExcludedFromSyncKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsExcludedFromSyncKey');

  NSURLResourceKey get NSURLUbiquitousItemIsExcludedFromSyncKey =>
      _NSURLUbiquitousItemIsExcludedFromSyncKey.value;

  set NSURLUbiquitousItemIsExcludedFromSyncKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemIsExcludedFromSyncKey.value = value;

  /// true if the ubiquitous item is shared. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLUbiquitousItemIsSharedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsSharedKey');

  NSURLResourceKey get NSURLUbiquitousItemIsSharedKey =>
      _NSURLUbiquitousItemIsSharedKey.value;

  set NSURLUbiquitousItemIsSharedKey(NSURLResourceKey value) =>
      _NSURLUbiquitousItemIsSharedKey.value = value;

  /// returns the current user's role for this shared item, or nil if not shared. (Read-only, value type NSString). Possible values below.
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousSharedItemCurrentUserRoleKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousSharedItemCurrentUserRoleKey');

  NSURLResourceKey get NSURLUbiquitousSharedItemCurrentUserRoleKey =>
      _NSURLUbiquitousSharedItemCurrentUserRoleKey.value;

  set NSURLUbiquitousSharedItemCurrentUserRoleKey(NSURLResourceKey value) =>
      _NSURLUbiquitousSharedItemCurrentUserRoleKey.value = value;

  /// returns the permissions for the current user, or nil if not shared. (Read-only, value type NSString). Possible values below.
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousSharedItemCurrentUserPermissionsKey =
      _lookup<NSURLResourceKey>(
          'NSURLUbiquitousSharedItemCurrentUserPermissionsKey');

  NSURLResourceKey get NSURLUbiquitousSharedItemCurrentUserPermissionsKey =>
      _NSURLUbiquitousSharedItemCurrentUserPermissionsKey.value;

  set NSURLUbiquitousSharedItemCurrentUserPermissionsKey(
          NSURLResourceKey value) =>
      _NSURLUbiquitousSharedItemCurrentUserPermissionsKey.value = value;

  /// returns a NSPersonNameComponents, or nil if the current user. (Read-only, value type NSPersonNameComponents)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousSharedItemOwnerNameComponentsKey =
      _lookup<NSURLResourceKey>(
          'NSURLUbiquitousSharedItemOwnerNameComponentsKey');

  NSURLResourceKey get NSURLUbiquitousSharedItemOwnerNameComponentsKey =>
      _NSURLUbiquitousSharedItemOwnerNameComponentsKey.value;

  set NSURLUbiquitousSharedItemOwnerNameComponentsKey(NSURLResourceKey value) =>
      _NSURLUbiquitousSharedItemOwnerNameComponentsKey.value = value;

  /// returns a NSPersonNameComponents for the most recent editor of the document, or nil if it is the current user. (Read-only, value type NSPersonNameComponents)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey =
      _lookup<NSURLResourceKey>(
          'NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey');

  NSURLResourceKey
      get NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey =>
          _NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey.value;

  set NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey(
          NSURLResourceKey value) =>
      _NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey.value = value;

  /// this item has not been downloaded yet. Use startDownloadingUbiquitousItemAtURL:error: to download it.
  late final ffi.Pointer<NSURLUbiquitousItemDownloadingStatus>
      _NSURLUbiquitousItemDownloadingStatusNotDownloaded =
      _lookup<NSURLUbiquitousItemDownloadingStatus>(
          'NSURLUbiquitousItemDownloadingStatusNotDownloaded');

  NSURLUbiquitousItemDownloadingStatus
      get NSURLUbiquitousItemDownloadingStatusNotDownloaded =>
          _NSURLUbiquitousItemDownloadingStatusNotDownloaded.value;

  set NSURLUbiquitousItemDownloadingStatusNotDownloaded(
          NSURLUbiquitousItemDownloadingStatus value) =>
      _NSURLUbiquitousItemDownloadingStatusNotDownloaded.value = value;

  /// there is a local version of this item available. The most current version will get downloaded as soon as possible.
  late final ffi.Pointer<NSURLUbiquitousItemDownloadingStatus>
      _NSURLUbiquitousItemDownloadingStatusDownloaded =
      _lookup<NSURLUbiquitousItemDownloadingStatus>(
          'NSURLUbiquitousItemDownloadingStatusDownloaded');

  NSURLUbiquitousItemDownloadingStatus
      get NSURLUbiquitousItemDownloadingStatusDownloaded =>
          _NSURLUbiquitousItemDownloadingStatusDownloaded.value;

  set NSURLUbiquitousItemDownloadingStatusDownloaded(
          NSURLUbiquitousItemDownloadingStatus value) =>
      _NSURLUbiquitousItemDownloadingStatusDownloaded.value = value;

  /// there is a local version of this item and it is the most up-to-date version known to this device.
  late final ffi.Pointer<NSURLUbiquitousItemDownloadingStatus>
      _NSURLUbiquitousItemDownloadingStatusCurrent =
      _lookup<NSURLUbiquitousItemDownloadingStatus>(
          'NSURLUbiquitousItemDownloadingStatusCurrent');

  NSURLUbiquitousItemDownloadingStatus
      get NSURLUbiquitousItemDownloadingStatusCurrent =>
          _NSURLUbiquitousItemDownloadingStatusCurrent.value;

  set NSURLUbiquitousItemDownloadingStatusCurrent(
          NSURLUbiquitousItemDownloadingStatus value) =>
      _NSURLUbiquitousItemDownloadingStatusCurrent.value = value;

  /// the current user is the owner of this shared item.
  late final ffi.Pointer<NSURLUbiquitousSharedItemRole>
      _NSURLUbiquitousSharedItemRoleOwner =
      _lookup<NSURLUbiquitousSharedItemRole>(
          'NSURLUbiquitousSharedItemRoleOwner');

  NSURLUbiquitousSharedItemRole get NSURLUbiquitousSharedItemRoleOwner =>
      _NSURLUbiquitousSharedItemRoleOwner.value;

  set NSURLUbiquitousSharedItemRoleOwner(NSURLUbiquitousSharedItemRole value) =>
      _NSURLUbiquitousSharedItemRoleOwner.value = value;

  /// the current user is a participant of this shared item.
  late final ffi.Pointer<NSURLUbiquitousSharedItemRole>
      _NSURLUbiquitousSharedItemRoleParticipant =
      _lookup<NSURLUbiquitousSharedItemRole>(
          'NSURLUbiquitousSharedItemRoleParticipant');

  NSURLUbiquitousSharedItemRole get NSURLUbiquitousSharedItemRoleParticipant =>
      _NSURLUbiquitousSharedItemRoleParticipant.value;

  set NSURLUbiquitousSharedItemRoleParticipant(
          NSURLUbiquitousSharedItemRole value) =>
      _NSURLUbiquitousSharedItemRoleParticipant.value = value;

  /// the current user is only allowed to read this item
  late final ffi.Pointer<NSURLUbiquitousSharedItemPermissions>
      _NSURLUbiquitousSharedItemPermissionsReadOnly =
      _lookup<NSURLUbiquitousSharedItemPermissions>(
          'NSURLUbiquitousSharedItemPermissionsReadOnly');

  NSURLUbiquitousSharedItemPermissions
      get NSURLUbiquitousSharedItemPermissionsReadOnly =>
          _NSURLUbiquitousSharedItemPermissionsReadOnly.value;

  set NSURLUbiquitousSharedItemPermissionsReadOnly(
          NSURLUbiquitousSharedItemPermissions value) =>
      _NSURLUbiquitousSharedItemPermissionsReadOnly.value = value;

  /// the current user is allowed to both read and write this item
  late final ffi.Pointer<NSURLUbiquitousSharedItemPermissions>
      _NSURLUbiquitousSharedItemPermissionsReadWrite =
      _lookup<NSURLUbiquitousSharedItemPermissions>(
          'NSURLUbiquitousSharedItemPermissionsReadWrite');

  NSURLUbiquitousSharedItemPermissions
      get NSURLUbiquitousSharedItemPermissionsReadWrite =>
          _NSURLUbiquitousSharedItemPermissionsReadWrite.value;

  set NSURLUbiquitousSharedItemPermissionsReadWrite(
          NSURLUbiquitousSharedItemPermissions value) =>
      _NSURLUbiquitousSharedItemPermissionsReadWrite.value = value;

  late final _class_NSURLQueryItem1 = _getClass1("NSURLQueryItem");
  late final _sel_initWithName_value_1 = _registerName1("initWithName:value:");
  instancetype _objc_msgSend_314(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> name,
    ffi.Pointer<ObjCObject> value,
  ) {
    return __objc_msgSend_314(
      obj,
      sel,
      name,
      value,
    );
  }

  late final __objc_msgSend_314Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_314 = __objc_msgSend_314Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _sel_queryItemWithName_value_1 =
      _registerName1("queryItemWithName:value:");
  late final _sel_value1 = _registerName1("value");
  late final _class_NSURLComponents1 = _getClass1("NSURLComponents");
  late final _sel_initWithURL_resolvingAgainstBaseURL_1 =
      _registerName1("initWithURL:resolvingAgainstBaseURL:");
  late final _sel_componentsWithURL_resolvingAgainstBaseURL_1 =
      _registerName1("componentsWithURL:resolvingAgainstBaseURL:");
  late final _sel_componentsWithString_1 =
      _registerName1("componentsWithString:");
  late final _sel_URLRelativeToURL_1 = _registerName1("URLRelativeToURL:");
  ffi.Pointer<ObjCObject> _objc_msgSend_315(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> baseURL,
  ) {
    return __objc_msgSend_315(
      obj,
      sel,
      baseURL,
    );
  }

  late final __objc_msgSend_315Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_315 = __objc_msgSend_315Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>, ffi.Pointer<ObjCObject>)>();

  late final _sel_setScheme_1 = _registerName1("setScheme:");
  late final _sel_setUser_1 = _registerName1("setUser:");
  late final _sel_setPassword_1 = _registerName1("setPassword:");
  late final _sel_setHost_1 = _registerName1("setHost:");
  late final _sel_setPort_1 = _registerName1("setPort:");
  late final _sel_setPath_1 = _registerName1("setPath:");
  late final _sel_setQuery_1 = _registerName1("setQuery:");
  late final _sel_setFragment_1 = _registerName1("setFragment:");
  late final _sel_percentEncodedUser1 = _registerName1("percentEncodedUser");
  late final _sel_setPercentEncodedUser_1 =
      _registerName1("setPercentEncodedUser:");
  late final _sel_percentEncodedPassword1 =
      _registerName1("percentEncodedPassword");
  late final _sel_setPercentEncodedPassword_1 =
      _registerName1("setPercentEncodedPassword:");
  late final _sel_percentEncodedHost1 = _registerName1("percentEncodedHost");
  late final _sel_setPercentEncodedHost_1 =
      _registerName1("setPercentEncodedHost:");
  late final _sel_percentEncodedPath1 = _registerName1("percentEncodedPath");
  late final _sel_setPercentEncodedPath_1 =
      _registerName1("setPercentEncodedPath:");
  late final _sel_percentEncodedQuery1 = _registerName1("percentEncodedQuery");
  late final _sel_setPercentEncodedQuery_1 =
      _registerName1("setPercentEncodedQuery:");
  late final _sel_percentEncodedFragment1 =
      _registerName1("percentEncodedFragment");
  late final _sel_setPercentEncodedFragment_1 =
      _registerName1("setPercentEncodedFragment:");
  late final _sel_rangeOfScheme1 = _registerName1("rangeOfScheme");
  NSRange _objc_msgSend_316(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_316(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_316Ptr = _lookup<
      ffi.NativeFunction<
          NSRange Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_316 = __objc_msgSend_316Ptr.asFunction<
      NSRange Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_rangeOfUser1 = _registerName1("rangeOfUser");
  late final _sel_rangeOfPassword1 = _registerName1("rangeOfPassword");
  late final _sel_rangeOfHost1 = _registerName1("rangeOfHost");
  late final _sel_rangeOfPort1 = _registerName1("rangeOfPort");
  late final _sel_rangeOfPath1 = _registerName1("rangeOfPath");
  late final _sel_rangeOfQuery1 = _registerName1("rangeOfQuery");
  late final _sel_rangeOfFragment1 = _registerName1("rangeOfFragment");
  late final _sel_queryItems1 = _registerName1("queryItems");
  late final _sel_setQueryItems_1 = _registerName1("setQueryItems:");
  late final _sel_percentEncodedQueryItems1 =
      _registerName1("percentEncodedQueryItems");
  late final _sel_setPercentEncodedQueryItems_1 =
      _registerName1("setPercentEncodedQueryItems:");
  late final _class_NSFileSecurity1 = _getClass1("NSFileSecurity");

  /// How much time is probably left in the operation, as an NSNumber containing a number of seconds.
  late final ffi.Pointer<NSProgressUserInfoKey1>
      _NSProgressEstimatedTimeRemainingKey =
      _lookup<NSProgressUserInfoKey1>('NSProgressEstimatedTimeRemainingKey');

  NSProgressUserInfoKey1 get NSProgressEstimatedTimeRemainingKey =>
      _NSProgressEstimatedTimeRemainingKey.value;

  set NSProgressEstimatedTimeRemainingKey(NSProgressUserInfoKey1 value) =>
      _NSProgressEstimatedTimeRemainingKey.value = value;

  /// How fast data is being processed, as an NSNumber containing bytes per second.
  late final ffi.Pointer<NSProgressUserInfoKey1> _NSProgressThroughputKey =
      _lookup<NSProgressUserInfoKey1>('NSProgressThroughputKey');

  NSProgressUserInfoKey1 get NSProgressThroughputKey =>
      _NSProgressThroughputKey.value;

  set NSProgressThroughputKey(NSProgressUserInfoKey1 value) =>
      _NSProgressThroughputKey.value = value;

  /// The value for the kind property that indicates that the work being done is one of the kind of file operations listed below. NSProgress of this kind is assumed to use bytes as the unit of work being done and the default implementation of -localizedDescription takes advantage of that to return more specific text than it could otherwise. The NSProgressFileTotalCountKey and NSProgressFileCompletedCountKey keys in the userInfo dictionary are used for the overall count of files.
  late final ffi.Pointer<NSProgressKind1> _NSProgressKindFile =
      _lookup<NSProgressKind1>('NSProgressKindFile');

  NSProgressKind1 get NSProgressKindFile => _NSProgressKindFile.value;

  set NSProgressKindFile(NSProgressKind1 value) =>
      _NSProgressKindFile.value = value;

  /// A user info dictionary key, for an entry that is required when the value for the kind property is NSProgressKindFile. The value must be one of the strings listed in the next section. The default implementations of of -localizedDescription and -localizedItemDescription use this value to determine the text that they return.
  late final ffi.Pointer<NSProgressUserInfoKey1>
      _NSProgressFileOperationKindKey =
      _lookup<NSProgressUserInfoKey1>('NSProgressFileOperationKindKey');

  NSProgressUserInfoKey1 get NSProgressFileOperationKindKey =>
      _NSProgressFileOperationKindKey.value;

  set NSProgressFileOperationKindKey(NSProgressUserInfoKey1 value) =>
      _NSProgressFileOperationKindKey.value = value;

  /// Possible values for NSProgressFileOperationKindKey entries.
  late final ffi.Pointer<NSProgressFileOperationKind1>
      _NSProgressFileOperationKindDownloading =
      _lookup<NSProgressFileOperationKind1>(
          'NSProgressFileOperationKindDownloading');

  NSProgressFileOperationKind1 get NSProgressFileOperationKindDownloading =>
      _NSProgressFileOperationKindDownloading.value;

  set NSProgressFileOperationKindDownloading(
          NSProgressFileOperationKind1 value) =>
      _NSProgressFileOperationKindDownloading.value = value;

  late final ffi.Pointer<NSProgressFileOperationKind1>
      _NSProgressFileOperationKindDecompressingAfterDownloading =
      _lookup<NSProgressFileOperationKind1>(
          'NSProgressFileOperationKindDecompressingAfterDownloading');

  NSProgressFileOperationKind1
      get NSProgressFileOperationKindDecompressingAfterDownloading =>
          _NSProgressFileOperationKindDecompressingAfterDownloading.value;

  set NSProgressFileOperationKindDecompressingAfterDownloading(
          NSProgressFileOperationKind1 value) =>
      _NSProgressFileOperationKindDecompressingAfterDownloading.value = value;

  late final ffi.Pointer<NSProgressFileOperationKind1>
      _NSProgressFileOperationKindReceiving =
      _lookup<NSProgressFileOperationKind1>(
          'NSProgressFileOperationKindReceiving');

  NSProgressFileOperationKind1 get NSProgressFileOperationKindReceiving =>
      _NSProgressFileOperationKindReceiving.value;

  set NSProgressFileOperationKindReceiving(
          NSProgressFileOperationKind1 value) =>
      _NSProgressFileOperationKindReceiving.value = value;

  late final ffi.Pointer<NSProgressFileOperationKind1>
      _NSProgressFileOperationKindCopying =
      _lookup<NSProgressFileOperationKind1>(
          'NSProgressFileOperationKindCopying');

  NSProgressFileOperationKind1 get NSProgressFileOperationKindCopying =>
      _NSProgressFileOperationKindCopying.value;

  set NSProgressFileOperationKindCopying(NSProgressFileOperationKind1 value) =>
      _NSProgressFileOperationKindCopying.value = value;

  late final ffi.Pointer<NSProgressFileOperationKind1>
      _NSProgressFileOperationKindUploading =
      _lookup<NSProgressFileOperationKind1>(
          'NSProgressFileOperationKindUploading');

  NSProgressFileOperationKind1 get NSProgressFileOperationKindUploading =>
      _NSProgressFileOperationKindUploading.value;

  set NSProgressFileOperationKindUploading(
          NSProgressFileOperationKind1 value) =>
      _NSProgressFileOperationKindUploading.value = value;

  /// A user info dictionary key. The value must be an NSURL identifying the item on which progress is being made. This is required for any NSProgress that is published using -publish to be reported to subscribers registered with +addSubscriberForFileURL:withPublishingHandler:.
  late final ffi.Pointer<NSProgressUserInfoKey1> _NSProgressFileURLKey =
      _lookup<NSProgressUserInfoKey1>('NSProgressFileURLKey');

  NSProgressUserInfoKey1 get NSProgressFileURLKey =>
      _NSProgressFileURLKey.value;

  set NSProgressFileURLKey(NSProgressUserInfoKey1 value) =>
      _NSProgressFileURLKey.value = value;

  /// User info dictionary keys. The values must be NSNumbers containing integers. These entries are optional but if they are both present then the default implementation of -localizedAdditionalDescription uses them to determine the text that it returns.
  late final ffi.Pointer<NSProgressUserInfoKey1> _NSProgressFileTotalCountKey =
      _lookup<NSProgressUserInfoKey1>('NSProgressFileTotalCountKey');

  NSProgressUserInfoKey1 get NSProgressFileTotalCountKey =>
      _NSProgressFileTotalCountKey.value;

  set NSProgressFileTotalCountKey(NSProgressUserInfoKey1 value) =>
      _NSProgressFileTotalCountKey.value = value;

  late final ffi.Pointer<NSProgressUserInfoKey1>
      _NSProgressFileCompletedCountKey =
      _lookup<NSProgressUserInfoKey1>('NSProgressFileCompletedCountKey');

  NSProgressUserInfoKey1 get NSProgressFileCompletedCountKey =>
      _NSProgressFileCompletedCountKey.value;

  set NSProgressFileCompletedCountKey(NSProgressUserInfoKey1 value) =>
      _NSProgressFileCompletedCountKey.value = value;

  /// User info dictionary keys. The value for the first entry must be an NSImage, typically an icon. The value for the second entry must be an NSValue containing an NSRect, in screen coordinates, locating the image where it initially appears on the screen.
  late final ffi.Pointer<NSProgressUserInfoKey1>
      _NSProgressFileAnimationImageKey =
      _lookup<NSProgressUserInfoKey1>('NSProgressFileAnimationImageKey');

  NSProgressUserInfoKey1 get NSProgressFileAnimationImageKey =>
      _NSProgressFileAnimationImageKey.value;

  set NSProgressFileAnimationImageKey(NSProgressUserInfoKey1 value) =>
      _NSProgressFileAnimationImageKey.value = value;

  late final ffi.Pointer<NSProgressUserInfoKey1>
      _NSProgressFileAnimationImageOriginalRectKey =
      _lookup<NSProgressUserInfoKey1>(
          'NSProgressFileAnimationImageOriginalRectKey');

  NSProgressUserInfoKey1 get NSProgressFileAnimationImageOriginalRectKey =>
      _NSProgressFileAnimationImageOriginalRectKey.value;

  set NSProgressFileAnimationImageOriginalRectKey(
          NSProgressUserInfoKey1 value) =>
      _NSProgressFileAnimationImageOriginalRectKey.value = value;

  /// A user info dictionary key. The value must be an NSImage containing an icon. This entry is optional but, if it is present, the Finder will use it to show the icon of a file while progress is being made on that file. For example, the App Store uses this to specify an icon for an application being downloaded before the icon can be gotten from the application bundle itself.
  late final ffi.Pointer<NSProgressUserInfoKey1> _NSProgressFileIconKey =
      _lookup<NSProgressUserInfoKey1>('NSProgressFileIconKey');

  NSProgressUserInfoKey1 get NSProgressFileIconKey =>
      _NSProgressFileIconKey.value;

  set NSProgressFileIconKey(NSProgressUserInfoKey1 value) =>
      _NSProgressFileIconKey.value = value;

  late final _class_NSHTTPURLResponse1 = _getClass1("NSHTTPURLResponse");
  late final _sel_initWithURL_statusCode_HTTPVersion_headerFields_1 =
      _registerName1("initWithURL:statusCode:HTTPVersion:headerFields:");
  instancetype _objc_msgSend_317(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> url,
    int statusCode,
    ffi.Pointer<ObjCObject> HTTPVersion,
    ffi.Pointer<ObjCObject> headerFields,
  ) {
    return __objc_msgSend_317(
      obj,
      sel,
      url,
      statusCode,
      HTTPVersion,
      headerFields,
    );
  }

  late final __objc_msgSend_317Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              NSInteger,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_317 = __objc_msgSend_317Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          int,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_statusCode1 = _registerName1("statusCode");
  late final _sel_allHeaderFields1 = _registerName1("allHeaderFields");
  late final _sel_localizedStringForStatusCode_1 =
      _registerName1("localizedStringForStatusCode:");
  ffi.Pointer<ObjCObject> _objc_msgSend_318(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int statusCode,
  ) {
    return __objc_msgSend_318(
      obj,
      sel,
      statusCode,
    );
  }

  late final __objc_msgSend_318Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, NSInteger)>>('objc_msgSend');
  late final __objc_msgSend_318 = __objc_msgSend_318Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  /// !
  /// @const NSHTTPCookieManagerAcceptPolicyChangedNotification
  /// @discussion Name of notification that should be posted to the
  /// distributed notification center whenever the accept cookies
  /// preference is changed
  late final ffi.Pointer<NSNotificationName>
      _NSHTTPCookieManagerAcceptPolicyChangedNotification =
      _lookup<NSNotificationName>(
          'NSHTTPCookieManagerAcceptPolicyChangedNotification');

  NSNotificationName get NSHTTPCookieManagerAcceptPolicyChangedNotification =>
      _NSHTTPCookieManagerAcceptPolicyChangedNotification.value;

  set NSHTTPCookieManagerAcceptPolicyChangedNotification(
          NSNotificationName value) =>
      _NSHTTPCookieManagerAcceptPolicyChangedNotification.value = value;

  /// !
  /// @const NSHTTPCookieManagerCookiesChangedNotification
  /// @abstract Notification sent when the set of cookies changes
  late final ffi.Pointer<NSNotificationName>
      _NSHTTPCookieManagerCookiesChangedNotification =
      _lookup<NSNotificationName>(
          'NSHTTPCookieManagerCookiesChangedNotification');

  NSNotificationName get NSHTTPCookieManagerCookiesChangedNotification =>
      _NSHTTPCookieManagerCookiesChangedNotification.value;

  set NSHTTPCookieManagerCookiesChangedNotification(NSNotificationName value) =>
      _NSHTTPCookieManagerCookiesChangedNotification.value = value;

  late final _class_NSBlockOperation1 = _getClass1("NSBlockOperation");
  late final _sel_blockOperationWithBlock_1 =
      _registerName1("blockOperationWithBlock:");
  instancetype _objc_msgSend_319(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<_ObjCBlock> block,
  ) {
    return __objc_msgSend_319(
      obj,
      sel,
      block,
    );
  }

  late final __objc_msgSend_319Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<_ObjCBlock>)>>('objc_msgSend');
  late final __objc_msgSend_319 = __objc_msgSend_319Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<_ObjCBlock>)>();

  late final _sel_addExecutionBlock_1 = _registerName1("addExecutionBlock:");
  late final _sel_executionBlocks1 = _registerName1("executionBlocks");
  late final _class_NSInvocationOperation1 =
      _getClass1("NSInvocationOperation");
  late final _sel_initWithTarget_selector_object_1 =
      _registerName1("initWithTarget:selector:object:");
  instancetype _objc_msgSend_320(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> target,
    ffi.Pointer<ObjCSel> sel1,
    ffi.Pointer<ObjCObject> arg,
  ) {
    return __objc_msgSend_320(
      obj,
      sel,
      target,
      sel1,
      arg,
    );
  }

  late final __objc_msgSend_320Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_320 = __objc_msgSend_320Ptr.asFunction<
      instancetype Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_initWithInvocation_1 = _registerName1("initWithInvocation:");
  instancetype _objc_msgSend_321(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> inv,
  ) {
    return __objc_msgSend_321(
      obj,
      sel,
      inv,
    );
  }

  late final __objc_msgSend_321Ptr = _lookup<
      ffi.NativeFunction<
          instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_321 = __objc_msgSend_321Ptr.asFunction<
      instancetype Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_invocation1 = _registerName1("invocation");
  ffi.Pointer<ObjCObject> _objc_msgSend_322(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_322(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_322Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_322 = __objc_msgSend_322Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_result1 = _registerName1("result");
  late final ffi.Pointer<NSExceptionName>
      _NSInvocationOperationVoidResultException =
      _lookup<NSExceptionName>('NSInvocationOperationVoidResultException');

  NSExceptionName get NSInvocationOperationVoidResultException =>
      _NSInvocationOperationVoidResultException.value;

  set NSInvocationOperationVoidResultException(NSExceptionName value) =>
      _NSInvocationOperationVoidResultException.value = value;

  late final ffi.Pointer<NSExceptionName>
      _NSInvocationOperationCancelledException =
      _lookup<NSExceptionName>('NSInvocationOperationCancelledException');

  NSExceptionName get NSInvocationOperationCancelledException =>
      _NSInvocationOperationCancelledException.value;

  set NSInvocationOperationCancelledException(NSExceptionName value) =>
      _NSInvocationOperationCancelledException.value = value;

  late final ffi.Pointer<NSInteger>
      _NSOperationQueueDefaultMaxConcurrentOperationCount =
      _lookup<NSInteger>('NSOperationQueueDefaultMaxConcurrentOperationCount');

  int get NSOperationQueueDefaultMaxConcurrentOperationCount =>
      _NSOperationQueueDefaultMaxConcurrentOperationCount.value;

  set NSOperationQueueDefaultMaxConcurrentOperationCount(int value) =>
      _NSOperationQueueDefaultMaxConcurrentOperationCount.value = value;

  /// Predefined domain for errors from most AppKit and Foundation APIs.
  late final ffi.Pointer<NSErrorDomain> _NSCocoaErrorDomain =
      _lookup<NSErrorDomain>('NSCocoaErrorDomain');

  NSErrorDomain get NSCocoaErrorDomain => _NSCocoaErrorDomain.value;

  set NSCocoaErrorDomain(NSErrorDomain value) =>
      _NSCocoaErrorDomain.value = value;

  /// Other predefined domains; value of "code" will correspond to preexisting values in these domains.
  late final ffi.Pointer<NSErrorDomain> _NSPOSIXErrorDomain =
      _lookup<NSErrorDomain>('NSPOSIXErrorDomain');

  NSErrorDomain get NSPOSIXErrorDomain => _NSPOSIXErrorDomain.value;

  set NSPOSIXErrorDomain(NSErrorDomain value) =>
      _NSPOSIXErrorDomain.value = value;

  late final ffi.Pointer<NSErrorDomain> _NSOSStatusErrorDomain =
      _lookup<NSErrorDomain>('NSOSStatusErrorDomain');

  NSErrorDomain get NSOSStatusErrorDomain => _NSOSStatusErrorDomain.value;

  set NSOSStatusErrorDomain(NSErrorDomain value) =>
      _NSOSStatusErrorDomain.value = value;

  late final ffi.Pointer<NSErrorDomain> _NSMachErrorDomain =
      _lookup<NSErrorDomain>('NSMachErrorDomain');

  NSErrorDomain get NSMachErrorDomain => _NSMachErrorDomain.value;

  set NSMachErrorDomain(NSErrorDomain value) =>
      _NSMachErrorDomain.value = value;

  /// Key in userInfo. A recommended standard way to embed NSErrors from underlying calls. The value of this key should be an NSError.
  late final ffi.Pointer<NSErrorUserInfoKey> _NSUnderlyingErrorKey =
      _lookup<NSErrorUserInfoKey>('NSUnderlyingErrorKey');

  NSErrorUserInfoKey get NSUnderlyingErrorKey => _NSUnderlyingErrorKey.value;

  set NSUnderlyingErrorKey(NSErrorUserInfoKey value) =>
      _NSUnderlyingErrorKey.value = value;

  /// Key in userInfo. A recommended standard way to embed a list of several NSErrors from underlying calls. The value of this key should be an NSArray of NSError. This value is independent from the value of `NSUnderlyingErrorKey` - neither, one, or both may be set.
  late final ffi.Pointer<NSErrorUserInfoKey> _NSMultipleUnderlyingErrorsKey =
      _lookup<NSErrorUserInfoKey>('NSMultipleUnderlyingErrorsKey');

  NSErrorUserInfoKey get NSMultipleUnderlyingErrorsKey =>
      _NSMultipleUnderlyingErrorsKey.value;

  set NSMultipleUnderlyingErrorsKey(NSErrorUserInfoKey value) =>
      _NSMultipleUnderlyingErrorsKey.value = value;

  /// NSString, a complete sentence (or more) describing ideally both what failed and why it failed.
  late final ffi.Pointer<NSErrorUserInfoKey> _NSLocalizedDescriptionKey =
      _lookup<NSErrorUserInfoKey>('NSLocalizedDescriptionKey');

  NSErrorUserInfoKey get NSLocalizedDescriptionKey =>
      _NSLocalizedDescriptionKey.value;

  set NSLocalizedDescriptionKey(NSErrorUserInfoKey value) =>
      _NSLocalizedDescriptionKey.value = value;

  /// NSString, a complete sentence (or more) describing why the operation failed.
  late final ffi.Pointer<NSErrorUserInfoKey> _NSLocalizedFailureReasonErrorKey =
      _lookup<NSErrorUserInfoKey>('NSLocalizedFailureReasonErrorKey');

  NSErrorUserInfoKey get NSLocalizedFailureReasonErrorKey =>
      _NSLocalizedFailureReasonErrorKey.value;

  set NSLocalizedFailureReasonErrorKey(NSErrorUserInfoKey value) =>
      _NSLocalizedFailureReasonErrorKey.value = value;

  /// NSString, a complete sentence (or more) describing what the user can do to fix the problem.
  late final ffi.Pointer<NSErrorUserInfoKey>
      _NSLocalizedRecoverySuggestionErrorKey =
      _lookup<NSErrorUserInfoKey>('NSLocalizedRecoverySuggestionErrorKey');

  NSErrorUserInfoKey get NSLocalizedRecoverySuggestionErrorKey =>
      _NSLocalizedRecoverySuggestionErrorKey.value;

  set NSLocalizedRecoverySuggestionErrorKey(NSErrorUserInfoKey value) =>
      _NSLocalizedRecoverySuggestionErrorKey.value = value;

  /// NSArray of NSStrings corresponding to button titles.
  late final ffi.Pointer<NSErrorUserInfoKey>
      _NSLocalizedRecoveryOptionsErrorKey =
      _lookup<NSErrorUserInfoKey>('NSLocalizedRecoveryOptionsErrorKey');

  NSErrorUserInfoKey get NSLocalizedRecoveryOptionsErrorKey =>
      _NSLocalizedRecoveryOptionsErrorKey.value;

  set NSLocalizedRecoveryOptionsErrorKey(NSErrorUserInfoKey value) =>
      _NSLocalizedRecoveryOptionsErrorKey.value = value;

  /// Instance of a subclass of NSObject that conforms to the NSErrorRecoveryAttempting informal protocol
  late final ffi.Pointer<NSErrorUserInfoKey> _NSRecoveryAttempterErrorKey =
      _lookup<NSErrorUserInfoKey>('NSRecoveryAttempterErrorKey');

  NSErrorUserInfoKey get NSRecoveryAttempterErrorKey =>
      _NSRecoveryAttempterErrorKey.value;

  set NSRecoveryAttempterErrorKey(NSErrorUserInfoKey value) =>
      _NSRecoveryAttempterErrorKey.value = value;

  /// NSString containing a help anchor
  late final ffi.Pointer<NSErrorUserInfoKey> _NSHelpAnchorErrorKey =
      _lookup<NSErrorUserInfoKey>('NSHelpAnchorErrorKey');

  NSErrorUserInfoKey get NSHelpAnchorErrorKey => _NSHelpAnchorErrorKey.value;

  set NSHelpAnchorErrorKey(NSErrorUserInfoKey value) =>
      _NSHelpAnchorErrorKey.value = value;

  /// NSString. This provides a string which will be shown when constructing the debugDescription of the NSError, to be used when debugging or when formatting the error with %@.  This string will never be used in localizedDescription, so will not be shown to the user.
  late final ffi.Pointer<NSErrorUserInfoKey> _NSDebugDescriptionErrorKey =
      _lookup<NSErrorUserInfoKey>('NSDebugDescriptionErrorKey');

  NSErrorUserInfoKey get NSDebugDescriptionErrorKey =>
      _NSDebugDescriptionErrorKey.value;

  set NSDebugDescriptionErrorKey(NSErrorUserInfoKey value) =>
      _NSDebugDescriptionErrorKey.value = value;

  /// NSString, a complete sentence (or more) describing what failed.  Setting a value for this key in userInfo dictionary of errors received from framework APIs is a good way to customize and fine tune the localizedDescription of an NSError.  As an example, for Foundation error code NSFileWriteOutOfSpaceError, setting the value of this key to "The image library could not be saved." will allow the localizedDescription of the error to come out as "The image library could not be saved. The volume Macintosh HD is out of space." rather than the default (say) “You can't save the file ImgDatabaseV2 because the volume Macintosh HD is out of space."
  late final ffi.Pointer<NSErrorUserInfoKey> _NSLocalizedFailureErrorKey =
      _lookup<NSErrorUserInfoKey>('NSLocalizedFailureErrorKey');

  NSErrorUserInfoKey get NSLocalizedFailureErrorKey =>
      _NSLocalizedFailureErrorKey.value;

  set NSLocalizedFailureErrorKey(NSErrorUserInfoKey value) =>
      _NSLocalizedFailureErrorKey.value = value;

  /// NSNumber containing NSStringEncoding
  late final ffi.Pointer<NSErrorUserInfoKey> _NSStringEncodingErrorKey =
      _lookup<NSErrorUserInfoKey>('NSStringEncodingErrorKey');

  NSErrorUserInfoKey get NSStringEncodingErrorKey =>
      _NSStringEncodingErrorKey.value;

  set NSStringEncodingErrorKey(NSErrorUserInfoKey value) =>
      _NSStringEncodingErrorKey.value = value;

  /// NSURL
  late final ffi.Pointer<NSErrorUserInfoKey> _NSURLErrorKey =
      _lookup<NSErrorUserInfoKey>('NSURLErrorKey');

  NSErrorUserInfoKey get NSURLErrorKey => _NSURLErrorKey.value;

  set NSURLErrorKey(NSErrorUserInfoKey value) => _NSURLErrorKey.value = value;

  /// NSString
  late final ffi.Pointer<NSErrorUserInfoKey> _NSFilePathErrorKey =
      _lookup<NSErrorUserInfoKey>('NSFilePathErrorKey');

  NSErrorUserInfoKey get NSFilePathErrorKey => _NSFilePathErrorKey.value;

  set NSFilePathErrorKey(NSErrorUserInfoKey value) =>
      _NSFilePathErrorKey.value = value;

  /// Is this an error handle?
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsError(
    Object handle,
  ) {
    return _Dart_IsError(
      handle,
    );
  }

  late final _Dart_IsErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsError');
  late final _Dart_IsError =
      _Dart_IsErrorPtr.asFunction<bool Function(Object)>();

  /// Is this an api error handle?
  ///
  /// Api error handles are produced when an api function is misused.
  /// This happens when a Dart embedding api function is called with
  /// invalid arguments or in an invalid context.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsApiError(
    Object handle,
  ) {
    return _Dart_IsApiError(
      handle,
    );
  }

  late final _Dart_IsApiErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsApiError');
  late final _Dart_IsApiError =
      _Dart_IsApiErrorPtr.asFunction<bool Function(Object)>();

  /// Is this an unhandled exception error handle?
  ///
  /// Unhandled exception error handles are produced when, during the
  /// execution of Dart code, an exception is thrown but not caught.
  /// This can occur in any function which triggers the execution of Dart
  /// code.
  ///
  /// See Dart_ErrorGetException and Dart_ErrorGetStackTrace.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsUnhandledExceptionError(
    Object handle,
  ) {
    return _Dart_IsUnhandledExceptionError(
      handle,
    );
  }

  late final _Dart_IsUnhandledExceptionErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsUnhandledExceptionError');
  late final _Dart_IsUnhandledExceptionError =
      _Dart_IsUnhandledExceptionErrorPtr.asFunction<bool Function(Object)>();

  /// Is this a compilation error handle?
  ///
  /// Compilation error handles are produced when, during the execution
  /// of Dart code, a compile-time error occurs.  This can occur in any
  /// function which triggers the execution of Dart code.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsCompilationError(
    Object handle,
  ) {
    return _Dart_IsCompilationError(
      handle,
    );
  }

  late final _Dart_IsCompilationErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsCompilationError');
  late final _Dart_IsCompilationError =
      _Dart_IsCompilationErrorPtr.asFunction<bool Function(Object)>();

  /// Is this a fatal error handle?
  ///
  /// Fatal error handles are produced when the system wants to shut down
  /// the current isolate.
  ///
  /// Requires there to be a current isolate.
  bool Dart_IsFatalError(
    Object handle,
  ) {
    return _Dart_IsFatalError(
      handle,
    );
  }

  late final _Dart_IsFatalErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFatalError');
  late final _Dart_IsFatalError =
      _Dart_IsFatalErrorPtr.asFunction<bool Function(Object)>();

  /// Gets the error message from an error handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A C string containing an error message if the handle is
  /// error. An empty C string ("") if the handle is valid. This C
  /// String is scope allocated and is only valid until the next call
  /// to Dart_ExitScope.
  ffi.Pointer<ffi.Char> Dart_GetError(
    Object handle,
  ) {
    return _Dart_GetError(
      handle,
    );
  }

  late final _Dart_GetErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Handle)>>(
          'Dart_GetError');
  late final _Dart_GetError =
      _Dart_GetErrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(Object)>();

  /// Is this an error handle for an unhandled exception?
  bool Dart_ErrorHasException(
    Object handle,
  ) {
    return _Dart_ErrorHasException(
      handle,
    );
  }

  late final _Dart_ErrorHasExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_ErrorHasException');
  late final _Dart_ErrorHasException =
      _Dart_ErrorHasExceptionPtr.asFunction<bool Function(Object)>();

  /// Gets the exception Object from an unhandled exception error handle.
  Object Dart_ErrorGetException(
    Object handle,
  ) {
    return _Dart_ErrorGetException(
      handle,
    );
  }

  late final _Dart_ErrorGetExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ErrorGetException');
  late final _Dart_ErrorGetException =
      _Dart_ErrorGetExceptionPtr.asFunction<Object Function(Object)>();

  /// Gets the stack trace Object from an unhandled exception error handle.
  Object Dart_ErrorGetStackTrace(
    Object handle,
  ) {
    return _Dart_ErrorGetStackTrace(
      handle,
    );
  }

  late final _Dart_ErrorGetStackTracePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ErrorGetStackTrace');
  late final _Dart_ErrorGetStackTrace =
      _Dart_ErrorGetStackTracePtr.asFunction<Object Function(Object)>();

  /// Produces an api error handle with the provided error message.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param error the error message.
  Object Dart_NewApiError(
    ffi.Pointer<ffi.Char> error,
  ) {
    return _Dart_NewApiError(
      error,
    );
  }

  late final _Dart_NewApiErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewApiError');
  late final _Dart_NewApiError =
      _Dart_NewApiErrorPtr.asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  Object Dart_NewCompilationError(
    ffi.Pointer<ffi.Char> error,
  ) {
    return _Dart_NewCompilationError(
      error,
    );
  }

  late final _Dart_NewCompilationErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewCompilationError');
  late final _Dart_NewCompilationError = _Dart_NewCompilationErrorPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Produces a new unhandled exception error handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param exception An instance of a Dart object to be thrown or
  /// an ApiError or CompilationError handle.
  /// When an ApiError or CompilationError handle is passed in
  /// a string object of the error message is created and it becomes
  /// the Dart object to be thrown.
  Object Dart_NewUnhandledExceptionError(
    Object exception,
  ) {
    return _Dart_NewUnhandledExceptionError(
      exception,
    );
  }

  late final _Dart_NewUnhandledExceptionErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewUnhandledExceptionError');
  late final _Dart_NewUnhandledExceptionError =
      _Dart_NewUnhandledExceptionErrorPtr.asFunction<Object Function(Object)>();

  /// Propagates an error.
  ///
  /// If the provided handle is an unhandled exception error, this
  /// function will cause the unhandled exception to be rethrown.  This
  /// will proceed in the standard way, walking up Dart frames until an
  /// appropriate 'catch' block is found, executing 'finally' blocks,
  /// etc.
  ///
  /// If the error is not an unhandled exception error, we will unwind
  /// the stack to the next C frame.  Intervening Dart frames will be
  /// discarded; specifically, 'finally' blocks will not execute.  This
  /// is the standard way that compilation errors (and the like) are
  /// handled by the Dart runtime.
  ///
  /// In either case, when an error is propagated any current scopes
  /// created by Dart_EnterScope will be exited.
  ///
  /// See the additional discussion under "Propagating Errors" at the
  /// beginning of this file.
  ///
  /// \param An error handle (See Dart_IsError)
  ///
  /// \return On success, this function does not return.  On failure, the
  /// process is terminated.
  void Dart_PropagateError(
    Object handle,
  ) {
    return _Dart_PropagateError(
      handle,
    );
  }

  late final _Dart_PropagateErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_PropagateError');
  late final _Dart_PropagateError =
      _Dart_PropagateErrorPtr.asFunction<void Function(Object)>();

  /// Converts an object to a string.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return The converted string if no error occurs during
  /// the conversion. If an error does occur, an error handle is
  /// returned.
  Object Dart_ToString(
    Object object,
  ) {
    return _Dart_ToString(
      object,
    );
  }

  late final _Dart_ToStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ToString');
  late final _Dart_ToString =
      _Dart_ToStringPtr.asFunction<Object Function(Object)>();

  /// Checks to see if two handles refer to identically equal objects.
  ///
  /// If both handles refer to instances, this is equivalent to using the top-level
  /// function identical() from dart:core. Otherwise, returns whether the two
  /// argument handles refer to the same object.
  ///
  /// \param obj1 An object to be compared.
  /// \param obj2 An object to be compared.
  ///
  /// \return True if the objects are identically equal.  False otherwise.
  bool Dart_IdentityEquals(
    Object obj1,
    Object obj2,
  ) {
    return _Dart_IdentityEquals(
      obj1,
      obj2,
    );
  }

  late final _Dart_IdentityEqualsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle, ffi.Handle)>>(
          'Dart_IdentityEquals');
  late final _Dart_IdentityEquals =
      _Dart_IdentityEqualsPtr.asFunction<bool Function(Object, Object)>();

  /// Allocates a handle in the current scope from a persistent handle.
  Object Dart_HandleFromPersistent(
    Object object,
  ) {
    return _Dart_HandleFromPersistent(
      object,
    );
  }

  late final _Dart_HandleFromPersistentPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_HandleFromPersistent');
  late final _Dart_HandleFromPersistent =
      _Dart_HandleFromPersistentPtr.asFunction<Object Function(Object)>();

  /// Allocates a handle in the current scope from a weak persistent handle.
  ///
  /// This will be a handle to Dart_Null if the object has been garbage collected.
  Object Dart_HandleFromWeakPersistent(
    Dart_WeakPersistentHandle object,
  ) {
    return _Dart_HandleFromWeakPersistent(
      object,
    );
  }

  late final _Dart_HandleFromWeakPersistentPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_WeakPersistentHandle)>>(
      'Dart_HandleFromWeakPersistent');
  late final _Dart_HandleFromWeakPersistent = _Dart_HandleFromWeakPersistentPtr
      .asFunction<Object Function(Dart_WeakPersistentHandle)>();

  /// Allocates a persistent handle for an object.
  ///
  /// This handle has the lifetime of the current isolate unless it is
  /// explicitly deallocated by calling Dart_DeletePersistentHandle.
  ///
  /// Requires there to be a current isolate.
  Object Dart_NewPersistentHandle(
    Object object,
  ) {
    return _Dart_NewPersistentHandle(
      object,
    );
  }

  late final _Dart_NewPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewPersistentHandle');
  late final _Dart_NewPersistentHandle =
      _Dart_NewPersistentHandlePtr.asFunction<Object Function(Object)>();

  /// Assign value of local handle to a persistent handle.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param obj1 A persistent handle whose value needs to be set.
  /// \param obj2 An object whose value needs to be set to the persistent handle.
  ///
  /// \return Success if the persistent handle was set
  /// Otherwise, returns an error.
  void Dart_SetPersistentHandle(
    Object obj1,
    Object obj2,
  ) {
    return _Dart_SetPersistentHandle(
      obj1,
      obj2,
    );
  }

  late final _Dart_SetPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle, ffi.Handle)>>(
          'Dart_SetPersistentHandle');
  late final _Dart_SetPersistentHandle =
      _Dart_SetPersistentHandlePtr.asFunction<void Function(Object, Object)>();

  /// Deallocates a persistent handle.
  ///
  /// Requires there to be a current isolate group.
  void Dart_DeletePersistentHandle(
    Object object,
  ) {
    return _Dart_DeletePersistentHandle(
      object,
    );
  }

  late final _Dart_DeletePersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_DeletePersistentHandle');
  late final _Dart_DeletePersistentHandle =
      _Dart_DeletePersistentHandlePtr.asFunction<void Function(Object)>();

  /// Allocates a weak persistent handle for an object.
  ///
  /// This handle has the lifetime of the current isolate. The handle can also be
  /// explicitly deallocated by calling Dart_DeleteWeakPersistentHandle.
  ///
  /// If the object becomes unreachable the callback is invoked with the peer as
  /// argument. The callback can be executed on any thread, will have a current
  /// isolate group, but will not have a current isolate. The callback can only
  /// call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle. This
  /// gives the embedder the ability to cleanup data associated with the object.
  /// The handle will point to the Dart_Null object after the finalizer has been
  /// run. It is illegal to call into the VM with any other Dart_* functions from
  /// the callback. If the handle is deleted before the object becomes
  /// unreachable, the callback is never invoked.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param object An object with identity.
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The weak persistent handle or NULL. NULL is returned in case of bad
  /// parameters.
  Dart_WeakPersistentHandle Dart_NewWeakPersistentHandle(
    Object object,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewWeakPersistentHandle(
      object,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewWeakPersistentHandlePtr = _lookup<
      ffi.NativeFunction<
          Dart_WeakPersistentHandle Function(
              ffi.Handle,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewWeakPersistentHandle');
  late final _Dart_NewWeakPersistentHandle =
      _Dart_NewWeakPersistentHandlePtr.asFunction<
          Dart_WeakPersistentHandle Function(
              Object, ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Deletes the given weak persistent [object] handle.
  ///
  /// Requires there to be a current isolate group.
  void Dart_DeleteWeakPersistentHandle(
    Dart_WeakPersistentHandle object,
  ) {
    return _Dart_DeleteWeakPersistentHandle(
      object,
    );
  }

  late final _Dart_DeleteWeakPersistentHandlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_WeakPersistentHandle)>>(
          'Dart_DeleteWeakPersistentHandle');
  late final _Dart_DeleteWeakPersistentHandle =
      _Dart_DeleteWeakPersistentHandlePtr.asFunction<
          void Function(Dart_WeakPersistentHandle)>();

  /// Updates the external memory size for the given weak persistent handle.
  ///
  /// May trigger garbage collection.
  void Dart_UpdateExternalSize(
    Dart_WeakPersistentHandle object,
    int external_allocation_size,
  ) {
    return _Dart_UpdateExternalSize(
      object,
      external_allocation_size,
    );
  }

  late final _Dart_UpdateExternalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_WeakPersistentHandle,
              ffi.IntPtr)>>('Dart_UpdateExternalSize');
  late final _Dart_UpdateExternalSize = _Dart_UpdateExternalSizePtr.asFunction<
      void Function(Dart_WeakPersistentHandle, int)>();

  /// Allocates a finalizable handle for an object.
  ///
  /// This handle has the lifetime of the current isolate group unless the object
  /// pointed to by the handle is garbage collected, in this case the VM
  /// automatically deletes the handle after invoking the callback associated
  /// with the handle. The handle can also be explicitly deallocated by
  /// calling Dart_DeleteFinalizableHandle.
  ///
  /// If the object becomes unreachable the callback is invoked with the
  /// the peer as argument. The callback can be executed on any thread, will have
  /// an isolate group, but will not have a current isolate. The callback can only
  /// call Dart_DeletePersistentHandle or Dart_DeleteWeakPersistentHandle.
  /// This gives the embedder the ability to cleanup data associated with the
  /// object and clear out any cached references to the handle. All references to
  /// this handle after the callback will be invalid. It is illegal to call into
  /// the VM with any other Dart_* functions from the callback. If the handle is
  /// deleted before the object becomes unreachable, the callback is never
  /// invoked.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param object An object with identity.
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The finalizable handle or NULL. NULL is returned in case of bad
  /// parameters.
  Dart_FinalizableHandle Dart_NewFinalizableHandle(
    Object object,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewFinalizableHandle(
      object,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewFinalizableHandlePtr = _lookup<
      ffi.NativeFunction<
          Dart_FinalizableHandle Function(ffi.Handle, ffi.Pointer<ffi.Void>,
              ffi.IntPtr, Dart_HandleFinalizer)>>('Dart_NewFinalizableHandle');
  late final _Dart_NewFinalizableHandle =
      _Dart_NewFinalizableHandlePtr.asFunction<
          Dart_FinalizableHandle Function(
              Object, ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Deletes the given finalizable [object] handle.
  ///
  /// The caller has to provide the actual Dart object the handle was created from
  /// to prove the object (and therefore the finalizable handle) is still alive.
  ///
  /// Requires there to be a current isolate.
  void Dart_DeleteFinalizableHandle(
    Dart_FinalizableHandle object,
    Object strong_ref_to_object,
  ) {
    return _Dart_DeleteFinalizableHandle(
      object,
      strong_ref_to_object,
    );
  }

  late final _Dart_DeleteFinalizableHandlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_FinalizableHandle,
              ffi.Handle)>>('Dart_DeleteFinalizableHandle');
  late final _Dart_DeleteFinalizableHandle = _Dart_DeleteFinalizableHandlePtr
      .asFunction<void Function(Dart_FinalizableHandle, Object)>();

  /// Updates the external memory size for the given finalizable handle.
  ///
  /// The caller has to provide the actual Dart object the handle was created from
  /// to prove the object (and therefore the finalizable handle) is still alive.
  ///
  /// May trigger garbage collection.
  void Dart_UpdateFinalizableExternalSize(
    Dart_FinalizableHandle object,
    Object strong_ref_to_object,
    int external_allocation_size,
  ) {
    return _Dart_UpdateFinalizableExternalSize(
      object,
      strong_ref_to_object,
      external_allocation_size,
    );
  }

  late final _Dart_UpdateFinalizableExternalSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_FinalizableHandle, ffi.Handle,
              ffi.IntPtr)>>('Dart_UpdateFinalizableExternalSize');
  late final _Dart_UpdateFinalizableExternalSize =
      _Dart_UpdateFinalizableExternalSizePtr.asFunction<
          void Function(Dart_FinalizableHandle, Object, int)>();

  /// Gets the version string for the Dart VM.
  ///
  /// The version of the Dart VM can be accessed without initializing the VM.
  ///
  /// \return The version string for the embedded Dart VM.
  ffi.Pointer<ffi.Char> Dart_VersionString() {
    return _Dart_VersionString();
  }

  late final _Dart_VersionStringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'Dart_VersionString');
  late final _Dart_VersionString =
      _Dart_VersionStringPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Initialize Dart_IsolateFlags with correct version and default values.
  void Dart_IsolateFlagsInitialize(
    ffi.Pointer<Dart_IsolateFlags> flags,
  ) {
    return _Dart_IsolateFlagsInitialize(
      flags,
    );
  }

  late final _Dart_IsolateFlagsInitializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<Dart_IsolateFlags>)>>('Dart_IsolateFlagsInitialize');
  late final _Dart_IsolateFlagsInitialize = _Dart_IsolateFlagsInitializePtr
      .asFunction<void Function(ffi.Pointer<Dart_IsolateFlags>)>();

  /// Initializes the VM.
  ///
  /// \param params A struct containing initialization information. The version
  /// field of the struct must be DART_INITIALIZE_PARAMS_CURRENT_VERSION.
  ///
  /// \return NULL if initialization is successful. Returns an error message
  /// otherwise. The caller is responsible for freeing the error message.
  ffi.Pointer<ffi.Char> Dart_Initialize(
    ffi.Pointer<Dart_InitializeParams> params,
  ) {
    return _Dart_Initialize(
      params,
    );
  }

  late final _Dart_InitializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<Dart_InitializeParams>)>>('Dart_Initialize');
  late final _Dart_Initialize = _Dart_InitializePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<Dart_InitializeParams>)>();

  /// Cleanup state in the VM before process termination.
  ///
  /// \return NULL if cleanup is successful. Returns an error message otherwise.
  /// The caller is responsible for freeing the error message.
  ///
  /// NOTE: This function must not be called on a thread that was created by the VM
  /// itself.
  ffi.Pointer<ffi.Char> Dart_Cleanup() {
    return _Dart_Cleanup();
  }

  late final _Dart_CleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'Dart_Cleanup');
  late final _Dart_Cleanup =
      _Dart_CleanupPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Sets command line flags. Should be called before Dart_Initialize.
  ///
  /// \param argc The length of the arguments array.
  /// \param argv An array of arguments.
  ///
  /// \return NULL if successful. Returns an error message otherwise.
  /// The caller is responsible for freeing the error message.
  ///
  /// NOTE: This call does not store references to the passed in c-strings.
  ffi.Pointer<ffi.Char> Dart_SetVMFlags(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Char>> argv,
  ) {
    return _Dart_SetVMFlags(
      argc,
      argv,
    );
  }

  late final _Dart_SetVMFlagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_SetVMFlags');
  late final _Dart_SetVMFlags = _Dart_SetVMFlagsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Returns true if the named VM flag is of boolean type, specified, and set to
  /// true.
  ///
  /// \param flag_name The name of the flag without leading punctuation
  /// (example: "enable_asserts").
  bool Dart_IsVMFlagSet(
    ffi.Pointer<ffi.Char> flag_name,
  ) {
    return _Dart_IsVMFlagSet(
      flag_name,
    );
  }

  late final _Dart_IsVMFlagSetPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_IsVMFlagSet');
  late final _Dart_IsVMFlagSet =
      _Dart_IsVMFlagSetPtr.asFunction<bool Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a new isolate. The new isolate becomes the current isolate.
  ///
  /// A snapshot can be used to restore the VM quickly to a saved state
  /// and is useful for fast startup. If snapshot data is provided, the
  /// isolate will be started using that snapshot data. Requires a core snapshot or
  /// an app snapshot created by Dart_CreateSnapshot or
  /// Dart_CreatePrecompiledSnapshot* from a VM with the same version.
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param script_uri The main source file or snapshot this isolate will load.
  /// The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a child
  /// isolate is created by Isolate.spawn. The embedder should use a URI that
  /// allows it to load the same program into such a child isolate.
  /// \param name A short name for the isolate to improve debugging messages.
  /// Typically of the format 'foo.dart:main()'.
  /// \param isolate_snapshot_data
  /// \param isolate_snapshot_instructions Buffers containing a snapshot of the
  /// isolate or NULL if no snapshot is provided. If provided, the buffers must
  /// remain valid until the isolate shuts down.
  /// \param flags Pointer to VM specific flags or NULL for default flags.
  /// \param isolate_group_data Embedder group data. This data can be obtained
  /// by calling Dart_IsolateGroupData and will be passed to the
  /// Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and
  /// Dart_IsolateGroupCleanupCallback.
  /// \param isolate_data Embedder data.  This data will be passed to
  /// the Dart_IsolateGroupCreateCallback when new isolates are spawned from
  /// this parent isolate.
  /// \param error Returns NULL if creation is successful, an error message
  /// otherwise. The caller is responsible for calling free() on the error
  /// message.
  ///
  /// \return The new isolate on success, or NULL if isolate creation failed.
  Dart_Isolate Dart_CreateIsolateGroup(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Uint8> isolate_snapshot_data,
    ffi.Pointer<ffi.Uint8> isolate_snapshot_instructions,
    ffi.Pointer<Dart_IsolateFlags> flags,
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateGroup(
      script_uri,
      name,
      isolate_snapshot_data,
      isolate_snapshot_instructions,
      flags,
      isolate_group_data,
      isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateGroupPtr = _lookup<
      ffi.NativeFunction<
          Dart_Isolate Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<Dart_IsolateFlags>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_CreateIsolateGroup');
  late final _Dart_CreateIsolateGroup = _Dart_CreateIsolateGroupPtr.asFunction<
      Dart_Isolate Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<Dart_IsolateFlags>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Creates a new isolate inside the isolate group of [group_member].
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param group_member An isolate from the same group into which the newly created
  /// isolate should be born into. Other threads may not have entered / enter this
  /// member isolate.
  /// \param name A short name for the isolate for debugging purposes.
  /// \param shutdown_callback A callback to be called when the isolate is being
  /// shutdown (may be NULL).
  /// \param cleanup_callback A callback to be called when the isolate is being
  /// cleaned up (may be NULL).
  /// \param isolate_data The embedder-specific data associated with this isolate.
  /// \param error Set to NULL if creation is successful, set to an error
  /// message otherwise. The caller is responsible for calling free() on the
  /// error message.
  ///
  /// \return The newly created isolate on success, or NULL if isolate creation
  /// failed.
  ///
  /// If successful, the newly created isolate will become the current isolate.
  Dart_Isolate Dart_CreateIsolateInGroup(
    Dart_Isolate group_member,
    ffi.Pointer<ffi.Char> name,
    Dart_IsolateShutdownCallback shutdown_callback,
    Dart_IsolateCleanupCallback cleanup_callback,
    ffi.Pointer<ffi.Void> child_isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateInGroup(
      group_member,
      name,
      shutdown_callback,
      cleanup_callback,
      child_isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateInGroupPtr = _lookup<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  Dart_Isolate,
                  ffi.Pointer<ffi.Char>,
                  Dart_IsolateShutdownCallback,
                  Dart_IsolateCleanupCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_CreateIsolateInGroup');
  late final _Dart_CreateIsolateInGroup =
      _Dart_CreateIsolateInGroupPtr.asFunction<
          Dart_Isolate Function(
              Dart_Isolate,
              ffi.Pointer<ffi.Char>,
              Dart_IsolateShutdownCallback,
              Dart_IsolateCleanupCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Creates a new isolate from a Dart Kernel file. The new isolate
  /// becomes the current isolate.
  ///
  /// Requires there to be no current isolate.
  ///
  /// \param script_uri The main source file or snapshot this isolate will load.
  /// The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a child
  /// isolate is created by Isolate.spawn. The embedder should use a URI that
  /// allows it to load the same program into such a child isolate.
  /// \param name A short name for the isolate to improve debugging messages.
  /// Typically of the format 'foo.dart:main()'.
  /// \param kernel_buffer
  /// \param kernel_buffer_size A buffer which contains a kernel/DIL program. Must
  /// remain valid until isolate shutdown.
  /// \param flags Pointer to VM specific flags or NULL for default flags.
  /// \param isolate_group_data Embedder group data. This data can be obtained
  /// by calling Dart_IsolateGroupData and will be passed to the
  /// Dart_IsolateShutdownCallback, Dart_IsolateCleanupCallback, and
  /// Dart_IsolateGroupCleanupCallback.
  /// \param isolate_data Embedder data.  This data will be passed to
  /// the Dart_IsolateGroupCreateCallback when new isolates are spawned from
  /// this parent isolate.
  /// \param error Returns NULL if creation is successful, an error message
  /// otherwise. The caller is responsible for calling free() on the error
  /// message.
  ///
  /// \return The new isolate on success, or NULL if isolate creation failed.
  Dart_Isolate Dart_CreateIsolateGroupFromKernel(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
    ffi.Pointer<Dart_IsolateFlags> flags,
    ffi.Pointer<ffi.Void> isolate_group_data,
    ffi.Pointer<ffi.Void> isolate_data,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_CreateIsolateGroupFromKernel(
      script_uri,
      name,
      kernel_buffer,
      kernel_buffer_size,
      flags,
      isolate_group_data,
      isolate_data,
      error,
    );
  }

  late final _Dart_CreateIsolateGroupFromKernelPtr = _lookup<
          ffi.NativeFunction<
              Dart_Isolate Function(
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Uint8>,
                  ffi.IntPtr,
                  ffi.Pointer<Dart_IsolateFlags>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_CreateIsolateGroupFromKernel');
  late final _Dart_CreateIsolateGroupFromKernel =
      _Dart_CreateIsolateGroupFromKernelPtr.asFunction<
          Dart_Isolate Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              int,
              ffi.Pointer<Dart_IsolateFlags>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Shuts down the current isolate. After this call, the current isolate is NULL.
  /// Any current scopes created by Dart_EnterScope will be exited. Invokes the
  /// shutdown callback and any callbacks of remaining weak persistent handles.
  ///
  /// Requires there to be a current isolate.
  void Dart_ShutdownIsolate() {
    return _Dart_ShutdownIsolate();
  }

  late final _Dart_ShutdownIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ShutdownIsolate');
  late final _Dart_ShutdownIsolate =
      _Dart_ShutdownIsolatePtr.asFunction<void Function()>();

  /// Returns the current isolate. Will return NULL if there is no
  /// current isolate.
  Dart_Isolate Dart_CurrentIsolate() {
    return _Dart_CurrentIsolate();
  }

  late final _Dart_CurrentIsolatePtr =
      _lookup<ffi.NativeFunction<Dart_Isolate Function()>>(
          'Dart_CurrentIsolate');
  late final _Dart_CurrentIsolate =
      _Dart_CurrentIsolatePtr.asFunction<Dart_Isolate Function()>();

  /// Returns the callback data associated with the current isolate. This
  /// data was set when the isolate got created or initialized.
  ffi.Pointer<ffi.Void> Dart_CurrentIsolateData() {
    return _Dart_CurrentIsolateData();
  }

  late final _Dart_CurrentIsolateDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'Dart_CurrentIsolateData');
  late final _Dart_CurrentIsolateData = _Dart_CurrentIsolateDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function()>();

  /// Returns the callback data associated with the given isolate. This
  /// data was set when the isolate got created or initialized.
  ffi.Pointer<ffi.Void> Dart_IsolateData(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateData(
      isolate,
    );
  }

  late final _Dart_IsolateDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(Dart_Isolate)>>(
          'Dart_IsolateData');
  late final _Dart_IsolateData = _Dart_IsolateDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(Dart_Isolate)>();

  /// Returns the current isolate group. Will return NULL if there is no
  /// current isolate group.
  Dart_IsolateGroup Dart_CurrentIsolateGroup() {
    return _Dart_CurrentIsolateGroup();
  }

  late final _Dart_CurrentIsolateGroupPtr =
      _lookup<ffi.NativeFunction<Dart_IsolateGroup Function()>>(
          'Dart_CurrentIsolateGroup');
  late final _Dart_CurrentIsolateGroup =
      _Dart_CurrentIsolateGroupPtr.asFunction<Dart_IsolateGroup Function()>();

  /// Returns the callback data associated with the current isolate group. This
  /// data was passed to the isolate group when it was created.
  ffi.Pointer<ffi.Void> Dart_CurrentIsolateGroupData() {
    return _Dart_CurrentIsolateGroupData();
  }

  late final _Dart_CurrentIsolateGroupDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'Dart_CurrentIsolateGroupData');
  late final _Dart_CurrentIsolateGroupData = _Dart_CurrentIsolateGroupDataPtr
      .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// Returns the callback data associated with the specified isolate group. This
  /// data was passed to the isolate when it was created.
  /// The embedder is responsible for ensuring the consistency of this data
  /// with respect to the lifecycle of an isolate group.
  ffi.Pointer<ffi.Void> Dart_IsolateGroupData(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateGroupData(
      isolate,
    );
  }

  late final _Dart_IsolateGroupDataPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(Dart_Isolate)>>(
          'Dart_IsolateGroupData');
  late final _Dart_IsolateGroupData = _Dart_IsolateGroupDataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(Dart_Isolate)>();

  /// Returns the debugging name for the current isolate.
  ///
  /// This name is unique to each isolate and should only be used to make
  /// debugging messages more comprehensible.
  Object Dart_DebugName() {
    return _Dart_DebugName();
  }

  late final _Dart_DebugNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_DebugName');
  late final _Dart_DebugName =
      _Dart_DebugNamePtr.asFunction<Object Function()>();

  /// Returns the ID for an isolate which is used to query the service protocol.
  ///
  /// It is the responsibility of the caller to free the returned ID.
  ffi.Pointer<ffi.Char> Dart_IsolateServiceId(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateServiceId(
      isolate,
    );
  }

  late final _Dart_IsolateServiceIdPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>>(
          'Dart_IsolateServiceId');
  late final _Dart_IsolateServiceId = _Dart_IsolateServiceIdPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(Dart_Isolate)>();

  /// Enters an isolate. After calling this function,
  /// the current isolate will be set to the provided isolate.
  ///
  /// Requires there to be no current isolate. Multiple threads may not be in
  /// the same isolate at once.
  void Dart_EnterIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_EnterIsolate(
      isolate,
    );
  }

  late final _Dart_EnterIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>(
          'Dart_EnterIsolate');
  late final _Dart_EnterIsolate =
      _Dart_EnterIsolatePtr.asFunction<void Function(Dart_Isolate)>();

  /// Kills the given isolate.
  ///
  /// This function has the same effect as dart:isolate's
  /// Isolate.kill(priority:immediate).
  /// It can interrupt ordinary Dart code but not native code. If the isolate is
  /// in the middle of a long running native function, the isolate will not be
  /// killed until control returns to Dart.
  ///
  /// Does not require a current isolate. It is safe to kill the current isolate if
  /// there is one.
  void Dart_KillIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_KillIsolate(
      isolate,
    );
  }

  late final _Dart_KillIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>(
          'Dart_KillIsolate');
  late final _Dart_KillIsolate =
      _Dart_KillIsolatePtr.asFunction<void Function(Dart_Isolate)>();

  /// Notifies the VM that the embedder expects |size| bytes of memory have become
  /// unreachable. The VM may use this hint to adjust the garbage collector's
  /// growth policy.
  ///
  /// Multiple calls are interpreted as increasing, not replacing, the estimate of
  /// unreachable memory.
  ///
  /// Requires there to be a current isolate.
  void Dart_HintFreed(
    int size,
  ) {
    return _Dart_HintFreed(
      size,
    );
  }

  late final _Dart_HintFreedPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.IntPtr)>>(
          'Dart_HintFreed');
  late final _Dart_HintFreed =
      _Dart_HintFreedPtr.asFunction<void Function(int)>();

  /// Notifies the VM that the embedder expects to be idle until |deadline|. The VM
  /// may use this time to perform garbage collection or other tasks to avoid
  /// delays during execution of Dart code in the future.
  ///
  /// |deadline| is measured in microseconds against the system's monotonic time.
  /// This clock can be accessed via Dart_TimelineGetMicros().
  ///
  /// Requires there to be a current isolate.
  void Dart_NotifyIdle(
    int deadline,
  ) {
    return _Dart_NotifyIdle(
      deadline,
    );
  }

  late final _Dart_NotifyIdlePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int64)>>(
          'Dart_NotifyIdle');
  late final _Dart_NotifyIdle =
      _Dart_NotifyIdlePtr.asFunction<void Function(int)>();

  /// Notifies the VM that the system is running low on memory.
  ///
  /// Does not require a current isolate. Only valid after calling Dart_Initialize.
  void Dart_NotifyLowMemory() {
    return _Dart_NotifyLowMemory();
  }

  late final _Dart_NotifyLowMemoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_NotifyLowMemory');
  late final _Dart_NotifyLowMemory =
      _Dart_NotifyLowMemoryPtr.asFunction<void Function()>();

  /// Starts the CPU sampling profiler.
  void Dart_StartProfiling() {
    return _Dart_StartProfiling();
  }

  late final _Dart_StartProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_StartProfiling');
  late final _Dart_StartProfiling =
      _Dart_StartProfilingPtr.asFunction<void Function()>();

  /// Stops the CPU sampling profiler.
  ///
  /// Note that some profile samples might still be taken after this fucntion
  /// returns due to the asynchronous nature of the implementation on some
  /// platforms.
  void Dart_StopProfiling() {
    return _Dart_StopProfiling();
  }

  late final _Dart_StopProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_StopProfiling');
  late final _Dart_StopProfiling =
      _Dart_StopProfilingPtr.asFunction<void Function()>();

  /// Notifies the VM that the current thread should not be profiled until a
  /// matching call to Dart_ThreadEnableProfiling is made.
  ///
  /// NOTE: By default, if a thread has entered an isolate it will be profiled.
  /// This function should be used when an embedder knows a thread is about
  /// to make a blocking call and wants to avoid unnecessary interrupts by
  /// the profiler.
  void Dart_ThreadDisableProfiling() {
    return _Dart_ThreadDisableProfiling();
  }

  late final _Dart_ThreadDisableProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_ThreadDisableProfiling');
  late final _Dart_ThreadDisableProfiling =
      _Dart_ThreadDisableProfilingPtr.asFunction<void Function()>();

  /// Notifies the VM that the current thread should be profiled.
  ///
  /// NOTE: It is only legal to call this function *after* calling
  /// Dart_ThreadDisableProfiling.
  ///
  /// NOTE: By default, if a thread has entered an isolate it will be profiled.
  void Dart_ThreadEnableProfiling() {
    return _Dart_ThreadEnableProfiling();
  }

  late final _Dart_ThreadEnableProfilingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Dart_ThreadEnableProfiling');
  late final _Dart_ThreadEnableProfiling =
      _Dart_ThreadEnableProfilingPtr.asFunction<void Function()>();

  /// Register symbol information for the Dart VM's profiler and crash dumps.
  ///
  /// This consumes the output of //topaz/runtime/dart/profiler_symbols, which
  /// should be treated as opaque.
  void Dart_AddSymbols(
    ffi.Pointer<ffi.Char> dso_name,
    ffi.Pointer<ffi.Void> buffer,
    int buffer_size,
  ) {
    return _Dart_AddSymbols(
      dso_name,
      buffer,
      buffer_size,
    );
  }

  late final _Dart_AddSymbolsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
              ffi.IntPtr)>>('Dart_AddSymbols');
  late final _Dart_AddSymbols = _Dart_AddSymbolsPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>, int)>();

  /// Exits an isolate. After this call, Dart_CurrentIsolate will
  /// return NULL.
  ///
  /// Requires there to be a current isolate.
  void Dart_ExitIsolate() {
    return _Dart_ExitIsolate();
  }

  late final _Dart_ExitIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ExitIsolate');
  late final _Dart_ExitIsolate =
      _Dart_ExitIsolatePtr.asFunction<void Function()>();

  /// Creates a full snapshot of the current isolate heap.
  ///
  /// A full snapshot is a compact representation of the dart vm isolate heap
  /// and dart isolate heap states. These snapshots are used to initialize
  /// the vm isolate on startup and fast initialization of an isolate.
  /// A Snapshot of the heap is created before any dart code has executed.
  ///
  /// Requires there to be a current isolate. Not available in the precompiled
  /// runtime (check Dart_IsPrecompiledRuntime).
  ///
  /// \param buffer Returns a pointer to a buffer containing the
  /// snapshot. This buffer is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param size Returns the size of the buffer.
  /// \param is_core Create a snapshot containing core libraries.
  /// Such snapshot should be agnostic to null safety mode.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateSnapshot(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> vm_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> vm_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    bool is_core,
  ) {
    return _Dart_CreateSnapshot(
      vm_snapshot_data_buffer,
      vm_snapshot_data_size,
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      is_core,
    );
  }

  late final _Dart_CreateSnapshotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Bool)>>('Dart_CreateSnapshot');
  late final _Dart_CreateSnapshot = _Dart_CreateSnapshotPtr.asFunction<
      Object Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>,
          bool)>();

  /// Returns whether the buffer contains a kernel file.
  ///
  /// \param buffer Pointer to a buffer that might contain a kernel binary.
  /// \param buffer_size Size of the buffer.
  ///
  /// \return Whether the buffer contains a kernel binary (full or partial).
  bool Dart_IsKernel(
    ffi.Pointer<ffi.Uint8> buffer,
    int buffer_size,
  ) {
    return _Dart_IsKernel(
      buffer,
      buffer_size,
    );
  }

  late final _Dart_IsKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>('Dart_IsKernel');
  late final _Dart_IsKernel = _Dart_IsKernelPtr.asFunction<
      bool Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Make isolate runnable.
  ///
  /// When isolates are spawned, this function is used to indicate that
  /// the creation and initialization (including script loading) of the
  /// isolate is complete and the isolate can start.
  /// This function expects there to be no current isolate.
  ///
  /// \param isolate The isolate to be made runnable.
  ///
  /// \return NULL if successful. Returns an error message otherwise. The caller
  /// is responsible for freeing the error message.
  ffi.Pointer<ffi.Char> Dart_IsolateMakeRunnable(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsolateMakeRunnable(
      isolate,
    );
  }

  late final _Dart_IsolateMakeRunnablePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>>(
          'Dart_IsolateMakeRunnable');
  late final _Dart_IsolateMakeRunnable = _Dart_IsolateMakeRunnablePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(Dart_Isolate)>();

  /// Allows embedders to provide an alternative wakeup mechanism for the
  /// delivery of inter-isolate messages. This setting only applies to
  /// the current isolate.
  ///
  /// Most embedders will only call this function once, before isolate
  /// execution begins. If this function is called after isolate
  /// execution begins, the embedder is responsible for threading issues.
  void Dart_SetMessageNotifyCallback(
    Dart_MessageNotifyCallback message_notify_callback,
  ) {
    return _Dart_SetMessageNotifyCallback(
      message_notify_callback,
    );
  }

  late final _Dart_SetMessageNotifyCallbackPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Dart_MessageNotifyCallback)>>(
      'Dart_SetMessageNotifyCallback');
  late final _Dart_SetMessageNotifyCallback = _Dart_SetMessageNotifyCallbackPtr
      .asFunction<void Function(Dart_MessageNotifyCallback)>();

  /// Query the current message notify callback for the isolate.
  ///
  /// \return The current message notify callback for the isolate.
  Dart_MessageNotifyCallback Dart_GetMessageNotifyCallback() {
    return _Dart_GetMessageNotifyCallback();
  }

  late final _Dart_GetMessageNotifyCallbackPtr =
      _lookup<ffi.NativeFunction<Dart_MessageNotifyCallback Function()>>(
          'Dart_GetMessageNotifyCallback');
  late final _Dart_GetMessageNotifyCallback = _Dart_GetMessageNotifyCallbackPtr
      .asFunction<Dart_MessageNotifyCallback Function()>();

  /// If the VM flag `--pause-isolates-on-start` was passed this will be true.
  ///
  /// \return A boolean value indicating if pause on start was requested.
  bool Dart_ShouldPauseOnStart() {
    return _Dart_ShouldPauseOnStart();
  }

  late final _Dart_ShouldPauseOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_ShouldPauseOnStart');
  late final _Dart_ShouldPauseOnStart =
      _Dart_ShouldPauseOnStartPtr.asFunction<bool Function()>();

  /// Override the VM flag `--pause-isolates-on-start` for the current isolate.
  ///
  /// \param should_pause Should the isolate be paused on start?
  ///
  /// NOTE: This must be called before Dart_IsolateMakeRunnable.
  void Dart_SetShouldPauseOnStart(
    bool should_pause,
  ) {
    return _Dart_SetShouldPauseOnStart(
      should_pause,
    );
  }

  late final _Dart_SetShouldPauseOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetShouldPauseOnStart');
  late final _Dart_SetShouldPauseOnStart =
      _Dart_SetShouldPauseOnStartPtr.asFunction<void Function(bool)>();

  /// Is the current isolate paused on start?
  ///
  /// \return A boolean value indicating if the isolate is paused on start.
  bool Dart_IsPausedOnStart() {
    return _Dart_IsPausedOnStart();
  }

  late final _Dart_IsPausedOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_IsPausedOnStart');
  late final _Dart_IsPausedOnStart =
      _Dart_IsPausedOnStartPtr.asFunction<bool Function()>();

  /// Called when the embedder has paused the current isolate on start and when
  /// the embedder has resumed the isolate.
  ///
  /// \param paused Is the isolate paused on start?
  void Dart_SetPausedOnStart(
    bool paused,
  ) {
    return _Dart_SetPausedOnStart(
      paused,
    );
  }

  late final _Dart_SetPausedOnStartPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetPausedOnStart');
  late final _Dart_SetPausedOnStart =
      _Dart_SetPausedOnStartPtr.asFunction<void Function(bool)>();

  /// If the VM flag `--pause-isolates-on-exit` was passed this will be true.
  ///
  /// \return A boolean value indicating if pause on exit was requested.
  bool Dart_ShouldPauseOnExit() {
    return _Dart_ShouldPauseOnExit();
  }

  late final _Dart_ShouldPauseOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_ShouldPauseOnExit');
  late final _Dart_ShouldPauseOnExit =
      _Dart_ShouldPauseOnExitPtr.asFunction<bool Function()>();

  /// Override the VM flag `--pause-isolates-on-exit` for the current isolate.
  ///
  /// \param should_pause Should the isolate be paused on exit?
  void Dart_SetShouldPauseOnExit(
    bool should_pause,
  ) {
    return _Dart_SetShouldPauseOnExit(
      should_pause,
    );
  }

  late final _Dart_SetShouldPauseOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetShouldPauseOnExit');
  late final _Dart_SetShouldPauseOnExit =
      _Dart_SetShouldPauseOnExitPtr.asFunction<void Function(bool)>();

  /// Is the current isolate paused on exit?
  ///
  /// \return A boolean value indicating if the isolate is paused on exit.
  bool Dart_IsPausedOnExit() {
    return _Dart_IsPausedOnExit();
  }

  late final _Dart_IsPausedOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_IsPausedOnExit');
  late final _Dart_IsPausedOnExit =
      _Dart_IsPausedOnExitPtr.asFunction<bool Function()>();

  /// Called when the embedder has paused the current isolate on exit and when
  /// the embedder has resumed the isolate.
  ///
  /// \param paused Is the isolate paused on exit?
  void Dart_SetPausedOnExit(
    bool paused,
  ) {
    return _Dart_SetPausedOnExit(
      paused,
    );
  }

  late final _Dart_SetPausedOnExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Dart_SetPausedOnExit');
  late final _Dart_SetPausedOnExit =
      _Dart_SetPausedOnExitPtr.asFunction<void Function(bool)>();

  /// Called when the embedder has caught a top level unhandled exception error
  /// in the current isolate.
  ///
  /// NOTE: It is illegal to call this twice on the same isolate without first
  /// clearing the sticky error to null.
  ///
  /// \param error The unhandled exception error.
  void Dart_SetStickyError(
    Object error,
  ) {
    return _Dart_SetStickyError(
      error,
    );
  }

  late final _Dart_SetStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>(
          'Dart_SetStickyError');
  late final _Dart_SetStickyError =
      _Dart_SetStickyErrorPtr.asFunction<void Function(Object)>();

  /// Does the current isolate have a sticky error?
  bool Dart_HasStickyError() {
    return _Dart_HasStickyError();
  }

  late final _Dart_HasStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_HasStickyError');
  late final _Dart_HasStickyError =
      _Dart_HasStickyErrorPtr.asFunction<bool Function()>();

  /// Gets the sticky error for the current isolate.
  ///
  /// \return A handle to the sticky error object or null.
  Object Dart_GetStickyError() {
    return _Dart_GetStickyError();
  }

  late final _Dart_GetStickyErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_GetStickyError');
  late final _Dart_GetStickyError =
      _Dart_GetStickyErrorPtr.asFunction<Object Function()>();

  /// Handles the next pending message for the current isolate.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_HandleMessage() {
    return _Dart_HandleMessage();
  }

  late final _Dart_HandleMessagePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_HandleMessage');
  late final _Dart_HandleMessage =
      _Dart_HandleMessagePtr.asFunction<Object Function()>();

  /// Drains the microtask queue, then blocks the calling thread until the current
  /// isolate recieves a message, then handles all messages.
  ///
  /// \param timeout_millis When non-zero, the call returns after the indicated
  /// number of milliseconds even if no message was received.
  /// \return A valid handle if no error occurs, otherwise an error handle.
  Object Dart_WaitForEvent(
    int timeout_millis,
  ) {
    return _Dart_WaitForEvent(
      timeout_millis,
    );
  }

  late final _Dart_WaitForEventPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int64)>>(
          'Dart_WaitForEvent');
  late final _Dart_WaitForEvent =
      _Dart_WaitForEventPtr.asFunction<Object Function(int)>();

  /// Handles any pending messages for the vm service for the current
  /// isolate.
  ///
  /// This function may be used by an embedder at a breakpoint to avoid
  /// pausing the vm service.
  ///
  /// This function can indirectly cause the message notify callback to
  /// be called.
  ///
  /// \return true if the vm service requests the program resume
  /// execution, false otherwise
  bool Dart_HandleServiceMessages() {
    return _Dart_HandleServiceMessages();
  }

  late final _Dart_HandleServiceMessagesPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_HandleServiceMessages');
  late final _Dart_HandleServiceMessages =
      _Dart_HandleServiceMessagesPtr.asFunction<bool Function()>();

  /// Does the current isolate have pending service messages?
  ///
  /// \return true if the isolate has pending service messages, false otherwise.
  bool Dart_HasServiceMessages() {
    return _Dart_HasServiceMessages();
  }

  late final _Dart_HasServiceMessagesPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_HasServiceMessages');
  late final _Dart_HasServiceMessages =
      _Dart_HasServiceMessagesPtr.asFunction<bool Function()>();

  /// Processes any incoming messages for the current isolate.
  ///
  /// This function may only be used when the embedder has not provided
  /// an alternate message delivery mechanism with
  /// Dart_SetMessageCallbacks. It is provided for convenience.
  ///
  /// This function waits for incoming messages for the current
  /// isolate. As new messages arrive, they are handled using
  /// Dart_HandleMessage. The routine exits when all ports to the
  /// current isolate are closed.
  ///
  /// \return A valid handle if the run loop exited successfully.  If an
  /// exception or other error occurs while processing messages, an
  /// error handle is returned.
  Object Dart_RunLoop() {
    return _Dart_RunLoop();
  }

  late final _Dart_RunLoopPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_RunLoop');
  late final _Dart_RunLoop = _Dart_RunLoopPtr.asFunction<Object Function()>();

  /// Lets the VM run message processing for the isolate.
  ///
  /// This function expects there to a current isolate and the current isolate
  /// must not have an active api scope. The VM will take care of making the
  /// isolate runnable (if not already), handles its message loop and will take
  /// care of shutting the isolate down once it's done.
  ///
  /// \param errors_are_fatal Whether uncaught errors should be fatal.
  /// \param on_error_port A port to notify on uncaught errors (or ILLEGAL_PORT).
  /// \param on_exit_port A port to notify on exit (or ILLEGAL_PORT).
  /// \param error A non-NULL pointer which will hold an error message if the call
  /// fails. The error has to be free()ed by the caller.
  ///
  /// \return If successfull the VM takes owernship of the isolate and takes care
  /// of its message loop. If not successful the caller retains owernship of the
  /// isolate.
  bool Dart_RunLoopAsync(
    bool errors_are_fatal,
    int on_error_port,
    int on_exit_port,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_RunLoopAsync(
      errors_are_fatal,
      on_error_port,
      on_exit_port,
      error,
    );
  }

  late final _Dart_RunLoopAsyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Bool, Dart_Port, Dart_Port,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_RunLoopAsync');
  late final _Dart_RunLoopAsync = _Dart_RunLoopAsyncPtr.asFunction<
      bool Function(bool, int, int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Gets the main port id for the current isolate.
  int Dart_GetMainPortId() {
    return _Dart_GetMainPortId();
  }

  late final _Dart_GetMainPortIdPtr =
      _lookup<ffi.NativeFunction<Dart_Port Function()>>('Dart_GetMainPortId');
  late final _Dart_GetMainPortId =
      _Dart_GetMainPortIdPtr.asFunction<int Function()>();

  /// Does the current isolate have live ReceivePorts?
  ///
  /// A ReceivePort is live when it has not been closed.
  bool Dart_HasLivePorts() {
    return _Dart_HasLivePorts();
  }

  late final _Dart_HasLivePortsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('Dart_HasLivePorts');
  late final _Dart_HasLivePorts =
      _Dart_HasLivePortsPtr.asFunction<bool Function()>();

  /// Posts a message for some isolate. The message is a serialized
  /// object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param port The destination port.
  /// \param object An object from the current isolate.
  ///
  /// \return True if the message was posted.
  bool Dart_Post(
    int port_id,
    Object object,
  ) {
    return _Dart_Post(
      port_id,
      object,
    );
  }

  late final _Dart_PostPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Port, ffi.Handle)>>(
          'Dart_Post');
  late final _Dart_Post =
      _Dart_PostPtr.asFunction<bool Function(int, Object)>();

  /// Returns a new SendPort with the provided port id.
  ///
  /// \param port_id The destination port.
  ///
  /// \return A new SendPort if no errors occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewSendPort(
    int port_id,
  ) {
    return _Dart_NewSendPort(
      port_id,
    );
  }

  late final _Dart_NewSendPortPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(Dart_Port)>>(
          'Dart_NewSendPort');
  late final _Dart_NewSendPort =
      _Dart_NewSendPortPtr.asFunction<Object Function(int)>();

  /// Gets the SendPort id for the provided SendPort.
  /// \param port A SendPort object whose id is desired.
  /// \param port_id Returns the id of the SendPort.
  /// \return Success if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_SendPortGetId(
    Object port,
    ffi.Pointer<Dart_Port> port_id,
  ) {
    return _Dart_SendPortGetId(
      port,
      port_id,
    );
  }

  late final _Dart_SendPortGetIdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<Dart_Port>)>>('Dart_SendPortGetId');
  late final _Dart_SendPortGetId = _Dart_SendPortGetIdPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_Port>)>();

  /// Enters a new scope.
  ///
  /// All new local handles will be created in this scope. Additionally,
  /// some functions may return "scope allocated" memory which is only
  /// valid within this scope.
  ///
  /// Requires there to be a current isolate.
  void Dart_EnterScope() {
    return _Dart_EnterScope();
  }

  late final _Dart_EnterScopePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_EnterScope');
  late final _Dart_EnterScope =
      _Dart_EnterScopePtr.asFunction<void Function()>();

  /// Exits a scope.
  ///
  /// The previous scope (if any) becomes the current scope.
  ///
  /// Requires there to be a current isolate.
  void Dart_ExitScope() {
    return _Dart_ExitScope();
  }

  late final _Dart_ExitScopePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_ExitScope');
  late final _Dart_ExitScope = _Dart_ExitScopePtr.asFunction<void Function()>();

  /// The Dart VM uses "zone allocation" for temporary structures. Zones
  /// support very fast allocation of small chunks of memory. The chunks
  /// cannot be deallocated individually, but instead zones support
  /// deallocating all chunks in one fast operation.
  ///
  /// This function makes it possible for the embedder to allocate
  /// temporary data in the VMs zone allocator.
  ///
  /// Zone allocation is possible:
  /// 1. when inside a scope where local handles can be allocated
  /// 2. when processing a message from a native port in a native port
  /// handler
  ///
  /// All the memory allocated this way will be reclaimed either on the
  /// next call to Dart_ExitScope or when the native port handler exits.
  ///
  /// \param size Size of the memory to allocate.
  ///
  /// \return A pointer to the allocated memory. NULL if allocation
  /// failed. Failure might due to is no current VM zone.
  ffi.Pointer<ffi.Uint8> Dart_ScopeAllocate(
    int size,
  ) {
    return _Dart_ScopeAllocate(
      size,
    );
  }

  late final _Dart_ScopeAllocatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(ffi.IntPtr)>>(
          'Dart_ScopeAllocate');
  late final _Dart_ScopeAllocate =
      _Dart_ScopeAllocatePtr.asFunction<ffi.Pointer<ffi.Uint8> Function(int)>();

  /// Returns the null object.
  ///
  /// \return A handle to the null object.
  Object Dart_Null() {
    return _Dart_Null();
  }

  late final _Dart_NullPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_Null');
  late final _Dart_Null = _Dart_NullPtr.asFunction<Object Function()>();

  /// Is this object null?
  bool Dart_IsNull(
    Object object,
  ) {
    return _Dart_IsNull(
      object,
    );
  }

  late final _Dart_IsNullPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsNull');
  late final _Dart_IsNull = _Dart_IsNullPtr.asFunction<bool Function(Object)>();

  /// Returns the empty string object.
  ///
  /// \return A handle to the empty string object.
  Object Dart_EmptyString() {
    return _Dart_EmptyString();
  }

  late final _Dart_EmptyStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_EmptyString');
  late final _Dart_EmptyString =
      _Dart_EmptyStringPtr.asFunction<Object Function()>();

  /// Returns types that are not classes, and which therefore cannot be looked up
  /// as library members by Dart_GetType.
  ///
  /// \return A handle to the dynamic, void or Never type.
  Object Dart_TypeDynamic() {
    return _Dart_TypeDynamic();
  }

  late final _Dart_TypeDynamicPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeDynamic');
  late final _Dart_TypeDynamic =
      _Dart_TypeDynamicPtr.asFunction<Object Function()>();

  Object Dart_TypeVoid() {
    return _Dart_TypeVoid();
  }

  late final _Dart_TypeVoidPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeVoid');
  late final _Dart_TypeVoid = _Dart_TypeVoidPtr.asFunction<Object Function()>();

  Object Dart_TypeNever() {
    return _Dart_TypeNever();
  }

  late final _Dart_TypeNeverPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_TypeNever');
  late final _Dart_TypeNever =
      _Dart_TypeNeverPtr.asFunction<Object Function()>();

  /// Checks if the two objects are equal.
  ///
  /// The result of the comparison is returned through the 'equal'
  /// parameter. The return value itself is used to indicate success or
  /// failure, not equality.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param obj1 An object to be compared.
  /// \param obj2 An object to be compared.
  /// \param equal Returns the result of the equality comparison.
  ///
  /// \return A valid handle if no error occurs during the comparison.
  Object Dart_ObjectEquals(
    Object obj1,
    Object obj2,
    ffi.Pointer<ffi.Bool> equal,
  ) {
    return _Dart_ObjectEquals(
      obj1,
      obj2,
      equal,
    );
  }

  late final _Dart_ObjectEqualsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_ObjectEquals');
  late final _Dart_ObjectEquals = _Dart_ObjectEqualsPtr.asFunction<
      Object Function(Object, Object, ffi.Pointer<ffi.Bool>)>();

  /// Is this object an instance of some type?
  ///
  /// The result of the test is returned through the 'instanceof' parameter.
  /// The return value itself is used to indicate success or failure.
  ///
  /// \param object An object.
  /// \param type A type.
  /// \param instanceof Return true if 'object' is an instance of type 'type'.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ObjectIsType(
    Object object,
    Object type,
    ffi.Pointer<ffi.Bool> instanceof,
  ) {
    return _Dart_ObjectIsType(
      object,
      type,
      instanceof,
    );
  }

  late final _Dart_ObjectIsTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_ObjectIsType');
  late final _Dart_ObjectIsType = _Dart_ObjectIsTypePtr.asFunction<
      Object Function(Object, Object, ffi.Pointer<ffi.Bool>)>();

  /// Query object type.
  ///
  /// \param object Some Object.
  ///
  /// \return true if Object is of the specified type.
  bool Dart_IsInstance(
    Object object,
  ) {
    return _Dart_IsInstance(
      object,
    );
  }

  late final _Dart_IsInstancePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsInstance');
  late final _Dart_IsInstance =
      _Dart_IsInstancePtr.asFunction<bool Function(Object)>();

  bool Dart_IsNumber(
    Object object,
  ) {
    return _Dart_IsNumber(
      object,
    );
  }

  late final _Dart_IsNumberPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsNumber');
  late final _Dart_IsNumber =
      _Dart_IsNumberPtr.asFunction<bool Function(Object)>();

  bool Dart_IsInteger(
    Object object,
  ) {
    return _Dart_IsInteger(
      object,
    );
  }

  late final _Dart_IsIntegerPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsInteger');
  late final _Dart_IsInteger =
      _Dart_IsIntegerPtr.asFunction<bool Function(Object)>();

  bool Dart_IsDouble(
    Object object,
  ) {
    return _Dart_IsDouble(
      object,
    );
  }

  late final _Dart_IsDoublePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsDouble');
  late final _Dart_IsDouble =
      _Dart_IsDoublePtr.asFunction<bool Function(Object)>();

  bool Dart_IsBoolean(
    Object object,
  ) {
    return _Dart_IsBoolean(
      object,
    );
  }

  late final _Dart_IsBooleanPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsBoolean');
  late final _Dart_IsBoolean =
      _Dart_IsBooleanPtr.asFunction<bool Function(Object)>();

  bool Dart_IsString(
    Object object,
  ) {
    return _Dart_IsString(
      object,
    );
  }

  late final _Dart_IsStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsString');
  late final _Dart_IsString =
      _Dart_IsStringPtr.asFunction<bool Function(Object)>();

  bool Dart_IsStringLatin1(
    Object object,
  ) {
    return _Dart_IsStringLatin1(
      object,
    );
  }

  late final _Dart_IsStringLatin1Ptr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsStringLatin1');
  late final _Dart_IsStringLatin1 =
      _Dart_IsStringLatin1Ptr.asFunction<bool Function(Object)>();

  bool Dart_IsExternalString(
    Object object,
  ) {
    return _Dart_IsExternalString(
      object,
    );
  }

  late final _Dart_IsExternalStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsExternalString');
  late final _Dart_IsExternalString =
      _Dart_IsExternalStringPtr.asFunction<bool Function(Object)>();

  bool Dart_IsList(
    Object object,
  ) {
    return _Dart_IsList(
      object,
    );
  }

  late final _Dart_IsListPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsList');
  late final _Dart_IsList = _Dart_IsListPtr.asFunction<bool Function(Object)>();

  bool Dart_IsMap(
    Object object,
  ) {
    return _Dart_IsMap(
      object,
    );
  }

  late final _Dart_IsMapPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsMap');
  late final _Dart_IsMap = _Dart_IsMapPtr.asFunction<bool Function(Object)>();

  bool Dart_IsLibrary(
    Object object,
  ) {
    return _Dart_IsLibrary(
      object,
    );
  }

  late final _Dart_IsLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsLibrary');
  late final _Dart_IsLibrary =
      _Dart_IsLibraryPtr.asFunction<bool Function(Object)>();

  bool Dart_IsType(
    Object handle,
  ) {
    return _Dart_IsType(
      handle,
    );
  }

  late final _Dart_IsTypePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>('Dart_IsType');
  late final _Dart_IsType = _Dart_IsTypePtr.asFunction<bool Function(Object)>();

  bool Dart_IsFunction(
    Object handle,
  ) {
    return _Dart_IsFunction(
      handle,
    );
  }

  late final _Dart_IsFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFunction');
  late final _Dart_IsFunction =
      _Dart_IsFunctionPtr.asFunction<bool Function(Object)>();

  bool Dart_IsVariable(
    Object handle,
  ) {
    return _Dart_IsVariable(
      handle,
    );
  }

  late final _Dart_IsVariablePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsVariable');
  late final _Dart_IsVariable =
      _Dart_IsVariablePtr.asFunction<bool Function(Object)>();

  bool Dart_IsTypeVariable(
    Object handle,
  ) {
    return _Dart_IsTypeVariable(
      handle,
    );
  }

  late final _Dart_IsTypeVariablePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTypeVariable');
  late final _Dart_IsTypeVariable =
      _Dart_IsTypeVariablePtr.asFunction<bool Function(Object)>();

  bool Dart_IsClosure(
    Object object,
  ) {
    return _Dart_IsClosure(
      object,
    );
  }

  late final _Dart_IsClosurePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsClosure');
  late final _Dart_IsClosure =
      _Dart_IsClosurePtr.asFunction<bool Function(Object)>();

  bool Dart_IsTypedData(
    Object object,
  ) {
    return _Dart_IsTypedData(
      object,
    );
  }

  late final _Dart_IsTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTypedData');
  late final _Dart_IsTypedData =
      _Dart_IsTypedDataPtr.asFunction<bool Function(Object)>();

  bool Dart_IsByteBuffer(
    Object object,
  ) {
    return _Dart_IsByteBuffer(
      object,
    );
  }

  late final _Dart_IsByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsByteBuffer');
  late final _Dart_IsByteBuffer =
      _Dart_IsByteBufferPtr.asFunction<bool Function(Object)>();

  bool Dart_IsFuture(
    Object object,
  ) {
    return _Dart_IsFuture(
      object,
    );
  }

  late final _Dart_IsFuturePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsFuture');
  late final _Dart_IsFuture =
      _Dart_IsFuturePtr.asFunction<bool Function(Object)>();

  /// Gets the type of a Dart language object.
  ///
  /// \param instance Some Dart object.
  ///
  /// \return If no error occurs, the type is returned. Otherwise an
  /// error handle is returned.
  Object Dart_InstanceGetType(
    Object instance,
  ) {
    return _Dart_InstanceGetType(
      instance,
    );
  }

  late final _Dart_InstanceGetTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_InstanceGetType');
  late final _Dart_InstanceGetType =
      _Dart_InstanceGetTypePtr.asFunction<Object Function(Object)>();

  /// Returns the name for the provided class type.
  ///
  /// \return A valid string handle if no error occurs during the
  /// operation.
  Object Dart_ClassName(
    Object cls_type,
  ) {
    return _Dart_ClassName(
      cls_type,
    );
  }

  late final _Dart_ClassNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClassName');
  late final _Dart_ClassName =
      _Dart_ClassNamePtr.asFunction<Object Function(Object)>();

  /// Returns the name for the provided function or method.
  ///
  /// \return A valid string handle if no error occurs during the
  /// operation.
  Object Dart_FunctionName(
    Object function,
  ) {
    return _Dart_FunctionName(
      function,
    );
  }

  late final _Dart_FunctionNamePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_FunctionName');
  late final _Dart_FunctionName =
      _Dart_FunctionNamePtr.asFunction<Object Function(Object)>();

  /// Returns a handle to the owner of a function.
  ///
  /// The owner of an instance method or a static method is its defining
  /// class. The owner of a top-level function is its defining
  /// library. The owner of the function of a non-implicit closure is the
  /// function of the method or closure that defines the non-implicit
  /// closure.
  ///
  /// \return A valid handle to the owner of the function, or an error
  /// handle if the argument is not a valid handle to a function.
  Object Dart_FunctionOwner(
    Object function,
  ) {
    return _Dart_FunctionOwner(
      function,
    );
  }

  late final _Dart_FunctionOwnerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_FunctionOwner');
  late final _Dart_FunctionOwner =
      _Dart_FunctionOwnerPtr.asFunction<Object Function(Object)>();

  /// Determines whether a function handle referes to a static function
  /// of method.
  ///
  /// For the purposes of the embedding API, a top-level function is
  /// implicitly declared static.
  ///
  /// \param function A handle to a function or method declaration.
  /// \param is_static Returns whether the function or method is declared static.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_FunctionIsStatic(
    Object function,
    ffi.Pointer<ffi.Bool> is_static,
  ) {
    return _Dart_FunctionIsStatic(
      function,
      is_static,
    );
  }

  late final _Dart_FunctionIsStaticPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_FunctionIsStatic');
  late final _Dart_FunctionIsStatic = _Dart_FunctionIsStaticPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Is this object a closure resulting from a tear-off (closurized method)?
  ///
  /// Returns true for closures produced when an ordinary method is accessed
  /// through a getter call. Returns false otherwise, in particular for closures
  /// produced from local function declarations.
  ///
  /// \param object Some Object.
  ///
  /// \return true if Object is a tear-off.
  bool Dart_IsTearOff(
    Object object,
  ) {
    return _Dart_IsTearOff(
      object,
    );
  }

  late final _Dart_IsTearOffPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>(
          'Dart_IsTearOff');
  late final _Dart_IsTearOff =
      _Dart_IsTearOffPtr.asFunction<bool Function(Object)>();

  /// Retrieves the function of a closure.
  ///
  /// \return A handle to the function of the closure, or an error handle if the
  /// argument is not a closure.
  Object Dart_ClosureFunction(
    Object closure,
  ) {
    return _Dart_ClosureFunction(
      closure,
    );
  }

  late final _Dart_ClosureFunctionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClosureFunction');
  late final _Dart_ClosureFunction =
      _Dart_ClosureFunctionPtr.asFunction<Object Function(Object)>();

  /// Returns a handle to the library which contains class.
  ///
  /// \return A valid handle to the library with owns class, null if the class
  /// has no library or an error handle if the argument is not a valid handle
  /// to a class type.
  Object Dart_ClassLibrary(
    Object cls_type,
  ) {
    return _Dart_ClassLibrary(
      cls_type,
    );
  }

  late final _Dart_ClassLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ClassLibrary');
  late final _Dart_ClassLibrary =
      _Dart_ClassLibraryPtr.asFunction<Object Function(Object)>();

  /// Does this Integer fit into a 64-bit signed integer?
  ///
  /// \param integer An integer.
  /// \param fits Returns true if the integer fits into a 64-bit signed integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerFitsIntoInt64(
    Object integer,
    ffi.Pointer<ffi.Bool> fits,
  ) {
    return _Dart_IntegerFitsIntoInt64(
      integer,
      fits,
    );
  }

  late final _Dart_IntegerFitsIntoInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IntegerFitsIntoInt64');
  late final _Dart_IntegerFitsIntoInt64 = _Dart_IntegerFitsIntoInt64Ptr
      .asFunction<Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Does this Integer fit into a 64-bit unsigned integer?
  ///
  /// \param integer An integer.
  /// \param fits Returns true if the integer fits into a 64-bit unsigned integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerFitsIntoUint64(
    Object integer,
    ffi.Pointer<ffi.Bool> fits,
  ) {
    return _Dart_IntegerFitsIntoUint64(
      integer,
      fits,
    );
  }

  late final _Dart_IntegerFitsIntoUint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Bool>)>>('Dart_IntegerFitsIntoUint64');
  late final _Dart_IntegerFitsIntoUint64 = _Dart_IntegerFitsIntoUint64Ptr
      .asFunction<Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The value of the integer.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewInteger(
    int value,
  ) {
    return _Dart_NewInteger(
      value,
    );
  }

  late final _Dart_NewIntegerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int64)>>(
          'Dart_NewInteger');
  late final _Dart_NewInteger =
      _Dart_NewIntegerPtr.asFunction<Object Function(int)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The unsigned value of the integer.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewIntegerFromUint64(
    int value,
  ) {
    return _Dart_NewIntegerFromUint64(
      value,
    );
  }

  late final _Dart_NewIntegerFromUint64Ptr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Uint64)>>(
          'Dart_NewIntegerFromUint64');
  late final _Dart_NewIntegerFromUint64 =
      _Dart_NewIntegerFromUint64Ptr.asFunction<Object Function(int)>();

  /// Returns an Integer with the provided value.
  ///
  /// \param value The value of the integer represented as a C string
  /// containing a hexadecimal number.
  ///
  /// \return The Integer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewIntegerFromHexCString(
    ffi.Pointer<ffi.Char> value,
  ) {
    return _Dart_NewIntegerFromHexCString(
      value,
    );
  }

  late final _Dart_NewIntegerFromHexCStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewIntegerFromHexCString');
  late final _Dart_NewIntegerFromHexCString = _Dart_NewIntegerFromHexCStringPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Gets the value of an Integer.
  ///
  /// The integer must fit into a 64-bit signed integer, otherwise an error occurs.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToInt64(
    Object integer,
    ffi.Pointer<ffi.Int64> value,
  ) {
    return _Dart_IntegerToInt64(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Int64>)>>('Dart_IntegerToInt64');
  late final _Dart_IntegerToInt64 = _Dart_IntegerToInt64Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Int64>)>();

  /// Gets the value of an Integer.
  ///
  /// The integer must fit into a 64-bit unsigned integer, otherwise an
  /// error occurs.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToUint64(
    Object integer,
    ffi.Pointer<ffi.Uint64> value,
  ) {
    return _Dart_IntegerToUint64(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToUint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Uint64>)>>('Dart_IntegerToUint64');
  late final _Dart_IntegerToUint64 = _Dart_IntegerToUint64Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Uint64>)>();

  /// Gets the value of an integer as a hexadecimal C string.
  ///
  /// \param integer An Integer.
  /// \param value Returns the value of the Integer as a hexadecimal C
  /// string. This C string is scope allocated and is only valid until
  /// the next call to Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_IntegerToHexCString(
    Object integer,
    ffi.Pointer<ffi.Pointer<ffi.Char>> value,
  ) {
    return _Dart_IntegerToHexCString(
      integer,
      value,
    );
  }

  late final _Dart_IntegerToHexCStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_IntegerToHexCString');
  late final _Dart_IntegerToHexCString =
      _Dart_IntegerToHexCStringPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Returns a Double with the provided value.
  ///
  /// \param value A double.
  ///
  /// \return The Double object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewDouble(
    double value,
  ) {
    return _Dart_NewDouble(
      value,
    );
  }

  late final _Dart_NewDoublePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Double)>>(
          'Dart_NewDouble');
  late final _Dart_NewDouble =
      _Dart_NewDoublePtr.asFunction<Object Function(double)>();

  /// Gets the value of a Double
  ///
  /// \param double_obj A Double
  /// \param value Returns the value of the Double.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_DoubleValue(
    Object double_obj,
    ffi.Pointer<ffi.Double> value,
  ) {
    return _Dart_DoubleValue(
      double_obj,
      value,
    );
  }

  late final _Dart_DoubleValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Double>)>>('Dart_DoubleValue');
  late final _Dart_DoubleValue = _Dart_DoubleValuePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Double>)>();

  /// Returns a closure of static function 'function_name' in the class 'class_name'
  /// in the exported namespace of specified 'library'.
  ///
  /// \param library Library object
  /// \param cls_type Type object representing a Class
  /// \param function_name Name of the static function in the class
  ///
  /// \return A valid Dart instance if no error occurs during the operation.
  Object Dart_GetStaticMethodClosure(
    Object library1,
    Object cls_type,
    Object function_name,
  ) {
    return _Dart_GetStaticMethodClosure(
      library1,
      cls_type,
      function_name,
    );
  }

  late final _Dart_GetStaticMethodClosurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle,
              ffi.Handle)>>('Dart_GetStaticMethodClosure');
  late final _Dart_GetStaticMethodClosure = _Dart_GetStaticMethodClosurePtr
      .asFunction<Object Function(Object, Object, Object)>();

  /// Returns the True object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A handle to the True object.
  Object Dart_True() {
    return _Dart_True();
  }

  late final _Dart_TruePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_True');
  late final _Dart_True = _Dart_TruePtr.asFunction<Object Function()>();

  /// Returns the False object.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \return A handle to the False object.
  Object Dart_False() {
    return _Dart_False();
  }

  late final _Dart_FalsePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_False');
  late final _Dart_False = _Dart_FalsePtr.asFunction<Object Function()>();

  /// Returns a Boolean with the provided value.
  ///
  /// \param value true or false.
  ///
  /// \return The Boolean object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewBoolean(
    bool value,
  ) {
    return _Dart_NewBoolean(
      value,
    );
  }

  late final _Dart_NewBooleanPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Bool)>>(
          'Dart_NewBoolean');
  late final _Dart_NewBoolean =
      _Dart_NewBooleanPtr.asFunction<Object Function(bool)>();

  /// Gets the value of a Boolean
  ///
  /// \param boolean_obj A Boolean
  /// \param value Returns the value of the Boolean.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_BooleanValue(
    Object boolean_obj,
    ffi.Pointer<ffi.Bool> value,
  ) {
    return _Dart_BooleanValue(
      boolean_obj,
      value,
    );
  }

  late final _Dart_BooleanValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_BooleanValue');
  late final _Dart_BooleanValue = _Dart_BooleanValuePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Gets the length of a String.
  ///
  /// \param str A String.
  /// \param length Returns the length of the String.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringLength(
    Object str,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringLength(
      str,
      length,
    );
  }

  late final _Dart_StringLengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_StringLength');
  late final _Dart_StringLength = _Dart_StringLengthPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Returns a String built from the provided C string
  /// (There is an implicit assumption that the C string passed in contains
  /// UTF-8 encoded characters and '\0' is considered as a termination
  /// character).
  ///
  /// \param value A C String
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromCString(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _Dart_NewStringFromCString(
      str,
    );
  }

  late final _Dart_NewStringFromCStringPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>(
          'Dart_NewStringFromCString');
  late final _Dart_NewStringFromCString = _Dart_NewStringFromCStringPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Char>)>();

  /// Returns a String built from an array of UTF-8 encoded characters.
  ///
  /// \param utf8_array An array of UTF-8 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF8(
    ffi.Pointer<ffi.Uint8> utf8_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF8(
      utf8_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>('Dart_NewStringFromUTF8');
  late final _Dart_NewStringFromUTF8 = _Dart_NewStringFromUTF8Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Returns a String built from an array of UTF-16 encoded characters.
  ///
  /// \param utf16_array An array of UTF-16 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF16(
    ffi.Pointer<ffi.Uint16> utf16_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF16(
      utf16_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint16>, ffi.IntPtr)>>('Dart_NewStringFromUTF16');
  late final _Dart_NewStringFromUTF16 = _Dart_NewStringFromUTF16Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Uint16>, int)>();

  /// Returns a String built from an array of UTF-32 encoded characters.
  ///
  /// \param utf32_array An array of UTF-32 encoded characters.
  /// \param length The length of the codepoints array.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewStringFromUTF32(
    ffi.Pointer<ffi.Int32> utf32_array,
    int length,
  ) {
    return _Dart_NewStringFromUTF32(
      utf32_array,
      length,
    );
  }

  late final _Dart_NewStringFromUTF32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Int32>, ffi.IntPtr)>>('Dart_NewStringFromUTF32');
  late final _Dart_NewStringFromUTF32 = _Dart_NewStringFromUTF32Ptr.asFunction<
      Object Function(ffi.Pointer<ffi.Int32>, int)>();

  /// Returns a String which references an external array of
  /// Latin-1 (ISO-8859-1) encoded characters.
  ///
  /// \param latin1_array Array of Latin-1 encoded characters. This must not move.
  /// \param length The length of the characters array.
  /// \param peer An external pointer to associate with this string.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A callback to be called when this string is finalized.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalLatin1String(
    ffi.Pointer<ffi.Uint8> latin1_array,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewExternalLatin1String(
      latin1_array,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewExternalLatin1StringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewExternalLatin1String');
  late final _Dart_NewExternalLatin1String =
      _Dart_NewExternalLatin1StringPtr.asFunction<
          Object Function(ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Void>,
              int, Dart_HandleFinalizer)>();

  /// Returns a String which references an external array of UTF-16 encoded
  /// characters.
  ///
  /// \param utf16_array An array of UTF-16 encoded characters. This must not move.
  /// \param length The length of the characters array.
  /// \param peer An external pointer to associate with this string.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A callback to be called when this string is finalized.
  ///
  /// \return The String object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalUTF16String(
    ffi.Pointer<ffi.Uint16> utf16_array,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewExternalUTF16String(
      utf16_array,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewExternalUTF16StringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Uint16>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewExternalUTF16String');
  late final _Dart_NewExternalUTF16String =
      _Dart_NewExternalUTF16StringPtr.asFunction<
          Object Function(ffi.Pointer<ffi.Uint16>, int, ffi.Pointer<ffi.Void>,
              int, Dart_HandleFinalizer)>();

  /// Gets the C string representation of a String.
  /// (It is a sequence of UTF-8 encoded values with a '\0' termination.)
  ///
  /// \param str A string.
  /// \param cstr Returns the String represented as a C string.
  /// This C string is scope allocated and is only valid until
  /// the next call to Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToCString(
    Object str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> cstr,
  ) {
    return _Dart_StringToCString(
      str,
      cstr,
    );
  }

  late final _Dart_StringToCStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('Dart_StringToCString');
  late final _Dart_StringToCString = _Dart_StringToCStringPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Gets a UTF-8 encoded representation of a String.
  ///
  /// Any unpaired surrogate code points in the string will be converted as
  /// replacement characters (U+FFFD, 0xEF 0xBF 0xBD in UTF-8). If you need
  /// to preserve unpaired surrogates, use the Dart_StringToUTF16 function.
  ///
  /// \param str A string.
  /// \param utf8_array Returns the String represented as UTF-8 code
  /// units.  This UTF-8 array is scope allocated and is only valid
  /// until the next call to Dart_ExitScope.
  /// \param length Used to return the length of the array which was
  /// actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToUTF8(
    Object str,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> utf8_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToUTF8(
      str,
      utf8_array,
      length,
    );
  }

  late final _Dart_StringToUTF8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToUTF8');
  late final _Dart_StringToUTF8 = _Dart_StringToUTF8Ptr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the data corresponding to the string object. This function returns
  /// the data only for Latin-1 (ISO-8859-1) string objects. For all other
  /// string objects it returns an error.
  ///
  /// \param str A string.
  /// \param latin1_array An array allocated by the caller, used to return
  /// the string data.
  /// \param length Used to pass in the length of the provided array.
  /// Used to return the length of the array which was actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToLatin1(
    Object str,
    ffi.Pointer<ffi.Uint8> latin1_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToLatin1(
      str,
      latin1_array,
      length,
    );
  }

  late final _Dart_StringToLatin1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToLatin1');
  late final _Dart_StringToLatin1 = _Dart_StringToLatin1Ptr.asFunction<
      Object Function(
          Object, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the UTF-16 encoded representation of a string.
  ///
  /// \param str A string.
  /// \param utf16_array An array allocated by the caller, used to return
  /// the array of UTF-16 encoded characters.
  /// \param length Used to pass in the length of the provided array.
  /// Used to return the length of the array which was actually used.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringToUTF16(
    Object str,
    ffi.Pointer<ffi.Uint16> utf16_array,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_StringToUTF16(
      str,
      utf16_array,
      length,
    );
  }

  late final _Dart_StringToUTF16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Pointer<ffi.Uint16>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_StringToUTF16');
  late final _Dart_StringToUTF16 = _Dart_StringToUTF16Ptr.asFunction<
      Object Function(
          Object, ffi.Pointer<ffi.Uint16>, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the storage size in bytes of a String.
  ///
  /// \param str A String.
  /// \param length Returns the storage size in bytes of the String.
  /// This is the size in bytes needed to store the String.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_StringStorageSize(
    Object str,
    ffi.Pointer<ffi.IntPtr> size,
  ) {
    return _Dart_StringStorageSize(
      str,
      size,
    );
  }

  late final _Dart_StringStorageSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_StringStorageSize');
  late final _Dart_StringStorageSize = _Dart_StringStorageSizePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Retrieves some properties associated with a String.
  /// Properties retrieved are:
  /// - character size of the string (one or two byte)
  /// - length of the string
  /// - peer pointer of string if it is an external string.
  /// \param str A String.
  /// \param char_size Returns the character size of the String.
  /// \param str_len Returns the length of the String.
  /// \param peer Returns the peer pointer associated with the String or 0 if
  /// there is no peer pointer for it.
  /// \return Success if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_StringGetProperties(
    Object str,
    ffi.Pointer<ffi.IntPtr> char_size,
    ffi.Pointer<ffi.IntPtr> str_len,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_StringGetProperties(
      str,
      char_size,
      str_len,
      peer,
    );
  }

  late final _Dart_StringGetPropertiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('Dart_StringGetProperties');
  late final _Dart_StringGetProperties =
      _Dart_StringGetPropertiesPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.IntPtr>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Returns a List<dynamic> of the desired length.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewList(
    int length,
  ) {
    return _Dart_NewList(
      length,
    );
  }

  late final _Dart_NewListPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>(
          'Dart_NewList');
  late final _Dart_NewList =
      _Dart_NewListPtr.asFunction<Object Function(int)>();

  /// TODO(bkonyi): convert this to use nullable types once NNBD is enabled.
  /// /**
  ///  * Returns a List of the desired length with the desired legacy element type.
  ///  *
  ///  * \param element_type_id The type of elements of the list.
  ///  * \param length The length of the list.
  ///  *
  ///  * \return The List object if no error occurs. Otherwise returns an error
  ///  * handle.
  ///  */
  Object Dart_NewListOf(
    int element_type_id,
    int length,
  ) {
    return _Dart_NewListOf(
      element_type_id,
      length,
    );
  }

  late final _Dart_NewListOfPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int32, ffi.IntPtr)>>(
          'Dart_NewListOf');
  late final _Dart_NewListOf =
      _Dart_NewListOfPtr.asFunction<Object Function(int, int)>();

  /// Returns a List of the desired length with the desired element type.
  ///
  /// \param element_type Handle to a nullable type object. E.g., from
  /// Dart_GetType or Dart_GetNullableType.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewListOfType(
    Object element_type,
    int length,
  ) {
    return _Dart_NewListOfType(
      element_type,
      length,
    );
  }

  late final _Dart_NewListOfTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.IntPtr)>>(
          'Dart_NewListOfType');
  late final _Dart_NewListOfType =
      _Dart_NewListOfTypePtr.asFunction<Object Function(Object, int)>();

  /// Returns a List of the desired length with the desired element type, filled
  /// with the provided object.
  ///
  /// \param element_type Handle to a type object. E.g., from Dart_GetType.
  ///
  /// \param fill_object Handle to an object of type 'element_type' that will be
  /// used to populate the list. This parameter can only be Dart_Null() if the
  /// length of the list is 0 or 'element_type' is a nullable type.
  ///
  /// \param length The length of the list.
  ///
  /// \return The List object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewListOfTypeFilled(
    Object element_type,
    Object fill_object,
    int length,
  ) {
    return _Dart_NewListOfTypeFilled(
      element_type,
      fill_object,
      length,
    );
  }

  late final _Dart_NewListOfTypeFilledPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Handle, ffi.IntPtr)>>('Dart_NewListOfTypeFilled');
  late final _Dart_NewListOfTypeFilled = _Dart_NewListOfTypeFilledPtr
      .asFunction<Object Function(Object, Object, int)>();

  /// Gets the length of a List.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param length Returns the length of the List.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ListLength(
    Object list,
    ffi.Pointer<ffi.IntPtr> length,
  ) {
    return _Dart_ListLength(
      list,
      length,
    );
  }

  late final _Dart_ListLengthPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.IntPtr>)>>('Dart_ListLength');
  late final _Dart_ListLength = _Dart_ListLengthPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the Object at some index of a List.
  ///
  /// If the index is out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param index A valid index into the List.
  ///
  /// \return The Object in the List at the specified index if no error
  /// occurs. Otherwise returns an error handle.
  Object Dart_ListGetAt(
    Object list,
    int index,
  ) {
    return _Dart_ListGetAt(
      list,
      index,
    );
  }

  late final _Dart_ListGetAtPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.IntPtr)>>(
          'Dart_ListGetAt');
  late final _Dart_ListGetAt =
      _Dart_ListGetAtPtr.asFunction<Object Function(Object, int)>();

  /// Gets a range of Objects from a List.
  ///
  /// If any of the requested index values are out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param list A List.
  /// \param offset The offset of the first item to get.
  /// \param length The number of items to get.
  /// \param result A pointer to fill with the objects.
  ///
  /// \return Success if no error occurs during the operation.
  Object Dart_ListGetRange(
    Object list,
    int offset,
    int length,
    ffi.Pointer<ffi.Handle> result,
  ) {
    return _Dart_ListGetRange(
      list,
      offset,
      length,
      result,
    );
  }

  late final _Dart_ListGetRangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_ListGetRange');
  late final _Dart_ListGetRange = _Dart_ListGetRangePtr.asFunction<
      Object Function(Object, int, int, ffi.Pointer<ffi.Handle>)>();

  /// Sets the Object at some index of a List.
  ///
  /// If the index is out of bounds, an error occurs.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param array A List.
  /// \param index A valid index into the List.
  /// \param value The Object to put in the List.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_ListSetAt(
    Object list,
    int index,
    Object value,
  ) {
    return _Dart_ListSetAt(
      list,
      index,
      value,
    );
  }

  late final _Dart_ListSetAtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.IntPtr, ffi.Handle)>>('Dart_ListSetAt');
  late final _Dart_ListSetAt =
      _Dart_ListSetAtPtr.asFunction<Object Function(Object, int, Object)>();

  /// May generate an unhandled exception error.
  Object Dart_ListGetAsBytes(
    Object list,
    int offset,
    ffi.Pointer<ffi.Uint8> native_array,
    int length,
  ) {
    return _Dart_ListGetAsBytes(
      list,
      offset,
      native_array,
      length,
    );
  }

  late final _Dart_ListGetAsBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_ListGetAsBytes');
  late final _Dart_ListGetAsBytes = _Dart_ListGetAsBytesPtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// May generate an unhandled exception error.
  Object Dart_ListSetAsBytes(
    Object list,
    int offset,
    ffi.Pointer<ffi.Uint8> native_array,
    int length,
  ) {
    return _Dart_ListSetAsBytes(
      list,
      offset,
      native_array,
      length,
    );
  }

  late final _Dart_ListSetAsBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_ListSetAsBytes');
  late final _Dart_ListSetAsBytes = _Dart_ListSetAsBytesPtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Gets the Object at some key of a Map.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  /// \param key An Object.
  ///
  /// \return The value in the map at the specified key, null if the map does not
  /// contain the key, or an error handle.
  Object Dart_MapGetAt(
    Object map,
    Object key,
  ) {
    return _Dart_MapGetAt(
      map,
      key,
    );
  }

  late final _Dart_MapGetAtPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_MapGetAt');
  late final _Dart_MapGetAt =
      _Dart_MapGetAtPtr.asFunction<Object Function(Object, Object)>();

  /// Returns whether the Map contains a given key.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  ///
  /// \return A handle on a boolean indicating whether map contains the key.
  /// Otherwise returns an error handle.
  Object Dart_MapContainsKey(
    Object map,
    Object key,
  ) {
    return _Dart_MapContainsKey(
      map,
      key,
    );
  }

  late final _Dart_MapContainsKeyPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_MapContainsKey');
  late final _Dart_MapContainsKey =
      _Dart_MapContainsKeyPtr.asFunction<Object Function(Object, Object)>();

  /// Gets the list of keys of a Map.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param map A Map.
  ///
  /// \return The list of key Objects if no error occurs. Otherwise returns an
  /// error handle.
  Object Dart_MapKeys(
    Object map,
  ) {
    return _Dart_MapKeys(
      map,
    );
  }

  late final _Dart_MapKeysPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_MapKeys');
  late final _Dart_MapKeys =
      _Dart_MapKeysPtr.asFunction<Object Function(Object)>();

  /// Return type if this object is a TypedData object.
  ///
  /// \return kInvalid if the object is not a TypedData object or the appropriate
  /// Dart_TypedData_Type.
  int Dart_GetTypeOfTypedData(
    Object object,
  ) {
    return _Dart_GetTypeOfTypedData(
      object,
    );
  }

  late final _Dart_GetTypeOfTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Handle)>>(
          'Dart_GetTypeOfTypedData');
  late final _Dart_GetTypeOfTypedData =
      _Dart_GetTypeOfTypedDataPtr.asFunction<int Function(Object)>();

  /// Return type if this object is an external TypedData object.
  ///
  /// \return kInvalid if the object is not an external TypedData object or
  /// the appropriate Dart_TypedData_Type.
  int Dart_GetTypeOfExternalTypedData(
    Object object,
  ) {
    return _Dart_GetTypeOfExternalTypedData(
      object,
    );
  }

  late final _Dart_GetTypeOfExternalTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Handle)>>(
          'Dart_GetTypeOfExternalTypedData');
  late final _Dart_GetTypeOfExternalTypedData =
      _Dart_GetTypeOfExternalTypedDataPtr.asFunction<int Function(Object)>();

  /// Returns a TypedData object of the desired length and type.
  ///
  /// \param type The type of the TypedData object.
  /// \param length The length of the TypedData object (length in type units).
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewTypedData(
    int type,
    int length,
  ) {
    return _Dart_NewTypedData(
      type,
      length,
    );
  }

  late final _Dart_NewTypedDataPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Int32, ffi.IntPtr)>>(
          'Dart_NewTypedData');
  late final _Dart_NewTypedData =
      _Dart_NewTypedDataPtr.asFunction<Object Function(int, int)>();

  /// Returns a TypedData object which references an external data array.
  ///
  /// \param type The type of the data array.
  /// \param data A data array. This array must not move.
  /// \param length The length of the data array (length in type units).
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalTypedData(
    int type,
    ffi.Pointer<ffi.Void> data,
    int length,
  ) {
    return _Dart_NewExternalTypedData(
      type,
      data,
      length,
    );
  }

  late final _Dart_NewExternalTypedDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Int32, ffi.Pointer<ffi.Void>,
              ffi.IntPtr)>>('Dart_NewExternalTypedData');
  late final _Dart_NewExternalTypedData = _Dart_NewExternalTypedDataPtr
      .asFunction<Object Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Returns a TypedData object which references an external data array.
  ///
  /// \param type The type of the data array.
  /// \param data A data array. This array must not move.
  /// \param length The length of the data array (length in type units).
  /// \param peer A pointer to a native object or NULL.  This value is
  /// provided to callback when it is invoked.
  /// \param external_allocation_size The number of externally allocated
  /// bytes for peer. Used to inform the garbage collector.
  /// \param callback A function pointer that will be invoked sometime
  /// after the object is garbage collected, unless the handle has been deleted.
  /// A valid callback needs to be specified it cannot be NULL.
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewExternalTypedDataWithFinalizer(
    int type,
    ffi.Pointer<ffi.Void> data,
    int length,
    ffi.Pointer<ffi.Void> peer,
    int external_allocation_size,
    Dart_HandleFinalizer callback,
  ) {
    return _Dart_NewExternalTypedDataWithFinalizer(
      type,
      data,
      length,
      peer,
      external_allocation_size,
      callback,
    );
  }

  late final _Dart_NewExternalTypedDataWithFinalizerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Int32,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Void>,
              ffi.IntPtr,
              Dart_HandleFinalizer)>>('Dart_NewExternalTypedDataWithFinalizer');
  late final _Dart_NewExternalTypedDataWithFinalizer =
      _Dart_NewExternalTypedDataWithFinalizerPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Void>, int,
              ffi.Pointer<ffi.Void>, int, Dart_HandleFinalizer)>();

  /// Returns a ByteBuffer object for the typed data.
  ///
  /// \param type_data The TypedData object.
  ///
  /// \return The ByteBuffer object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_NewByteBuffer(
    Object typed_data,
  ) {
    return _Dart_NewByteBuffer(
      typed_data,
    );
  }

  late final _Dart_NewByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_NewByteBuffer');
  late final _Dart_NewByteBuffer =
      _Dart_NewByteBufferPtr.asFunction<Object Function(Object)>();

  /// Acquires access to the internal data address of a TypedData object.
  ///
  /// \param object The typed data object whose internal data address is to
  /// be accessed.
  /// \param type The type of the object is returned here.
  /// \param data The internal data address is returned here.
  /// \param len Size of the typed array is returned here.
  ///
  /// Notes:
  /// When the internal address of the object is acquired any calls to a
  /// Dart API function that could potentially allocate an object or run
  /// any Dart code will return an error.
  ///
  /// Any Dart API functions for accessing the data should not be called
  /// before the corresponding release. In particular, the object should
  /// not be acquired again before its release. This leads to undefined
  /// behavior.
  ///
  /// \return Success if the internal data address is acquired successfully.
  /// Otherwise, returns an error handle.
  Object Dart_TypedDataAcquireData(
    Object object,
    ffi.Pointer<ffi.Int32> type,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    ffi.Pointer<ffi.IntPtr> len,
  ) {
    return _Dart_TypedDataAcquireData(
      object,
      type,
      data,
      len,
    );
  }

  late final _Dart_TypedDataAcquireDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_TypedDataAcquireData');
  late final _Dart_TypedDataAcquireData =
      _Dart_TypedDataAcquireDataPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.IntPtr>)>();

  /// Releases access to the internal data address that was acquired earlier using
  /// Dart_TypedDataAcquireData.
  ///
  /// \param object The typed data object whose internal data address is to be
  /// released.
  ///
  /// \return Success if the internal data address is released successfully.
  /// Otherwise, returns an error handle.
  Object Dart_TypedDataReleaseData(
    Object object,
  ) {
    return _Dart_TypedDataReleaseData(
      object,
    );
  }

  late final _Dart_TypedDataReleaseDataPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypedDataReleaseData');
  late final _Dart_TypedDataReleaseData =
      _Dart_TypedDataReleaseDataPtr.asFunction<Object Function(Object)>();

  /// Returns the TypedData object associated with the ByteBuffer object.
  ///
  /// \param byte_buffer The ByteBuffer object.
  ///
  /// \return The TypedData object if no error occurs. Otherwise returns
  /// an error handle.
  Object Dart_GetDataFromByteBuffer(
    Object byte_buffer,
  ) {
    return _Dart_GetDataFromByteBuffer(
      byte_buffer,
    );
  }

  late final _Dart_GetDataFromByteBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_GetDataFromByteBuffer');
  late final _Dart_GetDataFromByteBuffer =
      _Dart_GetDataFromByteBufferPtr.asFunction<Object Function(Object)>();

  /// Invokes a constructor, creating a new object.
  ///
  /// This function allows hidden constructors (constructors with leading
  /// underscores) to be called.
  ///
  /// \param type Type of object to be constructed.
  /// \param constructor_name The name of the constructor to invoke.  Use
  /// Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.
  /// This name should not include the name of the class.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the constructor.
  ///
  /// \return If the constructor is called and completes successfully,
  /// then the new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_New(
    Object type,
    Object constructor_name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_New(
      type,
      constructor_name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_NewPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_New');
  late final _Dart_New = _Dart_NewPtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Allocate a new object without invoking a constructor.
  ///
  /// \param type The type of an object to be allocated.
  ///
  /// \return The new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_Allocate(
    Object type,
  ) {
    return _Dart_Allocate(
      type,
    );
  }

  late final _Dart_AllocatePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_Allocate');
  late final _Dart_Allocate =
      _Dart_AllocatePtr.asFunction<Object Function(Object)>();

  /// Allocate a new object without invoking a constructor, and sets specified
  /// native fields.
  ///
  /// \param type The type of an object to be allocated.
  /// \param num_native_fields The number of native fields to set.
  /// \param native_fields An array containing the value of native fields.
  ///
  /// \return The new object. If an error occurs during execution, then an
  /// error handle is returned.
  Object Dart_AllocateWithNativeFields(
    Object type,
    int num_native_fields,
    ffi.Pointer<ffi.IntPtr> native_fields,
  ) {
    return _Dart_AllocateWithNativeFields(
      type,
      num_native_fields,
      native_fields,
    );
  }

  late final _Dart_AllocateWithNativeFieldsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_AllocateWithNativeFields');
  late final _Dart_AllocateWithNativeFields = _Dart_AllocateWithNativeFieldsPtr
      .asFunction<Object Function(Object, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Invokes a method or function.
  ///
  /// The 'target' parameter may be an object, type, or library.  If
  /// 'target' is an object, then this function will invoke an instance
  /// method.  If 'target' is a type, then this function will invoke a
  /// static method.  If 'target' is a library, then this function will
  /// invoke a top-level function from that library.
  /// NOTE: This API call cannot be used to invoke methods of a type object.
  ///
  /// This function ignores visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param target An object, type, or library.
  /// \param name The name of the function or method to invoke.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the function.
  ///
  /// \return If the function or method is called and completes
  /// successfully, then the return value is returned. If an error
  /// occurs during execution, then an error handle is returned.
  Object Dart_Invoke(
    Object target,
    Object name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_Invoke(
      target,
      name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_Invoke');
  late final _Dart_Invoke = _Dart_InvokePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Invokes a Closure with the given arguments.
  ///
  /// May generate an unhandled exception error.
  ///
  /// \return If no error occurs during execution, then the result of
  /// invoking the closure is returned. If an error occurs during
  /// execution, then an error handle is returned.
  Object Dart_InvokeClosure(
    Object closure,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_InvokeClosure(
      closure,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokeClosurePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_InvokeClosure');
  late final _Dart_InvokeClosure = _Dart_InvokeClosurePtr.asFunction<
      Object Function(Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Invokes a Generative Constructor on an object that was previously
  /// allocated using Dart_Allocate/Dart_AllocateWithNativeFields.
  ///
  /// The 'target' parameter must be an object.
  ///
  /// This function ignores visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param target An object.
  /// \param name The name of the constructor to invoke.
  /// Use Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor.
  /// \param number_of_arguments Size of the arguments array.
  /// \param arguments An array of arguments to the function.
  ///
  /// \return If the constructor is called and completes
  /// successfully, then the object is returned. If an error
  /// occurs during execution, then an error handle is returned.
  Object Dart_InvokeConstructor(
    Object object,
    Object name,
    int number_of_arguments,
    ffi.Pointer<ffi.Handle> arguments,
  ) {
    return _Dart_InvokeConstructor(
      object,
      name,
      number_of_arguments,
      arguments,
    );
  }

  late final _Dart_InvokeConstructorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.Handle>)>>('Dart_InvokeConstructor');
  late final _Dart_InvokeConstructor = _Dart_InvokeConstructorPtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Gets the value of a field.
  ///
  /// The 'container' parameter may be an object, type, or library.  If
  /// 'container' is an object, then this function will access an
  /// instance field.  If 'container' is a type, then this function will
  /// access a static field.  If 'container' is a library, then this
  /// function will access a top-level variable.
  /// NOTE: This API call cannot be used to access fields of a type object.
  ///
  /// This function ignores field visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param container An object, type, or library.
  /// \param name A field name.
  ///
  /// \return If no error occurs, then the value of the field is
  /// returned. Otherwise an error handle is returned.
  Object Dart_GetField(
    Object container,
    Object name,
  ) {
    return _Dart_GetField(
      container,
      name,
    );
  }

  late final _Dart_GetFieldPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_GetField');
  late final _Dart_GetField =
      _Dart_GetFieldPtr.asFunction<Object Function(Object, Object)>();

  /// Sets the value of a field.
  ///
  /// The 'container' parameter may actually be an object, type, or
  /// library.  If 'container' is an object, then this function will
  /// access an instance field.  If 'container' is a type, then this
  /// function will access a static field.  If 'container' is a library,
  /// then this function will access a top-level variable.
  /// NOTE: This API call cannot be used to access fields of a type object.
  ///
  /// This function ignores field visibility (leading underscores in names).
  ///
  /// May generate an unhandled exception error.
  ///
  /// \param container An object, type, or library.
  /// \param name A field name.
  /// \param value The new field value.
  ///
  /// \return A valid handle if no error occurs.
  Object Dart_SetField(
    Object container,
    Object name,
    Object value,
  ) {
    return _Dart_SetField(
      container,
      name,
      value,
    );
  }

  late final _Dart_SetFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Handle, ffi.Handle)>>('Dart_SetField');
  late final _Dart_SetField =
      _Dart_SetFieldPtr.asFunction<Object Function(Object, Object, Object)>();

  /// Throws an exception.
  ///
  /// This function causes a Dart language exception to be thrown. This
  /// will proceed in the standard way, walking up Dart frames until an
  /// appropriate 'catch' block is found, executing 'finally' blocks,
  /// etc.
  ///
  /// If an error handle is passed into this function, the error is
  /// propagated immediately.  See Dart_PropagateError for a discussion
  /// of error propagation.
  ///
  /// If successful, this function does not return. Note that this means
  /// that the destructors of any stack-allocated C++ objects will not be
  /// called. If there are no Dart frames on the stack, an error occurs.
  ///
  /// \return An error handle if the exception was not thrown.
  /// Otherwise the function does not return.
  Object Dart_ThrowException(
    Object exception,
  ) {
    return _Dart_ThrowException(
      exception,
    );
  }

  late final _Dart_ThrowExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_ThrowException');
  late final _Dart_ThrowException =
      _Dart_ThrowExceptionPtr.asFunction<Object Function(Object)>();

  /// Rethrows an exception.
  ///
  /// Rethrows an exception, unwinding all dart frames on the stack. If
  /// successful, this function does not return. Note that this means
  /// that the destructors of any stack-allocated C++ objects will not be
  /// called. If there are no Dart frames on the stack, an error occurs.
  ///
  /// \return An error handle if the exception was not thrown.
  /// Otherwise the function does not return.
  Object Dart_ReThrowException(
    Object exception,
    Object stacktrace,
  ) {
    return _Dart_ReThrowException(
      exception,
      stacktrace,
    );
  }

  late final _Dart_ReThrowExceptionPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_ReThrowException');
  late final _Dart_ReThrowException =
      _Dart_ReThrowExceptionPtr.asFunction<Object Function(Object, Object)>();

  /// Gets the number of native instance fields in an object.
  Object Dart_GetNativeInstanceFieldCount(
    Object obj,
    ffi.Pointer<ffi.Int> count,
  ) {
    return _Dart_GetNativeInstanceFieldCount(
      obj,
      count,
    );
  }

  late final _Dart_GetNativeInstanceFieldCountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<ffi.Int>)>>('Dart_GetNativeInstanceFieldCount');
  late final _Dart_GetNativeInstanceFieldCount =
      _Dart_GetNativeInstanceFieldCountPtr.asFunction<
          Object Function(Object, ffi.Pointer<ffi.Int>)>();

  /// Gets the value of a native field.
  ///
  /// TODO(turnidge): Document.
  Object Dart_GetNativeInstanceField(
    Object obj,
    int index,
    ffi.Pointer<ffi.IntPtr> value,
  ) {
    return _Dart_GetNativeInstanceField(
      obj,
      index,
      value,
    );
  }

  late final _Dart_GetNativeInstanceFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Int,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeInstanceField');
  late final _Dart_GetNativeInstanceField = _Dart_GetNativeInstanceFieldPtr
      .asFunction<Object Function(Object, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Sets the value of a native field.
  ///
  /// TODO(turnidge): Document.
  Object Dart_SetNativeInstanceField(
    Object obj,
    int index,
    int value,
  ) {
    return _Dart_SetNativeInstanceField(
      obj,
      index,
      value,
    );
  }

  late final _Dart_SetNativeInstanceFieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Int, ffi.IntPtr)>>('Dart_SetNativeInstanceField');
  late final _Dart_SetNativeInstanceField = _Dart_SetNativeInstanceFieldPtr
      .asFunction<Object Function(Object, int, int)>();

  /// Extracts current isolate group data from the native arguments structure.
  ffi.Pointer<ffi.Void> Dart_GetNativeIsolateGroupData(
    Dart_NativeArguments args,
  ) {
    return _Dart_GetNativeIsolateGroupData(
      args,
    );
  }

  late final _Dart_GetNativeIsolateGroupDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              Dart_NativeArguments)>>('Dart_GetNativeIsolateGroupData');
  late final _Dart_GetNativeIsolateGroupData =
      _Dart_GetNativeIsolateGroupDataPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(Dart_NativeArguments)>();

  /// Gets the native arguments based on the types passed in and populates
  /// the passed arguments buffer with appropriate native values.
  ///
  /// \param args the Native arguments block passed into the native call.
  /// \param num_arguments length of argument descriptor array and argument
  /// values array passed in.
  /// \param arg_descriptors an array that describes the arguments that
  /// need to be retrieved. For each argument to be retrieved the descriptor
  /// contains the argument number (0, 1 etc.) and the argument type
  /// described using Dart_NativeArgument_Type, e.g:
  /// DART_NATIVE_ARG_DESCRIPTOR(Dart_NativeArgument_kBool, 1) indicates
  /// that the first argument is to be retrieved and it should be a boolean.
  /// \param arg_values array into which the native arguments need to be
  /// extracted into, the array is allocated by the caller (it could be
  /// stack allocated to avoid the malloc/free performance overhead).
  ///
  /// \return Success if all the arguments could be extracted correctly,
  /// returns an error handle if there were any errors while extracting the
  /// arguments (mismatched number of arguments, incorrect types, etc.).
  Object Dart_GetNativeArguments(
    Dart_NativeArguments args,
    int num_arguments,
    ffi.Pointer<Dart_NativeArgument_Descriptor> arg_descriptors,
    ffi.Pointer<Dart_NativeArgument_Value> arg_values,
  ) {
    return _Dart_GetNativeArguments(
      args,
      num_arguments,
      arg_descriptors,
      arg_values,
    );
  }

  late final _Dart_GetNativeArgumentsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_NativeArguments,
                  ffi.Int,
                  ffi.Pointer<Dart_NativeArgument_Descriptor>,
                  ffi.Pointer<Dart_NativeArgument_Value>)>>(
      'Dart_GetNativeArguments');
  late final _Dart_GetNativeArguments = _Dart_GetNativeArgumentsPtr.asFunction<
      Object Function(
          Dart_NativeArguments,
          int,
          ffi.Pointer<Dart_NativeArgument_Descriptor>,
          ffi.Pointer<Dart_NativeArgument_Value>)>();

  /// Gets the native argument at some index.
  Object Dart_GetNativeArgument(
    Dart_NativeArguments args,
    int index,
  ) {
    return _Dart_GetNativeArgument(
      args,
      index,
    );
  }

  late final _Dart_GetNativeArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_NativeArguments, ffi.Int)>>('Dart_GetNativeArgument');
  late final _Dart_GetNativeArgument = _Dart_GetNativeArgumentPtr.asFunction<
      Object Function(Dart_NativeArguments, int)>();

  /// Gets the number of native arguments.
  int Dart_GetNativeArgumentCount(
    Dart_NativeArguments args,
  ) {
    return _Dart_GetNativeArgumentCount(
      args,
    );
  }

  late final _Dart_GetNativeArgumentCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Dart_NativeArguments)>>(
          'Dart_GetNativeArgumentCount');
  late final _Dart_GetNativeArgumentCount = _Dart_GetNativeArgumentCountPtr
      .asFunction<int Function(Dart_NativeArguments)>();

  /// Gets all the native fields of the native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param num_fields size of the intptr_t array 'field_values' passed in.
  /// \param field_values intptr_t array in which native field values are returned.
  /// \return Success if the native fields where copied in successfully. Otherwise
  /// returns an error handle. On success the native field values are copied
  /// into the 'field_values' array, if the argument at 'arg_index' is a
  /// null object then 0 is copied as the native field values into the
  /// 'field_values' array.
  Object Dart_GetNativeFieldsOfArgument(
    Dart_NativeArguments args,
    int arg_index,
    int num_fields,
    ffi.Pointer<ffi.IntPtr> field_values,
  ) {
    return _Dart_GetNativeFieldsOfArgument(
      args,
      arg_index,
      num_fields,
      field_values,
    );
  }

  late final _Dart_GetNativeFieldsOfArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeFieldsOfArgument');
  late final _Dart_GetNativeFieldsOfArgument =
      _Dart_GetNativeFieldsOfArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, int, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets the native field of the receiver.
  Object Dart_GetNativeReceiver(
    Dart_NativeArguments args,
    ffi.Pointer<ffi.IntPtr> value,
  ) {
    return _Dart_GetNativeReceiver(
      args,
      value,
    );
  }

  late final _Dart_GetNativeReceiverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetNativeReceiver');
  late final _Dart_GetNativeReceiver = _Dart_GetNativeReceiverPtr.asFunction<
      Object Function(Dart_NativeArguments, ffi.Pointer<ffi.IntPtr>)>();

  /// Gets a string native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param peer Returns the peer pointer if the string argument has one.
  /// \return Success if the string argument has a peer, if it does not
  /// have a peer then the String object is returned. Otherwise returns
  /// an error handle (argument is not a String object).
  Object Dart_GetNativeStringArgument(
    Dart_NativeArguments args,
    int arg_index,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_GetNativeStringArgument(
      args,
      arg_index,
      peer,
    );
  }

  late final _Dart_GetNativeStringArgumentPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(Dart_NativeArguments, ffi.Int,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'Dart_GetNativeStringArgument');
  late final _Dart_GetNativeStringArgument =
      _Dart_GetNativeStringArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Gets an integer native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param value Returns the integer value if the argument is an Integer.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeIntegerArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Int64> value,
  ) {
    return _Dart_GetNativeIntegerArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeIntegerArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Int64>)>>('Dart_GetNativeIntegerArgument');
  late final _Dart_GetNativeIntegerArgument =
      _Dart_GetNativeIntegerArgumentPtr.asFunction<
          Object Function(Dart_NativeArguments, int, ffi.Pointer<ffi.Int64>)>();

  /// Gets a boolean native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param value Returns the boolean value if the argument is a Boolean.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeBooleanArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Bool> value,
  ) {
    return _Dart_GetNativeBooleanArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeBooleanArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Bool>)>>('Dart_GetNativeBooleanArgument');
  late final _Dart_GetNativeBooleanArgument =
      _Dart_GetNativeBooleanArgumentPtr.asFunction<
          Object Function(Dart_NativeArguments, int, ffi.Pointer<ffi.Bool>)>();

  /// Gets a double native argument at some index.
  /// \param args Native arguments structure.
  /// \param arg_index Index of the desired argument in the structure above.
  /// \param value Returns the double value if the argument is a double.
  /// \return Success if no error occurs. Otherwise returns an error handle.
  Object Dart_GetNativeDoubleArgument(
    Dart_NativeArguments args,
    int index,
    ffi.Pointer<ffi.Double> value,
  ) {
    return _Dart_GetNativeDoubleArgument(
      args,
      index,
      value,
    );
  }

  late final _Dart_GetNativeDoubleArgumentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_NativeArguments, ffi.Int,
              ffi.Pointer<ffi.Double>)>>('Dart_GetNativeDoubleArgument');
  late final _Dart_GetNativeDoubleArgument =
      _Dart_GetNativeDoubleArgumentPtr.asFunction<
          Object Function(
              Dart_NativeArguments, int, ffi.Pointer<ffi.Double>)>();

  /// Sets the return value for a native function.
  ///
  /// If retval is an Error handle, then error will be propagated once
  /// the native functions exits. See Dart_PropagateError for a
  /// discussion of how different types of errors are propagated.
  void Dart_SetReturnValue(
    Dart_NativeArguments args,
    Object retval,
  ) {
    return _Dart_SetReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Dart_NativeArguments, ffi.Handle)>>('Dart_SetReturnValue');
  late final _Dart_SetReturnValue = _Dart_SetReturnValuePtr.asFunction<
      void Function(Dart_NativeArguments, Object)>();

  void Dart_SetWeakHandleReturnValue(
    Dart_NativeArguments args,
    Dart_WeakPersistentHandle rval,
  ) {
    return _Dart_SetWeakHandleReturnValue(
      args,
      rval,
    );
  }

  late final _Dart_SetWeakHandleReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Dart_NativeArguments,
              Dart_WeakPersistentHandle)>>('Dart_SetWeakHandleReturnValue');
  late final _Dart_SetWeakHandleReturnValue =
      _Dart_SetWeakHandleReturnValuePtr.asFunction<
          void Function(Dart_NativeArguments, Dart_WeakPersistentHandle)>();

  void Dart_SetBooleanReturnValue(
    Dart_NativeArguments args,
    bool retval,
  ) {
    return _Dart_SetBooleanReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetBooleanReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Dart_NativeArguments, ffi.Bool)>>('Dart_SetBooleanReturnValue');
  late final _Dart_SetBooleanReturnValue = _Dart_SetBooleanReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, bool)>();

  void Dart_SetIntegerReturnValue(
    Dart_NativeArguments args,
    int retval,
  ) {
    return _Dart_SetIntegerReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetIntegerReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Dart_NativeArguments, ffi.Int64)>>('Dart_SetIntegerReturnValue');
  late final _Dart_SetIntegerReturnValue = _Dart_SetIntegerReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, int)>();

  void Dart_SetDoubleReturnValue(
    Dart_NativeArguments args,
    double retval,
  ) {
    return _Dart_SetDoubleReturnValue(
      args,
      retval,
    );
  }

  late final _Dart_SetDoubleReturnValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Dart_NativeArguments, ffi.Double)>>('Dart_SetDoubleReturnValue');
  late final _Dart_SetDoubleReturnValue = _Dart_SetDoubleReturnValuePtr
      .asFunction<void Function(Dart_NativeArguments, double)>();

  /// Sets the environment callback for the current isolate. This
  /// callback is used to lookup environment values by name in the
  /// current environment. This enables the embedder to supply values for
  /// the const constructors bool.fromEnvironment, int.fromEnvironment
  /// and String.fromEnvironment.
  Object Dart_SetEnvironmentCallback(
    Dart_EnvironmentCallback callback,
  ) {
    return _Dart_SetEnvironmentCallback(
      callback,
    );
  }

  late final _Dart_SetEnvironmentCallbackPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_EnvironmentCallback)>>(
      'Dart_SetEnvironmentCallback');
  late final _Dart_SetEnvironmentCallback = _Dart_SetEnvironmentCallbackPtr
      .asFunction<Object Function(Dart_EnvironmentCallback)>();

  /// Sets the callback used to resolve native functions for a library.
  ///
  /// \param library A library.
  /// \param resolver A native entry resolver.
  ///
  /// \return A valid handle if the native resolver was set successfully.
  Object Dart_SetNativeResolver(
    Object library1,
    Dart_NativeEntryResolver resolver,
    Dart_NativeEntrySymbol symbol,
  ) {
    return _Dart_SetNativeResolver(
      library1,
      resolver,
      symbol,
    );
  }

  late final _Dart_SetNativeResolverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, Dart_NativeEntryResolver,
              Dart_NativeEntrySymbol)>>('Dart_SetNativeResolver');
  late final _Dart_SetNativeResolver = _Dart_SetNativeResolverPtr.asFunction<
      Object Function(
          Object, Dart_NativeEntryResolver, Dart_NativeEntrySymbol)>();

  /// Returns the callback used to resolve native functions for a library.
  ///
  /// \param library A library.
  /// \param resolver a pointer to a Dart_NativeEntryResolver
  ///
  /// \return A valid handle if the library was found.
  Object Dart_GetNativeResolver(
    Object library1,
    ffi.Pointer<Dart_NativeEntryResolver> resolver,
  ) {
    return _Dart_GetNativeResolver(
      library1,
      resolver,
    );
  }

  late final _Dart_GetNativeResolverPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  ffi.Handle, ffi.Pointer<Dart_NativeEntryResolver>)>>(
      'Dart_GetNativeResolver');
  late final _Dart_GetNativeResolver = _Dart_GetNativeResolverPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_NativeEntryResolver>)>();

  /// Returns the callback used to resolve native function symbols for a library.
  ///
  /// \param library A library.
  /// \param resolver a pointer to a Dart_NativeEntrySymbol.
  ///
  /// \return A valid handle if the library was found.
  Object Dart_GetNativeSymbol(
    Object library1,
    ffi.Pointer<Dart_NativeEntrySymbol> resolver,
  ) {
    return _Dart_GetNativeSymbol(
      library1,
      resolver,
    );
  }

  late final _Dart_GetNativeSymbolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              ffi.Pointer<Dart_NativeEntrySymbol>)>>('Dart_GetNativeSymbol');
  late final _Dart_GetNativeSymbol = _Dart_GetNativeSymbolPtr.asFunction<
      Object Function(Object, ffi.Pointer<Dart_NativeEntrySymbol>)>();

  /// Sets the callback used to resolve FFI native functions for a library.
  /// The resolved functions are expected to be a C function pointer of the
  /// correct signature (as specified in the `@FfiNative<NFT>()` function
  /// annotation in Dart code).
  ///
  /// NOTE: This is an experimental feature and might change in the future.
  ///
  /// \param library A library.
  /// \param resolver A native function resolver.
  ///
  /// \return A valid handle if the native resolver was set successfully.
  Object Dart_SetFfiNativeResolver(
    Object library1,
    Dart_FfiNativeResolver resolver,
  ) {
    return _Dart_SetFfiNativeResolver(
      library1,
      resolver,
    );
  }

  late final _Dart_SetFfiNativeResolverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle,
              Dart_FfiNativeResolver)>>('Dart_SetFfiNativeResolver');
  late final _Dart_SetFfiNativeResolver = _Dart_SetFfiNativeResolverPtr
      .asFunction<Object Function(Object, Dart_FfiNativeResolver)>();

  /// Sets library tag handler for the current isolate. This handler is
  /// used to handle the various tags encountered while loading libraries
  /// or scripts in the isolate.
  ///
  /// \param handler Handler code to be used for handling the various tags
  /// encountered while loading libraries or scripts in the isolate.
  ///
  /// \return If no error occurs, the handler is set for the isolate.
  /// Otherwise an error handle is returned.
  ///
  /// TODO(turnidge): Document.
  Object Dart_SetLibraryTagHandler(
    Dart_LibraryTagHandler handler,
  ) {
    return _Dart_SetLibraryTagHandler(
      handler,
    );
  }

  late final _Dart_SetLibraryTagHandlerPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(Dart_LibraryTagHandler)>>(
          'Dart_SetLibraryTagHandler');
  late final _Dart_SetLibraryTagHandler = _Dart_SetLibraryTagHandlerPtr
      .asFunction<Object Function(Dart_LibraryTagHandler)>();

  /// Sets the deferred load handler for the current isolate. This handler is
  /// used to handle loading deferred imports in an AppJIT or AppAOT program.
  Object Dart_SetDeferredLoadHandler(
    Dart_DeferredLoadHandler handler,
  ) {
    return _Dart_SetDeferredLoadHandler(
      handler,
    );
  }

  late final _Dart_SetDeferredLoadHandlerPtr = _lookup<
          ffi.NativeFunction<ffi.Handle Function(Dart_DeferredLoadHandler)>>(
      'Dart_SetDeferredLoadHandler');
  late final _Dart_SetDeferredLoadHandler = _Dart_SetDeferredLoadHandlerPtr
      .asFunction<Object Function(Dart_DeferredLoadHandler)>();

  /// Notifies the VM that a deferred load completed successfully. This function
  /// will eventually cause the corresponding `prefix.loadLibrary()` futures to
  /// complete.
  ///
  /// Requires the current isolate to be the same current isolate during the
  /// invocation of the Dart_DeferredLoadHandler.
  Object Dart_DeferredLoadComplete(
    int loading_unit_id,
    ffi.Pointer<ffi.Uint8> snapshot_data,
    ffi.Pointer<ffi.Uint8> snapshot_instructions,
  ) {
    return _Dart_DeferredLoadComplete(
      loading_unit_id,
      snapshot_data,
      snapshot_instructions,
    );
  }

  late final _Dart_DeferredLoadCompletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.IntPtr, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>)>>('Dart_DeferredLoadComplete');
  late final _Dart_DeferredLoadComplete =
      _Dart_DeferredLoadCompletePtr.asFunction<
          Object Function(
              int, ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>)>();

  /// Notifies the VM that a deferred load failed. This function
  /// will eventually cause the corresponding `prefix.loadLibrary()` futures to
  /// complete with an error.
  ///
  /// If `transient` is true, future invocations of `prefix.loadLibrary()` will
  /// trigger new load requests. If false, futures invocation will complete with
  /// the same error.
  ///
  /// Requires the current isolate to be the same current isolate during the
  /// invocation of the Dart_DeferredLoadHandler.
  Object Dart_DeferredLoadCompleteError(
    int loading_unit_id,
    ffi.Pointer<ffi.Char> error_message,
    bool transient,
  ) {
    return _Dart_DeferredLoadCompleteError(
      loading_unit_id,
      error_message,
      transient,
    );
  }

  late final _Dart_DeferredLoadCompleteErrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.IntPtr, ffi.Pointer<ffi.Char>,
              ffi.Bool)>>('Dart_DeferredLoadCompleteError');
  late final _Dart_DeferredLoadCompleteError =
      _Dart_DeferredLoadCompleteErrorPtr.asFunction<
          Object Function(int, ffi.Pointer<ffi.Char>, bool)>();

  /// Canonicalizes a url with respect to some library.
  ///
  /// The url is resolved with respect to the library's url and some url
  /// normalizations are performed.
  ///
  /// This canonicalization function should be sufficient for most
  /// embedders to implement the Dart_kCanonicalizeUrl tag.
  ///
  /// \param base_url The base url relative to which the url is
  /// being resolved.
  /// \param url The url being resolved and canonicalized.  This
  /// parameter is a string handle.
  ///
  /// \return If no error occurs, a String object is returned.  Otherwise
  /// an error handle is returned.
  Object Dart_DefaultCanonicalizeUrl(
    Object base_url,
    Object url,
  ) {
    return _Dart_DefaultCanonicalizeUrl(
      base_url,
      url,
    );
  }

  late final _Dart_DefaultCanonicalizeUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_DefaultCanonicalizeUrl');
  late final _Dart_DefaultCanonicalizeUrl = _Dart_DefaultCanonicalizeUrlPtr
      .asFunction<Object Function(Object, Object)>();

  /// Loads the root library for the current isolate.
  ///
  /// Requires there to be no current root library.
  ///
  /// \param buffer A buffer which contains a kernel binary (see
  /// pkg/kernel/binary.md). Must remain valid until isolate group shutdown.
  /// \param buffer_size Length of the passed in buffer.
  ///
  /// \return A handle to the root library, or an error.
  Object Dart_LoadScriptFromKernel(
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_size,
  ) {
    return _Dart_LoadScriptFromKernel(
      kernel_buffer,
      kernel_size,
    );
  }

  late final _Dart_LoadScriptFromKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_LoadScriptFromKernel');
  late final _Dart_LoadScriptFromKernel = _Dart_LoadScriptFromKernelPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Gets the library for the root script for the current isolate.
  ///
  /// If the root script has not yet been set for the current isolate,
  /// this function returns Dart_Null().  This function never returns an
  /// error handle.
  ///
  /// \return Returns the root Library for the current isolate or Dart_Null().
  Object Dart_RootLibrary() {
    return _Dart_RootLibrary();
  }

  late final _Dart_RootLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_RootLibrary');
  late final _Dart_RootLibrary =
      _Dart_RootLibraryPtr.asFunction<Object Function()>();

  /// Sets the root library for the current isolate.
  ///
  /// \return Returns an error handle if `library` is not a library handle.
  Object Dart_SetRootLibrary(
    Object library1,
  ) {
    return _Dart_SetRootLibrary(
      library1,
    );
  }

  late final _Dart_SetRootLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_SetRootLibrary');
  late final _Dart_SetRootLibrary =
      _Dart_SetRootLibraryPtr.asFunction<Object Function(Object)>();

  /// Lookup or instantiate a legacy type by name and type arguments from a
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parameteric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetType(
    Object library1,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetType(
      library1,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetType');
  late final _Dart_GetType = _Dart_GetTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Lookup or instantiate a nullable type by name and type arguments from
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parameteric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetNullableType(
    Object library1,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetNullableType(
      library1,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetNullableType');
  late final _Dart_GetNullableType = _Dart_GetNullableTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Lookup or instantiate a non-nullable type by name and type arguments from
  /// Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The class name for the type.
  /// \param number_of_type_arguments Number of type arguments.
  /// For non parametric types the number of type arguments would be 0.
  /// \param type_arguments Pointer to an array of type arguments.
  /// For non parameteric types a NULL would be passed in for this argument.
  ///
  /// \return If no error occurs, the type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_GetNonNullableType(
    Object library1,
    Object class_name,
    int number_of_type_arguments,
    ffi.Pointer<ffi.Handle> type_arguments,
  ) {
    return _Dart_GetNonNullableType(
      library1,
      class_name,
      number_of_type_arguments,
      type_arguments,
    );
  }

  late final _Dart_GetNonNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Handle, ffi.Handle, ffi.IntPtr,
              ffi.Pointer<ffi.Handle>)>>('Dart_GetNonNullableType');
  late final _Dart_GetNonNullableType = _Dart_GetNonNullableTypePtr.asFunction<
      Object Function(Object, Object, int, ffi.Pointer<ffi.Handle>)>();

  /// Creates a nullable version of the provided type.
  ///
  /// \param type The type to be converted to a nullable type.
  ///
  /// \return If no error occurs, a nullable type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_TypeToNullableType(
    Object type,
  ) {
    return _Dart_TypeToNullableType(
      type,
    );
  }

  late final _Dart_TypeToNullableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypeToNullableType');
  late final _Dart_TypeToNullableType =
      _Dart_TypeToNullableTypePtr.asFunction<Object Function(Object)>();

  /// Creates a non-nullable version of the provided type.
  ///
  /// \param type The type to be converted to a non-nullable type.
  ///
  /// \return If no error occurs, a non-nullable type is returned.
  /// Otherwise an error handle is returned.
  Object Dart_TypeToNonNullableType(
    Object type,
  ) {
    return _Dart_TypeToNonNullableType(
      type,
    );
  }

  late final _Dart_TypeToNonNullableTypePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_TypeToNonNullableType');
  late final _Dart_TypeToNonNullableType =
      _Dart_TypeToNonNullableTypePtr.asFunction<Object Function(Object)>();

  /// A type's nullability.
  ///
  /// \param type A Dart type.
  /// \param result An out parameter containing the result of the check. True if
  /// the type is of the specified nullability, false otherwise.
  ///
  /// \return Returns an error handle if type is not of type Type.
  Object Dart_IsNullableType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsNullableType(
      type,
      result,
    );
  }

  late final _Dart_IsNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsNullableType');
  late final _Dart_IsNullableType = _Dart_IsNullableTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  Object Dart_IsNonNullableType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsNonNullableType(
      type,
      result,
    );
  }

  late final _Dart_IsNonNullableTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsNonNullableType');
  late final _Dart_IsNonNullableType = _Dart_IsNonNullableTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  Object Dart_IsLegacyType(
    Object type,
    ffi.Pointer<ffi.Bool> result,
  ) {
    return _Dart_IsLegacyType(
      type,
      result,
    );
  }

  late final _Dart_IsLegacyTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Bool>)>>('Dart_IsLegacyType');
  late final _Dart_IsLegacyType = _Dart_IsLegacyTypePtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Bool>)>();

  /// Lookup a class or interface by name from a Library.
  ///
  /// \param library The library containing the class or interface.
  /// \param class_name The name of the class or interface.
  ///
  /// \return If no error occurs, the class or interface is
  /// returned. Otherwise an error handle is returned.
  Object Dart_GetClass(
    Object library1,
    Object class_name,
  ) {
    return _Dart_GetClass(
      library1,
      class_name,
    );
  }

  late final _Dart_GetClassPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_GetClass');
  late final _Dart_GetClass =
      _Dart_GetClassPtr.asFunction<Object Function(Object, Object)>();

  /// Returns an import path to a Library, such as "file:///test.dart" or
  /// "dart:core".
  Object Dart_LibraryUrl(
    Object library1,
  ) {
    return _Dart_LibraryUrl(
      library1,
    );
  }

  late final _Dart_LibraryUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LibraryUrl');
  late final _Dart_LibraryUrl =
      _Dart_LibraryUrlPtr.asFunction<Object Function(Object)>();

  /// Returns a URL from which a Library was loaded.
  Object Dart_LibraryResolvedUrl(
    Object library1,
  ) {
    return _Dart_LibraryResolvedUrl(
      library1,
    );
  }

  late final _Dart_LibraryResolvedUrlPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LibraryResolvedUrl');
  late final _Dart_LibraryResolvedUrl =
      _Dart_LibraryResolvedUrlPtr.asFunction<Object Function(Object)>();

  /// \return An array of libraries.
  Object Dart_GetLoadedLibraries() {
    return _Dart_GetLoadedLibraries();
  }

  late final _Dart_GetLoadedLibrariesPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>(
          'Dart_GetLoadedLibraries');
  late final _Dart_GetLoadedLibraries =
      _Dart_GetLoadedLibrariesPtr.asFunction<Object Function()>();

  Object Dart_LookupLibrary(
    Object url,
  ) {
    return _Dart_LookupLibrary(
      url,
    );
  }

  late final _Dart_LookupLibraryPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>(
          'Dart_LookupLibrary');
  late final _Dart_LookupLibrary =
      _Dart_LookupLibraryPtr.asFunction<Object Function(Object)>();

  /// Report an loading error for the library.
  ///
  /// \param library The library that failed to load.
  /// \param error The Dart error instance containing the load error.
  ///
  /// \return If the VM handles the error, the return value is
  /// a null handle. If it doesn't handle the error, the error
  /// object is returned.
  Object Dart_LibraryHandleError(
    Object library1,
    Object error,
  ) {
    return _Dart_LibraryHandleError(
      library1,
      error,
    );
  }

  late final _Dart_LibraryHandleErrorPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Handle, ffi.Handle)>>(
          'Dart_LibraryHandleError');
  late final _Dart_LibraryHandleError =
      _Dart_LibraryHandleErrorPtr.asFunction<Object Function(Object, Object)>();

  /// Called by the embedder to load a partial program. Does not set the root
  /// library.
  ///
  /// \param buffer A buffer which contains a kernel binary (see
  /// pkg/kernel/binary.md). Must remain valid until isolate shutdown.
  /// \param buffer_size Length of the passed in buffer.
  ///
  /// \return A handle to the main library of the compilation unit, or an error.
  Object Dart_LoadLibraryFromKernel(
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
  ) {
    return _Dart_LoadLibraryFromKernel(
      kernel_buffer,
      kernel_buffer_size,
    );
  }

  late final _Dart_LoadLibraryFromKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_LoadLibraryFromKernel');
  late final _Dart_LoadLibraryFromKernel = _Dart_LoadLibraryFromKernelPtr
      .asFunction<Object Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Indicates that all outstanding load requests have been satisfied.
  /// This finalizes all the new classes loaded and optionally completes
  /// deferred library futures.
  ///
  /// Requires there to be a current isolate.
  ///
  /// \param complete_futures Specify true if all deferred library
  /// futures should be completed, false otherwise.
  ///
  /// \return Success if all classes have been finalized and deferred library
  /// futures are completed. Otherwise, returns an error.
  Object Dart_FinalizeLoading(
    bool complete_futures,
  ) {
    return _Dart_FinalizeLoading(
      complete_futures,
    );
  }

  late final _Dart_FinalizeLoadingPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.Bool)>>(
          'Dart_FinalizeLoading');
  late final _Dart_FinalizeLoading =
      _Dart_FinalizeLoadingPtr.asFunction<Object Function(bool)>();

  /// Returns the value of peer field of 'object' in 'peer'.
  ///
  /// \param object An object.
  /// \param peer An out parameter that returns the value of the peer
  /// field.
  ///
  /// \return Returns an error if 'object' is a subtype of Null, num, or
  /// bool.
  Object Dart_GetPeer(
    Object object,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peer,
  ) {
    return _Dart_GetPeer(
      object,
      peer,
    );
  }

  late final _Dart_GetPeerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('Dart_GetPeer');
  late final _Dart_GetPeer = _Dart_GetPeerPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Sets the value of the peer field of 'object' to the value of
  /// 'peer'.
  ///
  /// \param object An object.
  /// \param peer A value to store in the peer field.
  ///
  /// \return Returns an error if 'object' is a subtype of Null, num, or
  /// bool.
  Object Dart_SetPeer(
    Object object,
    ffi.Pointer<ffi.Void> peer,
  ) {
    return _Dart_SetPeer(
      object,
      peer,
    );
  }

  late final _Dart_SetPeerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Handle, ffi.Pointer<ffi.Void>)>>('Dart_SetPeer');
  late final _Dart_SetPeer = _Dart_SetPeerPtr.asFunction<
      Object Function(Object, ffi.Pointer<ffi.Void>)>();

  bool Dart_IsKernelIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsKernelIsolate(
      isolate,
    );
  }

  late final _Dart_IsKernelIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Isolate)>>(
          'Dart_IsKernelIsolate');
  late final _Dart_IsKernelIsolate =
      _Dart_IsKernelIsolatePtr.asFunction<bool Function(Dart_Isolate)>();

  bool Dart_KernelIsolateIsRunning() {
    return _Dart_KernelIsolateIsRunning();
  }

  late final _Dart_KernelIsolateIsRunningPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_KernelIsolateIsRunning');
  late final _Dart_KernelIsolateIsRunning =
      _Dart_KernelIsolateIsRunningPtr.asFunction<bool Function()>();

  int Dart_KernelPort() {
    return _Dart_KernelPort();
  }

  late final _Dart_KernelPortPtr =
      _lookup<ffi.NativeFunction<Dart_Port Function()>>('Dart_KernelPort');
  late final _Dart_KernelPort =
      _Dart_KernelPortPtr.asFunction<int Function()>();

  /// Compiles the given `script_uri` to a kernel file.
  ///
  /// \param platform_kernel A buffer containing the kernel of the platform (e.g.
  /// `vm_platform_strong.dill`). The VM does not take ownership of this memory.
  ///
  /// \param platform_kernel_size The length of the platform_kernel buffer.
  ///
  /// \param snapshot_compile Set to `true` when the compilation is for a snapshot.
  /// This is used by the frontend to determine if compilation related information
  /// should be printed to console (e.g., null safety mode).
  ///
  /// \param verbosity Specifies the logging behavior of the kernel compilation
  /// service.
  ///
  /// \return Returns the result of the compilation.
  ///
  /// On a successful compilation the returned [Dart_KernelCompilationResult] has
  /// a status of [Dart_KernelCompilationStatus_Ok] and the `kernel`/`kernel_size`
  /// fields are set. The caller takes ownership of the malloc()ed buffer.
  ///
  /// On a failed compilation the `error` might be set describing the reason for
  /// the failed compilation. The caller takes ownership of the malloc()ed
  /// error.
  ///
  /// Requires there to be a current isolate.
  Dart_KernelCompilationResult Dart_CompileToKernel(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Uint8> platform_kernel,
    int platform_kernel_size,
    bool incremental_compile,
    bool snapshot_compile,
    ffi.Pointer<ffi.Char> package_config,
    int verbosity,
  ) {
    return _Dart_CompileToKernel(
      script_uri,
      platform_kernel,
      platform_kernel_size,
      incremental_compile,
      snapshot_compile,
      package_config,
      verbosity,
    );
  }

  late final _Dart_CompileToKernelPtr = _lookup<
      ffi.NativeFunction<
          Dart_KernelCompilationResult Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr,
              ffi.Bool,
              ffi.Bool,
              ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('Dart_CompileToKernel');
  late final _Dart_CompileToKernel = _Dart_CompileToKernelPtr.asFunction<
      Dart_KernelCompilationResult Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          int,
          bool,
          bool,
          ffi.Pointer<ffi.Char>,
          int)>();

  Dart_KernelCompilationResult Dart_KernelListDependencies() {
    return _Dart_KernelListDependencies();
  }

  late final _Dart_KernelListDependenciesPtr =
      _lookup<ffi.NativeFunction<Dart_KernelCompilationResult Function()>>(
          'Dart_KernelListDependencies');
  late final _Dart_KernelListDependencies = _Dart_KernelListDependenciesPtr
      .asFunction<Dart_KernelCompilationResult Function()>();

  /// Sets the kernel buffer which will be used to load Dart SDK sources
  /// dynamically at runtime.
  ///
  /// \param platform_kernel A buffer containing kernel which has sources for the
  /// Dart SDK populated. Note: The VM does not take ownership of this memory.
  ///
  /// \param platform_kernel_size The length of the platform_kernel buffer.
  void Dart_SetDartLibrarySourcesKernel(
    ffi.Pointer<ffi.Uint8> platform_kernel,
    int platform_kernel_size,
  ) {
    return _Dart_SetDartLibrarySourcesKernel(
      platform_kernel,
      platform_kernel_size,
    );
  }

  late final _Dart_SetDartLibrarySourcesKernelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_SetDartLibrarySourcesKernel');
  late final _Dart_SetDartLibrarySourcesKernel =
      _Dart_SetDartLibrarySourcesKernelPtr.asFunction<
          void Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Detect the null safety opt-in status.
  ///
  /// When running from source, it is based on the opt-in status of `script_uri`.
  /// When running from a kernel buffer, it is based on the mode used when
  /// generating `kernel_buffer`.
  /// When running from an appJIT or AOT snapshot, it is based on the mode used
  /// when generating `snapshot_data`.
  ///
  /// \param script_uri Uri of the script that contains the source code
  ///
  /// \param package_config Uri of the package configuration file (either in format
  /// of .packages or .dart_tool/package_config.json) for the null safety
  /// detection to resolve package imports against. If this parameter is not
  /// passed the package resolution of the parent isolate should be used.
  ///
  /// \param original_working_directory current working directory when the VM
  /// process was launched, this is used to correctly resolve the path specified
  /// for package_config.
  ///
  /// \param snapshot_data
  ///
  /// \param snapshot_instructions Buffers containing a snapshot of the
  /// isolate or NULL if no snapshot is provided. If provided, the buffers must
  /// remain valid until the isolate shuts down.
  ///
  /// \param kernel_buffer
  ///
  /// \param kernel_buffer_size A buffer which contains a kernel/DIL program. Must
  /// remain valid until isolate shutdown.
  ///
  /// \return Returns true if the null safety is opted in by the input being
  /// run `script_uri`, `snapshot_data` or `kernel_buffer`.
  bool Dart_DetectNullSafety(
    ffi.Pointer<ffi.Char> script_uri,
    ffi.Pointer<ffi.Char> package_config,
    ffi.Pointer<ffi.Char> original_working_directory,
    ffi.Pointer<ffi.Uint8> snapshot_data,
    ffi.Pointer<ffi.Uint8> snapshot_instructions,
    ffi.Pointer<ffi.Uint8> kernel_buffer,
    int kernel_buffer_size,
  ) {
    return _Dart_DetectNullSafety(
      script_uri,
      package_config,
      original_working_directory,
      snapshot_data,
      snapshot_instructions,
      kernel_buffer,
      kernel_buffer_size,
    );
  }

  late final _Dart_DetectNullSafetyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.IntPtr)>>('Dart_DetectNullSafety');
  late final _Dart_DetectNullSafety = _Dart_DetectNullSafetyPtr.asFunction<
      bool Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>,
          int)>();

  /// Returns true if isolate is the service isolate.
  ///
  /// \param isolate An isolate
  ///
  /// \return Returns true if 'isolate' is the service isolate.
  bool Dart_IsServiceIsolate(
    Dart_Isolate isolate,
  ) {
    return _Dart_IsServiceIsolate(
      isolate,
    );
  }

  late final _Dart_IsServiceIsolatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Isolate)>>(
          'Dart_IsServiceIsolate');
  late final _Dart_IsServiceIsolate =
      _Dart_IsServiceIsolatePtr.asFunction<bool Function(Dart_Isolate)>();

  /// Writes the CPU profile to the timeline as a series of 'instant' events.
  ///
  /// Note that this is an expensive operation.
  ///
  /// \param main_port The main port of the Isolate whose profile samples to write.
  /// \param error An optional error, must be free()ed by caller.
  ///
  /// \return Returns true if the profile is successfully written and false
  /// otherwise.
  bool Dart_WriteProfileToTimeline(
    int main_port,
    ffi.Pointer<ffi.Pointer<ffi.Char>> error,
  ) {
    return _Dart_WriteProfileToTimeline(
      main_port,
      error,
    );
  }

  late final _Dart_WriteProfileToTimelinePtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  Dart_Port, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>(
      'Dart_WriteProfileToTimeline');
  late final _Dart_WriteProfileToTimeline = _Dart_WriteProfileToTimelinePtr
      .asFunction<bool Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Compiles all functions reachable from entry points and marks
  /// the isolate to disallow future compilation.
  ///
  /// Entry points should be specified using `@pragma("vm:entry-point")`
  /// annotation.
  ///
  /// \return An error handle if a compilation error or runtime error running const
  /// constructors was encountered.
  Object Dart_Precompile() {
    return _Dart_Precompile();
  }

  late final _Dart_PrecompilePtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_Precompile');
  late final _Dart_Precompile =
      _Dart_PrecompilePtr.asFunction<Object Function()>();

  Object Dart_LoadingUnitLibraryUris(
    int loading_unit_id,
  ) {
    return _Dart_LoadingUnitLibraryUris(
      loading_unit_id,
    );
  }

  late final _Dart_LoadingUnitLibraryUrisPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>(
          'Dart_LoadingUnitLibraryUris');
  late final _Dart_LoadingUnitLibraryUris =
      _Dart_LoadingUnitLibraryUrisPtr.asFunction<Object Function(int)>();

  /// Creates a precompiled snapshot.
  /// - A root library must have been loaded.
  /// - Dart_Precompile must have been called.
  ///
  /// Outputs an assembly file defining the symbols listed in the definitions
  /// above.
  ///
  /// The assembly should be compiled as a static or shared library and linked or
  /// loaded by the embedder. Running this snapshot requires a VM compiled with
  /// DART_PRECOMPILED_SNAPSHOT. The kDartVmSnapshotData and
  /// kDartVmSnapshotInstructions should be passed to Dart_Initialize. The
  /// kDartIsolateSnapshotData and kDartIsolateSnapshotInstructions should be
  /// passed to Dart_CreateIsolateGroup.
  ///
  /// The callback will be invoked one or more times to provide the assembly code.
  ///
  /// If stripped is true, then the assembly code will not include DWARF
  /// debugging sections.
  ///
  /// If debug_callback_data is provided, debug_callback_data will be used with
  /// the callback to provide separate debugging information.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppAOTSnapshotAsAssembly(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
    bool stripped,
    ffi.Pointer<ffi.Void> debug_callback_data,
  ) {
    return _Dart_CreateAppAOTSnapshotAsAssembly(
      callback,
      callback_data,
      stripped,
      debug_callback_data,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsAssemblyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateAppAOTSnapshotAsAssembly');
  late final _Dart_CreateAppAOTSnapshotAsAssembly =
      _Dart_CreateAppAOTSnapshotAsAssemblyPtr.asFunction<
          Object Function(Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>,
              bool, ffi.Pointer<ffi.Void>)>();

  Object Dart_CreateAppAOTSnapshotAsAssemblies(
    Dart_CreateLoadingUnitCallback next_callback,
    ffi.Pointer<ffi.Void> next_callback_data,
    bool stripped,
    Dart_StreamingWriteCallback write_callback,
    Dart_StreamingCloseCallback close_callback,
  ) {
    return _Dart_CreateAppAOTSnapshotAsAssemblies(
      next_callback,
      next_callback_data,
      stripped,
      write_callback,
      close_callback,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsAssembliesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Handle Function(
                  Dart_CreateLoadingUnitCallback,
                  ffi.Pointer<ffi.Void>,
                  ffi.Bool,
                  Dart_StreamingWriteCallback,
                  Dart_StreamingCloseCallback)>>(
      'Dart_CreateAppAOTSnapshotAsAssemblies');
  late final _Dart_CreateAppAOTSnapshotAsAssemblies =
      _Dart_CreateAppAOTSnapshotAsAssembliesPtr.asFunction<
          Object Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>();

  /// Creates a precompiled snapshot.
  /// - A root library must have been loaded.
  /// - Dart_Precompile must have been called.
  ///
  /// Outputs an ELF shared library defining the symbols
  /// - _kDartVmSnapshotData
  /// - _kDartVmSnapshotInstructions
  /// - _kDartIsolateSnapshotData
  /// - _kDartIsolateSnapshotInstructions
  ///
  /// The shared library should be dynamically loaded by the embedder.
  /// Running this snapshot requires a VM compiled with DART_PRECOMPILED_SNAPSHOT.
  /// The kDartVmSnapshotData and kDartVmSnapshotInstructions should be passed to
  /// Dart_Initialize. The kDartIsolateSnapshotData and
  /// kDartIsolateSnapshotInstructions should be passed to Dart_CreateIsolate.
  ///
  /// The callback will be invoked one or more times to provide the binary output.
  ///
  /// If stripped is true, then the binary output will not include DWARF
  /// debugging sections.
  ///
  /// If debug_callback_data is provided, debug_callback_data will be used with
  /// the callback to provide separate debugging information.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppAOTSnapshotAsElf(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
    bool stripped,
    ffi.Pointer<ffi.Void> debug_callback_data,
  ) {
    return _Dart_CreateAppAOTSnapshotAsElf(
      callback,
      callback_data,
      stripped,
      debug_callback_data,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsElfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateAppAOTSnapshotAsElf');
  late final _Dart_CreateAppAOTSnapshotAsElf =
      _Dart_CreateAppAOTSnapshotAsElfPtr.asFunction<
          Object Function(Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>,
              bool, ffi.Pointer<ffi.Void>)>();

  Object Dart_CreateAppAOTSnapshotAsElfs(
    Dart_CreateLoadingUnitCallback next_callback,
    ffi.Pointer<ffi.Void> next_callback_data,
    bool stripped,
    Dart_StreamingWriteCallback write_callback,
    Dart_StreamingCloseCallback close_callback,
  ) {
    return _Dart_CreateAppAOTSnapshotAsElfs(
      next_callback,
      next_callback_data,
      stripped,
      write_callback,
      close_callback,
    );
  }

  late final _Dart_CreateAppAOTSnapshotAsElfsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              ffi.Bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>>('Dart_CreateAppAOTSnapshotAsElfs');
  late final _Dart_CreateAppAOTSnapshotAsElfs =
      _Dart_CreateAppAOTSnapshotAsElfsPtr.asFunction<
          Object Function(
              Dart_CreateLoadingUnitCallback,
              ffi.Pointer<ffi.Void>,
              bool,
              Dart_StreamingWriteCallback,
              Dart_StreamingCloseCallback)>();

  /// Like Dart_CreateAppAOTSnapshotAsAssembly, but only includes
  /// kDartVmSnapshotData and kDartVmSnapshotInstructions. It also does
  /// not strip DWARF information from the generated assembly or allow for
  /// separate debug information.
  Object Dart_CreateVMAOTSnapshotAsAssembly(
    Dart_StreamingWriteCallback callback,
    ffi.Pointer<ffi.Void> callback_data,
  ) {
    return _Dart_CreateVMAOTSnapshotAsAssembly(
      callback,
      callback_data,
    );
  }

  late final _Dart_CreateVMAOTSnapshotAsAssemblyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(Dart_StreamingWriteCallback,
              ffi.Pointer<ffi.Void>)>>('Dart_CreateVMAOTSnapshotAsAssembly');
  late final _Dart_CreateVMAOTSnapshotAsAssembly =
      _Dart_CreateVMAOTSnapshotAsAssemblyPtr.asFunction<
          Object Function(
              Dart_StreamingWriteCallback, ffi.Pointer<ffi.Void>)>();

  /// Sorts the class-ids in depth first traversal order of the inheritance
  /// tree. This is a costly operation, but it can make method dispatch
  /// more efficient and is done before writing snapshots.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_SortClasses() {
    return _Dart_SortClasses();
  }

  late final _Dart_SortClassesPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_SortClasses');
  late final _Dart_SortClasses =
      _Dart_SortClassesPtr.asFunction<Object Function()>();

  /// Creates a snapshot that caches compiled code and type feedback for faster
  /// startup and quicker warmup in a subsequent process.
  ///
  /// Outputs a snapshot in two pieces. The pieces should be passed to
  /// Dart_CreateIsolateGroup in a VM using the same VM snapshot pieces used in the
  /// current VM. The instructions piece must be loaded with read and execute
  /// permissions; the data piece may be loaded as read-only.
  ///
  /// - Requires the VM to have not been started with --precompilation.
  /// - Not supported when targeting IA32.
  /// - The VM writing the snapshot and the VM reading the snapshot must be the
  /// same version, must be built in the same DEBUG/RELEASE/PRODUCT mode, must
  /// be targeting the same architecture, and must both be in checked mode or
  /// both in unchecked mode.
  ///
  /// The buffers are scope allocated and are only valid until the next call to
  /// Dart_ExitScope.
  ///
  /// \return A valid handle if no error occurs during the operation.
  Object Dart_CreateAppJITSnapshotAsBlobs(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_instructions_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_instructions_size,
  ) {
    return _Dart_CreateAppJITSnapshotAsBlobs(
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      isolate_snapshot_instructions_buffer,
      isolate_snapshot_instructions_size,
    );
  }

  late final _Dart_CreateAppJITSnapshotAsBlobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_CreateAppJITSnapshotAsBlobs');
  late final _Dart_CreateAppJITSnapshotAsBlobs =
      _Dart_CreateAppJITSnapshotAsBlobsPtr.asFunction<
          Object Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>();

  /// Like Dart_CreateAppJITSnapshotAsBlobs, but also creates a new VM snapshot.
  Object Dart_CreateCoreJITSnapshotAsBlobs(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> vm_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> vm_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> vm_snapshot_instructions_buffer,
    ffi.Pointer<ffi.IntPtr> vm_snapshot_instructions_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_data_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_data_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> isolate_snapshot_instructions_buffer,
    ffi.Pointer<ffi.IntPtr> isolate_snapshot_instructions_size,
  ) {
    return _Dart_CreateCoreJITSnapshotAsBlobs(
      vm_snapshot_data_buffer,
      vm_snapshot_data_size,
      vm_snapshot_instructions_buffer,
      vm_snapshot_instructions_size,
      isolate_snapshot_data_buffer,
      isolate_snapshot_data_size,
      isolate_snapshot_instructions_buffer,
      isolate_snapshot_instructions_size,
    );
  }

  late final _Dart_CreateCoreJITSnapshotAsBlobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_CreateCoreJITSnapshotAsBlobs');
  late final _Dart_CreateCoreJITSnapshotAsBlobs =
      _Dart_CreateCoreJITSnapshotAsBlobsPtr.asFunction<
          Object Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>();

  /// Get obfuscation map for precompiled code.
  ///
  /// Obfuscation map is encoded as a JSON array of pairs (original name,
  /// obfuscated name).
  ///
  /// \return Returns an error handler if the VM was built in a mode that does not
  /// support obfuscation.
  Object Dart_GetObfuscationMap(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> buffer,
    ffi.Pointer<ffi.IntPtr> buffer_length,
  ) {
    return _Dart_GetObfuscationMap(
      buffer,
      buffer_length,
    );
  }

  late final _Dart_GetObfuscationMapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Handle Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.IntPtr>)>>('Dart_GetObfuscationMap');
  late final _Dart_GetObfuscationMap = _Dart_GetObfuscationMapPtr.asFunction<
      Object Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.IntPtr>)>();

  /// Returns whether the VM only supports running from precompiled snapshots and
  /// not from any other kind of snapshot or from source (that is, the VM was
  /// compiled with DART_PRECOMPILED_RUNTIME).
  bool Dart_IsPrecompiledRuntime() {
    return _Dart_IsPrecompiledRuntime();
  }

  late final _Dart_IsPrecompiledRuntimePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>(
          'Dart_IsPrecompiledRuntime');
  late final _Dart_IsPrecompiledRuntime =
      _Dart_IsPrecompiledRuntimePtr.asFunction<bool Function()>();

  /// Print a native stack trace. Used for crash handling.
  ///
  /// If context is NULL, prints the current stack trace. Otherwise, context
  /// should be a CONTEXT* (Windows) or ucontext_t* (POSIX) from a signal handler
  /// running on the current thread.
  void Dart_DumpNativeStackTrace(
    ffi.Pointer<ffi.Void> context,
  ) {
    return _Dart_DumpNativeStackTrace(
      context,
    );
  }

  late final _Dart_DumpNativeStackTracePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'Dart_DumpNativeStackTrace');
  late final _Dart_DumpNativeStackTrace = _Dart_DumpNativeStackTracePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Indicate that the process is about to abort, and the Dart VM should not
  /// attempt to cleanup resources.
  void Dart_PrepareToAbort() {
    return _Dart_PrepareToAbort();
  }

  late final _Dart_PrepareToAbortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Dart_PrepareToAbort');
  late final _Dart_PrepareToAbort =
      _Dart_PrepareToAbortPtr.asFunction<void Function()>();

  /// Posts a message on some port. The message will contain the Dart_CObject
  /// object graph rooted in 'message'.
  ///
  /// While the message is being sent the state of the graph of Dart_CObject
  /// structures rooted in 'message' should not be accessed, as the message
  /// generation will make temporary modifications to the data. When the message
  /// has been sent the graph will be fully restored.
  ///
  /// If true is returned, the message was enqueued, and finalizers for external
  /// typed data will eventually run, even if the receiving isolate shuts down
  /// before processing the message. If false is returned, the message was not
  /// enqueued and ownership of external typed data in the message remains with the
  /// caller.
  ///
  /// This function may be called on any thread when the VM is running (that is,
  /// after Dart_Initialize has returned and before Dart_Cleanup has been called).
  ///
  /// \param port_id The destination port.
  /// \param message The message to send.
  ///
  /// \return True if the message was posted.
  bool Dart_PostCObject(
    int port_id,
    ffi.Pointer<Dart_CObject> message,
  ) {
    return _Dart_PostCObject(
      port_id,
      message,
    );
  }

  late final _Dart_PostCObjectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              Dart_Port, ffi.Pointer<Dart_CObject>)>>('Dart_PostCObject');
  late final _Dart_PostCObject = _Dart_PostCObjectPtr.asFunction<
      bool Function(int, ffi.Pointer<Dart_CObject>)>();

  /// Posts a message on some port. The message will contain the integer 'message'.
  ///
  /// \param port_id The destination port.
  /// \param message The message to send.
  ///
  /// \return True if the message was posted.
  bool Dart_PostInteger(
    int port_id,
    int message,
  ) {
    return _Dart_PostInteger(
      port_id,
      message,
    );
  }

  late final _Dart_PostIntegerPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Port, ffi.Int64)>>(
          'Dart_PostInteger');
  late final _Dart_PostInteger =
      _Dart_PostIntegerPtr.asFunction<bool Function(int, int)>();

  /// Creates a new native port.  When messages are received on this
  /// native port, then they will be dispatched to the provided native
  /// message handler.
  ///
  /// \param name The name of this port in debugging messages.
  /// \param handler The C handler to run when messages arrive on the port.
  /// \param handle_concurrently Is it okay to process requests on this
  /// native port concurrently?
  ///
  /// \return If successful, returns the port id for the native port.  In
  /// case of error, returns ILLEGAL_PORT.
  int Dart_NewNativePort(
    ffi.Pointer<ffi.Char> name,
    Dart_NativeMessageHandler handler,
    bool handle_concurrently,
  ) {
    return _Dart_NewNativePort(
      name,
      handler,
      handle_concurrently,
    );
  }

  late final _Dart_NewNativePortPtr = _lookup<
      ffi.NativeFunction<
          Dart_Port Function(ffi.Pointer<ffi.Char>, Dart_NativeMessageHandler,
              ffi.Bool)>>('Dart_NewNativePort');
  late final _Dart_NewNativePort = _Dart_NewNativePortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, Dart_NativeMessageHandler, bool)>();

  /// Closes the native port with the given id.
  ///
  /// The port must have been allocated by a call to Dart_NewNativePort.
  ///
  /// \param native_port_id The id of the native port to close.
  ///
  /// \return Returns true if the port was closed successfully.
  bool Dart_CloseNativePort(
    int native_port_id,
  ) {
    return _Dart_CloseNativePort(
      native_port_id,
    );
  }

  late final _Dart_CloseNativePortPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Dart_Port)>>(
          'Dart_CloseNativePort');
  late final _Dart_CloseNativePort =
      _Dart_CloseNativePortPtr.asFunction<bool Function(int)>();

  /// Forces all loaded classes and functions to be compiled eagerly in
  /// the current isolate..
  ///
  /// TODO(turnidge): Document.
  Object Dart_CompileAll() {
    return _Dart_CompileAll();
  }

  late final _Dart_CompileAllPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>('Dart_CompileAll');
  late final _Dart_CompileAll =
      _Dart_CompileAllPtr.asFunction<Object Function()>();

  /// Finalizes all classes.
  Object Dart_FinalizeAllClasses() {
    return _Dart_FinalizeAllClasses();
  }

  late final _Dart_FinalizeAllClassesPtr =
      _lookup<ffi.NativeFunction<ffi.Handle Function()>>(
          'Dart_FinalizeAllClasses');
  late final _Dart_FinalizeAllClasses =
      _Dart_FinalizeAllClassesPtr.asFunction<Object Function()>();

  /// This function is intentionally undocumented.
  ///
  /// It should not be used outside internal tests.
  ffi.Pointer<ffi.Void> Dart_ExecuteInternalCommand(
    ffi.Pointer<ffi.Char> command,
    ffi.Pointer<ffi.Void> arg,
  ) {
    return _Dart_ExecuteInternalCommand(
      command,
      arg,
    );
  }

  late final _Dart_ExecuteInternalCommandPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('Dart_ExecuteInternalCommand');
  late final _Dart_ExecuteInternalCommand =
      _Dart_ExecuteInternalCommandPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();

  /// \mainpage Dynamically Linked Dart API
  ///
  /// This exposes a subset of symbols from dart_api.h and dart_native_api.h
  /// available in every Dart embedder through dynamic linking.
  ///
  /// All symbols are postfixed with _DL to indicate that they are dynamically
  /// linked and to prevent conflicts with the original symbol.
  ///
  /// Link `dart_api_dl.c` file into your library and invoke
  /// `Dart_InitializeApiDL` with `NativeApi.initializeApiDLData`.
  int Dart_InitializeApiDL(
    ffi.Pointer<ffi.Void> data,
  ) {
    return _Dart_InitializeApiDL(
      data,
    );
  }

  late final _Dart_InitializeApiDLPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(ffi.Pointer<ffi.Void>)>>(
          'Dart_InitializeApiDL');
  late final _Dart_InitializeApiDL = _Dart_InitializeApiDLPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>)>();

  late final ffi.Pointer<Dart_PostCObject_Type> _Dart_PostCObject_DL =
      _lookup<Dart_PostCObject_Type>('Dart_PostCObject_DL');

  Dart_PostCObject_Type get Dart_PostCObject_DL => _Dart_PostCObject_DL.value;

  set Dart_PostCObject_DL(Dart_PostCObject_Type value) =>
      _Dart_PostCObject_DL.value = value;

  late final ffi.Pointer<Dart_PostInteger_Type> _Dart_PostInteger_DL =
      _lookup<Dart_PostInteger_Type>('Dart_PostInteger_DL');

  Dart_PostInteger_Type get Dart_PostInteger_DL => _Dart_PostInteger_DL.value;

  set Dart_PostInteger_DL(Dart_PostInteger_Type value) =>
      _Dart_PostInteger_DL.value = value;

  late final ffi.Pointer<Dart_NewNativePort_Type> _Dart_NewNativePort_DL =
      _lookup<Dart_NewNativePort_Type>('Dart_NewNativePort_DL');

  Dart_NewNativePort_Type get Dart_NewNativePort_DL =>
      _Dart_NewNativePort_DL.value;

  set Dart_NewNativePort_DL(Dart_NewNativePort_Type value) =>
      _Dart_NewNativePort_DL.value = value;

  late final ffi.Pointer<Dart_CloseNativePort_Type> _Dart_CloseNativePort_DL =
      _lookup<Dart_CloseNativePort_Type>('Dart_CloseNativePort_DL');

  Dart_CloseNativePort_Type get Dart_CloseNativePort_DL =>
      _Dart_CloseNativePort_DL.value;

  set Dart_CloseNativePort_DL(Dart_CloseNativePort_Type value) =>
      _Dart_CloseNativePort_DL.value = value;

  late final ffi.Pointer<Dart_IsError_Type> _Dart_IsError_DL =
      _lookup<Dart_IsError_Type>('Dart_IsError_DL');

  Dart_IsError_Type get Dart_IsError_DL => _Dart_IsError_DL.value;

  set Dart_IsError_DL(Dart_IsError_Type value) =>
      _Dart_IsError_DL.value = value;

  late final ffi.Pointer<Dart_IsApiError_Type> _Dart_IsApiError_DL =
      _lookup<Dart_IsApiError_Type>('Dart_IsApiError_DL');

  Dart_IsApiError_Type get Dart_IsApiError_DL => _Dart_IsApiError_DL.value;

  set Dart_IsApiError_DL(Dart_IsApiError_Type value) =>
      _Dart_IsApiError_DL.value = value;

  late final ffi.Pointer<Dart_IsUnhandledExceptionError_Type>
      _Dart_IsUnhandledExceptionError_DL =
      _lookup<Dart_IsUnhandledExceptionError_Type>(
          'Dart_IsUnhandledExceptionError_DL');

  Dart_IsUnhandledExceptionError_Type get Dart_IsUnhandledExceptionError_DL =>
      _Dart_IsUnhandledExceptionError_DL.value;

  set Dart_IsUnhandledExceptionError_DL(
          Dart_IsUnhandledExceptionError_Type value) =>
      _Dart_IsUnhandledExceptionError_DL.value = value;

  late final ffi.Pointer<Dart_IsCompilationError_Type>
      _Dart_IsCompilationError_DL =
      _lookup<Dart_IsCompilationError_Type>('Dart_IsCompilationError_DL');

  Dart_IsCompilationError_Type get Dart_IsCompilationError_DL =>
      _Dart_IsCompilationError_DL.value;

  set Dart_IsCompilationError_DL(Dart_IsCompilationError_Type value) =>
      _Dart_IsCompilationError_DL.value = value;

  late final ffi.Pointer<Dart_IsFatalError_Type> _Dart_IsFatalError_DL =
      _lookup<Dart_IsFatalError_Type>('Dart_IsFatalError_DL');

  Dart_IsFatalError_Type get Dart_IsFatalError_DL =>
      _Dart_IsFatalError_DL.value;

  set Dart_IsFatalError_DL(Dart_IsFatalError_Type value) =>
      _Dart_IsFatalError_DL.value = value;

  late final ffi.Pointer<Dart_GetError_Type> _Dart_GetError_DL =
      _lookup<Dart_GetError_Type>('Dart_GetError_DL');

  Dart_GetError_Type get Dart_GetError_DL => _Dart_GetError_DL.value;

  set Dart_GetError_DL(Dart_GetError_Type value) =>
      _Dart_GetError_DL.value = value;

  late final ffi.Pointer<Dart_ErrorHasException_Type>
      _Dart_ErrorHasException_DL =
      _lookup<Dart_ErrorHasException_Type>('Dart_ErrorHasException_DL');

  Dart_ErrorHasException_Type get Dart_ErrorHasException_DL =>
      _Dart_ErrorHasException_DL.value;

  set Dart_ErrorHasException_DL(Dart_ErrorHasException_Type value) =>
      _Dart_ErrorHasException_DL.value = value;

  late final ffi.Pointer<Dart_ErrorGetException_Type>
      _Dart_ErrorGetException_DL =
      _lookup<Dart_ErrorGetException_Type>('Dart_ErrorGetException_DL');

  Dart_ErrorGetException_Type get Dart_ErrorGetException_DL =>
      _Dart_ErrorGetException_DL.value;

  set Dart_ErrorGetException_DL(Dart_ErrorGetException_Type value) =>
      _Dart_ErrorGetException_DL.value = value;

  late final ffi.Pointer<Dart_ErrorGetStackTrace_Type>
      _Dart_ErrorGetStackTrace_DL =
      _lookup<Dart_ErrorGetStackTrace_Type>('Dart_ErrorGetStackTrace_DL');

  Dart_ErrorGetStackTrace_Type get Dart_ErrorGetStackTrace_DL =>
      _Dart_ErrorGetStackTrace_DL.value;

  set Dart_ErrorGetStackTrace_DL(Dart_ErrorGetStackTrace_Type value) =>
      _Dart_ErrorGetStackTrace_DL.value = value;

  late final ffi.Pointer<Dart_NewApiError_Type> _Dart_NewApiError_DL =
      _lookup<Dart_NewApiError_Type>('Dart_NewApiError_DL');

  Dart_NewApiError_Type get Dart_NewApiError_DL => _Dart_NewApiError_DL.value;

  set Dart_NewApiError_DL(Dart_NewApiError_Type value) =>
      _Dart_NewApiError_DL.value = value;

  late final ffi.Pointer<Dart_NewCompilationError_Type>
      _Dart_NewCompilationError_DL =
      _lookup<Dart_NewCompilationError_Type>('Dart_NewCompilationError_DL');

  Dart_NewCompilationError_Type get Dart_NewCompilationError_DL =>
      _Dart_NewCompilationError_DL.value;

  set Dart_NewCompilationError_DL(Dart_NewCompilationError_Type value) =>
      _Dart_NewCompilationError_DL.value = value;

  late final ffi.Pointer<Dart_NewUnhandledExceptionError_Type>
      _Dart_NewUnhandledExceptionError_DL =
      _lookup<Dart_NewUnhandledExceptionError_Type>(
          'Dart_NewUnhandledExceptionError_DL');

  Dart_NewUnhandledExceptionError_Type get Dart_NewUnhandledExceptionError_DL =>
      _Dart_NewUnhandledExceptionError_DL.value;

  set Dart_NewUnhandledExceptionError_DL(
          Dart_NewUnhandledExceptionError_Type value) =>
      _Dart_NewUnhandledExceptionError_DL.value = value;

  late final ffi.Pointer<Dart_PropagateError_Type> _Dart_PropagateError_DL =
      _lookup<Dart_PropagateError_Type>('Dart_PropagateError_DL');

  Dart_PropagateError_Type get Dart_PropagateError_DL =>
      _Dart_PropagateError_DL.value;

  set Dart_PropagateError_DL(Dart_PropagateError_Type value) =>
      _Dart_PropagateError_DL.value = value;

  late final ffi.Pointer<Dart_HandleFromPersistent_Type>
      _Dart_HandleFromPersistent_DL =
      _lookup<Dart_HandleFromPersistent_Type>('Dart_HandleFromPersistent_DL');

  Dart_HandleFromPersistent_Type get Dart_HandleFromPersistent_DL =>
      _Dart_HandleFromPersistent_DL.value;

  set Dart_HandleFromPersistent_DL(Dart_HandleFromPersistent_Type value) =>
      _Dart_HandleFromPersistent_DL.value = value;

  late final ffi.Pointer<Dart_HandleFromWeakPersistent_Type>
      _Dart_HandleFromWeakPersistent_DL =
      _lookup<Dart_HandleFromWeakPersistent_Type>(
          'Dart_HandleFromWeakPersistent_DL');

  Dart_HandleFromWeakPersistent_Type get Dart_HandleFromWeakPersistent_DL =>
      _Dart_HandleFromWeakPersistent_DL.value;

  set Dart_HandleFromWeakPersistent_DL(
          Dart_HandleFromWeakPersistent_Type value) =>
      _Dart_HandleFromWeakPersistent_DL.value = value;

  late final ffi.Pointer<Dart_NewPersistentHandle_Type>
      _Dart_NewPersistentHandle_DL =
      _lookup<Dart_NewPersistentHandle_Type>('Dart_NewPersistentHandle_DL');

  Dart_NewPersistentHandle_Type get Dart_NewPersistentHandle_DL =>
      _Dart_NewPersistentHandle_DL.value;

  set Dart_NewPersistentHandle_DL(Dart_NewPersistentHandle_Type value) =>
      _Dart_NewPersistentHandle_DL.value = value;

  late final ffi.Pointer<Dart_SetPersistentHandle_Type>
      _Dart_SetPersistentHandle_DL =
      _lookup<Dart_SetPersistentHandle_Type>('Dart_SetPersistentHandle_DL');

  Dart_SetPersistentHandle_Type get Dart_SetPersistentHandle_DL =>
      _Dart_SetPersistentHandle_DL.value;

  set Dart_SetPersistentHandle_DL(Dart_SetPersistentHandle_Type value) =>
      _Dart_SetPersistentHandle_DL.value = value;

  late final ffi.Pointer<Dart_DeletePersistentHandle_Type>
      _Dart_DeletePersistentHandle_DL =
      _lookup<Dart_DeletePersistentHandle_Type>(
          'Dart_DeletePersistentHandle_DL');

  Dart_DeletePersistentHandle_Type get Dart_DeletePersistentHandle_DL =>
      _Dart_DeletePersistentHandle_DL.value;

  set Dart_DeletePersistentHandle_DL(Dart_DeletePersistentHandle_Type value) =>
      _Dart_DeletePersistentHandle_DL.value = value;

  late final ffi.Pointer<Dart_NewWeakPersistentHandle_Type>
      _Dart_NewWeakPersistentHandle_DL =
      _lookup<Dart_NewWeakPersistentHandle_Type>(
          'Dart_NewWeakPersistentHandle_DL');

  Dart_NewWeakPersistentHandle_Type get Dart_NewWeakPersistentHandle_DL =>
      _Dart_NewWeakPersistentHandle_DL.value;

  set Dart_NewWeakPersistentHandle_DL(
          Dart_NewWeakPersistentHandle_Type value) =>
      _Dart_NewWeakPersistentHandle_DL.value = value;

  late final ffi.Pointer<Dart_DeleteWeakPersistentHandle_Type>
      _Dart_DeleteWeakPersistentHandle_DL =
      _lookup<Dart_DeleteWeakPersistentHandle_Type>(
          'Dart_DeleteWeakPersistentHandle_DL');

  Dart_DeleteWeakPersistentHandle_Type get Dart_DeleteWeakPersistentHandle_DL =>
      _Dart_DeleteWeakPersistentHandle_DL.value;

  set Dart_DeleteWeakPersistentHandle_DL(
          Dart_DeleteWeakPersistentHandle_Type value) =>
      _Dart_DeleteWeakPersistentHandle_DL.value = value;

  late final ffi.Pointer<Dart_UpdateExternalSize_Type>
      _Dart_UpdateExternalSize_DL =
      _lookup<Dart_UpdateExternalSize_Type>('Dart_UpdateExternalSize_DL');

  Dart_UpdateExternalSize_Type get Dart_UpdateExternalSize_DL =>
      _Dart_UpdateExternalSize_DL.value;

  set Dart_UpdateExternalSize_DL(Dart_UpdateExternalSize_Type value) =>
      _Dart_UpdateExternalSize_DL.value = value;

  late final ffi.Pointer<Dart_NewFinalizableHandle_Type>
      _Dart_NewFinalizableHandle_DL =
      _lookup<Dart_NewFinalizableHandle_Type>('Dart_NewFinalizableHandle_DL');

  Dart_NewFinalizableHandle_Type get Dart_NewFinalizableHandle_DL =>
      _Dart_NewFinalizableHandle_DL.value;

  set Dart_NewFinalizableHandle_DL(Dart_NewFinalizableHandle_Type value) =>
      _Dart_NewFinalizableHandle_DL.value = value;

  late final ffi.Pointer<Dart_DeleteFinalizableHandle_Type>
      _Dart_DeleteFinalizableHandle_DL =
      _lookup<Dart_DeleteFinalizableHandle_Type>(
          'Dart_DeleteFinalizableHandle_DL');

  Dart_DeleteFinalizableHandle_Type get Dart_DeleteFinalizableHandle_DL =>
      _Dart_DeleteFinalizableHandle_DL.value;

  set Dart_DeleteFinalizableHandle_DL(
          Dart_DeleteFinalizableHandle_Type value) =>
      _Dart_DeleteFinalizableHandle_DL.value = value;

  late final ffi.Pointer<Dart_UpdateFinalizableExternalSize_Type>
      _Dart_UpdateFinalizableExternalSize_DL =
      _lookup<Dart_UpdateFinalizableExternalSize_Type>(
          'Dart_UpdateFinalizableExternalSize_DL');

  Dart_UpdateFinalizableExternalSize_Type
      get Dart_UpdateFinalizableExternalSize_DL =>
          _Dart_UpdateFinalizableExternalSize_DL.value;

  set Dart_UpdateFinalizableExternalSize_DL(
          Dart_UpdateFinalizableExternalSize_Type value) =>
      _Dart_UpdateFinalizableExternalSize_DL.value = value;

  late final ffi.Pointer<Dart_Post_Type> _Dart_Post_DL =
      _lookup<Dart_Post_Type>('Dart_Post_DL');

  Dart_Post_Type get Dart_Post_DL => _Dart_Post_DL.value;

  set Dart_Post_DL(Dart_Post_Type value) => _Dart_Post_DL.value = value;

  late final ffi.Pointer<Dart_NewSendPort_Type> _Dart_NewSendPort_DL =
      _lookup<Dart_NewSendPort_Type>('Dart_NewSendPort_DL');

  Dart_NewSendPort_Type get Dart_NewSendPort_DL => _Dart_NewSendPort_DL.value;

  set Dart_NewSendPort_DL(Dart_NewSendPort_Type value) =>
      _Dart_NewSendPort_DL.value = value;

  late final ffi.Pointer<Dart_SendPortGetId_Type> _Dart_SendPortGetId_DL =
      _lookup<Dart_SendPortGetId_Type>('Dart_SendPortGetId_DL');

  Dart_SendPortGetId_Type get Dart_SendPortGetId_DL =>
      _Dart_SendPortGetId_DL.value;

  set Dart_SendPortGetId_DL(Dart_SendPortGetId_Type value) =>
      _Dart_SendPortGetId_DL.value = value;

  late final ffi.Pointer<Dart_EnterScope_Type> _Dart_EnterScope_DL =
      _lookup<Dart_EnterScope_Type>('Dart_EnterScope_DL');

  Dart_EnterScope_Type get Dart_EnterScope_DL => _Dart_EnterScope_DL.value;

  set Dart_EnterScope_DL(Dart_EnterScope_Type value) =>
      _Dart_EnterScope_DL.value = value;

  late final ffi.Pointer<Dart_ExitScope_Type> _Dart_ExitScope_DL =
      _lookup<Dart_ExitScope_Type>('Dart_ExitScope_DL');

  Dart_ExitScope_Type get Dart_ExitScope_DL => _Dart_ExitScope_DL.value;

  set Dart_ExitScope_DL(Dart_ExitScope_Type value) =>
      _Dart_ExitScope_DL.value = value;

  late final _class_CUPHTTPTaskConfiguration1 =
      _getClass1("CUPHTTPTaskConfiguration");
  late final _sel_initWithPort_1 = _registerName1("initWithPort:");
  ffi.Pointer<ObjCObject> _objc_msgSend_323(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int sendPort,
  ) {
    return __objc_msgSend_323(
      obj,
      sel,
      sendPort,
    );
  }

  late final __objc_msgSend_323Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>, Dart_Port)>>('objc_msgSend');
  late final __objc_msgSend_323 = __objc_msgSend_323Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_sendPort1 = _registerName1("sendPort");
  late final _class_CUPHTTPClientDelegate1 =
      _getClass1("CUPHTTPClientDelegate");
  late final _sel_registerTask_withConfiguration_1 =
      _registerName1("registerTask:withConfiguration:");
  void _objc_msgSend_324(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> task,
    ffi.Pointer<ObjCObject> config,
  ) {
    return __objc_msgSend_324(
      obj,
      sel,
      task,
      config,
    );
  }

  late final __objc_msgSend_324Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_324 = __objc_msgSend_324Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCObject>)>();

  late final _class_CUPHTTPForwardedDelegate1 =
      _getClass1("CUPHTTPForwardedDelegate");
  late final _sel_initWithSession_task_1 =
      _registerName1("initWithSession:task:");
  ffi.Pointer<ObjCObject> _objc_msgSend_325(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> session,
    ffi.Pointer<ObjCObject> task,
  ) {
    return __objc_msgSend_325(
      obj,
      sel,
      session,
      task,
    );
  }

  late final __objc_msgSend_325Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_325 = __objc_msgSend_325Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_finish1 = _registerName1("finish");
  late final _sel_session1 = _registerName1("session");
  late final _sel_task1 = _registerName1("task");
  ffi.Pointer<ObjCObject> _objc_msgSend_326(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_326(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_326Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_326 = __objc_msgSend_326Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _class_NSLock1 = _getClass1("NSLock");
  late final _sel_lock1 = _registerName1("lock");
  ffi.Pointer<ObjCObject> _objc_msgSend_327(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_327(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_327Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_327 = __objc_msgSend_327Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _class_CUPHTTPForwardedRedirect1 =
      _getClass1("CUPHTTPForwardedRedirect");
  late final _sel_initWithSession_task_response_request_1 =
      _registerName1("initWithSession:task:response:request:");
  ffi.Pointer<ObjCObject> _objc_msgSend_328(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> session,
    ffi.Pointer<ObjCObject> task,
    ffi.Pointer<ObjCObject> response,
    ffi.Pointer<ObjCObject> request,
  ) {
    return __objc_msgSend_328(
      obj,
      sel,
      session,
      task,
      response,
      request,
    );
  }

  late final __objc_msgSend_328Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_328 = __objc_msgSend_328Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_finishWithRequest_1 = _registerName1("finishWithRequest:");
  void _objc_msgSend_329(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> request,
  ) {
    return __objc_msgSend_329(
      obj,
      sel,
      request,
    );
  }

  late final __objc_msgSend_329Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_329 = __objc_msgSend_329Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>)>();

  ffi.Pointer<ObjCObject> _objc_msgSend_330(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_330(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_330Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_330 = __objc_msgSend_330Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _sel_redirectRequest1 = _registerName1("redirectRequest");
  late final _class_CUPHTTPForwardedResponse1 =
      _getClass1("CUPHTTPForwardedResponse");
  late final _sel_initWithSession_task_response_1 =
      _registerName1("initWithSession:task:response:");
  ffi.Pointer<ObjCObject> _objc_msgSend_331(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> session,
    ffi.Pointer<ObjCObject> task,
    ffi.Pointer<ObjCObject> response,
  ) {
    return __objc_msgSend_331(
      obj,
      sel,
      session,
      task,
      response,
    );
  }

  late final __objc_msgSend_331Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_331 = __objc_msgSend_331Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_finishWithDisposition_1 =
      _registerName1("finishWithDisposition:");
  void _objc_msgSend_332(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    int disposition,
  ) {
    return __objc_msgSend_332(
      obj,
      sel,
      disposition,
    );
  }

  late final __objc_msgSend_332Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>,
              ffi.Int32)>>('objc_msgSend');
  late final __objc_msgSend_332 = __objc_msgSend_332Ptr.asFunction<
      void Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>, int)>();

  late final _sel_disposition1 = _registerName1("disposition");
  int _objc_msgSend_333(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
  ) {
    return __objc_msgSend_333(
      obj,
      sel,
    );
  }

  late final __objc_msgSend_333Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>>('objc_msgSend');
  late final __objc_msgSend_333 = __objc_msgSend_333Ptr.asFunction<
      int Function(ffi.Pointer<ObjCObject>, ffi.Pointer<ObjCSel>)>();

  late final _class_CUPHTTPForwardedData1 = _getClass1("CUPHTTPForwardedData");
  late final _sel_initWithSession_task_data_1 =
      _registerName1("initWithSession:task:data:");
  ffi.Pointer<ObjCObject> _objc_msgSend_334(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> session,
    ffi.Pointer<ObjCObject> task,
    ffi.Pointer<ObjCObject> data,
  ) {
    return __objc_msgSend_334(
      obj,
      sel,
      session,
      task,
      data,
    );
  }

  late final __objc_msgSend_334Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_334 = __objc_msgSend_334Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _class_CUPHTTPForwardedComplete1 =
      _getClass1("CUPHTTPForwardedComplete");
  late final _sel_initWithSession_task_error_1 =
      _registerName1("initWithSession:task:error:");
  ffi.Pointer<ObjCObject> _objc_msgSend_335(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> session,
    ffi.Pointer<ObjCObject> task,
    ffi.Pointer<ObjCObject> error,
  ) {
    return __objc_msgSend_335(
      obj,
      sel,
      session,
      task,
      error,
    );
  }

  late final __objc_msgSend_335Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_335 = __objc_msgSend_335Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _class_CUPHTTPForwardedFinishedDownloading1 =
      _getClass1("CUPHTTPForwardedFinishedDownloading");
  late final _sel_initWithSession_downloadTask_url_1 =
      _registerName1("initWithSession:downloadTask:url:");
  ffi.Pointer<ObjCObject> _objc_msgSend_336(
    ffi.Pointer<ObjCObject> obj,
    ffi.Pointer<ObjCSel> sel,
    ffi.Pointer<ObjCObject> session,
    ffi.Pointer<ObjCObject> downloadTask,
    ffi.Pointer<ObjCObject> location,
  ) {
    return __objc_msgSend_336(
      obj,
      sel,
      session,
      downloadTask,
      location,
    );
  }

  late final __objc_msgSend_336Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCSel>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>,
              ffi.Pointer<ObjCObject>)>>('objc_msgSend');
  late final __objc_msgSend_336 = __objc_msgSend_336Ptr.asFunction<
      ffi.Pointer<ObjCObject> Function(
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCSel>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>,
          ffi.Pointer<ObjCObject>)>();

  late final _sel_location1 = _registerName1("location");
}

/// Immutable Array
class _ObjCWrapper implements ffi.Finalizable {
  final ffi.Pointer<ObjCObject> _id;
  final NativeCupertinoHttp _lib;
  bool _pendingRelease;

  _ObjCWrapper._(this._id, this._lib,
      {bool retain = false, bool release = false})
      : _pendingRelease = release {
    if (retain) {
      _lib._objc_retain(_id);
    }
    if (release) {
      _lib._objc_releaseFinalizer1.attach(this, _id.cast(), detach: this);
    }
  }

  /// Releases the reference to the underlying ObjC object held by this wrapper.
  /// Throws a StateError if this wrapper doesn't currently hold a reference.
  void release() {
    if (_pendingRelease) {
      _pendingRelease = false;
      _lib._objc_release(_id);
      _lib._objc_releaseFinalizer1.detach(this);
    } else {
      throw StateError(
          'Released an ObjC object that was unowned or already released.');
    }
  }

  @override
  bool operator ==(Object other) {
    return other is _ObjCWrapper && _id == other._id;
  }

  @override
  int get hashCode => _id.hashCode;
}

class NSArray extends NSObject {
  NSArray._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSArray] that points to the same underlying object as [other].
  static NSArray castFrom<T extends _ObjCWrapper>(T other) {
    return NSArray._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSArray] that wraps the given raw object pointer.
  static NSArray castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSArray._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSArray].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSArray1);
  }

  int get count {
    return _lib._objc_msgSend_12(_id, _lib._sel_count1);
  }

  NSObject objectAtIndex_(int index) {
    final _ret = _lib._objc_msgSend_146(_id, _lib._sel_objectAtIndex_1, index);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSArray init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray initWithObjects_count_(
      ffi.Pointer<ffi.Pointer<ObjCObject>> objects, int cnt) {
    final _ret = _lib._objc_msgSend_147(
        _id, _lib._sel_initWithObjects_count_1, objects, cnt);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray initWithCoder_(NSCoder? coder) {
    final _ret = _lib._objc_msgSend_14(
        _id, _lib._sel_initWithCoder_1, coder?._id ?? ffi.nullptr);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray arrayByAddingObject_(NSObject anObject) {
    final _ret = _lib._objc_msgSend_73(
        _id, _lib._sel_arrayByAddingObject_1, anObject._id);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray arrayByAddingObjectsFromArray_(NSArray? otherArray) {
    final _ret = _lib._objc_msgSend_148(
        _id,
        _lib._sel_arrayByAddingObjectsFromArray_1,
        otherArray?._id ?? ffi.nullptr);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSString componentsJoinedByString_(NSString? separator) {
    final _ret = _lib._objc_msgSend_149(_id,
        _lib._sel_componentsJoinedByString_1, separator?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  bool containsObject_(NSObject anObject) {
    return _lib._objc_msgSend_0(_id, _lib._sel_containsObject_1, anObject._id);
  }

  NSString? get description {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_description1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString descriptionWithLocale_(NSObject locale) {
    final _ret = _lib._objc_msgSend_68(
        _id, _lib._sel_descriptionWithLocale_1, locale._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString descriptionWithLocale_indent_(NSObject locale, int level) {
    final _ret = _lib._objc_msgSend_74(
        _id, _lib._sel_descriptionWithLocale_indent_1, locale._id, level);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSObject firstObjectCommonWithArray_(NSArray? otherArray) {
    final _ret = _lib._objc_msgSend_86(_id,
        _lib._sel_firstObjectCommonWithArray_1, otherArray?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  void getObjects_range_(
      ffi.Pointer<ffi.Pointer<ObjCObject>> objects, NSRange range) {
    return _lib._objc_msgSend_150(
        _id, _lib._sel_getObjects_range_1, objects, range);
  }

  int indexOfObject_(NSObject anObject) {
    return _lib._objc_msgSend_151(_id, _lib._sel_indexOfObject_1, anObject._id);
  }

  int indexOfObject_inRange_(NSObject anObject, NSRange range) {
    return _lib._objc_msgSend_152(
        _id, _lib._sel_indexOfObject_inRange_1, anObject._id, range);
  }

  int indexOfObjectIdenticalTo_(NSObject anObject) {
    return _lib._objc_msgSend_151(
        _id, _lib._sel_indexOfObjectIdenticalTo_1, anObject._id);
  }

  int indexOfObjectIdenticalTo_inRange_(NSObject anObject, NSRange range) {
    return _lib._objc_msgSend_152(
        _id, _lib._sel_indexOfObjectIdenticalTo_inRange_1, anObject._id, range);
  }

  bool isEqualToArray_(NSArray? otherArray) {
    return _lib._objc_msgSend_153(
        _id, _lib._sel_isEqualToArray_1, otherArray?._id ?? ffi.nullptr);
  }

  NSObject get firstObject {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_firstObject1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSObject get lastObject {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_lastObject1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSArray array(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSArray1, _lib._sel_array1);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  static NSArray arrayWithObject_(NativeCupertinoHttp _lib, NSObject anObject) {
    final _ret = _lib._objc_msgSend_71(
        _lib._class_NSArray1, _lib._sel_arrayWithObject_1, anObject._id);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  static NSArray arrayWithObjects_count_(NativeCupertinoHttp _lib,
      ffi.Pointer<ffi.Pointer<ObjCObject>> objects, int cnt) {
    final _ret = _lib._objc_msgSend_147(
        _lib._class_NSArray1, _lib._sel_arrayWithObjects_count_1, objects, cnt);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  static NSArray arrayWithObjects_(
      NativeCupertinoHttp _lib, NSObject firstObj) {
    final _ret = _lib._objc_msgSend_71(
        _lib._class_NSArray1, _lib._sel_arrayWithObjects_1, firstObj._id);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  static NSArray arrayWithArray_(NativeCupertinoHttp _lib, NSArray? array) {
    final _ret = _lib._objc_msgSend_86(_lib._class_NSArray1,
        _lib._sel_arrayWithArray_1, array?._id ?? ffi.nullptr);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray initWithObjects_(NSObject firstObj) {
    final _ret =
        _lib._objc_msgSend_71(_id, _lib._sel_initWithObjects_1, firstObj._id);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray initWithArray_(NSArray? array) {
    final _ret = _lib._objc_msgSend_86(
        _id, _lib._sel_initWithArray_1, array?._id ?? ffi.nullptr);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray initWithArray_copyItems_(NSArray? array, bool flag) {
    final _ret = _lib._objc_msgSend_154(_id,
        _lib._sel_initWithArray_copyItems_1, array?._id ?? ffi.nullptr, flag);
    return NSArray._(_ret, _lib, retain: false, release: true);
  }

  /// Reads array stored in NSPropertyList format from the specified url.
  NSArray initWithContentsOfURL_error_(
      NSURL? url, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_155(
        _id,
        _lib._sel_initWithContentsOfURL_error_1,
        url?._id ?? ffi.nullptr,
        error);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  /// Reads array stored in NSPropertyList format from the specified url.
  static NSArray arrayWithContentsOfURL_error_(NativeCupertinoHttp _lib,
      NSURL? url, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_155(
        _lib._class_NSArray1,
        _lib._sel_arrayWithContentsOfURL_error_1,
        url?._id ?? ffi.nullptr,
        error);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  /// This method is unsafe because it could potentially cause buffer overruns. You should use -getObjects:range: instead.
  void getObjects_(ffi.Pointer<ffi.Pointer<ObjCObject>> objects) {
    return _lib._objc_msgSend_156(_id, _lib._sel_getObjects_1, objects);
  }

  /// These methods are deprecated, and will be marked with API_DEPRECATED in a subsequent release. Use the variants that use errors instead.
  static NSArray arrayWithContentsOfFile_(
      NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_157(_lib._class_NSArray1,
        _lib._sel_arrayWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  static NSArray arrayWithContentsOfURL_(NativeCupertinoHttp _lib, NSURL? url) {
    final _ret = _lib._objc_msgSend_158(_lib._class_NSArray1,
        _lib._sel_arrayWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray initWithContentsOfFile_(NSString? path) {
    final _ret = _lib._objc_msgSend_157(
        _id, _lib._sel_initWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray initWithContentsOfURL_(NSURL? url) {
    final _ret = _lib._objc_msgSend_158(
        _id, _lib._sel_initWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  bool writeToFile_atomically_(NSString? path, bool useAuxiliaryFile) {
    return _lib._objc_msgSend_24(_id, _lib._sel_writeToFile_atomically_1,
        path?._id ?? ffi.nullptr, useAuxiliaryFile);
  }

  bool writeToURL_atomically_(NSURL? url, bool atomically) {
    return _lib._objc_msgSend_79(_id, _lib._sel_writeToURL_atomically_1,
        url?._id ?? ffi.nullptr, atomically);
  }

  static NSArray new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSArray1, _lib._sel_new1);
    return NSArray._(_ret, _lib, retain: false, release: true);
  }

  static NSArray alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSArray1, _lib._sel_alloc1);
    return NSArray._(_ret, _lib, retain: false, release: true);
  }
}

class ObjCSel extends ffi.Opaque {}

class ObjCObject extends ffi.Opaque {}

class NSObject extends _ObjCWrapper {
  NSObject._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSObject] that points to the same underlying object as [other].
  static NSObject castFrom<T extends _ObjCWrapper>(T other) {
    return NSObject._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSObject] that wraps the given raw object pointer.
  static NSObject castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSObject._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSObject].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSObject1);
  }

  static void load(NativeCupertinoHttp _lib) {
    return _lib._objc_msgSend_1(_lib._class_NSObject1, _lib._sel_load1);
  }

  static void initialize(NativeCupertinoHttp _lib) {
    return _lib._objc_msgSend_1(_lib._class_NSObject1, _lib._sel_initialize1);
  }

  NSObject init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_new1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject allocWithZone_(
      NativeCupertinoHttp _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_allocWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_alloc1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  void dealloc() {
    return _lib._objc_msgSend_1(_id, _lib._sel_dealloc1);
  }

  void finalize() {
    return _lib._objc_msgSend_1(_id, _lib._sel_finalize1);
  }

  NSObject copy() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_copy1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  NSObject mutableCopy() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_mutableCopy1);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject copyWithZone_(
      NativeCupertinoHttp _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_copyWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static NSObject mutableCopyWithZone_(
      NativeCupertinoHttp _lib, ffi.Pointer<_NSZone> zone) {
    final _ret = _lib._objc_msgSend_3(
        _lib._class_NSObject1, _lib._sel_mutableCopyWithZone_1, zone);
    return NSObject._(_ret, _lib, retain: false, release: true);
  }

  static bool instancesRespondToSelector_(
      NativeCupertinoHttp _lib, ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_4(_lib._class_NSObject1,
        _lib._sel_instancesRespondToSelector_1, aSelector);
  }

  static bool conformsToProtocol_(
      NativeCupertinoHttp _lib, Protocol? protocol) {
    return _lib._objc_msgSend_5(_lib._class_NSObject1,
        _lib._sel_conformsToProtocol_1, protocol?._id ?? ffi.nullptr);
  }

  IMP methodForSelector_(ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_6(_id, _lib._sel_methodForSelector_1, aSelector);
  }

  static IMP instanceMethodForSelector_(
      NativeCupertinoHttp _lib, ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_6(_lib._class_NSObject1,
        _lib._sel_instanceMethodForSelector_1, aSelector);
  }

  void doesNotRecognizeSelector_(ffi.Pointer<ObjCSel> aSelector) {
    return _lib._objc_msgSend_7(
        _id, _lib._sel_doesNotRecognizeSelector_1, aSelector);
  }

  NSObject forwardingTargetForSelector_(ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_8(
        _id, _lib._sel_forwardingTargetForSelector_1, aSelector);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  void forwardInvocation_(NSInvocation? anInvocation) {
    return _lib._objc_msgSend_9(
        _id, _lib._sel_forwardInvocation_1, anInvocation?._id ?? ffi.nullptr);
  }

  NSMethodSignature methodSignatureForSelector_(
      ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_10(
        _id, _lib._sel_methodSignatureForSelector_1, aSelector);
    return NSMethodSignature._(_ret, _lib, retain: true, release: true);
  }

  static NSMethodSignature instanceMethodSignatureForSelector_(
      NativeCupertinoHttp _lib, ffi.Pointer<ObjCSel> aSelector) {
    final _ret = _lib._objc_msgSend_10(_lib._class_NSObject1,
        _lib._sel_instanceMethodSignatureForSelector_1, aSelector);
    return NSMethodSignature._(_ret, _lib, retain: true, release: true);
  }

  bool allowsWeakReference() {
    return _lib._objc_msgSend_11(_id, _lib._sel_allowsWeakReference1);
  }

  bool retainWeakReference() {
    return _lib._objc_msgSend_11(_id, _lib._sel_retainWeakReference1);
  }

  static bool isSubclassOfClass_(NativeCupertinoHttp _lib, NSObject aClass) {
    return _lib._objc_msgSend_0(
        _lib._class_NSObject1, _lib._sel_isSubclassOfClass_1, aClass._id);
  }

  static bool resolveClassMethod_(
      NativeCupertinoHttp _lib, ffi.Pointer<ObjCSel> sel) {
    return _lib._objc_msgSend_4(
        _lib._class_NSObject1, _lib._sel_resolveClassMethod_1, sel);
  }

  static bool resolveInstanceMethod_(
      NativeCupertinoHttp _lib, ffi.Pointer<ObjCSel> sel) {
    return _lib._objc_msgSend_4(
        _lib._class_NSObject1, _lib._sel_resolveInstanceMethod_1, sel);
  }

  static int hash(NativeCupertinoHttp _lib) {
    return _lib._objc_msgSend_12(_lib._class_NSObject1, _lib._sel_hash1);
  }

  static NSObject superclass(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_superclass1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSObject class1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSObject1, _lib._sel_class1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSString description(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_19(_lib._class_NSObject1, _lib._sel_description1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString debugDescription(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_19(
        _lib._class_NSObject1, _lib._sel_debugDescription1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  void URL_resourceDataDidBecomeAvailable_(NSURL? sender, NSData? newBytes) {
    return _lib._objc_msgSend_141(
        _id,
        _lib._sel_URL_resourceDataDidBecomeAvailable_1,
        sender?._id ?? ffi.nullptr,
        newBytes?._id ?? ffi.nullptr);
  }

  void URLResourceDidFinishLoading_(NSURL? sender) {
    return _lib._objc_msgSend_142(_id, _lib._sel_URLResourceDidFinishLoading_1,
        sender?._id ?? ffi.nullptr);
  }

  void URLResourceDidCancelLoading_(NSURL? sender) {
    return _lib._objc_msgSend_142(_id, _lib._sel_URLResourceDidCancelLoading_1,
        sender?._id ?? ffi.nullptr);
  }

  void URL_resourceDidFailLoadingWithReason_(NSURL? sender, NSString? reason) {
    return _lib._objc_msgSend_143(
        _id,
        _lib._sel_URL_resourceDidFailLoadingWithReason_1,
        sender?._id ?? ffi.nullptr,
        reason?._id ?? ffi.nullptr);
  }

  /// Given that an error alert has been presented document-modally to the user, and the user has chosen one of the error's recovery options, attempt recovery from the error, and send the selected message to the specified delegate. The option index is an index into the error's array of localized recovery options. The method selected by didRecoverSelector must have the same signature as:
  ///
  /// - (void)didPresentErrorWithRecovery:(BOOL)didRecover contextInfo:(void *)contextInfo;
  ///
  /// The value passed for didRecover must be YES if error recovery was completely successful, NO otherwise.
  void
      attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo_(
          NSError? error,
          int recoveryOptionIndex,
          NSObject delegate,
          ffi.Pointer<ObjCSel> didRecoverSelector,
          ffi.Pointer<ffi.Void> contextInfo) {
    return _lib._objc_msgSend_144(
        _id,
        _lib._sel_attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo_1,
        error?._id ?? ffi.nullptr,
        recoveryOptionIndex,
        delegate._id,
        didRecoverSelector,
        contextInfo);
  }

  /// Given that an error alert has been presented applicaton-modally to the user, and the user has chosen one of the error's recovery options, attempt recovery from the error, and return YES if error recovery was completely successful, NO otherwise. The recovery option index is an index into the error's array of localized recovery options.
  bool attemptRecoveryFromError_optionIndex_(
      NSError? error, int recoveryOptionIndex) {
    return _lib._objc_msgSend_145(
        _id,
        _lib._sel_attemptRecoveryFromError_optionIndex_1,
        error?._id ?? ffi.nullptr,
        recoveryOptionIndex);
  }
}

typedef instancetype = ffi.Pointer<ObjCObject>;

class _NSZone extends ffi.Opaque {}

class Protocol extends _ObjCWrapper {
  Protocol._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [Protocol] that points to the same underlying object as [other].
  static Protocol castFrom<T extends _ObjCWrapper>(T other) {
    return Protocol._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [Protocol] that wraps the given raw object pointer.
  static Protocol castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return Protocol._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [Protocol].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_Protocol1);
  }
}

typedef IMP = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;

class NSInvocation extends _ObjCWrapper {
  NSInvocation._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSInvocation] that points to the same underlying object as [other].
  static NSInvocation castFrom<T extends _ObjCWrapper>(T other) {
    return NSInvocation._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSInvocation] that wraps the given raw object pointer.
  static NSInvocation castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSInvocation._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSInvocation].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSInvocation1);
  }
}

class NSMethodSignature extends _ObjCWrapper {
  NSMethodSignature._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSMethodSignature] that points to the same underlying object as [other].
  static NSMethodSignature castFrom<T extends _ObjCWrapper>(T other) {
    return NSMethodSignature._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSMethodSignature] that wraps the given raw object pointer.
  static NSMethodSignature castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSMethodSignature._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSMethodSignature].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSMethodSignature1);
  }
}

typedef NSUInteger = ffi.UnsignedLong;

class NSString extends NSObject {
  NSString._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSString] that points to the same underlying object as [other].
  static NSString castFrom<T extends _ObjCWrapper>(T other) {
    return NSString._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSString] that wraps the given raw object pointer.
  static NSString castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSString._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSString].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSString1);
  }

  factory NSString(NativeCupertinoHttp _lib, String str) {
    final cstr = str.toNativeUtf8();
    final nsstr = stringWithCString_encoding_(_lib, cstr.cast(), 4 /* UTF8 */);
    pkg_ffi.calloc.free(cstr);
    return nsstr;
  }

  @override
  String toString() => (UTF8String).cast<pkg_ffi.Utf8>().toDartString();

  int get length {
    return _lib._objc_msgSend_12(_id, _lib._sel_length1);
  }

  int characterAtIndex_(int index) {
    return _lib._objc_msgSend_13(_id, _lib._sel_characterAtIndex_1, index);
  }

  @override
  NSString init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString initWithCoder_(NSCoder? coder) {
    final _ret = _lib._objc_msgSend_14(
        _id, _lib._sel_initWithCoder_1, coder?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters. UTF-8 encoding is used to determine the correct percent encoded characters. Entire URL strings cannot be percent-encoded. This method is intended to percent-encode an URL component or subcomponent string, NOT the entire URL string. Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.
  NSString stringByAddingPercentEncodingWithAllowedCharacters_(
      NSCharacterSet? allowedCharacters) {
    final _ret = _lib._objc_msgSend_138(
        _id,
        _lib._sel_stringByAddingPercentEncodingWithAllowedCharacters_1,
        allowedCharacters?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a new string made from the receiver by replacing all percent encoded sequences with the matching UTF-8 characters.
  NSString? get stringByRemovingPercentEncoding {
    final _ret =
        _lib._objc_msgSend_19(_id, _lib._sel_stringByRemovingPercentEncoding1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString stringByAddingPercentEscapesUsingEncoding_(int enc) {
    final _ret = _lib._objc_msgSend_139(
        _id, _lib._sel_stringByAddingPercentEscapesUsingEncoding_1, enc);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString stringByReplacingPercentEscapesUsingEncoding_(int enc) {
    final _ret = _lib._objc_msgSend_139(
        _id, _lib._sel_stringByReplacingPercentEscapesUsingEncoding_1, enc);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSString stringWithCString_encoding_(
      NativeCupertinoHttp _lib, ffi.Pointer<ffi.Char> cString, int enc) {
    final _ret = _lib._objc_msgSend_140(_lib._class_NSString1,
        _lib._sel_stringWithCString_encoding_1, cString, enc);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  ffi.Pointer<ffi.Char> get UTF8String {
    return _lib._objc_msgSend_40(_id, _lib._sel_UTF8String1);
  }

  static NSString new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSString1, _lib._sel_new1);
    return NSString._(_ret, _lib, retain: false, release: true);
  }

  static NSString alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSString1, _lib._sel_alloc1);
    return NSString._(_ret, _lib, retain: false, release: true);
  }
}

extension StringToNSString on String {
  NSString toNSString(NativeCupertinoHttp lib) => NSString(lib, this);
}

typedef unichar = ffi.UnsignedShort;

class NSCoder extends _ObjCWrapper {
  NSCoder._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSCoder] that points to the same underlying object as [other].
  static NSCoder castFrom<T extends _ObjCWrapper>(T other) {
    return NSCoder._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSCoder] that wraps the given raw object pointer.
  static NSCoder castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSCoder._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSCoder].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSCoder1);
  }
}

class NSCharacterSet extends NSObject {
  NSCharacterSet._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSCharacterSet] that points to the same underlying object as [other].
  static NSCharacterSet castFrom<T extends _ObjCWrapper>(T other) {
    return NSCharacterSet._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSCharacterSet] that wraps the given raw object pointer.
  static NSCharacterSet castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSCharacterSet._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSCharacterSet].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSCharacterSet1);
  }

  static NSCharacterSet? getControlCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_controlCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getWhitespaceCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_whitespaceCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getWhitespaceAndNewlineCharacterSet(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(_lib._class_NSCharacterSet1,
        _lib._sel_whitespaceAndNewlineCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getDecimalDigitCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_decimalDigitCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getLetterCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_letterCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getLowercaseLetterCharacterSet(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_lowercaseLetterCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getUppercaseLetterCharacterSet(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_uppercaseLetterCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getNonBaseCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_nonBaseCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getAlphanumericCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_alphanumericCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getDecomposableCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_decomposableCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getIllegalCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_illegalCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getPunctuationCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_punctuationCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getCapitalizedLetterCharacterSet(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_capitalizedLetterCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getSymbolCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_symbolCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet? getNewlineCharacterSet(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_newlineCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: false, release: true);
  }

  static NSCharacterSet characterSetWithRange_(
      NativeCupertinoHttp _lib, NSRange aRange) {
    final _ret = _lib._objc_msgSend_16(
        _lib._class_NSCharacterSet1, _lib._sel_characterSetWithRange_1, aRange);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet characterSetWithCharactersInString_(
      NativeCupertinoHttp _lib, NSString? aString) {
    final _ret = _lib._objc_msgSend_17(
        _lib._class_NSCharacterSet1,
        _lib._sel_characterSetWithCharactersInString_1,
        aString?._id ?? ffi.nullptr);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet characterSetWithBitmapRepresentation_(
      NativeCupertinoHttp _lib, NSData? data) {
    final _ret = _lib._objc_msgSend_133(
        _lib._class_NSCharacterSet1,
        _lib._sel_characterSetWithBitmapRepresentation_1,
        data?._id ?? ffi.nullptr);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet characterSetWithContentsOfFile_(
      NativeCupertinoHttp _lib, NSString? fName) {
    final _ret = _lib._objc_msgSend_17(_lib._class_NSCharacterSet1,
        _lib._sel_characterSetWithContentsOfFile_1, fName?._id ?? ffi.nullptr);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  NSCharacterSet initWithCoder_(NSCoder? coder) {
    final _ret = _lib._objc_msgSend_14(
        _id, _lib._sel_initWithCoder_1, coder?._id ?? ffi.nullptr);
    return NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  bool characterIsMember_(int aCharacter) {
    return _lib._objc_msgSend_134(
        _id, _lib._sel_characterIsMember_1, aCharacter);
  }

  NSData? get bitmapRepresentation {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_bitmapRepresentation1);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  NSCharacterSet? get invertedSet {
    final _ret = _lib._objc_msgSend_15(_id, _lib._sel_invertedSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  bool longCharacterIsMember_(int theLongChar) {
    return _lib._objc_msgSend_135(
        _id, _lib._sel_longCharacterIsMember_1, theLongChar);
  }

  bool isSupersetOfSet_(NSCharacterSet? theOtherSet) {
    return _lib._objc_msgSend_136(
        _id, _lib._sel_isSupersetOfSet_1, theOtherSet?._id ?? ffi.nullptr);
  }

  bool hasMemberInPlane_(int thePlane) {
    return _lib._objc_msgSend_137(_id, _lib._sel_hasMemberInPlane_1, thePlane);
  }

  /// Returns a character set containing the characters allowed in an URL's user subcomponent.
  static NSCharacterSet? getURLUserAllowedCharacterSet(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_URLUserAllowedCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in an URL's password subcomponent.
  static NSCharacterSet? getURLPasswordAllowedCharacterSet(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_URLPasswordAllowedCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in an URL's host subcomponent.
  static NSCharacterSet? getURLHostAllowedCharacterSet(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_URLHostAllowedCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in an URL's path component. ';' is a legal path character, but it is recommended that it be percent-encoded for best compatibility with NSURL (-stringByAddingPercentEncodingWithAllowedCharacters: will percent-encode any ';' characters if you pass the URLPathAllowedCharacterSet).
  static NSCharacterSet? getURLPathAllowedCharacterSet(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_URLPathAllowedCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in an URL's query component.
  static NSCharacterSet? getURLQueryAllowedCharacterSet(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_URLQueryAllowedCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in an URL's fragment component.
  static NSCharacterSet? getURLFragmentAllowedCharacterSet(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_15(
        _lib._class_NSCharacterSet1, _lib._sel_URLFragmentAllowedCharacterSet1);
    return _ret.address == 0
        ? null
        : NSCharacterSet._(_ret, _lib, retain: true, release: true);
  }

  static NSCharacterSet new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSCharacterSet1, _lib._sel_new1);
    return NSCharacterSet._(_ret, _lib, retain: false, release: true);
  }

  static NSCharacterSet alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSCharacterSet1, _lib._sel_alloc1);
    return NSCharacterSet._(_ret, _lib, retain: false, release: true);
  }
}

typedef NSRange = _NSRange;

class _NSRange extends ffi.Struct {
  @NSUInteger()
  external int location;

  @NSUInteger()
  external int length;
}

/// Immutable Data
class NSData extends NSObject {
  NSData._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSData] that points to the same underlying object as [other].
  static NSData castFrom<T extends _ObjCWrapper>(T other) {
    return NSData._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSData] that wraps the given raw object pointer.
  static NSData castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSData._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSData].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSData1);
  }

  int get length {
    return _lib._objc_msgSend_12(_id, _lib._sel_length1);
  }

  /// The -bytes method returns a pointer to a contiguous region of memory managed by the receiver.
  /// If the regions of memory represented by the receiver are already contiguous, it does so in O(1) time, otherwise it may take longer
  /// Using -enumerateByteRangesUsingBlock: will be efficient for both contiguous and discontiguous data.
  ffi.Pointer<ffi.Void> get bytes {
    return _lib._objc_msgSend_18(_id, _lib._sel_bytes1);
  }

  NSString? get description {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_description1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  void getBytes_length_(ffi.Pointer<ffi.Void> buffer, int length) {
    return _lib._objc_msgSend_20(
        _id, _lib._sel_getBytes_length_1, buffer, length);
  }

  void getBytes_range_(ffi.Pointer<ffi.Void> buffer, NSRange range) {
    return _lib._objc_msgSend_21(
        _id, _lib._sel_getBytes_range_1, buffer, range);
  }

  bool isEqualToData_(NSData? other) {
    return _lib._objc_msgSend_22(
        _id, _lib._sel_isEqualToData_1, other?._id ?? ffi.nullptr);
  }

  NSData subdataWithRange_(NSRange range) {
    final _ret =
        _lib._objc_msgSend_23(_id, _lib._sel_subdataWithRange_1, range);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  bool writeToFile_atomically_(NSString? path, bool useAuxiliaryFile) {
    return _lib._objc_msgSend_24(_id, _lib._sel_writeToFile_atomically_1,
        path?._id ?? ffi.nullptr, useAuxiliaryFile);
  }

  /// the atomically flag is ignored if the url is not of a type the supports atomic writes
  bool writeToURL_atomically_(NSURL? url, bool atomically) {
    return _lib._objc_msgSend_79(_id, _lib._sel_writeToURL_atomically_1,
        url?._id ?? ffi.nullptr, atomically);
  }

  bool writeToFile_options_error_(NSString? path, int writeOptionsMask,
      ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr) {
    return _lib._objc_msgSend_117(_id, _lib._sel_writeToFile_options_error_1,
        path?._id ?? ffi.nullptr, writeOptionsMask, errorPtr);
  }

  bool writeToURL_options_error_(NSURL? url, int writeOptionsMask,
      ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr) {
    return _lib._objc_msgSend_118(_id, _lib._sel_writeToURL_options_error_1,
        url?._id ?? ffi.nullptr, writeOptionsMask, errorPtr);
  }

  NSRange rangeOfData_options_range_(
      NSData? dataToFind, int mask, NSRange searchRange) {
    return _lib._objc_msgSend_119(_id, _lib._sel_rangeOfData_options_range_1,
        dataToFind?._id ?? ffi.nullptr, mask, searchRange);
  }

  /// 'block' is called once for each contiguous region of memory in the receiver (once total for contiguous NSDatas), until either all bytes have been enumerated, or the 'stop' parameter is set to YES.
  void enumerateByteRangesUsingBlock_(ObjCBlock1 block) {
    return _lib._objc_msgSend_120(
        _id, _lib._sel_enumerateByteRangesUsingBlock_1, block._impl);
  }

  static NSData data(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSData1, _lib._sel_data1);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  static NSData dataWithBytes_length_(
      NativeCupertinoHttp _lib, ffi.Pointer<ffi.Void> bytes, int length) {
    final _ret = _lib._objc_msgSend_121(
        _lib._class_NSData1, _lib._sel_dataWithBytes_length_1, bytes, length);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  static NSData dataWithBytesNoCopy_length_(
      NativeCupertinoHttp _lib, ffi.Pointer<ffi.Void> bytes, int length) {
    final _ret = _lib._objc_msgSend_121(_lib._class_NSData1,
        _lib._sel_dataWithBytesNoCopy_length_1, bytes, length);
    return NSData._(_ret, _lib, retain: false, release: true);
  }

  static NSData dataWithBytesNoCopy_length_freeWhenDone_(
      NativeCupertinoHttp _lib,
      ffi.Pointer<ffi.Void> bytes,
      int length,
      bool b) {
    final _ret = _lib._objc_msgSend_122(_lib._class_NSData1,
        _lib._sel_dataWithBytesNoCopy_length_freeWhenDone_1, bytes, length, b);
    return NSData._(_ret, _lib, retain: false, release: true);
  }

  static NSData dataWithContentsOfFile_options_error_(
      NativeCupertinoHttp _lib,
      NSString? path,
      int readOptionsMask,
      ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr) {
    final _ret = _lib._objc_msgSend_123(
        _lib._class_NSData1,
        _lib._sel_dataWithContentsOfFile_options_error_1,
        path?._id ?? ffi.nullptr,
        readOptionsMask,
        errorPtr);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  static NSData dataWithContentsOfURL_options_error_(
      NativeCupertinoHttp _lib,
      NSURL? url,
      int readOptionsMask,
      ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr) {
    final _ret = _lib._objc_msgSend_124(
        _lib._class_NSData1,
        _lib._sel_dataWithContentsOfURL_options_error_1,
        url?._id ?? ffi.nullptr,
        readOptionsMask,
        errorPtr);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  static NSData dataWithContentsOfFile_(
      NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_29(_lib._class_NSData1,
        _lib._sel_dataWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  static NSData dataWithContentsOfURL_(NativeCupertinoHttp _lib, NSURL? url) {
    final _ret = _lib._objc_msgSend_110(_lib._class_NSData1,
        _lib._sel_dataWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSData initWithBytes_length_(ffi.Pointer<ffi.Void> bytes, int length) {
    final _ret = _lib._objc_msgSend_121(
        _id, _lib._sel_initWithBytes_length_1, bytes, length);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSData initWithBytesNoCopy_length_(ffi.Pointer<ffi.Void> bytes, int length) {
    final _ret = _lib._objc_msgSend_121(
        _id, _lib._sel_initWithBytesNoCopy_length_1, bytes, length);
    return NSData._(_ret, _lib, retain: false, release: true);
  }

  NSData initWithBytesNoCopy_length_freeWhenDone_(
      ffi.Pointer<ffi.Void> bytes, int length, bool b) {
    final _ret = _lib._objc_msgSend_122(_id,
        _lib._sel_initWithBytesNoCopy_length_freeWhenDone_1, bytes, length, b);
    return NSData._(_ret, _lib, retain: false, release: true);
  }

  NSData initWithBytesNoCopy_length_deallocator_(
      ffi.Pointer<ffi.Void> bytes, int length, ObjCBlock2 deallocator) {
    final _ret = _lib._objc_msgSend_125(
        _id,
        _lib._sel_initWithBytesNoCopy_length_deallocator_1,
        bytes,
        length,
        deallocator._impl);
    return NSData._(_ret, _lib, retain: false, release: true);
  }

  NSData initWithContentsOfFile_options_error_(NSString? path,
      int readOptionsMask, ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr) {
    final _ret = _lib._objc_msgSend_123(
        _id,
        _lib._sel_initWithContentsOfFile_options_error_1,
        path?._id ?? ffi.nullptr,
        readOptionsMask,
        errorPtr);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSData initWithContentsOfURL_options_error_(NSURL? url, int readOptionsMask,
      ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr) {
    final _ret = _lib._objc_msgSend_124(
        _id,
        _lib._sel_initWithContentsOfURL_options_error_1,
        url?._id ?? ffi.nullptr,
        readOptionsMask,
        errorPtr);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSData initWithContentsOfFile_(NSString? path) {
    final _ret = _lib._objc_msgSend_29(
        _id, _lib._sel_initWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSData initWithContentsOfURL_(NSURL? url) {
    final _ret = _lib._objc_msgSend_110(
        _id, _lib._sel_initWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSData initWithData_(NSData? data) {
    final _ret = _lib._objc_msgSend_126(
        _id, _lib._sel_initWithData_1, data?._id ?? ffi.nullptr);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  static NSData dataWithData_(NativeCupertinoHttp _lib, NSData? data) {
    final _ret = _lib._objc_msgSend_126(_lib._class_NSData1,
        _lib._sel_dataWithData_1, data?._id ?? ffi.nullptr);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  /// Create an NSData from a Base-64 encoded NSString using the given options. By default, returns nil when the input is not recognized as valid Base-64.
  NSData initWithBase64EncodedString_options_(
      NSString? base64String, int options) {
    final _ret = _lib._objc_msgSend_127(
        _id,
        _lib._sel_initWithBase64EncodedString_options_1,
        base64String?._id ?? ffi.nullptr,
        options);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  /// Create a Base-64 encoded NSString from the receiver's contents using the given options.
  NSString base64EncodedStringWithOptions_(int options) {
    final _ret = _lib._objc_msgSend_128(
        _id, _lib._sel_base64EncodedStringWithOptions_1, options);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Create an NSData from a Base-64, UTF-8 encoded NSData. By default, returns nil when the input is not recognized as valid Base-64.
  NSData initWithBase64EncodedData_options_(NSData? base64Data, int options) {
    final _ret = _lib._objc_msgSend_129(
        _id,
        _lib._sel_initWithBase64EncodedData_options_1,
        base64Data?._id ?? ffi.nullptr,
        options);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  /// Create a Base-64, UTF-8 encoded NSData from the receiver's contents using the given options.
  NSData base64EncodedDataWithOptions_(int options) {
    final _ret = _lib._objc_msgSend_130(
        _id, _lib._sel_base64EncodedDataWithOptions_1, options);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  /// These methods return a compressed or decompressed version of the receiver using the specified algorithm.
  NSData decompressedDataUsingAlgorithm_error_(
      int algorithm, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_131(_id,
        _lib._sel_decompressedDataUsingAlgorithm_error_1, algorithm, error);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSData compressedDataUsingAlgorithm_error_(
      int algorithm, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_131(
        _id, _lib._sel_compressedDataUsingAlgorithm_error_1, algorithm, error);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  void getBytes_(ffi.Pointer<ffi.Void> buffer) {
    return _lib._objc_msgSend_132(_id, _lib._sel_getBytes_1, buffer);
  }

  static NSObject dataWithContentsOfMappedFile_(
      NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_29(_lib._class_NSData1,
        _lib._sel_dataWithContentsOfMappedFile_1, path?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSObject initWithContentsOfMappedFile_(NSString? path) {
    final _ret = _lib._objc_msgSend_29(_id,
        _lib._sel_initWithContentsOfMappedFile_1, path?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// These methods first appeared in NSData.h on OS X 10.9 and iOS 7.0. They are deprecated in the same releases in favor of the methods in the NSDataBase64Encoding category. However, these methods have existed for several releases, so they may be used for applications targeting releases prior to OS X 10.9 and iOS 7.0.
  NSObject initWithBase64Encoding_(NSString? base64String) {
    final _ret = _lib._objc_msgSend_29(_id, _lib._sel_initWithBase64Encoding_1,
        base64String?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSString base64Encoding() {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_base64Encoding1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSData new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSData1, _lib._sel_new1);
    return NSData._(_ret, _lib, retain: false, release: true);
  }

  static NSData alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSData1, _lib._sel_alloc1);
    return NSData._(_ret, _lib, retain: false, release: true);
  }
}

class NSURL extends NSObject {
  NSURL._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURL] that points to the same underlying object as [other].
  static NSURL castFrom<T extends _ObjCWrapper>(T other) {
    return NSURL._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURL] that wraps the given raw object pointer.
  static NSURL castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURL._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURL].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURL1);
  }

  /// this call percent-encodes both the host and path, so this cannot be used to set a username/password or port in the hostname part or with a IPv6 '[...]' type address. NSURLComponents handles IPv6 addresses correctly.
  NSURL initWithScheme_host_path_(
      NSString? scheme, NSString? host, NSString? path) {
    final _ret = _lib._objc_msgSend_25(
        _id,
        _lib._sel_initWithScheme_host_path_1,
        scheme?._id ?? ffi.nullptr,
        host?._id ?? ffi.nullptr,
        path?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes a newly created file NSURL referencing the local file or directory at path, relative to a base URL.
  NSURL initFileURLWithPath_isDirectory_relativeToURL_(
      NSString? path, bool isDir, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_26(
        _id,
        _lib._sel_initFileURLWithPath_isDirectory_relativeToURL_1,
        path?._id ?? ffi.nullptr,
        isDir,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Better to use initFileURLWithPath:isDirectory:relativeToURL: if you know if the path is a directory vs non-directory, as it saves an I/O.
  NSURL initFileURLWithPath_relativeToURL_(NSString? path, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_27(
        _id,
        _lib._sel_initFileURLWithPath_relativeToURL_1,
        path?._id ?? ffi.nullptr,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL initFileURLWithPath_isDirectory_(NSString? path, bool isDir) {
    final _ret = _lib._objc_msgSend_28(
        _id,
        _lib._sel_initFileURLWithPath_isDirectory_1,
        path?._id ?? ffi.nullptr,
        isDir);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Better to use initFileURLWithPath:isDirectory: if you know if the path is a directory vs non-directory, as it saves an i/o.
  NSURL initFileURLWithPath_(NSString? path) {
    final _ret = _lib._objc_msgSend_29(
        _id, _lib._sel_initFileURLWithPath_1, path?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created file NSURL referencing the local file or directory at path, relative to a base URL.
  static NSURL fileURLWithPath_isDirectory_relativeToURL_(
      NativeCupertinoHttp _lib, NSString? path, bool isDir, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_30(
        _lib._class_NSURL1,
        _lib._sel_fileURLWithPath_isDirectory_relativeToURL_1,
        path?._id ?? ffi.nullptr,
        isDir,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Better to use fileURLWithPath:isDirectory:relativeToURL: if you know if the path is a directory vs non-directory, as it saves an I/O.
  static NSURL fileURLWithPath_relativeToURL_(
      NativeCupertinoHttp _lib, NSString? path, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_31(
        _lib._class_NSURL1,
        _lib._sel_fileURLWithPath_relativeToURL_1,
        path?._id ?? ffi.nullptr,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  static NSURL fileURLWithPath_isDirectory_(
      NativeCupertinoHttp _lib, NSString? path, bool isDir) {
    final _ret = _lib._objc_msgSend_32(
        _lib._class_NSURL1,
        _lib._sel_fileURLWithPath_isDirectory_1,
        path?._id ?? ffi.nullptr,
        isDir);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Better to use fileURLWithPath:isDirectory: if you know if the path is a directory vs non-directory, as it saves an i/o.
  static NSURL fileURLWithPath_(NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_33(_lib._class_NSURL1,
        _lib._sel_fileURLWithPath_1, path?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes a newly created URL referencing the local file or directory at the file system representation of the path. File system representation is a null-terminated C string with canonical UTF-8 encoding.
  NSURL initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL_(
      ffi.Pointer<ffi.Char> path, bool isDir, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_34(
        _id,
        _lib._sel_initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL_1,
        path,
        isDir,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created URL referencing the local file or directory at the file system representation of the path. File system representation is a null-terminated C string with canonical UTF-8 encoding.
  static NSURL fileURLWithFileSystemRepresentation_isDirectory_relativeToURL_(
      NativeCupertinoHttp _lib,
      ffi.Pointer<ffi.Char> path,
      bool isDir,
      NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_35(
        _lib._class_NSURL1,
        _lib._sel_fileURLWithFileSystemRepresentation_isDirectory_relativeToURL_1,
        path,
        isDir,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// These methods expect their string arguments to contain any percent escape codes that are necessary. It is an error for URLString to be nil.
  NSURL initWithString_(NSString? URLString) {
    final _ret = _lib._objc_msgSend_29(
        _id, _lib._sel_initWithString_1, URLString?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL initWithString_relativeToURL_(NSString? URLString, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_27(
        _id,
        _lib._sel_initWithString_relativeToURL_1,
        URLString?._id ?? ffi.nullptr,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  static NSURL URLWithString_(NativeCupertinoHttp _lib, NSString? URLString) {
    final _ret = _lib._objc_msgSend_29(_lib._class_NSURL1,
        _lib._sel_URLWithString_1, URLString?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  static NSURL URLWithString_relativeToURL_(
      NativeCupertinoHttp _lib, NSString? URLString, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_27(
        _lib._class_NSURL1,
        _lib._sel_URLWithString_relativeToURL_1,
        URLString?._id ?? ffi.nullptr,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes a newly created NSURL using the contents of the given data, relative to a base URL. If the data representation is not a legal URL string as ASCII bytes, the URL object may not behave as expected.
  NSURL initWithDataRepresentation_relativeToURL_(
      NSData? data, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_36(
        _id,
        _lib._sel_initWithDataRepresentation_relativeToURL_1,
        data?._id ?? ffi.nullptr,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created NSURL using the contents of the given data, relative to a base URL. If the data representation is not a legal URL string as ASCII bytes, the URL object may not behave as expected.
  static NSURL URLWithDataRepresentation_relativeToURL_(
      NativeCupertinoHttp _lib, NSData? data, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_37(
        _lib._class_NSURL1,
        _lib._sel_URLWithDataRepresentation_relativeToURL_1,
        data?._id ?? ffi.nullptr,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes a newly created absolute NSURL using the contents of the given data, relative to a base URL. If the data representation is not a legal URL string as ASCII bytes, the URL object may not behave as expected.
  NSURL initAbsoluteURLWithDataRepresentation_relativeToURL_(
      NSData? data, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_36(
        _id,
        _lib._sel_initAbsoluteURLWithDataRepresentation_relativeToURL_1,
        data?._id ?? ffi.nullptr,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created absolute NSURL using the contents of the given data, relative to a base URL. If the data representation is not a legal URL string as ASCII bytes, the URL object may not behave as expected.
  static NSURL absoluteURLWithDataRepresentation_relativeToURL_(
      NativeCupertinoHttp _lib, NSData? data, NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_37(
        _lib._class_NSURL1,
        _lib._sel_absoluteURLWithDataRepresentation_relativeToURL_1,
        data?._id ?? ffi.nullptr,
        baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns the data representation of the URL's relativeString. If the URL was initialized with -initWithData:relativeToURL:, the data representation returned are the same bytes as those used at initialization; otherwise, the data representation returned are the bytes of the relativeString encoded with NSUTF8StringEncoding.
  NSData? get dataRepresentation {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_dataRepresentation1);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  NSString? get absoluteString {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_absoluteString1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// The relative portion of a URL.  If baseURL is nil, or if the receiver is itself absolute, this is the same as absoluteString
  NSString? get relativeString {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_relativeString1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// may be nil.
  NSURL? get baseURL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_baseURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// if the receiver is itself absolute, this will return self.
  NSURL? get absoluteURL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_absoluteURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Any URL is composed of these two basic pieces.  The full URL would be the concatenation of [myURL scheme], ':', [myURL resourceSpecifier]
  NSString? get scheme {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_scheme1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get resourceSpecifier {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_resourceSpecifier1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// If the URL conforms to rfc 1808 (the most common form of URL), the following accessors will return the various components; otherwise they return nil.  The litmus test for conformance is as recommended in RFC 1808 - whether the first two characters of resourceSpecifier is @"//".  In all cases, they return the component's value after resolving the receiver against its base URL.
  NSString? get host {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_host1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSNumber? get port {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_port1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSString? get user {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_user1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get password {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_password1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get path {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_path1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get fragment {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_fragment1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get parameterString {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_parameterString1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get query {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_query1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// The same as path if baseURL is nil
  NSString? get relativePath {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_relativePath1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Determines if a given URL string's path represents a directory (i.e. the path component in the URL string ends with a '/' character). This does not check the resource the URL refers to.
  bool get hasDirectoryPath {
    return _lib._objc_msgSend_11(_id, _lib._sel_hasDirectoryPath1);
  }

  /// Returns the URL's path in file system representation. File system representation is a null-terminated C string with canonical UTF-8 encoding.
  bool getFileSystemRepresentation_maxLength_(
      ffi.Pointer<ffi.Char> buffer, int maxBufferLength) {
    return _lib._objc_msgSend_70(
        _id,
        _lib._sel_getFileSystemRepresentation_maxLength_1,
        buffer,
        maxBufferLength);
  }

  /// Returns the URL's path in file system representation. File system representation is a null-terminated C string with canonical UTF-8 encoding. The returned C string will be automatically freed just as a returned object would be released; your code should copy the representation or use getFileSystemRepresentation:maxLength: if it needs to store the representation outside of the autorelease context in which the representation is created.
  ffi.Pointer<ffi.Char> get fileSystemRepresentation {
    return _lib._objc_msgSend_40(_id, _lib._sel_fileSystemRepresentation1);
  }

  /// Whether the scheme is file:; if [myURL isFileURL] is YES, then [myURL path] is suitable for input into NSFileManager or NSPathUtilities.
  bool get fileURL {
    return _lib._objc_msgSend_11(_id, _lib._sel_isFileURL1);
  }

  NSURL? get standardizedURL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_standardizedURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns whether the URL's resource exists and is reachable. This method synchronously checks if the resource's backing store is reachable. Checking reachability is appropriate when making decisions that do not require other immediate operations on the resource, e.g. periodic maintenance of UI state that depends on the existence of a specific document. When performing operations such as opening a file or copying resource properties, it is more efficient to simply try the operation and handle failures. If this method returns NO, the optional error is populated. This method is currently applicable only to URLs for file system resources. For other URL types, NO is returned. Symbol is present in iOS 4, but performs no operation.
  bool checkResourceIsReachableAndReturnError_(
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_92(
        _id, _lib._sel_checkResourceIsReachableAndReturnError_1, error);
  }

  /// Returns whether the URL is a file reference URL. Symbol is present in iOS 4, but performs no operation.
  bool isFileReferenceURL() {
    return _lib._objc_msgSend_11(_id, _lib._sel_isFileReferenceURL1);
  }

  /// Returns a file reference URL that refers to the same resource as a specified file URL. File reference URLs use a URL path syntax that identifies a file system object by reference, not by path. This form of file URL remains valid when the file system path of the URL’s underlying resource changes. An error will occur if the url parameter is not a file URL. File reference URLs cannot be created to file system objects which do not exist or are not reachable. In some areas of the file system hierarchy, file reference URLs cannot be generated to the leaf node of the URL path. A file reference URL's path should never be persistently stored because is not valid across system restarts, and across remounts of volumes -- if you want to create a persistent reference to a file system object, use a bookmark (see -bookmarkDataWithOptions:includingResourceValuesForKeys:relativeToURL:error:). Symbol is present in iOS 4, but performs no operation.
  NSURL fileReferenceURL() {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_fileReferenceURL1);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a file path URL that refers to the same resource as a specified URL. File path URLs use a file system style path. An error will occur if the url parameter is not a file URL. A file reference URL's resource must exist and be reachable to be converted to a file path URL. Symbol is present in iOS 4, but performs no operation.
  NSURL? get filePathURL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_filePathURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns the resource value identified by a given resource key. This method first checks if the URL object already caches the resource value. If so, it returns the cached resource value to the caller. If not, then this method synchronously obtains the resource value from the backing store, adds the resource value to the URL object's cache, and returns the resource value to the caller. The type of the resource value varies by resource property (see resource key definitions). If this method returns YES and value is populated with nil, it means the resource property is not available for the specified resource and no errors occurred when determining the resource property was not available. If this method returns NO, the optional error is populated. This method is currently applicable only to URLs for file system resources. Symbol is present in iOS 4, but performs no operation.
  bool getResourceValue_forKey_error_(
      ffi.Pointer<ffi.Pointer<ObjCObject>> value,
      NSURLResourceKey key,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_93(
        _id, _lib._sel_getResourceValue_forKey_error_1, value, key, error);
  }

  /// Returns the resource values identified by specified array of resource keys. This method first checks if the URL object already caches the resource values. If so, it returns the cached resource values to the caller. If not, then this method synchronously obtains the resource values from the backing store, adds the resource values to the URL object's cache, and returns the resource values to the caller. The type of the resource values vary by property (see resource key definitions). If the result dictionary does not contain a resource value for one or more of the requested resource keys, it means those resource properties are not available for the specified resource and no errors occurred when determining those resource properties were not available. If this method returns NULL, the optional error is populated. This method is currently applicable only to URLs for file system resources. Symbol is present in iOS 4, but performs no operation.
  NSDictionary resourceValuesForKeys_error_(
      NSArray? keys, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_94(
        _id,
        _lib._sel_resourceValuesForKeys_error_1,
        keys?._id ?? ffi.nullptr,
        error);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Sets the resource value identified by a given resource key. This method writes the new resource value out to the backing store. Attempts to set a read-only resource property or to set a resource property not supported by the resource are ignored and are not considered errors. If this method returns NO, the optional error is populated. This method is currently applicable only to URLs for file system resources. Symbol is present in iOS 4, but performs no operation.
  bool setResourceValue_forKey_error_(NSObject value, NSURLResourceKey key,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_95(
        _id, _lib._sel_setResourceValue_forKey_error_1, value._id, key, error);
  }

  /// Sets any number of resource values of a URL's resource. This method writes the new resource values out to the backing store. Attempts to set read-only resource properties or to set resource properties not supported by the resource are ignored and are not considered errors. If an error occurs after some resource properties have been successfully changed, the userInfo dictionary in the returned error contains an array of resource keys that were not set with the key kCFURLKeysOfUnsetValuesKey. The order in which the resource values are set is not defined. If you need to guarantee the order resource values are set, you should make multiple requests to this method or to -setResourceValue:forKey:error: to guarantee the order. If this method returns NO, the optional error is populated. This method is currently applicable only to URLs for file system resources. Symbol is present in iOS 4, but performs no operation.
  bool setResourceValues_error_(
      NSDictionary? keyedValues, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_96(_id, _lib._sel_setResourceValues_error_1,
        keyedValues?._id ?? ffi.nullptr, error);
  }

  /// Removes the cached resource value identified by a given resource value key from the URL object. Removing a cached resource value may remove other cached resource values because some resource values are cached as a set of values, and because some resource values depend on other resource values (temporary resource values have no dependencies). This method is currently applicable only to URLs for file system resources.
  void removeCachedResourceValueForKey_(NSURLResourceKey key) {
    return _lib._objc_msgSend_97(
        _id, _lib._sel_removeCachedResourceValueForKey_1, key);
  }

  /// Removes all cached resource values and all temporary resource values from the URL object. This method is currently applicable only to URLs for file system resources.
  void removeAllCachedResourceValues() {
    return _lib._objc_msgSend_1(_id, _lib._sel_removeAllCachedResourceValues1);
  }

  /// Sets a temporary resource value on the URL object. Temporary resource values are for client use. Temporary resource values exist only in memory and are never written to the resource's backing store. Once set, a temporary resource value can be copied from the URL object with -getResourceValue:forKey:error: or -resourceValuesForKeys:error:. To remove a temporary resource value from the URL object, use -removeCachedResourceValueForKey:. Care should be taken to ensure the key that identifies a temporary resource value is unique and does not conflict with system defined keys (using reverse domain name notation in your temporary resource value keys is recommended). This method is currently applicable only to URLs for file system resources.
  void setTemporaryResourceValue_forKey_(NSObject value, NSURLResourceKey key) {
    return _lib._objc_msgSend_98(
        _id, _lib._sel_setTemporaryResourceValue_forKey_1, value._id, key);
  }

  /// Returns bookmark data for the URL, created with specified options and resource values. If this method returns nil, the optional error is populated.
  NSData
      bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error_(
          int options,
          NSArray? keys,
          NSURL? relativeURL,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_99(
        _id,
        _lib._sel_bookmarkDataWithOptions_includingResourceValuesForKeys_relativeToURL_error_1,
        options,
        keys?._id ?? ffi.nullptr,
        relativeURL?._id ?? ffi.nullptr,
        error);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes a newly created NSURL that refers to a location specified by resolving bookmark data. If this method returns nil, the optional error is populated.
  NSURL
      initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_(
          NSData? bookmarkData,
          int options,
          NSURL? relativeURL,
          ffi.Pointer<ffi.Bool> isStale,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_100(
        _id,
        _lib._sel_initByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_1,
        bookmarkData?._id ?? ffi.nullptr,
        options,
        relativeURL?._id ?? ffi.nullptr,
        isStale,
        error);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Creates and Initializes an NSURL that refers to a location specified by resolving bookmark data. If this method returns nil, the optional error is populated.
  static NSURL
      URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_(
          NativeCupertinoHttp _lib,
          NSData? bookmarkData,
          int options,
          NSURL? relativeURL,
          ffi.Pointer<ffi.Bool> isStale,
          ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_100(
        _lib._class_NSURL1,
        _lib._sel_URLByResolvingBookmarkData_options_relativeToURL_bookmarkDataIsStale_error_1,
        bookmarkData?._id ?? ffi.nullptr,
        options,
        relativeURL?._id ?? ffi.nullptr,
        isStale,
        error);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns the resource values for properties identified by a specified array of keys contained in specified bookmark data. If the result dictionary does not contain a resource value for one or more of the requested resource keys, it means those resource properties are not available in the bookmark data.
  static NSDictionary resourceValuesForKeys_fromBookmarkData_(
      NativeCupertinoHttp _lib, NSArray? keys, NSData? bookmarkData) {
    final _ret = _lib._objc_msgSend_101(
        _lib._class_NSURL1,
        _lib._sel_resourceValuesForKeys_fromBookmarkData_1,
        keys?._id ?? ffi.nullptr,
        bookmarkData?._id ?? ffi.nullptr);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Creates an alias file on disk at a specified location with specified bookmark data. bookmarkData must have been created with the NSURLBookmarkCreationSuitableForBookmarkFile option. bookmarkFileURL must either refer to an existing file (which will be overwritten), or to location in an existing directory. If this method returns NO, the optional error is populated.
  static bool writeBookmarkData_toURL_options_error_(
      NativeCupertinoHttp _lib,
      NSData? bookmarkData,
      NSURL? bookmarkFileURL,
      int options,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_102(
        _lib._class_NSURL1,
        _lib._sel_writeBookmarkData_toURL_options_error_1,
        bookmarkData?._id ?? ffi.nullptr,
        bookmarkFileURL?._id ?? ffi.nullptr,
        options,
        error);
  }

  /// Initializes and returns bookmark data derived from an alias file pointed to by a specified URL. If bookmarkFileURL refers to an alias file created prior to OS X v10.6 that contains Alias Manager information but no bookmark data, this method synthesizes bookmark data for the file. If this method returns nil, the optional error is populated.
  static NSData bookmarkDataWithContentsOfURL_error_(NativeCupertinoHttp _lib,
      NSURL? bookmarkFileURL, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_103(
        _lib._class_NSURL1,
        _lib._sel_bookmarkDataWithContentsOfURL_error_1,
        bookmarkFileURL?._id ?? ffi.nullptr,
        error);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  /// Creates and initializes a NSURL that refers to the location specified by resolving the alias file at url. If the url argument does not refer to an alias file as defined by the NSURLIsAliasFileKey property, the NSURL returned is the same as url argument. This method fails and returns nil if the url argument is unreachable, or if the original file or directory could not be located or is not reachable, or if the original file or directory is on a volume that could not be located or mounted. If this method fails, the optional error is populated. The NSURLBookmarkResolutionWithSecurityScope option is not supported by this method.
  static NSURL URLByResolvingAliasFileAtURL_options_error_(
      NativeCupertinoHttp _lib,
      NSURL? url,
      int options,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_104(
        _lib._class_NSURL1,
        _lib._sel_URLByResolvingAliasFileAtURL_options_error_1,
        url?._id ?? ffi.nullptr,
        options,
        error);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Given a NSURL created by resolving a bookmark data created with security scope, make the resource referenced by the url accessible to the process. When access to this resource is no longer needed the client must call stopAccessingSecurityScopedResource. Each call to startAccessingSecurityScopedResource must be balanced with a call to stopAccessingSecurityScopedResource (Note: this is not reference counted).
  bool startAccessingSecurityScopedResource() {
    return _lib._objc_msgSend_11(
        _id, _lib._sel_startAccessingSecurityScopedResource1);
  }

  /// Revokes the access granted to the url by a prior successful call to startAccessingSecurityScopedResource.
  void stopAccessingSecurityScopedResource() {
    return _lib._objc_msgSend_1(
        _id, _lib._sel_stopAccessingSecurityScopedResource1);
  }

  /// Get resource values from URLs of 'promised' items. A promised item is not guaranteed to have its contents in the file system until you use NSFileCoordinator to perform a coordinated read on its URL, which causes the contents to be downloaded or otherwise generated. Promised item URLs are returned by various APIs, including currently:
  /// - NSMetadataQueryUbiquitousDataScope
  /// - NSMetadataQueryUbiquitousDocumentsScope
  /// - An NSFilePresenter presenting the contents of the directory located by -URLForUbiquitousContainerIdentifier: or a subdirectory thereof
  ///
  /// The following methods behave identically to their similarly named methods above (-getResourceValue:forKey:error:, etc.), except that they allow you to get resource values and check for presence regardless of whether the promised item's contents currently exist at the URL. You must use these APIs instead of the normal NSURL resource value APIs if and only if any of the following are true:
  /// - You are using a URL that you know came directly from one of the above APIs
  /// - You are inside the accessor block of a coordinated read or write that used NSFileCoordinatorReadingImmediatelyAvailableMetadataOnly, NSFileCoordinatorWritingForDeleting, NSFileCoordinatorWritingForMoving, or NSFileCoordinatorWritingContentIndependentMetadataOnly
  ///
  /// Most of the NSURL resource value keys will work with these APIs. However, there are some that are tied to the item's contents that will not work, such as NSURLContentAccessDateKey or NSURLGenerationIdentifierKey. If one of these keys is used, the method will return YES, but the value for the key will be nil.
  bool getPromisedItemResourceValue_forKey_error_(
      ffi.Pointer<ffi.Pointer<ObjCObject>> value,
      NSURLResourceKey key,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_93(
        _id,
        _lib._sel_getPromisedItemResourceValue_forKey_error_1,
        value,
        key,
        error);
  }

  NSDictionary promisedItemResourceValuesForKeys_error_(
      NSArray? keys, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_94(
        _id,
        _lib._sel_promisedItemResourceValuesForKeys_error_1,
        keys?._id ?? ffi.nullptr,
        error);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  bool checkPromisedItemIsReachableAndReturnError_(
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_92(
        _id, _lib._sel_checkPromisedItemIsReachableAndReturnError_1, error);
  }

  /// The following methods work on the path portion of a URL in the same manner that the NSPathUtilities methods on NSString do.
  static NSURL fileURLWithPathComponents_(
      NativeCupertinoHttp _lib, NSArray? components) {
    final _ret = _lib._objc_msgSend_105(_lib._class_NSURL1,
        _lib._sel_fileURLWithPathComponents_1, components?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSArray? get pathComponents {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_pathComponents1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSString? get lastPathComponent {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_lastPathComponent1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get pathExtension {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_pathExtension1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSURL URLByAppendingPathComponent_(NSString? pathComponent) {
    final _ret = _lib._objc_msgSend_33(
        _id,
        _lib._sel_URLByAppendingPathComponent_1,
        pathComponent?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL URLByAppendingPathComponent_isDirectory_(
      NSString? pathComponent, bool isDirectory) {
    final _ret = _lib._objc_msgSend_32(
        _id,
        _lib._sel_URLByAppendingPathComponent_isDirectory_1,
        pathComponent?._id ?? ffi.nullptr,
        isDirectory);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL? get URLByDeletingLastPathComponent {
    final _ret =
        _lib._objc_msgSend_39(_id, _lib._sel_URLByDeletingLastPathComponent1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL URLByAppendingPathExtension_(NSString? pathExtension) {
    final _ret = _lib._objc_msgSend_33(
        _id,
        _lib._sel_URLByAppendingPathExtension_1,
        pathExtension?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL? get URLByDeletingPathExtension {
    final _ret =
        _lib._objc_msgSend_39(_id, _lib._sel_URLByDeletingPathExtension1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// The following methods work only on `file:` scheme URLs; for non-`file:` scheme URLs, these methods return the URL unchanged.
  NSURL? get URLByStandardizingPath {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_URLByStandardizingPath1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  NSURL? get URLByResolvingSymlinksInPath {
    final _ret =
        _lib._objc_msgSend_39(_id, _lib._sel_URLByResolvingSymlinksInPath1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Blocks to load the data if necessary.  If shouldUseCache is YES, then if an equivalent URL has already been loaded and cached, its resource data will be returned immediately.  If shouldUseCache is NO, a new load will be started
  NSData resourceDataUsingCache_(bool shouldUseCache) {
    final _ret = _lib._objc_msgSend_106(
        _id, _lib._sel_resourceDataUsingCache_1, shouldUseCache);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  /// Starts an asynchronous load of the data, registering delegate to receive notification.  Only one such background load can proceed at a time.
  void loadResourceDataNotifyingClient_usingCache_(
      NSObject client, bool shouldUseCache) {
    return _lib._objc_msgSend_107(
        _id,
        _lib._sel_loadResourceDataNotifyingClient_usingCache_1,
        client._id,
        shouldUseCache);
  }

  NSObject propertyForKey_(NSString? propertyKey) {
    final _ret = _lib._objc_msgSend_29(
        _id, _lib._sel_propertyForKey_1, propertyKey?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// These attempt to write the given arguments for the resource specified by the URL; they return success or failure
  bool setResourceData_(NSData? data) {
    return _lib._objc_msgSend_22(
        _id, _lib._sel_setResourceData_1, data?._id ?? ffi.nullptr);
  }

  bool setProperty_forKey_(NSObject property, NSString? propertyKey) {
    return _lib._objc_msgSend_108(_id, _lib._sel_setProperty_forKey_1,
        property._id, propertyKey?._id ?? ffi.nullptr);
  }

  /// Sophisticated clients will want to ask for this, then message the handle directly.  If shouldUseCache is NO, a newly instantiated handle is returned, even if an equivalent URL has been loaded
  NSURLHandle URLHandleUsingCache_(bool shouldUseCache) {
    final _ret = _lib._objc_msgSend_116(
        _id, _lib._sel_URLHandleUsingCache_1, shouldUseCache);
    return NSURLHandle._(_ret, _lib, retain: true, release: true);
  }

  static NSURL new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSURL1, _lib._sel_new1);
    return NSURL._(_ret, _lib, retain: false, release: true);
  }

  static NSURL alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSURL1, _lib._sel_alloc1);
    return NSURL._(_ret, _lib, retain: false, release: true);
  }
}

class NSNumber extends NSValue {
  NSNumber._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSNumber] that points to the same underlying object as [other].
  static NSNumber castFrom<T extends _ObjCWrapper>(T other) {
    return NSNumber._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSNumber] that wraps the given raw object pointer.
  static NSNumber castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSNumber._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSNumber].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSNumber1);
  }

  @override
  NSNumber initWithCoder_(NSCoder? coder) {
    final _ret = _lib._objc_msgSend_14(
        _id, _lib._sel_initWithCoder_1, coder?._id ?? ffi.nullptr);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithChar_(int value) {
    final _ret = _lib._objc_msgSend_42(_id, _lib._sel_initWithChar_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedChar_(int value) {
    final _ret =
        _lib._objc_msgSend_43(_id, _lib._sel_initWithUnsignedChar_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithShort_(int value) {
    final _ret = _lib._objc_msgSend_44(_id, _lib._sel_initWithShort_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedShort_(int value) {
    final _ret =
        _lib._objc_msgSend_45(_id, _lib._sel_initWithUnsignedShort_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithInt_(int value) {
    final _ret = _lib._objc_msgSend_46(_id, _lib._sel_initWithInt_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedInt_(int value) {
    final _ret =
        _lib._objc_msgSend_47(_id, _lib._sel_initWithUnsignedInt_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithLong_(int value) {
    final _ret = _lib._objc_msgSend_48(_id, _lib._sel_initWithLong_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedLong_(int value) {
    final _ret =
        _lib._objc_msgSend_49(_id, _lib._sel_initWithUnsignedLong_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithLongLong_(int value) {
    final _ret =
        _lib._objc_msgSend_50(_id, _lib._sel_initWithLongLong_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedLongLong_(int value) {
    final _ret =
        _lib._objc_msgSend_51(_id, _lib._sel_initWithUnsignedLongLong_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithFloat_(double value) {
    final _ret = _lib._objc_msgSend_52(_id, _lib._sel_initWithFloat_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithDouble_(double value) {
    final _ret = _lib._objc_msgSend_53(_id, _lib._sel_initWithDouble_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithBool_(bool value) {
    final _ret = _lib._objc_msgSend_54(_id, _lib._sel_initWithBool_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithInteger_(int value) {
    final _ret = _lib._objc_msgSend_48(_id, _lib._sel_initWithInteger_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  NSNumber initWithUnsignedInteger_(int value) {
    final _ret =
        _lib._objc_msgSend_49(_id, _lib._sel_initWithUnsignedInteger_1, value);
    return NSNumber._(_ret, _lib, retain: true, release: true);
  }

  int get charValue {
    return _lib._objc_msgSend_55(_id, _lib._sel_charValue1);
  }

  int get unsignedCharValue {
    return _lib._objc_msgSend_56(_id, _lib._sel_unsignedCharValue1);
  }

  int get shortValue {
    return _lib._objc_msgSend_57(_id, _lib._sel_shortValue1);
  }

  int get unsignedShortValue {
    return _lib._objc_msgSend_58(_id, _lib._sel_unsignedShortValue1);
  }

  int get intValue {
    return _lib._objc_msgSend_59(_id, _lib._sel_intValue1);
  }

  int get unsignedIntValue {
    return _lib._objc_msgSend_60(_id, _lib._sel_unsignedIntValue1);
  }

  int get longValue {
    return _lib._objc_msgSend_61(_id, _lib._sel_longValue1);
  }

  int get unsignedLongValue {
    return _lib._objc_msgSend_12(_id, _lib._sel_unsignedLongValue1);
  }

  int get longLongValue {
    return _lib._objc_msgSend_62(_id, _lib._sel_longLongValue1);
  }

  int get unsignedLongLongValue {
    return _lib._objc_msgSend_63(_id, _lib._sel_unsignedLongLongValue1);
  }

  double get floatValue {
    return _lib._objc_msgSend_64(_id, _lib._sel_floatValue1);
  }

  double get doubleValue {
    return _lib._objc_msgSend_65(_id, _lib._sel_doubleValue1);
  }

  bool get boolValue {
    return _lib._objc_msgSend_11(_id, _lib._sel_boolValue1);
  }

  int get integerValue {
    return _lib._objc_msgSend_61(_id, _lib._sel_integerValue1);
  }

  int get unsignedIntegerValue {
    return _lib._objc_msgSend_12(_id, _lib._sel_unsignedIntegerValue1);
  }

  NSString? get stringValue {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_stringValue1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  int compare_(NSNumber? otherNumber) {
    return _lib._objc_msgSend_66(
        _id, _lib._sel_compare_1, otherNumber?._id ?? ffi.nullptr);
  }

  bool isEqualToNumber_(NSNumber? number) {
    return _lib._objc_msgSend_67(
        _id, _lib._sel_isEqualToNumber_1, number?._id ?? ffi.nullptr);
  }

  NSString descriptionWithLocale_(NSObject locale) {
    final _ret = _lib._objc_msgSend_68(
        _id, _lib._sel_descriptionWithLocale_1, locale._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSNumber new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSNumber1, _lib._sel_new1);
    return NSNumber._(_ret, _lib, retain: false, release: true);
  }

  static NSNumber alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSNumber1, _lib._sel_alloc1);
    return NSNumber._(_ret, _lib, retain: false, release: true);
  }
}

class NSValue extends NSObject {
  NSValue._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSValue] that points to the same underlying object as [other].
  static NSValue castFrom<T extends _ObjCWrapper>(T other) {
    return NSValue._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSValue] that wraps the given raw object pointer.
  static NSValue castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSValue._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSValue].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSValue1);
  }

  void getValue_size_(ffi.Pointer<ffi.Void> value, int size) {
    return _lib._objc_msgSend_20(_id, _lib._sel_getValue_size_1, value, size);
  }

  ffi.Pointer<ffi.Char> get objCType {
    return _lib._objc_msgSend_40(_id, _lib._sel_objCType1);
  }

  NSValue initWithBytes_objCType_(
      ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Char> type) {
    final _ret = _lib._objc_msgSend_41(
        _id, _lib._sel_initWithBytes_objCType_1, value, type);
    return NSValue._(_ret, _lib, retain: true, release: true);
  }

  NSValue initWithCoder_(NSCoder? coder) {
    final _ret = _lib._objc_msgSend_14(
        _id, _lib._sel_initWithCoder_1, coder?._id ?? ffi.nullptr);
    return NSValue._(_ret, _lib, retain: true, release: true);
  }

  static NSValue new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSValue1, _lib._sel_new1);
    return NSValue._(_ret, _lib, retain: false, release: true);
  }

  static NSValue alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSValue1, _lib._sel_alloc1);
    return NSValue._(_ret, _lib, retain: false, release: true);
  }
}

typedef NSInteger = ffi.Long;

abstract class NSComparisonResult {
  static const int NSOrderedAscending = -1;
  static const int NSOrderedSame = 0;
  static const int NSOrderedDescending = 1;
}

class NSError extends NSObject {
  NSError._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSError] that points to the same underlying object as [other].
  static NSError castFrom<T extends _ObjCWrapper>(T other) {
    return NSError._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSError] that wraps the given raw object pointer.
  static NSError castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSError._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSError].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSError1);
  }

  /// Domain cannot be nil; dict may be nil if no userInfo desired.
  NSError initWithDomain_code_userInfo_(
      NSErrorDomain domain, int code, NSDictionary? dict) {
    final _ret = _lib._objc_msgSend_88(
        _id,
        _lib._sel_initWithDomain_code_userInfo_1,
        domain,
        code,
        dict?._id ?? ffi.nullptr);
    return NSError._(_ret, _lib, retain: true, release: true);
  }

  static NSError errorWithDomain_code_userInfo_(NativeCupertinoHttp _lib,
      NSErrorDomain domain, int code, NSDictionary? dict) {
    final _ret = _lib._objc_msgSend_88(
        _lib._class_NSError1,
        _lib._sel_errorWithDomain_code_userInfo_1,
        domain,
        code,
        dict?._id ?? ffi.nullptr);
    return NSError._(_ret, _lib, retain: true, release: true);
  }

  /// These define the error. Domains are described by names that are arbitrary strings used to differentiate groups of codes; for custom domain using reverse-DNS naming will help avoid conflicts. Codes are domain-specific.
  NSErrorDomain get domain {
    return _lib._objc_msgSend_19(_id, _lib._sel_domain1);
  }

  int get code {
    return _lib._objc_msgSend_61(_id, _lib._sel_code1);
  }

  /// Additional info which may be used to describe the error further. Examples of keys that might be included in here are "Line Number", "Failed URL", etc. Embedding other errors in here can also be used as a way to communicate underlying reasons for failures; for instance "File System Error" embedded in the userInfo of an NSError returned from a higher level document object. If the embedded error information is itself NSError, the standard key NSUnderlyingErrorKey can be used.
  NSDictionary? get userInfo {
    final _ret = _lib._objc_msgSend_89(_id, _lib._sel_userInfo1);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// The primary user-presentable message for the error, for instance for NSFileReadNoPermissionError: "The file "File Name" couldn't be opened because you don't have permission to view it.". This message should ideally indicate what failed and why it failed. This value either comes from NSLocalizedDescriptionKey, or NSLocalizedFailureErrorKey+NSLocalizedFailureReasonErrorKey, or NSLocalizedFailureErrorKey. The steps this takes to construct the description include:
  /// 1. Look for NSLocalizedDescriptionKey in userInfo, use value as-is if present.
  /// 2. Look for NSLocalizedFailureErrorKey in userInfo. If present, use, combining with value for NSLocalizedFailureReasonErrorKey if available.
  /// 3. Fetch NSLocalizedDescriptionKey from userInfoValueProvider, use value as-is if present.
  /// 4. Fetch NSLocalizedFailureErrorKey from userInfoValueProvider. If present, use, combining with value for NSLocalizedFailureReasonErrorKey if available.
  /// 5. Look for NSLocalizedFailureReasonErrorKey in userInfo or from userInfoValueProvider; combine with generic "Operation failed" message.
  /// 6. Last resort localized but barely-presentable string manufactured from domain and code. The result is never nil.
  NSString? get localizedDescription {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_localizedDescription1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Return a complete sentence which describes why the operation failed. For instance, for NSFileReadNoPermissionError: "You don't have permission.". In many cases this will be just the "because" part of the error message (but as a complete sentence, which makes localization easier).  Default implementation of this picks up the value of NSLocalizedFailureReasonErrorKey from the userInfo dictionary. If not present, it consults the userInfoValueProvider for the domain, and if that returns nil, this also returns nil.
  NSString? get localizedFailureReason {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_localizedFailureReason1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Return the string that can be displayed as the "informative" (aka "secondary") message on an alert panel. For instance, for NSFileReadNoPermissionError: "To view or change permissions, select the item in the Finder and choose File > Get Info.". Default implementation of this picks up the value of NSLocalizedRecoverySuggestionErrorKey from the userInfo dictionary. If not present, it consults the userInfoValueProvider for the domain, and if that returns nil, this also returns nil.
  NSString? get localizedRecoverySuggestion {
    final _ret =
        _lib._objc_msgSend_19(_id, _lib._sel_localizedRecoverySuggestion1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Return titles of buttons that are appropriate for displaying in an alert. These should match the string provided as a part of localizedRecoverySuggestion.  The first string would be the title of the right-most and default button, the second one next to it, and so on. If used in an alert the corresponding default return values are NSAlertFirstButtonReturn + n. Default implementation of this picks up the value of NSLocalizedRecoveryOptionsErrorKey from the userInfo dictionary. If not present, it consults the userInfoValueProvider for the domain, and if that returns nil, this also returns nil. nil return usually implies no special suggestion, which would imply a single "OK" button.
  NSArray? get localizedRecoveryOptions {
    final _ret =
        _lib._objc_msgSend_72(_id, _lib._sel_localizedRecoveryOptions1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  /// Return an object that conforms to the NSErrorRecoveryAttempting informal protocol. The recovery attempter must be an object that can correctly interpret an index into the array returned by localizedRecoveryOptions. The default implementation of this picks up the value of NSRecoveryAttempterErrorKey from the userInfo dictionary. If not present, it consults the userInfoValueProvider for the domain. If that returns nil, this also returns nil.
  NSObject get recoveryAttempter {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_recoveryAttempter1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// Return the help anchor that can be used to create a help button to accompany the error when it's displayed to the user.  This is done automatically by +[NSAlert alertWithError:], which the presentError: variants in NSApplication go through. The default implementation of this picks up the value of the NSHelpAnchorErrorKey from the userInfo dictionary. If not present, it consults the userInfoValueProvider for the domain.  If that returns nil, this also returns nil.
  NSString? get helpAnchor {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_helpAnchor1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Return a list of underlying errors, if any. It includes the values of both NSUnderlyingErrorKey and NSMultipleUnderlyingErrorsKey. If there are no underlying errors, returns an empty array.
  NSArray? get underlyingErrors {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_underlyingErrors1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  /// Specify a block which will be called from the implementations of localizedDescription, localizedFailureReason, localizedRecoverySuggestion, localizedRecoveryOptions, recoveryAttempter, helpAnchor, and debugDescription when the underlying value for these is not present in the userInfo dictionary of NSError instances with the specified domain.  The provider will be called with the userInfo key corresponding to the queried property: For instance, NSLocalizedDescriptionKey for localizedDescription.  The provider should return nil for any keys it is not able to provide and, very importantly, any keys it does not recognize (since we may extend the list of keys in future releases).
  ///
  /// The specified block will be called synchronously at the time when the above properties are queried. The results are not cached.
  ///
  /// This provider is optional. It enables localization and formatting of error messages to be done lazily; rather than populating the userInfo at NSError creation time, these keys will be fetched on-demand when asked for.
  ///
  /// It is expected that only the “owner” of an NSError domain specifies the provider for the domain, and this is done once. This facility is not meant for consumers of errors to customize the userInfo entries.  This facility should not be used to customize the behaviors of error domains provided by the system.
  ///
  /// If an appropriate result for the requested key cannot be provided, return nil rather than choosing to manufacture a generic fallback response such as "Operation could not be completed, error 42." NSError will take care of the fallback cases.
  static void setUserInfoValueProviderForDomain_provider_(
      NativeCupertinoHttp _lib, NSErrorDomain errorDomain, ObjCBlock provider) {
    return _lib._objc_msgSend_90(
        _lib._class_NSError1,
        _lib._sel_setUserInfoValueProviderForDomain_provider_1,
        errorDomain,
        provider._impl);
  }

  static ObjCBlock userInfoValueProviderForDomain_(NativeCupertinoHttp _lib,
      NSError? err, NSErrorUserInfoKey userInfoKey, NSErrorDomain errorDomain) {
    final _ret = _lib._objc_msgSend_91(
        _lib._class_NSError1,
        _lib._sel_userInfoValueProviderForDomain_1,
        err?._id ?? ffi.nullptr,
        userInfoKey,
        errorDomain);
    return ObjCBlock._(_ret, _lib);
  }

  static NSError new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSError1, _lib._sel_new1);
    return NSError._(_ret, _lib, retain: false, release: true);
  }

  static NSError alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSError1, _lib._sel_alloc1);
    return NSError._(_ret, _lib, retain: false, release: true);
  }
}

typedef NSErrorDomain = ffi.Pointer<ObjCObject>;

/// Immutable Dictionary
class NSDictionary extends NSObject {
  NSDictionary._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSDictionary] that points to the same underlying object as [other].
  static NSDictionary castFrom<T extends _ObjCWrapper>(T other) {
    return NSDictionary._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSDictionary] that wraps the given raw object pointer.
  static NSDictionary castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSDictionary._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSDictionary].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSDictionary1);
  }

  int get count {
    return _lib._objc_msgSend_12(_id, _lib._sel_count1);
  }

  NSObject objectForKey_(NSObject aKey) {
    final _ret = _lib._objc_msgSend_71(_id, _lib._sel_objectForKey_1, aKey._id);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSArray? get allKeys {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_allKeys1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray allKeysForObject_(NSObject anObject) {
    final _ret =
        _lib._objc_msgSend_73(_id, _lib._sel_allKeysForObject_1, anObject._id);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSArray? get allValues {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_allValues1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  NSString? get description {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_description1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get descriptionInStringsFileFormat {
    final _ret =
        _lib._objc_msgSend_19(_id, _lib._sel_descriptionInStringsFileFormat1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString descriptionWithLocale_(NSObject locale) {
    final _ret = _lib._objc_msgSend_68(
        _id, _lib._sel_descriptionWithLocale_1, locale._id);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString descriptionWithLocale_indent_(NSObject locale, int level) {
    final _ret = _lib._objc_msgSend_74(
        _id, _lib._sel_descriptionWithLocale_indent_1, locale._id, level);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  bool isEqualToDictionary_(NSDictionary? otherDictionary) {
    return _lib._objc_msgSend_75(_id, _lib._sel_isEqualToDictionary_1,
        otherDictionary?._id ?? ffi.nullptr);
  }

  /// This method is unsafe because it could potentially cause buffer overruns. You should use -getObjects:andKeys:count:
  void getObjects_andKeys_(ffi.Pointer<ffi.Pointer<ObjCObject>> objects,
      ffi.Pointer<ffi.Pointer<ObjCObject>> keys) {
    return _lib._objc_msgSend_76(
        _id, _lib._sel_getObjects_andKeys_1, objects, keys);
  }

  /// These methods are deprecated, and will be marked with API_DEPRECATED in a subsequent release. Use the variants that use errors instead.
  static NSDictionary dictionaryWithContentsOfFile_(
      NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_77(_lib._class_NSDictionary1,
        _lib._sel_dictionaryWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSDictionary dictionaryWithContentsOfURL_(
      NativeCupertinoHttp _lib, NSURL? url) {
    final _ret = _lib._objc_msgSend_78(_lib._class_NSDictionary1,
        _lib._sel_dictionaryWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  NSDictionary initWithContentsOfFile_(NSString? path) {
    final _ret = _lib._objc_msgSend_77(
        _id, _lib._sel_initWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  NSDictionary initWithContentsOfURL_(NSURL? url) {
    final _ret = _lib._objc_msgSend_78(
        _id, _lib._sel_initWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  bool writeToFile_atomically_(NSString? path, bool useAuxiliaryFile) {
    return _lib._objc_msgSend_24(_id, _lib._sel_writeToFile_atomically_1,
        path?._id ?? ffi.nullptr, useAuxiliaryFile);
  }

  /// the atomically flag is ignored if url of a type that cannot be written atomically.
  bool writeToURL_atomically_(NSURL? url, bool atomically) {
    return _lib._objc_msgSend_79(_id, _lib._sel_writeToURL_atomically_1,
        url?._id ?? ffi.nullptr, atomically);
  }

  static NSDictionary dictionary(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSDictionary1, _lib._sel_dictionary1);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSDictionary dictionaryWithObject_forKey_(
      NativeCupertinoHttp _lib, NSObject object, NSObject key) {
    final _ret = _lib._objc_msgSend_80(_lib._class_NSDictionary1,
        _lib._sel_dictionaryWithObject_forKey_1, object._id, key._id);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSDictionary dictionaryWithObjects_forKeys_count_(
      NativeCupertinoHttp _lib,
      ffi.Pointer<ffi.Pointer<ObjCObject>> objects,
      ffi.Pointer<ffi.Pointer<ObjCObject>> keys,
      int cnt) {
    final _ret = _lib._objc_msgSend_81(_lib._class_NSDictionary1,
        _lib._sel_dictionaryWithObjects_forKeys_count_1, objects, keys, cnt);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSDictionary dictionaryWithObjectsAndKeys_(
      NativeCupertinoHttp _lib, NSObject firstObject) {
    final _ret = _lib._objc_msgSend_71(_lib._class_NSDictionary1,
        _lib._sel_dictionaryWithObjectsAndKeys_1, firstObject._id);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSDictionary dictionaryWithDictionary_(
      NativeCupertinoHttp _lib, NSDictionary? dict) {
    final _ret = _lib._objc_msgSend_82(_lib._class_NSDictionary1,
        _lib._sel_dictionaryWithDictionary_1, dict?._id ?? ffi.nullptr);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSDictionary dictionaryWithObjects_forKeys_(
      NativeCupertinoHttp _lib, NSArray? objects, NSArray? keys) {
    final _ret = _lib._objc_msgSend_83(
        _lib._class_NSDictionary1,
        _lib._sel_dictionaryWithObjects_forKeys_1,
        objects?._id ?? ffi.nullptr,
        keys?._id ?? ffi.nullptr);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  NSDictionary initWithObjectsAndKeys_(NSObject firstObject) {
    final _ret = _lib._objc_msgSend_71(
        _id, _lib._sel_initWithObjectsAndKeys_1, firstObject._id);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  NSDictionary initWithDictionary_(NSDictionary? otherDictionary) {
    final _ret = _lib._objc_msgSend_82(_id, _lib._sel_initWithDictionary_1,
        otherDictionary?._id ?? ffi.nullptr);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  NSDictionary initWithDictionary_copyItems_(
      NSDictionary? otherDictionary, bool flag) {
    final _ret = _lib._objc_msgSend_84(
        _id,
        _lib._sel_initWithDictionary_copyItems_1,
        otherDictionary?._id ?? ffi.nullptr,
        flag);
    return NSDictionary._(_ret, _lib, retain: false, release: true);
  }

  NSDictionary initWithObjects_forKeys_(NSArray? objects, NSArray? keys) {
    final _ret = _lib._objc_msgSend_83(_id, _lib._sel_initWithObjects_forKeys_1,
        objects?._id ?? ffi.nullptr, keys?._id ?? ffi.nullptr);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Reads dictionary stored in NSPropertyList format from the specified url.
  NSDictionary initWithContentsOfURL_error_(
      NSURL? url, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_85(
        _id,
        _lib._sel_initWithContentsOfURL_error_1,
        url?._id ?? ffi.nullptr,
        error);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Reads dictionary stored in NSPropertyList format from the specified url.
  static NSDictionary dictionaryWithContentsOfURL_error_(
      NativeCupertinoHttp _lib,
      NSURL? url,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_85(
        _lib._class_NSDictionary1,
        _lib._sel_dictionaryWithContentsOfURL_error_1,
        url?._id ?? ffi.nullptr,
        error);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Use this method to create a key set to pass to +dictionaryWithSharedKeySet:.
  /// The keys are copied from the array and must be copyable.
  /// If the array parameter is nil or not an NSArray, an exception is thrown.
  /// If the array of keys is empty, an empty key set is returned.
  /// The array of keys may contain duplicates, which are ignored (it is undefined which object of each duplicate pair is used).
  /// As for any usage of hashing, is recommended that the keys have a well-distributed implementation of -hash, and the hash codes must satisfy the hash/isEqual: invariant.
  /// Keys with duplicate hash codes are allowed, but will cause lower performance and increase memory usage.
  static NSObject sharedKeySetForKeys_(
      NativeCupertinoHttp _lib, NSArray? keys) {
    final _ret = _lib._objc_msgSend_86(_lib._class_NSDictionary1,
        _lib._sel_sharedKeySetForKeys_1, keys?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  int countByEnumeratingWithState_objects_count_(
      ffi.Pointer<NSFastEnumerationState> state,
      ffi.Pointer<ffi.Pointer<ObjCObject>> buffer,
      int len) {
    return _lib._objc_msgSend_87(
        _id,
        _lib._sel_countByEnumeratingWithState_objects_count_1,
        state,
        buffer,
        len);
  }

  static NSDictionary new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSDictionary1, _lib._sel_new1);
    return NSDictionary._(_ret, _lib, retain: false, release: true);
  }

  static NSDictionary alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSDictionary1, _lib._sel_alloc1);
    return NSDictionary._(_ret, _lib, retain: false, release: true);
  }
}

class NSFastEnumerationState extends ffi.Struct {
  @ffi.UnsignedLong()
  external int state;

  external ffi.Pointer<ffi.Pointer<ObjCObject>> itemsPtr;

  external ffi.Pointer<ffi.UnsignedLong> mutationsPtr;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.UnsignedLong> extra;
}

ffi.Pointer<ObjCObject> _ObjCBlock_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0,
    NSErrorUserInfoKey arg1) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Pointer<ObjCObject> Function(
                  ffi.Pointer<ObjCObject> arg0, NSErrorUserInfoKey arg1)>>()
      .asFunction<
          ffi.Pointer<ObjCObject> Function(ffi.Pointer<ObjCObject> arg0,
              NSErrorUserInfoKey arg1)>()(arg0, arg1);
}

final _ObjCBlock_closureRegistry = <int, Function>{};
int _ObjCBlock_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock_registerClosure(Function fn) {
  final id = ++_ObjCBlock_closureRegistryIndex;
  _ObjCBlock_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

ffi.Pointer<ObjCObject> _ObjCBlock_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0,
    NSErrorUserInfoKey arg1) {
  return _ObjCBlock_closureRegistry[block.ref.target.address]!(arg0, arg1);
}

class ObjCBlock {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock._(this._impl, this._lib);
  ObjCBlock.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<ObjCObject> Function(
                      ffi.Pointer<ObjCObject> arg0, NSErrorUserInfoKey arg1)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                    ffi.Pointer<ObjCObject> Function(
                        ffi.Pointer<_ObjCBlock> block,
                        ffi.Pointer<ObjCObject> arg0,
                        NSErrorUserInfoKey arg1)>(_ObjCBlock_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock.fromFunction(
      this._lib,
      ffi.Pointer<ObjCObject> Function(
              ffi.Pointer<ObjCObject> arg0, NSErrorUserInfoKey arg1)
          fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                    ffi.Pointer<ObjCObject> Function(
                        ffi.Pointer<_ObjCBlock> block,
                        ffi.Pointer<ObjCObject> arg0,
                        NSErrorUserInfoKey arg1)>(_ObjCBlock_closureTrampoline)
                .cast(),
            _ObjCBlock_registerClosure(fn));
  ffi.Pointer<ObjCObject> call(
      ffi.Pointer<ObjCObject> arg0, NSErrorUserInfoKey arg1) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<ObjCObject> Function(ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0, NSErrorUserInfoKey arg1)>>()
        .asFunction<
            ffi.Pointer<ObjCObject> Function(
                ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0,
                NSErrorUserInfoKey arg1)>()(_impl, arg0, arg1);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

typedef NSErrorUserInfoKey = ffi.Pointer<ObjCObject>;

class _ObjCBlockDesc extends ffi.Struct {
  @ffi.UnsignedLong()
  external int reserved;

  @ffi.UnsignedLong()
  external int size;

  external ffi.Pointer<ffi.Void> copy_helper;

  external ffi.Pointer<ffi.Void> dispose_helper;

  external ffi.Pointer<ffi.Char> signature;
}

class _ObjCBlock extends ffi.Struct {
  external ffi.Pointer<ffi.Void> isa;

  @ffi.Int()
  external int flags;

  @ffi.Int()
  external int reserved;

  external ffi.Pointer<ffi.Void> invoke;

  external ffi.Pointer<_ObjCBlockDesc> descriptor;

  external ffi.Pointer<ffi.Void> target;
}

typedef NSURLResourceKey = ffi.Pointer<ObjCObject>;

/// Working with Bookmarks and alias (bookmark) files
abstract class NSURLBookmarkCreationOptions {
  /// This option does nothing and has no effect on bookmark resolution
  static const int NSURLBookmarkCreationPreferFileIDResolution = 256;

  /// creates bookmark data with "less" information, which may be smaller but still be able to resolve in certain ways
  static const int NSURLBookmarkCreationMinimalBookmark = 512;

  /// include the properties required by writeBookmarkData:toURL:options: in the bookmark data created
  static const int NSURLBookmarkCreationSuitableForBookmarkFile = 1024;

  /// include information in the bookmark data which allows the same sandboxed process to access the resource after being relaunched
  static const int NSURLBookmarkCreationWithSecurityScope = 2048;

  /// if used with kCFURLBookmarkCreationWithSecurityScope, at resolution time only read access to the resource will be granted
  static const int NSURLBookmarkCreationSecurityScopeAllowOnlyReadAccess = 4096;
}

abstract class NSURLBookmarkResolutionOptions {
  /// don't perform any user interaction during bookmark resolution
  static const int NSURLBookmarkResolutionWithoutUI = 256;

  /// don't mount a volume during bookmark resolution
  static const int NSURLBookmarkResolutionWithoutMounting = 512;

  /// use the secure information included at creation time to provide the ability to access the resource in a sandboxed process
  static const int NSURLBookmarkResolutionWithSecurityScope = 1024;
}

typedef NSURLBookmarkFileCreationOptions = NSUInteger;

class NSURLHandle extends NSObject {
  NSURLHandle._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLHandle] that points to the same underlying object as [other].
  static NSURLHandle castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLHandle._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLHandle] that wraps the given raw object pointer.
  static NSURLHandle castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLHandle._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLHandle].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURLHandle1);
  }

  static void registerURLHandleClass_(
      NativeCupertinoHttp _lib, NSObject anURLHandleSubclass) {
    return _lib._objc_msgSend_109(_lib._class_NSURLHandle1,
        _lib._sel_registerURLHandleClass_1, anURLHandleSubclass._id);
  }

  static NSObject URLHandleClassForURL_(
      NativeCupertinoHttp _lib, NSURL? anURL) {
    final _ret = _lib._objc_msgSend_110(_lib._class_NSURLHandle1,
        _lib._sel_URLHandleClassForURL_1, anURL?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  int status() {
    return _lib._objc_msgSend_111(_id, _lib._sel_status1);
  }

  NSString failureReason() {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_failureReason1);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  void addClient_(NSObject? client) {
    return _lib._objc_msgSend_109(
        _id, _lib._sel_addClient_1, client?._id ?? ffi.nullptr);
  }

  void removeClient_(NSObject? client) {
    return _lib._objc_msgSend_109(
        _id, _lib._sel_removeClient_1, client?._id ?? ffi.nullptr);
  }

  void loadInBackground() {
    return _lib._objc_msgSend_1(_id, _lib._sel_loadInBackground1);
  }

  void cancelLoadInBackground() {
    return _lib._objc_msgSend_1(_id, _lib._sel_cancelLoadInBackground1);
  }

  NSData resourceData() {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_resourceData1);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  NSData availableResourceData() {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_availableResourceData1);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  int expectedResourceDataSize() {
    return _lib._objc_msgSend_62(_id, _lib._sel_expectedResourceDataSize1);
  }

  void flushCachedData() {
    return _lib._objc_msgSend_1(_id, _lib._sel_flushCachedData1);
  }

  void backgroundLoadDidFailWithReason_(NSString? reason) {
    return _lib._objc_msgSend_97(
        _id,
        _lib._sel_backgroundLoadDidFailWithReason_1,
        reason?._id ?? ffi.nullptr);
  }

  void didLoadBytes_loadComplete_(NSData? newBytes, bool yorn) {
    return _lib._objc_msgSend_112(_id, _lib._sel_didLoadBytes_loadComplete_1,
        newBytes?._id ?? ffi.nullptr, yorn);
  }

  static bool canInitWithURL_(NativeCupertinoHttp _lib, NSURL? anURL) {
    return _lib._objc_msgSend_113(_lib._class_NSURLHandle1,
        _lib._sel_canInitWithURL_1, anURL?._id ?? ffi.nullptr);
  }

  static NSURLHandle cachedHandleForURL_(
      NativeCupertinoHttp _lib, NSURL? anURL) {
    final _ret = _lib._objc_msgSend_114(_lib._class_NSURLHandle1,
        _lib._sel_cachedHandleForURL_1, anURL?._id ?? ffi.nullptr);
    return NSURLHandle._(_ret, _lib, retain: true, release: true);
  }

  NSObject initWithURL_cached_(NSURL? anURL, bool willCache) {
    final _ret = _lib._objc_msgSend_115(_id, _lib._sel_initWithURL_cached_1,
        anURL?._id ?? ffi.nullptr, willCache);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSObject propertyForKey_(NSString? propertyKey) {
    final _ret = _lib._objc_msgSend_29(
        _id, _lib._sel_propertyForKey_1, propertyKey?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSObject propertyForKeyIfAvailable_(NSString? propertyKey) {
    final _ret = _lib._objc_msgSend_29(_id,
        _lib._sel_propertyForKeyIfAvailable_1, propertyKey?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  bool writeProperty_forKey_(NSObject propertyValue, NSString? propertyKey) {
    return _lib._objc_msgSend_108(_id, _lib._sel_writeProperty_forKey_1,
        propertyValue._id, propertyKey?._id ?? ffi.nullptr);
  }

  bool writeData_(NSData? data) {
    return _lib._objc_msgSend_22(
        _id, _lib._sel_writeData_1, data?._id ?? ffi.nullptr);
  }

  NSData loadInForeground() {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_loadInForeground1);
    return NSData._(_ret, _lib, retain: true, release: true);
  }

  void beginLoadInBackground() {
    return _lib._objc_msgSend_1(_id, _lib._sel_beginLoadInBackground1);
  }

  void endLoadInBackground() {
    return _lib._objc_msgSend_1(_id, _lib._sel_endLoadInBackground1);
  }

  static NSURLHandle new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSURLHandle1, _lib._sel_new1);
    return NSURLHandle._(_ret, _lib, retain: false, release: true);
  }

  static NSURLHandle alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLHandle1, _lib._sel_alloc1);
    return NSURLHandle._(_ret, _lib, retain: false, release: true);
  }
}

abstract class NSURLHandleStatus {
  static const int NSURLHandleNotLoaded = 0;
  static const int NSURLHandleLoadSucceeded = 1;
  static const int NSURLHandleLoadInProgress = 2;
  static const int NSURLHandleLoadFailed = 3;
}

abstract class NSDataWritingOptions {
  /// Hint to use auxiliary file when saving; equivalent to atomically:YES
  static const int NSDataWritingAtomic = 1;

  /// Hint to  prevent overwriting an existing file. Cannot be combined with NSDataWritingAtomic.
  static const int NSDataWritingWithoutOverwriting = 2;
  static const int NSDataWritingFileProtectionNone = 268435456;
  static const int NSDataWritingFileProtectionComplete = 536870912;
  static const int NSDataWritingFileProtectionCompleteUnlessOpen = 805306368;
  static const int
      NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication =
      1073741824;
  static const int NSDataWritingFileProtectionMask = 4026531840;

  /// Deprecated name for NSDataWritingAtomic
  static const int NSAtomicWrite = 1;
}

/// Data Search Options
abstract class NSDataSearchOptions {
  static const int NSDataSearchBackwards = 1;
  static const int NSDataSearchAnchored = 2;
}

void _ObjCBlock1_fnPtrTrampoline(ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ffi.Void> arg0, NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> arg0, NSRange arg1,
                  ffi.Pointer<ffi.Bool> arg2)>>()
      .asFunction<
          void Function(ffi.Pointer<ffi.Void> arg0, NSRange arg1,
              ffi.Pointer<ffi.Bool> arg2)>()(arg0, arg1, arg2);
}

final _ObjCBlock1_closureRegistry = <int, Function>{};
int _ObjCBlock1_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock1_registerClosure(Function fn) {
  final id = ++_ObjCBlock1_closureRegistryIndex;
  _ObjCBlock1_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock1_closureTrampoline(ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ffi.Void> arg0, NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
  return _ObjCBlock1_closureRegistry[block.ref.target.address]!(
      arg0, arg1, arg2);
}

class ObjCBlock1 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock1._(this._impl, this._lib);
  ObjCBlock1.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void> arg0, NSRange arg1,
                      ffi.Pointer<ffi.Bool> arg2)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ffi.Void> arg0,
                            NSRange arg1,
                            ffi.Pointer<ffi.Bool> arg2)>(
                    _ObjCBlock1_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock1.fromFunction(
      this._lib,
      void Function(ffi.Pointer<ffi.Void> arg0, NSRange arg1,
              ffi.Pointer<ffi.Bool> arg2)
          fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ffi.Void> arg0,
                            NSRange arg1,
                            ffi.Pointer<ffi.Bool> arg2)>(
                    _ObjCBlock1_closureTrampoline)
                .cast(),
            _ObjCBlock1_registerClosure(fn));
  void call(
      ffi.Pointer<ffi.Void> arg0, NSRange arg1, ffi.Pointer<ffi.Bool> arg2) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ffi.Void> arg0,
                    NSRange arg1,
                    ffi.Pointer<ffi.Bool> arg2)>>()
        .asFunction<
            void Function(
                ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ffi.Void> arg0,
                NSRange arg1,
                ffi.Pointer<ffi.Bool> arg2)>()(_impl, arg0, arg1, arg2);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

/// Read/Write Options
abstract class NSDataReadingOptions {
  /// Hint to map the file in if possible and safe
  static const int NSDataReadingMappedIfSafe = 1;

  /// Hint to get the file not to be cached in the kernel
  static const int NSDataReadingUncached = 2;

  /// Hint to map the file in if possible. This takes precedence over NSDataReadingMappedIfSafe if both are given.
  static const int NSDataReadingMappedAlways = 8;

  /// Deprecated name for NSDataReadingMappedIfSafe
  static const int NSDataReadingMapped = 1;

  /// Deprecated name for NSDataReadingMapped
  static const int NSMappedRead = 1;

  /// Deprecated name for NSDataReadingUncached
  static const int NSUncachedRead = 2;
}

void _ObjCBlock2_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ffi.Void> arg0, int arg1) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void> arg0, NSUInteger arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<ffi.Void> arg0, int arg1)>()(arg0, arg1);
}

final _ObjCBlock2_closureRegistry = <int, Function>{};
int _ObjCBlock2_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock2_registerClosure(Function fn) {
  final id = ++_ObjCBlock2_closureRegistryIndex;
  _ObjCBlock2_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock2_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ffi.Void> arg0, int arg1) {
  return _ObjCBlock2_closureRegistry[block.ref.target.address]!(arg0, arg1);
}

class ObjCBlock2 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock2._(this._impl, this._lib);
  ObjCBlock2.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> arg0, NSUInteger arg1)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                    ffi.Void Function(
                        ffi.Pointer<_ObjCBlock> block,
                        ffi.Pointer<ffi.Void> arg0,
                        NSUInteger arg1)>(_ObjCBlock2_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock2.fromFunction(
      this._lib, void Function(ffi.Pointer<ffi.Void> arg0, int arg1) fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                    ffi.Void Function(
                        ffi.Pointer<_ObjCBlock> block,
                        ffi.Pointer<ffi.Void> arg0,
                        NSUInteger arg1)>(_ObjCBlock2_closureTrampoline)
                .cast(),
            _ObjCBlock2_registerClosure(fn));
  void call(ffi.Pointer<ffi.Void> arg0, int arg1) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ffi.Void> arg0, NSUInteger arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ffi.Void> arg0, int arg1)>()(_impl, arg0, arg1);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

abstract class NSDataBase64DecodingOptions {
  /// Use the following option to modify the decoding algorithm so that it ignores unknown non-Base64 bytes, including line ending characters.
  static const int NSDataBase64DecodingIgnoreUnknownCharacters = 1;
}

/// Base 64 Options
abstract class NSDataBase64EncodingOptions {
  /// Use zero or one of the following to control the maximum line length after which a line ending is inserted. No line endings are inserted by default.
  static const int NSDataBase64Encoding64CharacterLineLength = 1;
  static const int NSDataBase64Encoding76CharacterLineLength = 2;

  /// Use zero or more of the following to specify which kind of line ending is inserted. The default line ending is CR LF.
  static const int NSDataBase64EncodingEndLineWithCarriageReturn = 16;
  static const int NSDataBase64EncodingEndLineWithLineFeed = 32;
}

/// Various algorithms provided for compression APIs. See NSData and NSMutableData.
abstract class NSDataCompressionAlgorithm {
  /// LZFSE is the recommended compression algorithm if you don't have a specific reason to use another algorithm. Note that LZFSE is intended for use with Apple devices only. This algorithm generally compresses better than Zlib, but not as well as LZMA. It is generally slower than LZ4.
  static const int NSDataCompressionAlgorithmLZFSE = 0;

  /// LZ4 is appropriate if compression speed is critical. LZ4 generally sacrifices compression ratio in order to achieve its greater speed.
  /// This implementation of LZ4 makes a small modification to the standard format, which is described in greater detail in <compression.h>.
  static const int NSDataCompressionAlgorithmLZ4 = 1;

  /// LZMA is appropriate if compression ratio is critical and memory usage and compression speed are not a factor. LZMA is an order of magnitude slower for both compression and decompression than other algorithms. It can also use a very large amount of memory, so if you need to compress large amounts of data on embedded devices with limited memory you should probably avoid LZMA.
  /// Encoding uses LZMA level 6 only, but decompression works with any compression level.
  static const int NSDataCompressionAlgorithmLZMA = 2;

  /// Zlib is appropriate if you want a good balance between compression speed and compression ratio, but only if you need interoperability with non-Apple platforms. Otherwise, LZFSE is generally a better choice than Zlib.
  /// Encoding uses Zlib level 5 only, but decompression works with any compression level. It uses the raw DEFLATE format as described in IETF RFC 1951.
  static const int NSDataCompressionAlgorithmZlib = 3;
}

typedef UTF32Char = UInt32;
typedef UInt32 = ffi.UnsignedInt;
typedef NSStringEncoding = NSUInteger;

abstract class NSBinarySearchingOptions {
  static const int NSBinarySearchingFirstEqual = 256;
  static const int NSBinarySearchingLastEqual = 512;
  static const int NSBinarySearchingInsertionIndex = 1024;
}

/// Mutable Array
class NSMutableArray extends NSArray {
  NSMutableArray._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSMutableArray] that points to the same underlying object as [other].
  static NSMutableArray castFrom<T extends _ObjCWrapper>(T other) {
    return NSMutableArray._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSMutableArray] that wraps the given raw object pointer.
  static NSMutableArray castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSMutableArray._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSMutableArray].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSMutableArray1);
  }

  void addObject_(NSObject anObject) {
    return _lib._objc_msgSend_109(_id, _lib._sel_addObject_1, anObject._id);
  }

  void insertObject_atIndex_(NSObject anObject, int index) {
    return _lib._objc_msgSend_159(
        _id, _lib._sel_insertObject_atIndex_1, anObject._id, index);
  }

  void removeLastObject() {
    return _lib._objc_msgSend_1(_id, _lib._sel_removeLastObject1);
  }

  void removeObjectAtIndex_(int index) {
    return _lib._objc_msgSend_160(_id, _lib._sel_removeObjectAtIndex_1, index);
  }

  void replaceObjectAtIndex_withObject_(int index, NSObject anObject) {
    return _lib._objc_msgSend_161(
        _id, _lib._sel_replaceObjectAtIndex_withObject_1, index, anObject._id);
  }

  @override
  NSMutableArray init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  NSMutableArray initWithCapacity_(int numItems) {
    final _ret =
        _lib._objc_msgSend_146(_id, _lib._sel_initWithCapacity_1, numItems);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSMutableArray initWithCoder_(NSCoder? coder) {
    final _ret = _lib._objc_msgSend_14(
        _id, _lib._sel_initWithCoder_1, coder?._id ?? ffi.nullptr);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  void addObjectsFromArray_(NSArray? otherArray) {
    return _lib._objc_msgSend_162(
        _id, _lib._sel_addObjectsFromArray_1, otherArray?._id ?? ffi.nullptr);
  }

  void exchangeObjectAtIndex_withObjectAtIndex_(int idx1, int idx2) {
    return _lib._objc_msgSend_163(
        _id, _lib._sel_exchangeObjectAtIndex_withObjectAtIndex_1, idx1, idx2);
  }

  void removeAllObjects() {
    return _lib._objc_msgSend_1(_id, _lib._sel_removeAllObjects1);
  }

  void removeObject_inRange_(NSObject anObject, NSRange range) {
    return _lib._objc_msgSend_164(
        _id, _lib._sel_removeObject_inRange_1, anObject._id, range);
  }

  void removeObject_(NSObject anObject) {
    return _lib._objc_msgSend_109(_id, _lib._sel_removeObject_1, anObject._id);
  }

  void removeObjectIdenticalTo_inRange_(NSObject anObject, NSRange range) {
    return _lib._objc_msgSend_164(
        _id, _lib._sel_removeObjectIdenticalTo_inRange_1, anObject._id, range);
  }

  void removeObjectIdenticalTo_(NSObject anObject) {
    return _lib._objc_msgSend_109(
        _id, _lib._sel_removeObjectIdenticalTo_1, anObject._id);
  }

  void removeObjectsFromIndices_numIndices_(
      ffi.Pointer<NSUInteger> indices, int cnt) {
    return _lib._objc_msgSend_165(
        _id, _lib._sel_removeObjectsFromIndices_numIndices_1, indices, cnt);
  }

  void removeObjectsInArray_(NSArray? otherArray) {
    return _lib._objc_msgSend_162(
        _id, _lib._sel_removeObjectsInArray_1, otherArray?._id ?? ffi.nullptr);
  }

  void removeObjectsInRange_(NSRange range) {
    return _lib._objc_msgSend_166(_id, _lib._sel_removeObjectsInRange_1, range);
  }

  void replaceObjectsInRange_withObjectsFromArray_range_(
      NSRange range, NSArray? otherArray, NSRange otherRange) {
    return _lib._objc_msgSend_167(
        _id,
        _lib._sel_replaceObjectsInRange_withObjectsFromArray_range_1,
        range,
        otherArray?._id ?? ffi.nullptr,
        otherRange);
  }

  void replaceObjectsInRange_withObjectsFromArray_(
      NSRange range, NSArray? otherArray) {
    return _lib._objc_msgSend_168(
        _id,
        _lib._sel_replaceObjectsInRange_withObjectsFromArray_1,
        range,
        otherArray?._id ?? ffi.nullptr);
  }

  void setArray_(NSArray? otherArray) {
    return _lib._objc_msgSend_162(
        _id, _lib._sel_setArray_1, otherArray?._id ?? ffi.nullptr);
  }

  void sortUsingFunction_context_(
      ffi.Pointer<
              ffi.NativeFunction<
                  NSInteger Function(ffi.Pointer<ObjCObject>,
                      ffi.Pointer<ObjCObject>, ffi.Pointer<ffi.Void>)>>
          compare,
      ffi.Pointer<ffi.Void> context) {
    return _lib._objc_msgSend_169(
        _id, _lib._sel_sortUsingFunction_context_1, compare, context);
  }

  void sortUsingSelector_(ffi.Pointer<ObjCSel> comparator) {
    return _lib._objc_msgSend_7(_id, _lib._sel_sortUsingSelector_1, comparator);
  }

  void insertObjects_atIndexes_(NSArray? objects, NSIndexSet? indexes) {
    return _lib._objc_msgSend_190(_id, _lib._sel_insertObjects_atIndexes_1,
        objects?._id ?? ffi.nullptr, indexes?._id ?? ffi.nullptr);
  }

  void removeObjectsAtIndexes_(NSIndexSet? indexes) {
    return _lib._objc_msgSend_191(
        _id, _lib._sel_removeObjectsAtIndexes_1, indexes?._id ?? ffi.nullptr);
  }

  void replaceObjectsAtIndexes_withObjects_(
      NSIndexSet? indexes, NSArray? objects) {
    return _lib._objc_msgSend_192(
        _id,
        _lib._sel_replaceObjectsAtIndexes_withObjects_1,
        indexes?._id ?? ffi.nullptr,
        objects?._id ?? ffi.nullptr);
  }

  void setObject_atIndexedSubscript_(NSObject obj, int idx) {
    return _lib._objc_msgSend_159(
        _id, _lib._sel_setObject_atIndexedSubscript_1, obj._id, idx);
  }

  void sortUsingComparator_(NSComparator cmptr) {
    return _lib._objc_msgSend_193(_id, _lib._sel_sortUsingComparator_1, cmptr);
  }

  void sortWithOptions_usingComparator_(int opts, NSComparator cmptr) {
    return _lib._objc_msgSend_194(
        _id, _lib._sel_sortWithOptions_usingComparator_1, opts, cmptr);
  }

  static NSMutableArray arrayWithCapacity_(
      NativeCupertinoHttp _lib, int numItems) {
    final _ret = _lib._objc_msgSend_146(
        _lib._class_NSMutableArray1, _lib._sel_arrayWithCapacity_1, numItems);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableArray arrayWithContentsOfFile_(
      NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_195(_lib._class_NSMutableArray1,
        _lib._sel_arrayWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableArray arrayWithContentsOfURL_(
      NativeCupertinoHttp _lib, NSURL? url) {
    final _ret = _lib._objc_msgSend_196(_lib._class_NSMutableArray1,
        _lib._sel_arrayWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  NSMutableArray initWithContentsOfFile_(NSString? path) {
    final _ret = _lib._objc_msgSend_195(
        _id, _lib._sel_initWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  NSMutableArray initWithContentsOfURL_(NSURL? url) {
    final _ret = _lib._objc_msgSend_196(
        _id, _lib._sel_initWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  void applyDifference_() {
    return _lib._objc_msgSend_1(_id, _lib._sel_applyDifference_1);
  }

  static NSMutableArray array(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableArray1, _lib._sel_array1);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableArray arrayWithObject_(
      NativeCupertinoHttp _lib, NSObject anObject) {
    final _ret = _lib._objc_msgSend_71(
        _lib._class_NSMutableArray1, _lib._sel_arrayWithObject_1, anObject._id);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableArray arrayWithObjects_count_(NativeCupertinoHttp _lib,
      ffi.Pointer<ffi.Pointer<ObjCObject>> objects, int cnt) {
    final _ret = _lib._objc_msgSend_147(_lib._class_NSMutableArray1,
        _lib._sel_arrayWithObjects_count_1, objects, cnt);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableArray arrayWithObjects_(
      NativeCupertinoHttp _lib, NSObject firstObj) {
    final _ret = _lib._objc_msgSend_71(_lib._class_NSMutableArray1,
        _lib._sel_arrayWithObjects_1, firstObj._id);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableArray arrayWithArray_(
      NativeCupertinoHttp _lib, NSArray? array) {
    final _ret = _lib._objc_msgSend_86(_lib._class_NSMutableArray1,
        _lib._sel_arrayWithArray_1, array?._id ?? ffi.nullptr);
    return NSMutableArray._(_ret, _lib, retain: true, release: true);
  }

  /// Reads array stored in NSPropertyList format from the specified url.
  static NSArray arrayWithContentsOfURL_error_(NativeCupertinoHttp _lib,
      NSURL? url, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_155(
        _lib._class_NSMutableArray1,
        _lib._sel_arrayWithContentsOfURL_error_1,
        url?._id ?? ffi.nullptr,
        error);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableArray new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableArray1, _lib._sel_new1);
    return NSMutableArray._(_ret, _lib, retain: false, release: true);
  }

  static NSMutableArray alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableArray1, _lib._sel_alloc1);
    return NSMutableArray._(_ret, _lib, retain: false, release: true);
  }
}

class NSIndexSet extends NSObject {
  NSIndexSet._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSIndexSet] that points to the same underlying object as [other].
  static NSIndexSet castFrom<T extends _ObjCWrapper>(T other) {
    return NSIndexSet._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSIndexSet] that wraps the given raw object pointer.
  static NSIndexSet castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSIndexSet._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSIndexSet].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSIndexSet1);
  }

  static NSIndexSet indexSet(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSIndexSet1, _lib._sel_indexSet1);
    return NSIndexSet._(_ret, _lib, retain: true, release: true);
  }

  static NSIndexSet indexSetWithIndex_(NativeCupertinoHttp _lib, int value) {
    final _ret = _lib._objc_msgSend_146(
        _lib._class_NSIndexSet1, _lib._sel_indexSetWithIndex_1, value);
    return NSIndexSet._(_ret, _lib, retain: true, release: true);
  }

  static NSIndexSet indexSetWithIndexesInRange_(
      NativeCupertinoHttp _lib, NSRange range) {
    final _ret = _lib._objc_msgSend_170(
        _lib._class_NSIndexSet1, _lib._sel_indexSetWithIndexesInRange_1, range);
    return NSIndexSet._(_ret, _lib, retain: true, release: true);
  }

  NSIndexSet initWithIndexesInRange_(NSRange range) {
    final _ret =
        _lib._objc_msgSend_170(_id, _lib._sel_initWithIndexesInRange_1, range);
    return NSIndexSet._(_ret, _lib, retain: true, release: true);
  }

  NSIndexSet initWithIndexSet_(NSIndexSet? indexSet) {
    final _ret = _lib._objc_msgSend_171(
        _id, _lib._sel_initWithIndexSet_1, indexSet?._id ?? ffi.nullptr);
    return NSIndexSet._(_ret, _lib, retain: true, release: true);
  }

  NSIndexSet initWithIndex_(int value) {
    final _ret = _lib._objc_msgSend_146(_id, _lib._sel_initWithIndex_1, value);
    return NSIndexSet._(_ret, _lib, retain: true, release: true);
  }

  bool isEqualToIndexSet_(NSIndexSet? indexSet) {
    return _lib._objc_msgSend_172(
        _id, _lib._sel_isEqualToIndexSet_1, indexSet?._id ?? ffi.nullptr);
  }

  int get count {
    return _lib._objc_msgSend_12(_id, _lib._sel_count1);
  }

  int get firstIndex {
    return _lib._objc_msgSend_12(_id, _lib._sel_firstIndex1);
  }

  int get lastIndex {
    return _lib._objc_msgSend_12(_id, _lib._sel_lastIndex1);
  }

  int indexGreaterThanIndex_(int value) {
    return _lib._objc_msgSend_173(
        _id, _lib._sel_indexGreaterThanIndex_1, value);
  }

  int indexLessThanIndex_(int value) {
    return _lib._objc_msgSend_173(_id, _lib._sel_indexLessThanIndex_1, value);
  }

  int indexGreaterThanOrEqualToIndex_(int value) {
    return _lib._objc_msgSend_173(
        _id, _lib._sel_indexGreaterThanOrEqualToIndex_1, value);
  }

  int indexLessThanOrEqualToIndex_(int value) {
    return _lib._objc_msgSend_173(
        _id, _lib._sel_indexLessThanOrEqualToIndex_1, value);
  }

  int getIndexes_maxCount_inIndexRange_(ffi.Pointer<NSUInteger> indexBuffer,
      int bufferSize, NSRangePointer range) {
    return _lib._objc_msgSend_174(
        _id,
        _lib._sel_getIndexes_maxCount_inIndexRange_1,
        indexBuffer,
        bufferSize,
        range);
  }

  int countOfIndexesInRange_(NSRange range) {
    return _lib._objc_msgSend_175(
        _id, _lib._sel_countOfIndexesInRange_1, range);
  }

  bool containsIndex_(int value) {
    return _lib._objc_msgSend_176(_id, _lib._sel_containsIndex_1, value);
  }

  bool containsIndexesInRange_(NSRange range) {
    return _lib._objc_msgSend_177(
        _id, _lib._sel_containsIndexesInRange_1, range);
  }

  bool containsIndexes_(NSIndexSet? indexSet) {
    return _lib._objc_msgSend_172(
        _id, _lib._sel_containsIndexes_1, indexSet?._id ?? ffi.nullptr);
  }

  bool intersectsIndexesInRange_(NSRange range) {
    return _lib._objc_msgSend_177(
        _id, _lib._sel_intersectsIndexesInRange_1, range);
  }

  void enumerateIndexesUsingBlock_(ObjCBlock3 block) {
    return _lib._objc_msgSend_178(
        _id, _lib._sel_enumerateIndexesUsingBlock_1, block._impl);
  }

  void enumerateIndexesWithOptions_usingBlock_(int opts, ObjCBlock3 block) {
    return _lib._objc_msgSend_179(_id,
        _lib._sel_enumerateIndexesWithOptions_usingBlock_1, opts, block._impl);
  }

  void enumerateIndexesInRange_options_usingBlock_(
      NSRange range, int opts, ObjCBlock3 block) {
    return _lib._objc_msgSend_180(
        _id,
        _lib._sel_enumerateIndexesInRange_options_usingBlock_1,
        range,
        opts,
        block._impl);
  }

  int indexPassingTest_(ObjCBlock4 predicate) {
    return _lib._objc_msgSend_181(
        _id, _lib._sel_indexPassingTest_1, predicate._impl);
  }

  int indexWithOptions_passingTest_(int opts, ObjCBlock4 predicate) {
    return _lib._objc_msgSend_182(
        _id, _lib._sel_indexWithOptions_passingTest_1, opts, predicate._impl);
  }

  int indexInRange_options_passingTest_(
      NSRange range, int opts, ObjCBlock4 predicate) {
    return _lib._objc_msgSend_183(
        _id,
        _lib._sel_indexInRange_options_passingTest_1,
        range,
        opts,
        predicate._impl);
  }

  NSIndexSet indexesPassingTest_(ObjCBlock4 predicate) {
    final _ret = _lib._objc_msgSend_184(
        _id, _lib._sel_indexesPassingTest_1, predicate._impl);
    return NSIndexSet._(_ret, _lib, retain: true, release: true);
  }

  NSIndexSet indexesWithOptions_passingTest_(int opts, ObjCBlock4 predicate) {
    final _ret = _lib._objc_msgSend_185(
        _id, _lib._sel_indexesWithOptions_passingTest_1, opts, predicate._impl);
    return NSIndexSet._(_ret, _lib, retain: true, release: true);
  }

  NSIndexSet indexesInRange_options_passingTest_(
      NSRange range, int opts, ObjCBlock4 predicate) {
    final _ret = _lib._objc_msgSend_186(
        _id,
        _lib._sel_indexesInRange_options_passingTest_1,
        range,
        opts,
        predicate._impl);
    return NSIndexSet._(_ret, _lib, retain: true, release: true);
  }

  void enumerateRangesUsingBlock_(ObjCBlock5 block) {
    return _lib._objc_msgSend_187(
        _id, _lib._sel_enumerateRangesUsingBlock_1, block._impl);
  }

  void enumerateRangesWithOptions_usingBlock_(int opts, ObjCBlock5 block) {
    return _lib._objc_msgSend_188(_id,
        _lib._sel_enumerateRangesWithOptions_usingBlock_1, opts, block._impl);
  }

  void enumerateRangesInRange_options_usingBlock_(
      NSRange range, int opts, ObjCBlock5 block) {
    return _lib._objc_msgSend_189(
        _id,
        _lib._sel_enumerateRangesInRange_options_usingBlock_1,
        range,
        opts,
        block._impl);
  }

  static NSIndexSet new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSIndexSet1, _lib._sel_new1);
    return NSIndexSet._(_ret, _lib, retain: false, release: true);
  }

  static NSIndexSet alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSIndexSet1, _lib._sel_alloc1);
    return NSIndexSet._(_ret, _lib, retain: false, release: true);
  }
}

typedef NSRangePointer = ffi.Pointer<NSRange>;
void _ObjCBlock3_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block, int arg0, ffi.Pointer<ffi.Bool> arg1) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(NSUInteger arg0, ffi.Pointer<ffi.Bool> arg1)>>()
      .asFunction<
          void Function(int arg0, ffi.Pointer<ffi.Bool> arg1)>()(arg0, arg1);
}

final _ObjCBlock3_closureRegistry = <int, Function>{};
int _ObjCBlock3_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock3_registerClosure(Function fn) {
  final id = ++_ObjCBlock3_closureRegistryIndex;
  _ObjCBlock3_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock3_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block, int arg0, ffi.Pointer<ffi.Bool> arg1) {
  return _ObjCBlock3_closureRegistry[block.ref.target.address]!(arg0, arg1);
}

class ObjCBlock3 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock3._(this._impl, this._lib);
  ObjCBlock3.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      NSUInteger arg0, ffi.Pointer<ffi.Bool> arg1)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                            NSUInteger arg0, ffi.Pointer<ffi.Bool> arg1)>(
                    _ObjCBlock3_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock3.fromFunction(
      this._lib, void Function(int arg0, ffi.Pointer<ffi.Bool> arg1) fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                            NSUInteger arg0, ffi.Pointer<ffi.Bool> arg1)>(
                    _ObjCBlock3_closureTrampoline)
                .cast(),
            _ObjCBlock3_registerClosure(fn));
  void call(int arg0, ffi.Pointer<ffi.Bool> arg1) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                    NSUInteger arg0, ffi.Pointer<ffi.Bool> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<_ObjCBlock> block, int arg0,
                ffi.Pointer<ffi.Bool> arg1)>()(_impl, arg0, arg1);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

abstract class NSEnumerationOptions {
  static const int NSEnumerationConcurrent = 1;
  static const int NSEnumerationReverse = 2;
}

bool _ObjCBlock4_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block, int arg0, ffi.Pointer<ffi.Bool> arg1) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Bool Function(NSUInteger arg0, ffi.Pointer<ffi.Bool> arg1)>>()
      .asFunction<
          bool Function(int arg0, ffi.Pointer<ffi.Bool> arg1)>()(arg0, arg1);
}

final _ObjCBlock4_closureRegistry = <int, Function>{};
int _ObjCBlock4_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock4_registerClosure(Function fn) {
  final id = ++_ObjCBlock4_closureRegistryIndex;
  _ObjCBlock4_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

bool _ObjCBlock4_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block, int arg0, ffi.Pointer<ffi.Bool> arg1) {
  return _ObjCBlock4_closureRegistry[block.ref.target.address]!(arg0, arg1);
}

class ObjCBlock4 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock4._(this._impl, this._lib);
  ObjCBlock4.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      NSUInteger arg0, ffi.Pointer<ffi.Bool> arg1)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Bool Function(ffi.Pointer<_ObjCBlock> block,
                            NSUInteger arg0, ffi.Pointer<ffi.Bool> arg1)>(
                    _ObjCBlock4_fnPtrTrampoline, false)
                .cast(),
            ptr.cast());
  ObjCBlock4.fromFunction(
      this._lib, bool Function(int arg0, ffi.Pointer<ffi.Bool> arg1) fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Bool Function(ffi.Pointer<_ObjCBlock> block,
                            NSUInteger arg0, ffi.Pointer<ffi.Bool> arg1)>(
                    _ObjCBlock4_closureTrampoline, false)
                .cast(),
            _ObjCBlock4_registerClosure(fn));
  bool call(int arg0, ffi.Pointer<ffi.Bool> arg1) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<_ObjCBlock> block,
                    NSUInteger arg0, ffi.Pointer<ffi.Bool> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<_ObjCBlock> block, int arg0,
                ffi.Pointer<ffi.Bool> arg1)>()(_impl, arg0, arg1);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

void _ObjCBlock5_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block, NSRange arg0, ffi.Pointer<ffi.Bool> arg1) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(NSRange arg0, ffi.Pointer<ffi.Bool> arg1)>>()
      .asFunction<
          void Function(
              NSRange arg0, ffi.Pointer<ffi.Bool> arg1)>()(arg0, arg1);
}

final _ObjCBlock5_closureRegistry = <int, Function>{};
int _ObjCBlock5_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock5_registerClosure(Function fn) {
  final id = ++_ObjCBlock5_closureRegistryIndex;
  _ObjCBlock5_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock5_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block, NSRange arg0, ffi.Pointer<ffi.Bool> arg1) {
  return _ObjCBlock5_closureRegistry[block.ref.target.address]!(arg0, arg1);
}

class ObjCBlock5 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock5._(this._impl, this._lib);
  ObjCBlock5.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(NSRange arg0, ffi.Pointer<ffi.Bool> arg1)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                            NSRange arg0, ffi.Pointer<ffi.Bool> arg1)>(
                    _ObjCBlock5_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock5.fromFunction(
      this._lib, void Function(NSRange arg0, ffi.Pointer<ffi.Bool> arg1) fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                            NSRange arg0, ffi.Pointer<ffi.Bool> arg1)>(
                    _ObjCBlock5_closureTrampoline)
                .cast(),
            _ObjCBlock5_registerClosure(fn));
  void call(NSRange arg0, ffi.Pointer<ffi.Bool> arg1) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<_ObjCBlock> block, NSRange arg0,
                    ffi.Pointer<ffi.Bool> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<_ObjCBlock> block, NSRange arg0,
                ffi.Pointer<ffi.Bool> arg1)>()(_impl, arg0, arg1);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

typedef NSComparator = ffi.Pointer<_ObjCBlock>;
int _ObjCBlock6_fnPtrTrampoline(ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Int32 Function(ffi.Pointer<ObjCObject> arg0,
                  ffi.Pointer<ObjCObject> arg1)>>()
      .asFunction<
          int Function(ffi.Pointer<ObjCObject> arg0,
              ffi.Pointer<ObjCObject> arg1)>()(arg0, arg1);
}

final _ObjCBlock6_closureRegistry = <int, Function>{};
int _ObjCBlock6_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock6_registerClosure(Function fn) {
  final id = ++_ObjCBlock6_closureRegistryIndex;
  _ObjCBlock6_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

int _ObjCBlock6_closureTrampoline(ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1) {
  return _ObjCBlock6_closureRegistry[block.ref.target.address]!(arg0, arg1);
}

class ObjCBlock6 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock6._(this._impl, this._lib);
  ObjCBlock6.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int32 Function(ffi.Pointer<ObjCObject> arg0,
                      ffi.Pointer<ObjCObject> arg1)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Int32 Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Pointer<ObjCObject> arg1)>(
                    _ObjCBlock6_fnPtrTrampoline, 0)
                .cast(),
            ptr.cast());
  ObjCBlock6.fromFunction(
      this._lib,
      int Function(ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1)
          fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Int32 Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Pointer<ObjCObject> arg1)>(
                    _ObjCBlock6_closureTrampoline, 0)
                .cast(),
            _ObjCBlock6_registerClosure(fn));
  int call(ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Int32 Function(
                    ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0,
                    ffi.Pointer<ObjCObject> arg1)>>()
        .asFunction<
            int Function(
                ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0,
                ffi.Pointer<ObjCObject> arg1)>()(_impl, arg0, arg1);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

abstract class NSSortOptions {
  static const int NSSortConcurrent = 1;
  static const int NSSortStable = 16;
}

/// Mutable Data
class NSMutableData extends NSData {
  NSMutableData._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSMutableData] that points to the same underlying object as [other].
  static NSMutableData castFrom<T extends _ObjCWrapper>(T other) {
    return NSMutableData._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSMutableData] that wraps the given raw object pointer.
  static NSMutableData castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSMutableData._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSMutableData].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSMutableData1);
  }

  ffi.Pointer<ffi.Void> get mutableBytes {
    return _lib._objc_msgSend_18(_id, _lib._sel_mutableBytes1);
  }

  @override
  int get length {
    return _lib._objc_msgSend_12(_id, _lib._sel_length1);
  }

  set length(int value) {
    _lib._objc_msgSend_197(_id, _lib._sel_setLength_1, value);
  }

  void appendBytes_length_(ffi.Pointer<ffi.Void> bytes, int length) {
    return _lib._objc_msgSend_20(
        _id, _lib._sel_appendBytes_length_1, bytes, length);
  }

  void appendData_(NSData? other) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_appendData_1, other?._id ?? ffi.nullptr);
  }

  void increaseLengthBy_(int extraLength) {
    return _lib._objc_msgSend_160(
        _id, _lib._sel_increaseLengthBy_1, extraLength);
  }

  void replaceBytesInRange_withBytes_(
      NSRange range, ffi.Pointer<ffi.Void> bytes) {
    return _lib._objc_msgSend_199(
        _id, _lib._sel_replaceBytesInRange_withBytes_1, range, bytes);
  }

  void resetBytesInRange_(NSRange range) {
    return _lib._objc_msgSend_166(_id, _lib._sel_resetBytesInRange_1, range);
  }

  void setData_(NSData? data) {
    return _lib._objc_msgSend_198(
        _id, _lib._sel_setData_1, data?._id ?? ffi.nullptr);
  }

  void replaceBytesInRange_withBytes_length_(NSRange range,
      ffi.Pointer<ffi.Void> replacementBytes, int replacementLength) {
    return _lib._objc_msgSend_200(
        _id,
        _lib._sel_replaceBytesInRange_withBytes_length_1,
        range,
        replacementBytes,
        replacementLength);
  }

  static NSMutableData dataWithCapacity_(
      NativeCupertinoHttp _lib, int aNumItems) {
    final _ret = _lib._objc_msgSend_146(
        _lib._class_NSMutableData1, _lib._sel_dataWithCapacity_1, aNumItems);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableData dataWithLength_(NativeCupertinoHttp _lib, int length) {
    final _ret = _lib._objc_msgSend_146(
        _lib._class_NSMutableData1, _lib._sel_dataWithLength_1, length);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  NSMutableData initWithCapacity_(int capacity) {
    final _ret =
        _lib._objc_msgSend_146(_id, _lib._sel_initWithCapacity_1, capacity);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  NSMutableData initWithLength_(int length) {
    final _ret =
        _lib._objc_msgSend_146(_id, _lib._sel_initWithLength_1, length);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  /// These methods compress or decompress the receiver's contents in-place using the specified algorithm. If the operation is not successful, these methods leave the receiver unchanged..
  bool decompressUsingAlgorithm_error_(
      int algorithm, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_201(
        _id, _lib._sel_decompressUsingAlgorithm_error_1, algorithm, error);
  }

  bool compressUsingAlgorithm_error_(
      int algorithm, ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    return _lib._objc_msgSend_201(
        _id, _lib._sel_compressUsingAlgorithm_error_1, algorithm, error);
  }

  static NSMutableData data(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableData1, _lib._sel_data1);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableData dataWithBytes_length_(
      NativeCupertinoHttp _lib, ffi.Pointer<ffi.Void> bytes, int length) {
    final _ret = _lib._objc_msgSend_121(_lib._class_NSMutableData1,
        _lib._sel_dataWithBytes_length_1, bytes, length);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableData dataWithBytesNoCopy_length_(
      NativeCupertinoHttp _lib, ffi.Pointer<ffi.Void> bytes, int length) {
    final _ret = _lib._objc_msgSend_121(_lib._class_NSMutableData1,
        _lib._sel_dataWithBytesNoCopy_length_1, bytes, length);
    return NSMutableData._(_ret, _lib, retain: false, release: true);
  }

  static NSMutableData dataWithBytesNoCopy_length_freeWhenDone_(
      NativeCupertinoHttp _lib,
      ffi.Pointer<ffi.Void> bytes,
      int length,
      bool b) {
    final _ret = _lib._objc_msgSend_122(_lib._class_NSMutableData1,
        _lib._sel_dataWithBytesNoCopy_length_freeWhenDone_1, bytes, length, b);
    return NSMutableData._(_ret, _lib, retain: false, release: true);
  }

  static NSMutableData dataWithContentsOfFile_options_error_(
      NativeCupertinoHttp _lib,
      NSString? path,
      int readOptionsMask,
      ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr) {
    final _ret = _lib._objc_msgSend_123(
        _lib._class_NSMutableData1,
        _lib._sel_dataWithContentsOfFile_options_error_1,
        path?._id ?? ffi.nullptr,
        readOptionsMask,
        errorPtr);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableData dataWithContentsOfURL_options_error_(
      NativeCupertinoHttp _lib,
      NSURL? url,
      int readOptionsMask,
      ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr) {
    final _ret = _lib._objc_msgSend_124(
        _lib._class_NSMutableData1,
        _lib._sel_dataWithContentsOfURL_options_error_1,
        url?._id ?? ffi.nullptr,
        readOptionsMask,
        errorPtr);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableData dataWithContentsOfFile_(
      NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_29(_lib._class_NSMutableData1,
        _lib._sel_dataWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableData dataWithContentsOfURL_(
      NativeCupertinoHttp _lib, NSURL? url) {
    final _ret = _lib._objc_msgSend_110(_lib._class_NSMutableData1,
        _lib._sel_dataWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableData dataWithData_(NativeCupertinoHttp _lib, NSData? data) {
    final _ret = _lib._objc_msgSend_126(_lib._class_NSMutableData1,
        _lib._sel_dataWithData_1, data?._id ?? ffi.nullptr);
    return NSMutableData._(_ret, _lib, retain: true, release: true);
  }

  static NSObject dataWithContentsOfMappedFile_(
      NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_29(_lib._class_NSMutableData1,
        _lib._sel_dataWithContentsOfMappedFile_1, path?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableData new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableData1, _lib._sel_new1);
    return NSMutableData._(_ret, _lib, retain: false, release: true);
  }

  static NSMutableData alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableData1, _lib._sel_alloc1);
    return NSMutableData._(_ret, _lib, retain: false, release: true);
  }
}

/// Purgeable Data
class NSPurgeableData extends NSMutableData {
  NSPurgeableData._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSPurgeableData] that points to the same underlying object as [other].
  static NSPurgeableData castFrom<T extends _ObjCWrapper>(T other) {
    return NSPurgeableData._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSPurgeableData] that wraps the given raw object pointer.
  static NSPurgeableData castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSPurgeableData._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSPurgeableData].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSPurgeableData1);
  }

  static NSPurgeableData dataWithCapacity_(
      NativeCupertinoHttp _lib, int aNumItems) {
    final _ret = _lib._objc_msgSend_146(
        _lib._class_NSPurgeableData1, _lib._sel_dataWithCapacity_1, aNumItems);
    return NSPurgeableData._(_ret, _lib, retain: true, release: true);
  }

  static NSPurgeableData dataWithLength_(NativeCupertinoHttp _lib, int length) {
    final _ret = _lib._objc_msgSend_146(
        _lib._class_NSPurgeableData1, _lib._sel_dataWithLength_1, length);
    return NSPurgeableData._(_ret, _lib, retain: true, release: true);
  }

  static NSPurgeableData data(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSPurgeableData1, _lib._sel_data1);
    return NSPurgeableData._(_ret, _lib, retain: true, release: true);
  }

  static NSPurgeableData dataWithBytes_length_(
      NativeCupertinoHttp _lib, ffi.Pointer<ffi.Void> bytes, int length) {
    final _ret = _lib._objc_msgSend_121(_lib._class_NSPurgeableData1,
        _lib._sel_dataWithBytes_length_1, bytes, length);
    return NSPurgeableData._(_ret, _lib, retain: true, release: true);
  }

  static NSPurgeableData dataWithBytesNoCopy_length_(
      NativeCupertinoHttp _lib, ffi.Pointer<ffi.Void> bytes, int length) {
    final _ret = _lib._objc_msgSend_121(_lib._class_NSPurgeableData1,
        _lib._sel_dataWithBytesNoCopy_length_1, bytes, length);
    return NSPurgeableData._(_ret, _lib, retain: false, release: true);
  }

  static NSPurgeableData dataWithBytesNoCopy_length_freeWhenDone_(
      NativeCupertinoHttp _lib,
      ffi.Pointer<ffi.Void> bytes,
      int length,
      bool b) {
    final _ret = _lib._objc_msgSend_122(_lib._class_NSPurgeableData1,
        _lib._sel_dataWithBytesNoCopy_length_freeWhenDone_1, bytes, length, b);
    return NSPurgeableData._(_ret, _lib, retain: false, release: true);
  }

  static NSPurgeableData dataWithContentsOfFile_options_error_(
      NativeCupertinoHttp _lib,
      NSString? path,
      int readOptionsMask,
      ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr) {
    final _ret = _lib._objc_msgSend_123(
        _lib._class_NSPurgeableData1,
        _lib._sel_dataWithContentsOfFile_options_error_1,
        path?._id ?? ffi.nullptr,
        readOptionsMask,
        errorPtr);
    return NSPurgeableData._(_ret, _lib, retain: true, release: true);
  }

  static NSPurgeableData dataWithContentsOfURL_options_error_(
      NativeCupertinoHttp _lib,
      NSURL? url,
      int readOptionsMask,
      ffi.Pointer<ffi.Pointer<ObjCObject>> errorPtr) {
    final _ret = _lib._objc_msgSend_124(
        _lib._class_NSPurgeableData1,
        _lib._sel_dataWithContentsOfURL_options_error_1,
        url?._id ?? ffi.nullptr,
        readOptionsMask,
        errorPtr);
    return NSPurgeableData._(_ret, _lib, retain: true, release: true);
  }

  static NSPurgeableData dataWithContentsOfFile_(
      NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_29(_lib._class_NSPurgeableData1,
        _lib._sel_dataWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSPurgeableData._(_ret, _lib, retain: true, release: true);
  }

  static NSPurgeableData dataWithContentsOfURL_(
      NativeCupertinoHttp _lib, NSURL? url) {
    final _ret = _lib._objc_msgSend_110(_lib._class_NSPurgeableData1,
        _lib._sel_dataWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSPurgeableData._(_ret, _lib, retain: true, release: true);
  }

  static NSPurgeableData dataWithData_(NativeCupertinoHttp _lib, NSData? data) {
    final _ret = _lib._objc_msgSend_126(_lib._class_NSPurgeableData1,
        _lib._sel_dataWithData_1, data?._id ?? ffi.nullptr);
    return NSPurgeableData._(_ret, _lib, retain: true, release: true);
  }

  static NSObject dataWithContentsOfMappedFile_(
      NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_29(_lib._class_NSPurgeableData1,
        _lib._sel_dataWithContentsOfMappedFile_1, path?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSPurgeableData new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSPurgeableData1, _lib._sel_new1);
    return NSPurgeableData._(_ret, _lib, retain: false, release: true);
  }

  static NSPurgeableData alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSPurgeableData1, _lib._sel_alloc1);
    return NSPurgeableData._(_ret, _lib, retain: false, release: true);
  }
}

/// Mutable Dictionary
class NSMutableDictionary extends NSDictionary {
  NSMutableDictionary._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSMutableDictionary] that points to the same underlying object as [other].
  static NSMutableDictionary castFrom<T extends _ObjCWrapper>(T other) {
    return NSMutableDictionary._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSMutableDictionary] that wraps the given raw object pointer.
  static NSMutableDictionary castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSMutableDictionary._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSMutableDictionary].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSMutableDictionary1);
  }

  void removeObjectForKey_(NSObject aKey) {
    return _lib._objc_msgSend_109(
        _id, _lib._sel_removeObjectForKey_1, aKey._id);
  }

  void setObject_forKey_(NSObject anObject, NSObject aKey) {
    return _lib._objc_msgSend_202(
        _id, _lib._sel_setObject_forKey_1, anObject._id, aKey._id);
  }

  NSMutableDictionary init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  NSMutableDictionary initWithCapacity_(int numItems) {
    final _ret =
        _lib._objc_msgSend_146(_id, _lib._sel_initWithCapacity_1, numItems);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  NSMutableDictionary initWithCoder_(NSCoder? coder) {
    final _ret = _lib._objc_msgSend_14(
        _id, _lib._sel_initWithCoder_1, coder?._id ?? ffi.nullptr);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  void addEntriesFromDictionary_(NSDictionary? otherDictionary) {
    return _lib._objc_msgSend_203(_id, _lib._sel_addEntriesFromDictionary_1,
        otherDictionary?._id ?? ffi.nullptr);
  }

  void removeAllObjects() {
    return _lib._objc_msgSend_1(_id, _lib._sel_removeAllObjects1);
  }

  void removeObjectsForKeys_(NSArray? keyArray) {
    return _lib._objc_msgSend_162(
        _id, _lib._sel_removeObjectsForKeys_1, keyArray?._id ?? ffi.nullptr);
  }

  void setDictionary_(NSDictionary? otherDictionary) {
    return _lib._objc_msgSend_203(
        _id, _lib._sel_setDictionary_1, otherDictionary?._id ?? ffi.nullptr);
  }

  void setObject_forKeyedSubscript_(NSObject obj, NSObject key) {
    return _lib._objc_msgSend_202(
        _id, _lib._sel_setObject_forKeyedSubscript_1, obj._id, key._id);
  }

  static NSMutableDictionary dictionaryWithCapacity_(
      NativeCupertinoHttp _lib, int numItems) {
    final _ret = _lib._objc_msgSend_146(_lib._class_NSMutableDictionary1,
        _lib._sel_dictionaryWithCapacity_1, numItems);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableDictionary dictionaryWithContentsOfFile_(
      NativeCupertinoHttp _lib, NSString? path) {
    final _ret = _lib._objc_msgSend_204(_lib._class_NSMutableDictionary1,
        _lib._sel_dictionaryWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableDictionary dictionaryWithContentsOfURL_(
      NativeCupertinoHttp _lib, NSURL? url) {
    final _ret = _lib._objc_msgSend_205(_lib._class_NSMutableDictionary1,
        _lib._sel_dictionaryWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  NSMutableDictionary initWithContentsOfFile_(NSString? path) {
    final _ret = _lib._objc_msgSend_204(
        _id, _lib._sel_initWithContentsOfFile_1, path?._id ?? ffi.nullptr);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  NSMutableDictionary initWithContentsOfURL_(NSURL? url) {
    final _ret = _lib._objc_msgSend_205(
        _id, _lib._sel_initWithContentsOfURL_1, url?._id ?? ffi.nullptr);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Create a mutable dictionary which is optimized for dealing with a known set of keys.
  /// Keys that are not in the key set can still be set into the dictionary, but that usage is not optimal.
  /// As with any dictionary, the keys must be copyable.
  /// If keyset is nil, an exception is thrown.
  /// If keyset is not an object returned by +sharedKeySetForKeys:, an exception is thrown.
  static NSMutableDictionary dictionaryWithSharedKeySet_(
      NativeCupertinoHttp _lib, NSObject keyset) {
    final _ret = _lib._objc_msgSend_206(_lib._class_NSMutableDictionary1,
        _lib._sel_dictionaryWithSharedKeySet_1, keyset._id);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableDictionary dictionary(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSMutableDictionary1, _lib._sel_dictionary1);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableDictionary dictionaryWithObject_forKey_(
      NativeCupertinoHttp _lib, NSObject object, NSObject key) {
    final _ret = _lib._objc_msgSend_80(_lib._class_NSMutableDictionary1,
        _lib._sel_dictionaryWithObject_forKey_1, object._id, key._id);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableDictionary dictionaryWithObjects_forKeys_count_(
      NativeCupertinoHttp _lib,
      ffi.Pointer<ffi.Pointer<ObjCObject>> objects,
      ffi.Pointer<ffi.Pointer<ObjCObject>> keys,
      int cnt) {
    final _ret = _lib._objc_msgSend_81(_lib._class_NSMutableDictionary1,
        _lib._sel_dictionaryWithObjects_forKeys_count_1, objects, keys, cnt);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableDictionary dictionaryWithObjectsAndKeys_(
      NativeCupertinoHttp _lib, NSObject firstObject) {
    final _ret = _lib._objc_msgSend_71(_lib._class_NSMutableDictionary1,
        _lib._sel_dictionaryWithObjectsAndKeys_1, firstObject._id);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableDictionary dictionaryWithDictionary_(
      NativeCupertinoHttp _lib, NSDictionary? dict) {
    final _ret = _lib._objc_msgSend_82(_lib._class_NSMutableDictionary1,
        _lib._sel_dictionaryWithDictionary_1, dict?._id ?? ffi.nullptr);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableDictionary dictionaryWithObjects_forKeys_(
      NativeCupertinoHttp _lib, NSArray? objects, NSArray? keys) {
    final _ret = _lib._objc_msgSend_83(
        _lib._class_NSMutableDictionary1,
        _lib._sel_dictionaryWithObjects_forKeys_1,
        objects?._id ?? ffi.nullptr,
        keys?._id ?? ffi.nullptr);
    return NSMutableDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Reads dictionary stored in NSPropertyList format from the specified url.
  static NSDictionary dictionaryWithContentsOfURL_error_(
      NativeCupertinoHttp _lib,
      NSURL? url,
      ffi.Pointer<ffi.Pointer<ObjCObject>> error) {
    final _ret = _lib._objc_msgSend_85(
        _lib._class_NSMutableDictionary1,
        _lib._sel_dictionaryWithContentsOfURL_error_1,
        url?._id ?? ffi.nullptr,
        error);
    return NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Use this method to create a key set to pass to +dictionaryWithSharedKeySet:.
  /// The keys are copied from the array and must be copyable.
  /// If the array parameter is nil or not an NSArray, an exception is thrown.
  /// If the array of keys is empty, an empty key set is returned.
  /// The array of keys may contain duplicates, which are ignored (it is undefined which object of each duplicate pair is used).
  /// As for any usage of hashing, is recommended that the keys have a well-distributed implementation of -hash, and the hash codes must satisfy the hash/isEqual: invariant.
  /// Keys with duplicate hash codes are allowed, but will cause lower performance and increase memory usage.
  static NSObject sharedKeySetForKeys_(
      NativeCupertinoHttp _lib, NSArray? keys) {
    final _ret = _lib._objc_msgSend_86(_lib._class_NSMutableDictionary1,
        _lib._sel_sharedKeySetForKeys_1, keys?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableDictionary new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableDictionary1, _lib._sel_new1);
    return NSMutableDictionary._(_ret, _lib, retain: false, release: true);
  }

  static NSMutableDictionary alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSMutableDictionary1, _lib._sel_alloc1);
    return NSMutableDictionary._(_ret, _lib, retain: false, release: true);
  }
}

/// !
/// @enum NSURLRequestCachePolicy
///
/// @discussion The NSURLRequestCachePolicy enum defines constants that
/// can be used to specify the type of interactions that take place with
/// the caching system when the URL loading system processes a request.
/// Specifically, these constants cover interactions that have to do
/// with whether already-existing cache data is returned to satisfy a
/// URL load request.
///
/// @constant NSURLRequestUseProtocolCachePolicy Specifies that the
/// caching logic defined in the protocol implementation, if any, is
/// used for a particular URL load request. This is the default policy
/// for URL load requests.
///
/// @constant NSURLRequestReloadIgnoringLocalCacheData Specifies that the
/// data for the URL load should be loaded from the origin source. No
/// existing local cache data, regardless of its freshness or validity,
/// should be used to satisfy a URL load request.
///
/// @constant NSURLRequestReloadIgnoringLocalAndRemoteCacheData Specifies that
/// not only should the local cache data be ignored, but that proxies and
/// other intermediates should be instructed to disregard their caches
/// so far as the protocol allows.
///
/// @constant NSURLRequestReloadIgnoringCacheData Older name for
/// NSURLRequestReloadIgnoringLocalCacheData.
///
/// @constant NSURLRequestReturnCacheDataElseLoad Specifies that the
/// existing cache data should be used to satisfy a URL load request,
/// regardless of its age or expiration date. However, if there is no
/// existing data in the cache corresponding to a URL load request,
/// the URL is loaded from the origin source.
///
/// @constant NSURLRequestReturnCacheDataDontLoad Specifies that the
/// existing cache data should be used to satisfy a URL load request,
/// regardless of its age or expiration date. However, if there is no
/// existing data in the cache corresponding to a URL load request, no
/// attempt is made to load the URL from the origin source, and the
/// load is considered to have failed. This constant specifies a
/// behavior that is similar to an "offline" mode.
///
/// @constant NSURLRequestReloadRevalidatingCacheData Specifies that
/// the existing cache data may be used provided the origin source
/// confirms its validity, otherwise the URL is loaded from the
/// origin source.
abstract class NSURLRequestCachePolicy {
  static const int NSURLRequestUseProtocolCachePolicy = 0;
  static const int NSURLRequestReloadIgnoringLocalCacheData = 1;
  static const int NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4;
  static const int NSURLRequestReloadIgnoringCacheData = 1;
  static const int NSURLRequestReturnCacheDataElseLoad = 2;
  static const int NSURLRequestReturnCacheDataDontLoad = 3;
  static const int NSURLRequestReloadRevalidatingCacheData = 5;
}

/// !
/// @enum NSURLRequestNetworkServiceType
///
/// @discussion The NSURLRequestNetworkServiceType enum defines constants that
/// can be used to specify the service type to associate with this request.  The
/// service type is used to provide the networking layers a hint of the purpose
/// of the request.
///
/// @constant NSURLNetworkServiceTypeDefault Is the default value for an NSURLRequest
/// when created.  This value should be left unchanged for the vast majority of requests.
///
/// @constant NSURLNetworkServiceTypeVoIP Specifies that the request is for voice over IP
/// control traffic.
///
/// @constant NSURLNetworkServiceTypeVideo Specifies that the request is for video
/// traffic.
///
/// @constant NSURLNetworkServiceTypeBackground Specifies that the request is for background
/// traffic (such as a file download).
///
/// @constant NSURLNetworkServiceTypeVoice Specifies that the request is for voice data.
///
/// @constant NSURLNetworkServiceTypeResponsiveData Specifies that the request is for responsive (time sensitive) data.
///
/// @constant NSURLNetworkServiceTypeAVStreaming Specifies that the request is streaming audio/video data.
///
/// @constant NSURLNetworkServiceTypeResponsiveAV Specifies that the request is for responsive (time sensitive) audio/video data.
///
/// @constant NSURLNetworkServiceTypeCallSignaling Specifies that the request is for call signaling.
abstract class NSURLRequestNetworkServiceType {
  /// Standard internet traffic
  static const int NSURLNetworkServiceTypeDefault = 0;

  /// Voice over IP control traffic
  static const int NSURLNetworkServiceTypeVoIP = 1;

  /// Video traffic
  static const int NSURLNetworkServiceTypeVideo = 2;

  /// Background traffic
  static const int NSURLNetworkServiceTypeBackground = 3;

  /// Voice data
  static const int NSURLNetworkServiceTypeVoice = 4;

  /// Responsive data
  static const int NSURLNetworkServiceTypeResponsiveData = 6;

  /// Multimedia Audio/Video Streaming
  static const int NSURLNetworkServiceTypeAVStreaming = 8;

  /// Responsive Multimedia Audio/Video
  static const int NSURLNetworkServiceTypeResponsiveAV = 9;

  /// Call Signaling
  static const int NSURLNetworkServiceTypeCallSignaling = 11;
}

/// !
/// @class NSURLRequest
///
/// @abstract An NSURLRequest object represents a URL load request in a
/// manner independent of protocol and URL scheme.
///
/// @discussion NSURLRequest encapsulates two basic data elements about
/// a URL load request:
/// <ul>
/// <li>The URL to load.
/// <li>The policy to use when consulting the URL content cache made
/// available by the implementation.
/// </ul>
/// In addition, NSURLRequest is designed to be extended to support
/// protocol-specific data by adding categories to access a property
/// object provided in an interface targeted at protocol implementors.
/// <ul>
/// <li>Protocol implementors should direct their attention to the
/// NSURLRequestExtensibility category on NSURLRequest for more
/// information on how to provide extensions on NSURLRequest to
/// support protocol-specific request information.
/// <li>Clients of this API who wish to create NSURLRequest objects to
/// load URL content should consult the protocol-specific NSURLRequest
/// categories that are available. The NSHTTPURLRequest category on
/// NSURLRequest is an example.
/// </ul>
/// <p>
/// Objects of this class are used to create NSURLConnection instances,
/// which can are used to perform the load of a URL, or as input to the
/// NSURLConnection class method which performs synchronous loads.
class NSURLRequest extends NSObject {
  NSURLRequest._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLRequest] that points to the same underlying object as [other].
  static NSURLRequest castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLRequest._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLRequest] that wraps the given raw object pointer.
  static NSURLRequest castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLRequest._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLRequest].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURLRequest1);
  }

  /// !
  /// @method requestWithURL:
  /// @abstract Allocates and initializes an NSURLRequest with the given
  /// URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSURLRequest requestWithURL_(NativeCupertinoHttp _lib, NSURL? URL) {
    final _ret = _lib._objc_msgSend_110(_lib._class_NSURLRequest1,
        _lib._sel_requestWithURL_1, URL?._id ?? ffi.nullptr);
    return NSURLRequest._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @property supportsSecureCoding
  /// @abstract Indicates that NSURLRequest implements the NSSecureCoding protocol.
  /// @result A BOOL value set to YES.
  static bool getSupportsSecureCoding(NativeCupertinoHttp _lib) {
    return _lib._objc_msgSend_11(
        _lib._class_NSURLRequest1, _lib._sel_supportsSecureCoding1);
  }

  /// !
  /// @method requestWithURL:cachePolicy:timeoutInterval:
  /// @abstract Allocates and initializes a NSURLRequest with the given
  /// URL and cache policy.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSURLRequest requestWithURL_cachePolicy_timeoutInterval_(
      NativeCupertinoHttp _lib,
      NSURL? URL,
      int cachePolicy,
      double timeoutInterval) {
    final _ret = _lib._objc_msgSend_207(
        _lib._class_NSURLRequest1,
        _lib._sel_requestWithURL_cachePolicy_timeoutInterval_1,
        URL?._id ?? ffi.nullptr,
        cachePolicy,
        timeoutInterval);
    return NSURLRequest._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @method initWithURL:
  /// @abstract Initializes an NSURLRequest with the given URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result An initialized NSURLRequest.
  NSURLRequest initWithURL_(NSURL? URL) {
    final _ret = _lib._objc_msgSend_110(
        _id, _lib._sel_initWithURL_1, URL?._id ?? ffi.nullptr);
    return NSURLRequest._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @method initWithURL:
  /// @abstract Initializes an NSURLRequest with the given URL and
  /// cache policy.
  /// @discussion This is the designated initializer for the
  /// NSURLRequest class.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result An initialized NSURLRequest.
  NSURLRequest initWithURL_cachePolicy_timeoutInterval_(
      NSURL? URL, int cachePolicy, double timeoutInterval) {
    final _ret = _lib._objc_msgSend_207(
        _id,
        _lib._sel_initWithURL_cachePolicy_timeoutInterval_1,
        URL?._id ?? ffi.nullptr,
        cachePolicy,
        timeoutInterval);
    return NSURLRequest._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the URL of the receiver.
  /// @result The URL of the receiver.
  NSURL? get URL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_URL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the cache policy of the receiver.
  /// @result The cache policy of the receiver.
  int get cachePolicy {
    return _lib._objc_msgSend_208(_id, _lib._sel_cachePolicy1);
  }

  /// !
  /// @abstract Returns the timeout interval of the receiver.
  /// @discussion The timeout interval specifies the limit on the idle
  /// interval alloted to a request in the process of loading. The "idle
  /// interval" is defined as the period of time that has passed since the
  /// last instance of load activity occurred for a request that is in the
  /// process of loading. Hence, when an instance of load activity occurs
  /// (e.g. bytes are received from the network for a request), the idle
  /// interval for a request is reset to 0. If the idle interval ever
  /// becomes greater than or equal to the timeout interval, the request
  /// is considered to have timed out. This timeout interval is measured
  /// in seconds.
  /// @result The timeout interval of the receiver.
  double get timeoutInterval {
    return _lib._objc_msgSend_65(_id, _lib._sel_timeoutInterval1);
  }

  /// !
  /// @abstract The main document URL associated with this load.
  /// @discussion This URL is used for the cookie "same domain as main
  /// document" policy. There may also be other future uses.
  /// See setMainDocumentURL:
  /// NOTE: In the current implementation, this value is unused by the
  /// framework. A fully functional version of this method will be available
  /// in the future.
  /// @result The main document URL.
  NSURL? get mainDocumentURL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_mainDocumentURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the NSURLRequestNetworkServiceType associated with this request.
  /// @discussion  This will return NSURLNetworkServiceTypeDefault for requests that have
  /// not explicitly set a networkServiceType (using the setNetworkServiceType method).
  /// @result The NSURLRequestNetworkServiceType associated with this request.
  int get networkServiceType {
    return _lib._objc_msgSend_209(_id, _lib._sel_networkServiceType1);
  }

  /// !
  /// @abstract returns whether a connection created with this request is allowed to use
  /// the built in cellular radios (if present).
  /// @result YES if the receiver is allowed to use the built in cellular radios to
  /// satify the request, NO otherwise.
  bool get allowsCellularAccess {
    return _lib._objc_msgSend_11(_id, _lib._sel_allowsCellularAccess1);
  }

  /// !
  /// @abstract returns whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as expensive.
  /// @result YES if the receiver is allowed to use an interface marked as expensive to
  /// satify the request, NO otherwise.
  bool get allowsExpensiveNetworkAccess {
    return _lib._objc_msgSend_11(_id, _lib._sel_allowsExpensiveNetworkAccess1);
  }

  /// !
  /// @abstract returns whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as constrained.
  /// @result YES if the receiver is allowed to use an interface marked as constrained to
  /// satify the request, NO otherwise.
  bool get allowsConstrainedNetworkAccess {
    return _lib._objc_msgSend_11(
        _id, _lib._sel_allowsConstrainedNetworkAccess1);
  }

  /// !
  /// @abstract returns whether we assume that server supports HTTP/3. Enables QUIC
  /// racing without HTTP/3 service discovery.
  /// @result YES if server endpoint is known to support HTTP/3. Defaults to NO.
  /// The default may be YES in a future OS update.
  bool get assumesHTTP3Capable {
    return _lib._objc_msgSend_11(_id, _lib._sel_assumesHTTP3Capable1);
  }

  /// !
  /// @abstract Returns the HTTP request method of the receiver.
  /// @result the HTTP request method of the receiver.
  NSString? get HTTPMethod {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_HTTPMethod1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns a dictionary containing all the HTTP header fields
  /// of the receiver.
  /// @result a dictionary containing all the HTTP header fields of the
  /// receiver.
  NSDictionary? get allHTTPHeaderFields {
    final _ret = _lib._objc_msgSend_89(_id, _lib._sel_allHTTPHeaderFields1);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @method valueForHTTPHeaderField:
  /// @abstract Returns the value which corresponds to the given header
  /// field. Note that, in keeping with the HTTP RFC, HTTP header field
  /// names are case-insensitive.
  /// @param field the header field name to use for the lookup
  /// (case-insensitive).
  /// @result the value associated with the given header field, or nil if
  /// there is no value associated with the given header field.
  NSString valueForHTTPHeaderField_(NSString? field) {
    final _ret = _lib._objc_msgSend_149(
        _id, _lib._sel_valueForHTTPHeaderField_1, field?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the request body data of the receiver.
  /// @discussion This data is sent as the message body of the request, as
  /// in done in an HTTP POST request.
  /// @result The request body data of the receiver.
  NSData? get HTTPBody {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_HTTPBody1);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the request body stream of the receiver
  /// if any has been set
  /// @discussion The stream is returned for examination only; it is
  /// not safe for the caller to manipulate the stream in any way.  Also
  /// note that the HTTPBodyStream and HTTPBody are mutually exclusive - only
  /// one can be set on a given request.  Also note that the body stream is
  /// preserved across copies, but is LOST when the request is coded via the
  /// NSCoding protocol
  /// @result The request body stream of the receiver.
  NSInputStream? get HTTPBodyStream {
    final _ret = _lib._objc_msgSend_210(_id, _lib._sel_HTTPBodyStream1);
    return _ret.address == 0
        ? null
        : NSInputStream._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Determine whether default cookie handling will happen for
  /// this request.
  /// @discussion NOTE: This value is not used prior to 10.3
  /// @result YES if cookies will be sent with and set for this request;
  /// otherwise NO.
  bool get HTTPShouldHandleCookies {
    return _lib._objc_msgSend_11(_id, _lib._sel_HTTPShouldHandleCookies1);
  }

  /// !
  /// @abstract Reports whether the receiver is not expected to wait for the
  /// previous response before transmitting.
  /// @result YES if the receiver should transmit before the previous response
  /// is received.  NO if the receiver should wait for the previous response
  /// before transmitting.
  bool get HTTPShouldUsePipelining {
    return _lib._objc_msgSend_11(_id, _lib._sel_HTTPShouldUsePipelining1);
  }

  static NSURLRequest new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLRequest1, _lib._sel_new1);
    return NSURLRequest._(_ret, _lib, retain: false, release: true);
  }

  static NSURLRequest alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLRequest1, _lib._sel_alloc1);
    return NSURLRequest._(_ret, _lib, retain: false, release: true);
  }
}

typedef NSTimeInterval = ffi.Double;

class NSInputStream extends _ObjCWrapper {
  NSInputStream._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSInputStream] that points to the same underlying object as [other].
  static NSInputStream castFrom<T extends _ObjCWrapper>(T other) {
    return NSInputStream._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSInputStream] that wraps the given raw object pointer.
  static NSInputStream castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSInputStream._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSInputStream].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSInputStream1);
  }
}

/// !
/// @class NSMutableURLRequest
///
/// @abstract An NSMutableURLRequest object represents a mutable URL load
/// request in a manner independent of protocol and URL scheme.
///
/// @discussion This specialization of NSURLRequest is provided to aid
/// developers who may find it more convenient to mutate a single request
/// object for a series of URL loads instead of creating an immutable
/// NSURLRequest for each load. This programming model is supported by
/// the following contract stipulation between NSMutableURLRequest and
/// NSURLConnection: NSURLConnection makes a deep copy of each
/// NSMutableURLRequest object passed to one of its initializers.
/// <p>NSMutableURLRequest is designed to be extended to support
/// protocol-specific data by adding categories to access a property
/// object provided in an interface targeted at protocol implementors.
/// <ul>
/// <li>Protocol implementors should direct their attention to the
/// NSMutableURLRequestExtensibility category on
/// NSMutableURLRequest for more information on how to provide
/// extensions on NSMutableURLRequest to support protocol-specific
/// request information.
/// <li>Clients of this API who wish to create NSMutableURLRequest
/// objects to load URL content should consult the protocol-specific
/// NSMutableURLRequest categories that are available. The
/// NSMutableHTTPURLRequest category on NSMutableURLRequest is an
/// example.
/// </ul>
class NSMutableURLRequest extends NSURLRequest {
  NSMutableURLRequest._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSMutableURLRequest] that points to the same underlying object as [other].
  static NSMutableURLRequest castFrom<T extends _ObjCWrapper>(T other) {
    return NSMutableURLRequest._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSMutableURLRequest] that wraps the given raw object pointer.
  static NSMutableURLRequest castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSMutableURLRequest._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSMutableURLRequest].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSMutableURLRequest1);
  }

  /// !
  /// @abstract The URL of the receiver.
  @override
  NSURL? get URL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_URL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract The URL of the receiver.
  set URL(NSURL? value) {
    _lib._objc_msgSend_211(_id, _lib._sel_setURL_1, value?._id ?? ffi.nullptr);
  }

  /// !
  /// @abstract The cache policy of the receiver.
  @override
  int get cachePolicy {
    return _lib._objc_msgSend_208(_id, _lib._sel_cachePolicy1);
  }

  /// !
  /// @abstract The cache policy of the receiver.
  set cachePolicy(int value) {
    _lib._objc_msgSend_212(_id, _lib._sel_setCachePolicy_1, value);
  }

  /// !
  /// @abstract Sets the timeout interval of the receiver.
  /// @discussion The timeout interval specifies the limit on the idle
  /// interval allotted to a request in the process of loading. The "idle
  /// interval" is defined as the period of time that has passed since the
  /// last instance of load activity occurred for a request that is in the
  /// process of loading. Hence, when an instance of load activity occurs
  /// (e.g. bytes are received from the network for a request), the idle
  /// interval for a request is reset to 0. If the idle interval ever
  /// becomes greater than or equal to the timeout interval, the request
  /// is considered to have timed out. This timeout interval is measured
  /// in seconds.
  @override
  double get timeoutInterval {
    return _lib._objc_msgSend_65(_id, _lib._sel_timeoutInterval1);
  }

  /// !
  /// @abstract Sets the timeout interval of the receiver.
  /// @discussion The timeout interval specifies the limit on the idle
  /// interval allotted to a request in the process of loading. The "idle
  /// interval" is defined as the period of time that has passed since the
  /// last instance of load activity occurred for a request that is in the
  /// process of loading. Hence, when an instance of load activity occurs
  /// (e.g. bytes are received from the network for a request), the idle
  /// interval for a request is reset to 0. If the idle interval ever
  /// becomes greater than or equal to the timeout interval, the request
  /// is considered to have timed out. This timeout interval is measured
  /// in seconds.
  set timeoutInterval(double value) {
    _lib._objc_msgSend_213(_id, _lib._sel_setTimeoutInterval_1, value);
  }

  /// !
  /// @abstract Sets the main document URL
  /// @discussion The caller should pass the URL for an appropriate main
  /// document, if known. For example, when loading a web page, the URL
  /// of the main html document for the top-level frame should be
  /// passed.  This main document will be used to implement the cookie
  /// "only from same domain as main document" policy, and possibly
  /// other things in the future.
  /// NOTE: In the current implementation, the passed-in value is unused by the
  /// framework. A fully functional version of this method will be available
  /// in the future.
  @override
  NSURL? get mainDocumentURL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_mainDocumentURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the main document URL
  /// @discussion The caller should pass the URL for an appropriate main
  /// document, if known. For example, when loading a web page, the URL
  /// of the main html document for the top-level frame should be
  /// passed.  This main document will be used to implement the cookie
  /// "only from same domain as main document" policy, and possibly
  /// other things in the future.
  /// NOTE: In the current implementation, the passed-in value is unused by the
  /// framework. A fully functional version of this method will be available
  /// in the future.
  set mainDocumentURL(NSURL? value) {
    _lib._objc_msgSend_211(
        _id, _lib._sel_setMainDocumentURL_1, value?._id ?? ffi.nullptr);
  }

  /// !
  /// @abstract Sets the NSURLRequestNetworkServiceType to associate with this request
  /// @discussion This method is used to provide the network layers with a hint as to the purpose
  /// of the request.  Most clients should not need to use this method.
  @override
  int get networkServiceType {
    return _lib._objc_msgSend_209(_id, _lib._sel_networkServiceType1);
  }

  /// !
  /// @abstract Sets the NSURLRequestNetworkServiceType to associate with this request
  /// @discussion This method is used to provide the network layers with a hint as to the purpose
  /// of the request.  Most clients should not need to use this method.
  set networkServiceType(int value) {
    _lib._objc_msgSend_214(_id, _lib._sel_setNetworkServiceType_1, value);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// the built in cellular radios (if present).
  /// @discussion NO if the receiver should not be allowed to use the built in
  /// cellular radios to satisfy the request, YES otherwise.  The default is YES.
  @override
  bool get allowsCellularAccess {
    return _lib._objc_msgSend_11(_id, _lib._sel_allowsCellularAccess1);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// the built in cellular radios (if present).
  /// @discussion NO if the receiver should not be allowed to use the built in
  /// cellular radios to satisfy the request, YES otherwise.  The default is YES.
  set allowsCellularAccess(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setAllowsCellularAccess_1, value);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as expensive.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as expensive to
  /// satify the request, YES otherwise.
  @override
  bool get allowsExpensiveNetworkAccess {
    return _lib._objc_msgSend_11(_id, _lib._sel_allowsExpensiveNetworkAccess1);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as expensive.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as expensive to
  /// satify the request, YES otherwise.
  set allowsExpensiveNetworkAccess(bool value) {
    _lib._objc_msgSend_215(
        _id, _lib._sel_setAllowsExpensiveNetworkAccess_1, value);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as constrained.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as constrained to
  /// satify the request, YES otherwise.
  @override
  bool get allowsConstrainedNetworkAccess {
    return _lib._objc_msgSend_11(
        _id, _lib._sel_allowsConstrainedNetworkAccess1);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as constrained.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as constrained to
  /// satify the request, YES otherwise.
  set allowsConstrainedNetworkAccess(bool value) {
    _lib._objc_msgSend_215(
        _id, _lib._sel_setAllowsConstrainedNetworkAccess_1, value);
  }

  /// !
  /// @abstract returns whether we assume that server supports HTTP/3. Enables QUIC
  /// racing without HTTP/3 service discovery.
  /// @result YES if server endpoint is known to support HTTP/3. Defaults to NO.
  /// The default may be YES in a future OS update.
  @override
  bool get assumesHTTP3Capable {
    return _lib._objc_msgSend_11(_id, _lib._sel_assumesHTTP3Capable1);
  }

  /// !
  /// @abstract returns whether we assume that server supports HTTP/3. Enables QUIC
  /// racing without HTTP/3 service discovery.
  /// @result YES if server endpoint is known to support HTTP/3. Defaults to NO.
  /// The default may be YES in a future OS update.
  set assumesHTTP3Capable(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setAssumesHTTP3Capable_1, value);
  }

  /// !
  /// @abstract Sets the HTTP request method of the receiver.
  @override
  NSString? get HTTPMethod {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_HTTPMethod1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the HTTP request method of the receiver.
  set HTTPMethod(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setHTTPMethod_1, value?._id ?? ffi.nullptr);
  }

  /// !
  /// @abstract Sets the HTTP header fields of the receiver to the given
  /// dictionary.
  /// @discussion This method replaces all header fields that may have
  /// existed before this method call.
  /// <p>Since HTTP header fields must be string values, each object and
  /// key in the dictionary passed to this method must answer YES when
  /// sent an <tt>-isKindOfClass:[NSString class]</tt> message. If either
  /// the key or value for a key-value pair answers NO when sent this
  /// message, the key-value pair is skipped.
  @override
  NSDictionary? get allHTTPHeaderFields {
    final _ret = _lib._objc_msgSend_89(_id, _lib._sel_allHTTPHeaderFields1);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the HTTP header fields of the receiver to the given
  /// dictionary.
  /// @discussion This method replaces all header fields that may have
  /// existed before this method call.
  /// <p>Since HTTP header fields must be string values, each object and
  /// key in the dictionary passed to this method must answer YES when
  /// sent an <tt>-isKindOfClass:[NSString class]</tt> message. If either
  /// the key or value for a key-value pair answers NO when sent this
  /// message, the key-value pair is skipped.
  set allHTTPHeaderFields(NSDictionary? value) {
    _lib._objc_msgSend_217(
        _id, _lib._sel_setAllHTTPHeaderFields_1, value?._id ?? ffi.nullptr);
  }

  /// !
  /// @method setValue:forHTTPHeaderField:
  /// @abstract Sets the value of the given HTTP header field.
  /// @discussion If a value was previously set for the given header
  /// field, that value is replaced with the given value. Note that, in
  /// keeping with the HTTP RFC, HTTP header field names are
  /// case-insensitive.
  /// @param value the header field value.
  /// @param field the header field name (case-insensitive).
  void setValue_forHTTPHeaderField_(NSString? value, NSString? field) {
    return _lib._objc_msgSend_218(_id, _lib._sel_setValue_forHTTPHeaderField_1,
        value?._id ?? ffi.nullptr, field?._id ?? ffi.nullptr);
  }

  /// !
  /// @method addValue:forHTTPHeaderField:
  /// @abstract Adds an HTTP header field in the current header
  /// dictionary.
  /// @discussion This method provides a way to add values to header
  /// fields incrementally. If a value was previously set for the given
  /// header field, the given value is appended to the previously-existing
  /// value. The appropriate field delimiter, a comma in the case of HTTP,
  /// is added by the implementation, and should not be added to the given
  /// value by the caller. Note that, in keeping with the HTTP RFC, HTTP
  /// header field names are case-insensitive.
  /// @param value the header field value.
  /// @param field the header field name (case-insensitive).
  void addValue_forHTTPHeaderField_(NSString? value, NSString? field) {
    return _lib._objc_msgSend_218(_id, _lib._sel_addValue_forHTTPHeaderField_1,
        value?._id ?? ffi.nullptr, field?._id ?? ffi.nullptr);
  }

  /// !
  /// @abstract Sets the request body data of the receiver.
  /// @discussion This data is sent as the message body of the request, as
  /// in done in an HTTP POST request.
  @override
  NSData? get HTTPBody {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_HTTPBody1);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the request body data of the receiver.
  /// @discussion This data is sent as the message body of the request, as
  /// in done in an HTTP POST request.
  set HTTPBody(NSData? value) {
    _lib._objc_msgSend_219(
        _id, _lib._sel_setHTTPBody_1, value?._id ?? ffi.nullptr);
  }

  /// !
  /// @abstract Sets the request body to be the contents of the given stream.
  /// @discussion The provided stream should be unopened; the request will take
  /// over the stream's delegate.  The entire stream's contents will be
  /// transmitted as the HTTP body of the request.  Note that the body stream
  /// and the body data (set by setHTTPBody:, above) are mutually exclusive
  /// - setting one will clear the other.
  @override
  NSInputStream? get HTTPBodyStream {
    final _ret = _lib._objc_msgSend_210(_id, _lib._sel_HTTPBodyStream1);
    return _ret.address == 0
        ? null
        : NSInputStream._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the request body to be the contents of the given stream.
  /// @discussion The provided stream should be unopened; the request will take
  /// over the stream's delegate.  The entire stream's contents will be
  /// transmitted as the HTTP body of the request.  Note that the body stream
  /// and the body data (set by setHTTPBody:, above) are mutually exclusive
  /// - setting one will clear the other.
  set HTTPBodyStream(NSInputStream? value) {
    _lib._objc_msgSend_220(
        _id, _lib._sel_setHTTPBodyStream_1, value?._id ?? ffi.nullptr);
  }

  /// !
  /// @abstract Decide whether default cookie handling will happen for
  /// this request (YES if cookies should be sent with and set for this request;
  /// otherwise NO).
  /// @discussion The default is YES - in other words, cookies are sent from and
  /// stored to the cookie manager by default.
  /// NOTE: In releases prior to 10.3, this value is ignored
  @override
  bool get HTTPShouldHandleCookies {
    return _lib._objc_msgSend_11(_id, _lib._sel_HTTPShouldHandleCookies1);
  }

  /// !
  /// @abstract Decide whether default cookie handling will happen for
  /// this request (YES if cookies should be sent with and set for this request;
  /// otherwise NO).
  /// @discussion The default is YES - in other words, cookies are sent from and
  /// stored to the cookie manager by default.
  /// NOTE: In releases prior to 10.3, this value is ignored
  set HTTPShouldHandleCookies(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setHTTPShouldHandleCookies_1, value);
  }

  /// !
  /// @abstract Sets whether the request should not wait for the previous response
  /// before transmitting (YES if the receiver should transmit before the previous response is
  /// received.  NO to wait for the previous response before transmitting)
  /// @discussion Calling this method with a YES value does not guarantee HTTP
  /// pipelining behavior.  This method may have no effect if an HTTP proxy is
  /// configured, or if the HTTP request uses an unsafe request method (e.g., POST
  /// requests will not pipeline).  Pipelining behavior also may not begin until
  /// the second request on a given TCP connection.  There may be other situations
  /// where pipelining does not occur even though YES was set.
  /// HTTP 1.1 allows the client to send multiple requests to the server without
  /// waiting for a response.  Though HTTP 1.1 requires support for pipelining,
  /// some servers report themselves as being HTTP 1.1 but do not support
  /// pipelining (disconnecting, sending resources misordered, omitting part of
  /// a resource, etc.).
  @override
  bool get HTTPShouldUsePipelining {
    return _lib._objc_msgSend_11(_id, _lib._sel_HTTPShouldUsePipelining1);
  }

  /// !
  /// @abstract Sets whether the request should not wait for the previous response
  /// before transmitting (YES if the receiver should transmit before the previous response is
  /// received.  NO to wait for the previous response before transmitting)
  /// @discussion Calling this method with a YES value does not guarantee HTTP
  /// pipelining behavior.  This method may have no effect if an HTTP proxy is
  /// configured, or if the HTTP request uses an unsafe request method (e.g., POST
  /// requests will not pipeline).  Pipelining behavior also may not begin until
  /// the second request on a given TCP connection.  There may be other situations
  /// where pipelining does not occur even though YES was set.
  /// HTTP 1.1 allows the client to send multiple requests to the server without
  /// waiting for a response.  Though HTTP 1.1 requires support for pipelining,
  /// some servers report themselves as being HTTP 1.1 but do not support
  /// pipelining (disconnecting, sending resources misordered, omitting part of
  /// a resource, etc.).
  set HTTPShouldUsePipelining(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setHTTPShouldUsePipelining_1, value);
  }

  /// !
  /// @method requestWithURL:
  /// @abstract Allocates and initializes an NSURLRequest with the given
  /// URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSMutableURLRequest requestWithURL_(
      NativeCupertinoHttp _lib, NSURL? URL) {
    final _ret = _lib._objc_msgSend_110(_lib._class_NSMutableURLRequest1,
        _lib._sel_requestWithURL_1, URL?._id ?? ffi.nullptr);
    return NSMutableURLRequest._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @property supportsSecureCoding
  /// @abstract Indicates that NSURLRequest implements the NSSecureCoding protocol.
  /// @result A BOOL value set to YES.
  static bool getSupportsSecureCoding(NativeCupertinoHttp _lib) {
    return _lib._objc_msgSend_11(
        _lib._class_NSMutableURLRequest1, _lib._sel_supportsSecureCoding1);
  }

  /// !
  /// @method requestWithURL:cachePolicy:timeoutInterval:
  /// @abstract Allocates and initializes a NSURLRequest with the given
  /// URL and cache policy.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSMutableURLRequest requestWithURL_cachePolicy_timeoutInterval_(
      NativeCupertinoHttp _lib,
      NSURL? URL,
      int cachePolicy,
      double timeoutInterval) {
    final _ret = _lib._objc_msgSend_207(
        _lib._class_NSMutableURLRequest1,
        _lib._sel_requestWithURL_cachePolicy_timeoutInterval_1,
        URL?._id ?? ffi.nullptr,
        cachePolicy,
        timeoutInterval);
    return NSMutableURLRequest._(_ret, _lib, retain: true, release: true);
  }

  static NSMutableURLRequest new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSMutableURLRequest1, _lib._sel_new1);
    return NSMutableURLRequest._(_ret, _lib, retain: false, release: true);
  }

  static NSMutableURLRequest alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSMutableURLRequest1, _lib._sel_alloc1);
    return NSMutableURLRequest._(_ret, _lib, retain: false, release: true);
  }
}

/// NSURLSession is a replacement API for NSURLConnection.  It provides
/// options that affect the policy of, and various aspects of the
/// mechanism by which NSURLRequest objects are retrieved from the
/// network.
///
/// An NSURLSession may be bound to a delegate object.  The delegate is
/// invoked for certain events during the lifetime of a session, such as
/// server authentication or determining whether a resource to be loaded
/// should be converted into a download.
///
/// NSURLSession instances are threadsafe.
///
/// The default NSURLSession uses a system provided delegate and is
/// appropriate to use in place of existing code that uses
/// +[NSURLConnection sendAsynchronousRequest:queue:completionHandler:]
///
/// An NSURLSession creates NSURLSessionTask objects which represent the
/// action of a resource being loaded.  These are analogous to
/// NSURLConnection objects but provide for more control and a unified
/// delegate model.
///
/// NSURLSessionTask objects are always created in a suspended state and
/// must be sent the -resume message before they will execute.
///
/// Subclasses of NSURLSessionTask are used to syntactically
/// differentiate between data and file downloads.
///
/// An NSURLSessionDataTask receives the resource as a series of calls to
/// the URLSession:dataTask:didReceiveData: delegate method.  This is type of
/// task most commonly associated with retrieving objects for immediate parsing
/// by the consumer.
///
/// An NSURLSessionUploadTask differs from an NSURLSessionDataTask
/// in how its instance is constructed.  Upload tasks are explicitly created
/// by referencing a file or data object to upload, or by utilizing the
/// -URLSession:task:needNewBodyStream: delegate message to supply an upload
/// body.
///
/// An NSURLSessionDownloadTask will directly write the response data to
/// a temporary file.  When completed, the delegate is sent
/// URLSession:downloadTask:didFinishDownloadingToURL: and given an opportunity
/// to move this file to a permanent location in its sandboxed container, or to
/// otherwise read the file. If canceled, an NSURLSessionDownloadTask can
/// produce a data blob that can be used to resume a download at a later
/// time.
///
/// Beginning with iOS 9 and Mac OS X 10.11, NSURLSessionStream is
/// available as a task type.  This allows for direct TCP/IP connection
/// to a given host and port with optional secure handshaking and
/// navigation of proxies.  Data tasks may also be upgraded to a
/// NSURLSessionStream task via the HTTP Upgrade: header and appropriate
/// use of the pipelining option of NSURLSessionConfiguration.  See RFC
/// 2817 and RFC 6455 for information about the Upgrade: header, and
/// comments below on turning data tasks into stream tasks.
///
/// An NSURLSessionWebSocketTask is a task that allows clients to connect to servers supporting
/// WebSocket. The task will perform the HTTP handshake to upgrade the connection
/// and once the WebSocket handshake is successful, the client can read and write
/// messages that will be framed using the WebSocket protocol by the framework.
class NSURLSession extends NSObject {
  NSURLSession._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSession] that points to the same underlying object as [other].
  static NSURLSession castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLSession._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLSession] that wraps the given raw object pointer.
  static NSURLSession castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSession._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSession].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURLSession1);
  }

  /// The shared session uses the currently set global NSURLCache,
  /// NSHTTPCookieStorage and NSURLCredentialStorage objects.
  static NSURLSession? getSharedSession(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_221(
        _lib._class_NSURLSession1, _lib._sel_sharedSession1);
    return _ret.address == 0
        ? null
        : NSURLSession._(_ret, _lib, retain: true, release: true);
  }

  /// Customization of NSURLSession occurs during creation of a new session.
  /// If you only need to use the convenience routines with custom
  /// configuration options it is not necessary to specify a delegate.
  /// If you do specify a delegate, the delegate will be retained until after
  /// the delegate has been sent the URLSession:didBecomeInvalidWithError: message.
  static NSURLSession sessionWithConfiguration_(
      NativeCupertinoHttp _lib, NSURLSessionConfiguration? configuration) {
    final _ret = _lib._objc_msgSend_268(
        _lib._class_NSURLSession1,
        _lib._sel_sessionWithConfiguration_1,
        configuration?._id ?? ffi.nullptr);
    return NSURLSession._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSession sessionWithConfiguration_delegate_delegateQueue_(
      NativeCupertinoHttp _lib,
      NSURLSessionConfiguration? configuration,
      NSObject? delegate,
      NSOperationQueue? queue) {
    final _ret = _lib._objc_msgSend_279(
        _lib._class_NSURLSession1,
        _lib._sel_sessionWithConfiguration_delegate_delegateQueue_1,
        configuration?._id ?? ffi.nullptr,
        delegate?._id ?? ffi.nullptr,
        queue?._id ?? ffi.nullptr);
    return NSURLSession._(_ret, _lib, retain: true, release: true);
  }

  NSOperationQueue? get delegateQueue {
    final _ret = _lib._objc_msgSend_278(_id, _lib._sel_delegateQueue1);
    return _ret.address == 0
        ? null
        : NSOperationQueue._(_ret, _lib, retain: true, release: true);
  }

  NSObject? get delegate {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_delegate1);
    return _ret.address == 0
        ? null
        : NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSURLSessionConfiguration? get configuration {
    final _ret = _lib._objc_msgSend_222(_id, _lib._sel_configuration1);
    return _ret.address == 0
        ? null
        : NSURLSessionConfiguration._(_ret, _lib, retain: true, release: true);
  }

  /// The sessionDescription property is available for the developer to
  /// provide a descriptive label for the session.
  NSString? get sessionDescription {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_sessionDescription1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// The sessionDescription property is available for the developer to
  /// provide a descriptive label for the session.
  set sessionDescription(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setSessionDescription_1, value?._id ?? ffi.nullptr);
  }

  /// -finishTasksAndInvalidate returns immediately and existing tasks will be allowed
  /// to run to completion.  New tasks may not be created.  The session
  /// will continue to make delegate callbacks until URLSession:didBecomeInvalidWithError:
  /// has been issued.
  ///
  /// -finishTasksAndInvalidate and -invalidateAndCancel do not
  /// have any effect on the shared session singleton.
  ///
  /// When invalidating a background session, it is not safe to create another background
  /// session with the same identifier until URLSession:didBecomeInvalidWithError: has
  /// been issued.
  void finishTasksAndInvalidate() {
    return _lib._objc_msgSend_1(_id, _lib._sel_finishTasksAndInvalidate1);
  }

  /// -invalidateAndCancel acts as -finishTasksAndInvalidate, but issues
  /// -cancel to all outstanding tasks for this session.  Note task
  /// cancellation is subject to the state of the task, and some tasks may
  /// have already have completed at the time they are sent -cancel.
  void invalidateAndCancel() {
    return _lib._objc_msgSend_1(_id, _lib._sel_invalidateAndCancel1);
  }

  /// empty all cookies, cache and credential stores, removes disk files, issues -flushWithCompletionHandler:. Invokes completionHandler() on the delegate queue if not nil.
  void resetWithCompletionHandler_(ObjCBlock7 completionHandler) {
    return _lib._objc_msgSend_275(
        _id, _lib._sel_resetWithCompletionHandler_1, completionHandler._impl);
  }

  /// flush storage to disk and clear transient network caches.  Invokes completionHandler() on the delegate queue if not nil.
  void flushWithCompletionHandler_(ObjCBlock7 completionHandler) {
    return _lib._objc_msgSend_275(
        _id, _lib._sel_flushWithCompletionHandler_1, completionHandler._impl);
  }

  /// invokes completionHandler with outstanding data, upload and download tasks.
  void getTasksWithCompletionHandler_(ObjCBlock10 completionHandler) {
    return _lib._objc_msgSend_280(_id,
        _lib._sel_getTasksWithCompletionHandler_1, completionHandler._impl);
  }

  /// invokes completionHandler with all outstanding tasks.
  void getAllTasksWithCompletionHandler_(ObjCBlock9 completionHandler) {
    return _lib._objc_msgSend_281(_id,
        _lib._sel_getAllTasksWithCompletionHandler_1, completionHandler._impl);
  }

  /// Creates a data task with the given request.  The request may have a body stream.
  NSURLSessionDataTask dataTaskWithRequest_(NSURLRequest? request) {
    final _ret = _lib._objc_msgSend_282(
        _id, _lib._sel_dataTaskWithRequest_1, request?._id ?? ffi.nullptr);
    return NSURLSessionDataTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates a data task to retrieve the contents of the given URL.
  NSURLSessionDataTask dataTaskWithURL_(NSURL? url) {
    final _ret = _lib._objc_msgSend_283(
        _id, _lib._sel_dataTaskWithURL_1, url?._id ?? ffi.nullptr);
    return NSURLSessionDataTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates an upload task with the given request.  The body of the request will be created from the file referenced by fileURL
  NSURLSessionUploadTask uploadTaskWithRequest_fromFile_(
      NSURLRequest? request, NSURL? fileURL) {
    final _ret = _lib._objc_msgSend_284(
        _id,
        _lib._sel_uploadTaskWithRequest_fromFile_1,
        request?._id ?? ffi.nullptr,
        fileURL?._id ?? ffi.nullptr);
    return NSURLSessionUploadTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates an upload task with the given request.  The body of the request is provided from the bodyData.
  NSURLSessionUploadTask uploadTaskWithRequest_fromData_(
      NSURLRequest? request, NSData? bodyData) {
    final _ret = _lib._objc_msgSend_285(
        _id,
        _lib._sel_uploadTaskWithRequest_fromData_1,
        request?._id ?? ffi.nullptr,
        bodyData?._id ?? ffi.nullptr);
    return NSURLSessionUploadTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates an upload task with the given request.  The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required.
  NSURLSessionUploadTask uploadTaskWithStreamedRequest_(NSURLRequest? request) {
    final _ret = _lib._objc_msgSend_286(_id,
        _lib._sel_uploadTaskWithStreamedRequest_1, request?._id ?? ffi.nullptr);
    return NSURLSessionUploadTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates a download task with the given request.
  NSURLSessionDownloadTask downloadTaskWithRequest_(NSURLRequest? request) {
    final _ret = _lib._objc_msgSend_288(
        _id, _lib._sel_downloadTaskWithRequest_1, request?._id ?? ffi.nullptr);
    return NSURLSessionDownloadTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates a download task to download the contents of the given URL.
  NSURLSessionDownloadTask downloadTaskWithURL_(NSURL? url) {
    final _ret = _lib._objc_msgSend_289(
        _id, _lib._sel_downloadTaskWithURL_1, url?._id ?? ffi.nullptr);
    return NSURLSessionDownloadTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates a download task with the resume data.  If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called.
  NSURLSessionDownloadTask downloadTaskWithResumeData_(NSData? resumeData) {
    final _ret = _lib._objc_msgSend_290(_id,
        _lib._sel_downloadTaskWithResumeData_1, resumeData?._id ?? ffi.nullptr);
    return NSURLSessionDownloadTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates a bidirectional stream task to a given host and port.
  NSURLSessionStreamTask streamTaskWithHostName_port_(
      NSString? hostname, int port) {
    final _ret = _lib._objc_msgSend_293(
        _id,
        _lib._sel_streamTaskWithHostName_port_1,
        hostname?._id ?? ffi.nullptr,
        port);
    return NSURLSessionStreamTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates a bidirectional stream task with an NSNetService to identify the endpoint.
  /// The NSNetService will be resolved before any IO completes.
  NSURLSessionStreamTask streamTaskWithNetService_(NSNetService? service) {
    final _ret = _lib._objc_msgSend_294(
        _id, _lib._sel_streamTaskWithNetService_1, service?._id ?? ffi.nullptr);
    return NSURLSessionStreamTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates a WebSocket task given the url. The given url must have a ws or wss scheme.
  NSURLSessionWebSocketTask webSocketTaskWithURL_(NSURL? url) {
    final _ret = _lib._objc_msgSend_301(
        _id, _lib._sel_webSocketTaskWithURL_1, url?._id ?? ffi.nullptr);
    return NSURLSessionWebSocketTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates a WebSocket task given the url and an array of protocols. The protocols will be used in the WebSocket handshake to
  /// negotiate a prefered protocol with the server
  /// Note - The protocol will not affect the WebSocket framing. More details on the protocol can be found by reading the WebSocket RFC
  NSURLSessionWebSocketTask webSocketTaskWithURL_protocols_(
      NSURL? url, NSArray? protocols) {
    final _ret = _lib._objc_msgSend_302(
        _id,
        _lib._sel_webSocketTaskWithURL_protocols_1,
        url?._id ?? ffi.nullptr,
        protocols?._id ?? ffi.nullptr);
    return NSURLSessionWebSocketTask._(_ret, _lib, retain: true, release: true);
  }

  /// Creates a WebSocket task given the request. The request properties can be modified and will be used by the task during the HTTP handshake phase.
  /// Clients who want to add custom protocols can do so by directly adding headers with the key Sec-WebSocket-Protocol
  /// and a comma separated list of protocols they wish to negotiate with the server. The custom HTTP headers provided by the client will remain unchanged for the handshake with the server.
  NSURLSessionWebSocketTask webSocketTaskWithRequest_(NSURLRequest? request) {
    final _ret = _lib._objc_msgSend_303(
        _id, _lib._sel_webSocketTaskWithRequest_1, request?._id ?? ffi.nullptr);
    return NSURLSessionWebSocketTask._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSURLSession init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSession._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSession new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLSession1, _lib._sel_new1);
    return NSURLSession._(_ret, _lib, retain: false, release: true);
  }

  /// data task convenience methods.  These methods create tasks that
  /// bypass the normal delegate calls for response and data delivery,
  /// and provide a simple cancelable asynchronous interface to receiving
  /// data.  Errors will be returned in the NSURLErrorDomain,
  /// see <Foundation/NSURLError.h>.  The delegate, if any, will still be
  /// called for authentication challenges.
  NSURLSessionDataTask dataTaskWithRequest_completionHandler_(
      NSURLRequest? request, ObjCBlock15 completionHandler) {
    final _ret = _lib._objc_msgSend_304(
        _id,
        _lib._sel_dataTaskWithRequest_completionHandler_1,
        request?._id ?? ffi.nullptr,
        completionHandler._impl);
    return NSURLSessionDataTask._(_ret, _lib, retain: true, release: true);
  }

  NSURLSessionDataTask dataTaskWithURL_completionHandler_(
      NSURL? url, ObjCBlock15 completionHandler) {
    final _ret = _lib._objc_msgSend_305(
        _id,
        _lib._sel_dataTaskWithURL_completionHandler_1,
        url?._id ?? ffi.nullptr,
        completionHandler._impl);
    return NSURLSessionDataTask._(_ret, _lib, retain: true, release: true);
  }

  /// upload convenience method.
  NSURLSessionUploadTask uploadTaskWithRequest_fromFile_completionHandler_(
      NSURLRequest? request, NSURL? fileURL, ObjCBlock15 completionHandler) {
    final _ret = _lib._objc_msgSend_306(
        _id,
        _lib._sel_uploadTaskWithRequest_fromFile_completionHandler_1,
        request?._id ?? ffi.nullptr,
        fileURL?._id ?? ffi.nullptr,
        completionHandler._impl);
    return NSURLSessionUploadTask._(_ret, _lib, retain: true, release: true);
  }

  NSURLSessionUploadTask uploadTaskWithRequest_fromData_completionHandler_(
      NSURLRequest? request, NSData? bodyData, ObjCBlock15 completionHandler) {
    final _ret = _lib._objc_msgSend_307(
        _id,
        _lib._sel_uploadTaskWithRequest_fromData_completionHandler_1,
        request?._id ?? ffi.nullptr,
        bodyData?._id ?? ffi.nullptr,
        completionHandler._impl);
    return NSURLSessionUploadTask._(_ret, _lib, retain: true, release: true);
  }

  /// download task convenience methods.  When a download successfully
  /// completes, the NSURL will point to a file that must be read or
  /// copied during the invocation of the completion routine.  The file
  /// will be removed automatically.
  NSURLSessionDownloadTask downloadTaskWithRequest_completionHandler_(
      NSURLRequest? request, ObjCBlock16 completionHandler) {
    final _ret = _lib._objc_msgSend_308(
        _id,
        _lib._sel_downloadTaskWithRequest_completionHandler_1,
        request?._id ?? ffi.nullptr,
        completionHandler._impl);
    return NSURLSessionDownloadTask._(_ret, _lib, retain: true, release: true);
  }

  NSURLSessionDownloadTask downloadTaskWithURL_completionHandler_(
      NSURL? url, ObjCBlock16 completionHandler) {
    final _ret = _lib._objc_msgSend_309(
        _id,
        _lib._sel_downloadTaskWithURL_completionHandler_1,
        url?._id ?? ffi.nullptr,
        completionHandler._impl);
    return NSURLSessionDownloadTask._(_ret, _lib, retain: true, release: true);
  }

  NSURLSessionDownloadTask downloadTaskWithResumeData_completionHandler_(
      NSData? resumeData, ObjCBlock16 completionHandler) {
    final _ret = _lib._objc_msgSend_310(
        _id,
        _lib._sel_downloadTaskWithResumeData_completionHandler_1,
        resumeData?._id ?? ffi.nullptr,
        completionHandler._impl);
    return NSURLSessionDownloadTask._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSession alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLSession1, _lib._sel_alloc1);
    return NSURLSession._(_ret, _lib, retain: false, release: true);
  }
}

/// Configuration options for an NSURLSession.  When a session is
/// created, a copy of the configuration object is made - you cannot
/// modify the configuration of a session after it has been created.
///
/// The shared session uses the global singleton credential, cache
/// and cookie storage objects.
///
/// An ephemeral session has no persistent disk storage for cookies,
/// cache or credentials.
///
/// A background session can be used to perform networking operations
/// on behalf of a suspended application, within certain constraints.
class NSURLSessionConfiguration extends NSObject {
  NSURLSessionConfiguration._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionConfiguration] that points to the same underlying object as [other].
  static NSURLSessionConfiguration castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLSessionConfiguration._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionConfiguration] that wraps the given raw object pointer.
  static NSURLSessionConfiguration castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionConfiguration._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionConfiguration].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionConfiguration1);
  }

  static NSURLSessionConfiguration? getDefaultSessionConfiguration(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_222(_lib._class_NSURLSessionConfiguration1,
        _lib._sel_defaultSessionConfiguration1);
    return _ret.address == 0
        ? null
        : NSURLSessionConfiguration._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionConfiguration? getEphemeralSessionConfiguration(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_222(_lib._class_NSURLSessionConfiguration1,
        _lib._sel_ephemeralSessionConfiguration1);
    return _ret.address == 0
        ? null
        : NSURLSessionConfiguration._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionConfiguration
      backgroundSessionConfigurationWithIdentifier_(
          NativeCupertinoHttp _lib, NSString? identifier) {
    final _ret = _lib._objc_msgSend_223(
        _lib._class_NSURLSessionConfiguration1,
        _lib._sel_backgroundSessionConfigurationWithIdentifier_1,
        identifier?._id ?? ffi.nullptr);
    return NSURLSessionConfiguration._(_ret, _lib, retain: true, release: true);
  }

  /// identifier for the background session configuration
  NSString? get identifier {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_identifier1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// default cache policy for requests
  int get requestCachePolicy {
    return _lib._objc_msgSend_208(_id, _lib._sel_requestCachePolicy1);
  }

  /// default cache policy for requests
  set requestCachePolicy(int value) {
    _lib._objc_msgSend_212(_id, _lib._sel_setRequestCachePolicy_1, value);
  }

  /// default timeout for requests.  This will cause a timeout if no data is transmitted for the given timeout value, and is reset whenever data is transmitted.
  double get timeoutIntervalForRequest {
    return _lib._objc_msgSend_65(_id, _lib._sel_timeoutIntervalForRequest1);
  }

  /// default timeout for requests.  This will cause a timeout if no data is transmitted for the given timeout value, and is reset whenever data is transmitted.
  set timeoutIntervalForRequest(double value) {
    _lib._objc_msgSend_213(
        _id, _lib._sel_setTimeoutIntervalForRequest_1, value);
  }

  /// default timeout for requests.  This will cause a timeout if a resource is not able to be retrieved within a given timeout.
  double get timeoutIntervalForResource {
    return _lib._objc_msgSend_65(_id, _lib._sel_timeoutIntervalForResource1);
  }

  /// default timeout for requests.  This will cause a timeout if a resource is not able to be retrieved within a given timeout.
  set timeoutIntervalForResource(double value) {
    _lib._objc_msgSend_213(
        _id, _lib._sel_setTimeoutIntervalForResource_1, value);
  }

  /// type of service for requests.
  int get networkServiceType {
    return _lib._objc_msgSend_209(_id, _lib._sel_networkServiceType1);
  }

  /// type of service for requests.
  set networkServiceType(int value) {
    _lib._objc_msgSend_214(_id, _lib._sel_setNetworkServiceType_1, value);
  }

  /// allow request to route over cellular.
  bool get allowsCellularAccess {
    return _lib._objc_msgSend_11(_id, _lib._sel_allowsCellularAccess1);
  }

  /// allow request to route over cellular.
  set allowsCellularAccess(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setAllowsCellularAccess_1, value);
  }

  /// allow request to route over expensive networks.  Defaults to YES.
  bool get allowsExpensiveNetworkAccess {
    return _lib._objc_msgSend_11(_id, _lib._sel_allowsExpensiveNetworkAccess1);
  }

  /// allow request to route over expensive networks.  Defaults to YES.
  set allowsExpensiveNetworkAccess(bool value) {
    _lib._objc_msgSend_215(
        _id, _lib._sel_setAllowsExpensiveNetworkAccess_1, value);
  }

  /// allow request to route over networks in constrained mode. Defaults to YES.
  bool get allowsConstrainedNetworkAccess {
    return _lib._objc_msgSend_11(
        _id, _lib._sel_allowsConstrainedNetworkAccess1);
  }

  /// allow request to route over networks in constrained mode. Defaults to YES.
  set allowsConstrainedNetworkAccess(bool value) {
    _lib._objc_msgSend_215(
        _id, _lib._sel_setAllowsConstrainedNetworkAccess_1, value);
  }

  /// Causes tasks to wait for network connectivity to become available, rather
  /// than immediately failing with an error (such as NSURLErrorNotConnectedToInternet)
  /// when it is not. When waiting for connectivity, the timeoutIntervalForRequest
  /// property does not apply, but the timeoutIntervalForResource property does.
  ///
  /// Unsatisfactory connectivity (that requires waiting) includes cases where the
  /// device has limited or insufficient connectivity for a task (e.g., only has a
  /// cellular connection but the allowsCellularAccess property is NO, or requires
  /// a VPN connection in order to reach the desired host).
  ///
  /// Default value is NO. Ignored by background sessions, as background sessions
  /// always wait for connectivity.
  bool get waitsForConnectivity {
    return _lib._objc_msgSend_11(_id, _lib._sel_waitsForConnectivity1);
  }

  /// Causes tasks to wait for network connectivity to become available, rather
  /// than immediately failing with an error (such as NSURLErrorNotConnectedToInternet)
  /// when it is not. When waiting for connectivity, the timeoutIntervalForRequest
  /// property does not apply, but the timeoutIntervalForResource property does.
  ///
  /// Unsatisfactory connectivity (that requires waiting) includes cases where the
  /// device has limited or insufficient connectivity for a task (e.g., only has a
  /// cellular connection but the allowsCellularAccess property is NO, or requires
  /// a VPN connection in order to reach the desired host).
  ///
  /// Default value is NO. Ignored by background sessions, as background sessions
  /// always wait for connectivity.
  set waitsForConnectivity(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setWaitsForConnectivity_1, value);
  }

  /// allows background tasks to be scheduled at the discretion of the system for optimal performance.
  bool get discretionary {
    return _lib._objc_msgSend_11(_id, _lib._sel_isDiscretionary1);
  }

  /// allows background tasks to be scheduled at the discretion of the system for optimal performance.
  set discretionary(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setDiscretionary_1, value);
  }

  /// The identifier of the shared data container into which files in background sessions should be downloaded.
  /// App extensions wishing to use background sessions *must* set this property to a valid container identifier, or
  /// all transfers in that session will fail with NSURLErrorBackgroundSessionRequiresSharedContainer.
  NSString? get sharedContainerIdentifier {
    final _ret =
        _lib._objc_msgSend_19(_id, _lib._sel_sharedContainerIdentifier1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// The identifier of the shared data container into which files in background sessions should be downloaded.
  /// App extensions wishing to use background sessions *must* set this property to a valid container identifier, or
  /// all transfers in that session will fail with NSURLErrorBackgroundSessionRequiresSharedContainer.
  set sharedContainerIdentifier(NSString? value) {
    _lib._objc_msgSend_216(_id, _lib._sel_setSharedContainerIdentifier_1,
        value?._id ?? ffi.nullptr);
  }

  /// Allows the app to be resumed or launched in the background when tasks in background sessions complete
  /// or when auth is required. This only applies to configurations created with +backgroundSessionConfigurationWithIdentifier:
  /// and the default value is YES.
  ///
  /// NOTE: macOS apps based on AppKit do not support background launch.
  bool get sessionSendsLaunchEvents {
    return _lib._objc_msgSend_11(_id, _lib._sel_sessionSendsLaunchEvents1);
  }

  /// Allows the app to be resumed or launched in the background when tasks in background sessions complete
  /// or when auth is required. This only applies to configurations created with +backgroundSessionConfigurationWithIdentifier:
  /// and the default value is YES.
  ///
  /// NOTE: macOS apps based on AppKit do not support background launch.
  set sessionSendsLaunchEvents(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setSessionSendsLaunchEvents_1, value);
  }

  /// The proxy dictionary, as described by <CFNetwork/CFHTTPStream.h>
  NSDictionary? get connectionProxyDictionary {
    final _ret =
        _lib._objc_msgSend_89(_id, _lib._sel_connectionProxyDictionary1);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// The proxy dictionary, as described by <CFNetwork/CFHTTPStream.h>
  set connectionProxyDictionary(NSDictionary? value) {
    _lib._objc_msgSend_217(_id, _lib._sel_setConnectionProxyDictionary_1,
        value?._id ?? ffi.nullptr);
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  int get TLSMinimumSupportedProtocol {
    return _lib._objc_msgSend_224(_id, _lib._sel_TLSMinimumSupportedProtocol1);
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  set TLSMinimumSupportedProtocol(int value) {
    _lib._objc_msgSend_225(
        _id, _lib._sel_setTLSMinimumSupportedProtocol_1, value);
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  int get TLSMaximumSupportedProtocol {
    return _lib._objc_msgSend_224(_id, _lib._sel_TLSMaximumSupportedProtocol1);
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  set TLSMaximumSupportedProtocol(int value) {
    _lib._objc_msgSend_225(
        _id, _lib._sel_setTLSMaximumSupportedProtocol_1, value);
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  int get TLSMinimumSupportedProtocolVersion {
    return _lib._objc_msgSend_226(
        _id, _lib._sel_TLSMinimumSupportedProtocolVersion1);
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  set TLSMinimumSupportedProtocolVersion(int value) {
    _lib._objc_msgSend_227(
        _id, _lib._sel_setTLSMinimumSupportedProtocolVersion_1, value);
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  int get TLSMaximumSupportedProtocolVersion {
    return _lib._objc_msgSend_226(
        _id, _lib._sel_TLSMaximumSupportedProtocolVersion1);
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  set TLSMaximumSupportedProtocolVersion(int value) {
    _lib._objc_msgSend_227(
        _id, _lib._sel_setTLSMaximumSupportedProtocolVersion_1, value);
  }

  /// Allow the use of HTTP pipelining
  bool get HTTPShouldUsePipelining {
    return _lib._objc_msgSend_11(_id, _lib._sel_HTTPShouldUsePipelining1);
  }

  /// Allow the use of HTTP pipelining
  set HTTPShouldUsePipelining(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setHTTPShouldUsePipelining_1, value);
  }

  /// Allow the session to set cookies on requests
  bool get HTTPShouldSetCookies {
    return _lib._objc_msgSend_11(_id, _lib._sel_HTTPShouldSetCookies1);
  }

  /// Allow the session to set cookies on requests
  set HTTPShouldSetCookies(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setHTTPShouldSetCookies_1, value);
  }

  /// Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage.
  int get HTTPCookieAcceptPolicy {
    return _lib._objc_msgSend_228(_id, _lib._sel_HTTPCookieAcceptPolicy1);
  }

  /// Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage.
  set HTTPCookieAcceptPolicy(int value) {
    _lib._objc_msgSend_229(_id, _lib._sel_setHTTPCookieAcceptPolicy_1, value);
  }

  /// Specifies additional headers which will be set on outgoing requests.
  /// Note that these headers are added to the request only if not already present.
  NSDictionary? get HTTPAdditionalHeaders {
    final _ret = _lib._objc_msgSend_89(_id, _lib._sel_HTTPAdditionalHeaders1);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// Specifies additional headers which will be set on outgoing requests.
  /// Note that these headers are added to the request only if not already present.
  set HTTPAdditionalHeaders(NSDictionary? value) {
    _lib._objc_msgSend_217(
        _id, _lib._sel_setHTTPAdditionalHeaders_1, value?._id ?? ffi.nullptr);
  }

  /// The maximum number of simultanous persistent connections per host
  int get HTTPMaximumConnectionsPerHost {
    return _lib._objc_msgSend_61(_id, _lib._sel_HTTPMaximumConnectionsPerHost1);
  }

  /// The maximum number of simultanous persistent connections per host
  set HTTPMaximumConnectionsPerHost(int value) {
    _lib._objc_msgSend_230(
        _id, _lib._sel_setHTTPMaximumConnectionsPerHost_1, value);
  }

  /// The cookie storage object to use, or nil to indicate that no cookies should be handled
  NSHTTPCookieStorage? get HTTPCookieStorage {
    final _ret = _lib._objc_msgSend_231(_id, _lib._sel_HTTPCookieStorage1);
    return _ret.address == 0
        ? null
        : NSHTTPCookieStorage._(_ret, _lib, retain: true, release: true);
  }

  /// The cookie storage object to use, or nil to indicate that no cookies should be handled
  set HTTPCookieStorage(NSHTTPCookieStorage? value) {
    _lib._objc_msgSend_260(
        _id, _lib._sel_setHTTPCookieStorage_1, value?._id ?? ffi.nullptr);
  }

  /// The credential storage object, or nil to indicate that no credential storage is to be used
  NSURLCredentialStorage? get URLCredentialStorage {
    final _ret = _lib._objc_msgSend_261(_id, _lib._sel_URLCredentialStorage1);
    return _ret.address == 0
        ? null
        : NSURLCredentialStorage._(_ret, _lib, retain: true, release: true);
  }

  /// The credential storage object, or nil to indicate that no credential storage is to be used
  set URLCredentialStorage(NSURLCredentialStorage? value) {
    _lib._objc_msgSend_262(
        _id, _lib._sel_setURLCredentialStorage_1, value?._id ?? ffi.nullptr);
  }

  /// The URL resource cache, or nil to indicate that no caching is to be performed
  NSURLCache? get URLCache {
    final _ret = _lib._objc_msgSend_263(_id, _lib._sel_URLCache1);
    return _ret.address == 0
        ? null
        : NSURLCache._(_ret, _lib, retain: true, release: true);
  }

  /// The URL resource cache, or nil to indicate that no caching is to be performed
  set URLCache(NSURLCache? value) {
    _lib._objc_msgSend_264(
        _id, _lib._sel_setURLCache_1, value?._id ?? ffi.nullptr);
  }

  /// Enable extended background idle mode for any tcp sockets created.    Enabling this mode asks the system to keep the socket open
  /// and delay reclaiming it when the process moves to the background (see https://developer.apple.com/library/ios/technotes/tn2277/_index.html)
  bool get shouldUseExtendedBackgroundIdleMode {
    return _lib._objc_msgSend_11(
        _id, _lib._sel_shouldUseExtendedBackgroundIdleMode1);
  }

  /// Enable extended background idle mode for any tcp sockets created.    Enabling this mode asks the system to keep the socket open
  /// and delay reclaiming it when the process moves to the background (see https://developer.apple.com/library/ios/technotes/tn2277/_index.html)
  set shouldUseExtendedBackgroundIdleMode(bool value) {
    _lib._objc_msgSend_215(
        _id, _lib._sel_setShouldUseExtendedBackgroundIdleMode_1, value);
  }

  /// An optional array of Class objects which subclass NSURLProtocol.
  /// The Class will be sent +canInitWithRequest: when determining if
  /// an instance of the class can be used for a given URL scheme.
  /// You should not use +[NSURLProtocol registerClass:], as that
  /// method will register your class with the default session rather
  /// than with an instance of NSURLSession.
  /// Custom NSURLProtocol subclasses are not available to background
  /// sessions.
  NSArray? get protocolClasses {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_protocolClasses1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  /// An optional array of Class objects which subclass NSURLProtocol.
  /// The Class will be sent +canInitWithRequest: when determining if
  /// an instance of the class can be used for a given URL scheme.
  /// You should not use +[NSURLProtocol registerClass:], as that
  /// method will register your class with the default session rather
  /// than with an instance of NSURLSession.
  /// Custom NSURLProtocol subclasses are not available to background
  /// sessions.
  set protocolClasses(NSArray? value) {
    _lib._objc_msgSend_265(
        _id, _lib._sel_setProtocolClasses_1, value?._id ?? ffi.nullptr);
  }

  /// multipath service type to use for connections.  The default is NSURLSessionMultipathServiceTypeNone
  int get multipathServiceType {
    return _lib._objc_msgSend_266(_id, _lib._sel_multipathServiceType1);
  }

  /// multipath service type to use for connections.  The default is NSURLSessionMultipathServiceTypeNone
  set multipathServiceType(int value) {
    _lib._objc_msgSend_267(_id, _lib._sel_setMultipathServiceType_1, value);
  }

  @override
  NSURLSessionConfiguration init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSessionConfiguration._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionConfiguration new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionConfiguration1, _lib._sel_new1);
    return NSURLSessionConfiguration._(_ret, _lib,
        retain: false, release: true);
  }

  static NSURLSessionConfiguration backgroundSessionConfiguration_(
      NativeCupertinoHttp _lib, NSString? identifier) {
    final _ret = _lib._objc_msgSend_223(
        _lib._class_NSURLSessionConfiguration1,
        _lib._sel_backgroundSessionConfiguration_1,
        identifier?._id ?? ffi.nullptr);
    return NSURLSessionConfiguration._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionConfiguration alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionConfiguration1, _lib._sel_alloc1);
    return NSURLSessionConfiguration._(_ret, _lib,
        retain: false, release: true);
  }
}

abstract class SSLProtocol {
  static const int kSSLProtocolUnknown = 0;
  static const int kTLSProtocol1 = 4;
  static const int kTLSProtocol11 = 7;
  static const int kTLSProtocol12 = 8;
  static const int kDTLSProtocol1 = 9;
  static const int kTLSProtocol13 = 10;
  static const int kDTLSProtocol12 = 11;
  static const int kTLSProtocolMaxSupported = 999;
  static const int kSSLProtocol2 = 1;
  static const int kSSLProtocol3 = 2;
  static const int kSSLProtocol3Only = 3;
  static const int kTLSProtocol1Only = 5;
  static const int kSSLProtocolAll = 6;
}

abstract class tls_protocol_version_t {
  static const int tls_protocol_version_TLSv10 = 769;
  static const int tls_protocol_version_TLSv11 = 770;
  static const int tls_protocol_version_TLSv12 = 771;
  static const int tls_protocol_version_TLSv13 = 772;
  static const int tls_protocol_version_DTLSv10 = -257;
  static const int tls_protocol_version_DTLSv12 = -259;
}

abstract class NSHTTPCookieAcceptPolicy {
  static const int NSHTTPCookieAcceptPolicyAlways = 0;
  static const int NSHTTPCookieAcceptPolicyNever = 1;
  static const int NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain = 2;
}

class NSHTTPCookieStorage extends NSObject {
  NSHTTPCookieStorage._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSHTTPCookieStorage] that points to the same underlying object as [other].
  static NSHTTPCookieStorage castFrom<T extends _ObjCWrapper>(T other) {
    return NSHTTPCookieStorage._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSHTTPCookieStorage] that wraps the given raw object pointer.
  static NSHTTPCookieStorage castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSHTTPCookieStorage._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSHTTPCookieStorage].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSHTTPCookieStorage1);
  }

  static NSHTTPCookieStorage? getSharedHTTPCookieStorage(
      NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_231(
        _lib._class_NSHTTPCookieStorage1, _lib._sel_sharedHTTPCookieStorage1);
    return _ret.address == 0
        ? null
        : NSHTTPCookieStorage._(_ret, _lib, retain: true, release: true);
  }

  static NSHTTPCookieStorage sharedCookieStorageForGroupContainerIdentifier_(
      NativeCupertinoHttp _lib, NSString? identifier) {
    final _ret = _lib._objc_msgSend_232(
        _lib._class_NSHTTPCookieStorage1,
        _lib._sel_sharedCookieStorageForGroupContainerIdentifier_1,
        identifier?._id ?? ffi.nullptr);
    return NSHTTPCookieStorage._(_ret, _lib, retain: true, release: true);
  }

  NSArray? get cookies {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_cookies1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  void setCookie_(NSHTTPCookie? cookie) {
    return _lib._objc_msgSend_233(
        _id, _lib._sel_setCookie_1, cookie?._id ?? ffi.nullptr);
  }

  void deleteCookie_(NSHTTPCookie? cookie) {
    return _lib._objc_msgSend_233(
        _id, _lib._sel_deleteCookie_1, cookie?._id ?? ffi.nullptr);
  }

  void removeCookiesSinceDate_(NSDate? date) {
    return _lib._objc_msgSend_235(
        _id, _lib._sel_removeCookiesSinceDate_1, date?._id ?? ffi.nullptr);
  }

  NSArray cookiesForURL_(NSURL? URL) {
    final _ret = _lib._objc_msgSend_158(
        _id, _lib._sel_cookiesForURL_1, URL?._id ?? ffi.nullptr);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  void setCookies_forURL_mainDocumentURL_(
      NSArray? cookies, NSURL? URL, NSURL? mainDocumentURL) {
    return _lib._objc_msgSend_236(
        _id,
        _lib._sel_setCookies_forURL_mainDocumentURL_1,
        cookies?._id ?? ffi.nullptr,
        URL?._id ?? ffi.nullptr,
        mainDocumentURL?._id ?? ffi.nullptr);
  }

  int get cookieAcceptPolicy {
    return _lib._objc_msgSend_228(_id, _lib._sel_cookieAcceptPolicy1);
  }

  set cookieAcceptPolicy(int value) {
    _lib._objc_msgSend_229(_id, _lib._sel_setCookieAcceptPolicy_1, value);
  }

  NSArray sortedCookiesUsingDescriptors_(NSArray? sortOrder) {
    final _ret = _lib._objc_msgSend_148(
        _id,
        _lib._sel_sortedCookiesUsingDescriptors_1,
        sortOrder?._id ?? ffi.nullptr);
    return NSArray._(_ret, _lib, retain: true, release: true);
  }

  void storeCookies_forTask_(NSArray? cookies, NSURLSessionTask? task) {
    return _lib._objc_msgSend_258(_id, _lib._sel_storeCookies_forTask_1,
        cookies?._id ?? ffi.nullptr, task?._id ?? ffi.nullptr);
  }

  void getCookiesForTask_completionHandler_(
      NSURLSessionTask? task, ObjCBlock9 completionHandler) {
    return _lib._objc_msgSend_259(
        _id,
        _lib._sel_getCookiesForTask_completionHandler_1,
        task?._id ?? ffi.nullptr,
        completionHandler._impl);
  }

  static NSHTTPCookieStorage new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSHTTPCookieStorage1, _lib._sel_new1);
    return NSHTTPCookieStorage._(_ret, _lib, retain: false, release: true);
  }

  static NSHTTPCookieStorage alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSHTTPCookieStorage1, _lib._sel_alloc1);
    return NSHTTPCookieStorage._(_ret, _lib, retain: false, release: true);
  }
}

class NSHTTPCookie extends _ObjCWrapper {
  NSHTTPCookie._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSHTTPCookie] that points to the same underlying object as [other].
  static NSHTTPCookie castFrom<T extends _ObjCWrapper>(T other) {
    return NSHTTPCookie._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSHTTPCookie] that wraps the given raw object pointer.
  static NSHTTPCookie castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSHTTPCookie._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSHTTPCookie].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSHTTPCookie1);
  }
}

class NSDate extends NSObject {
  NSDate._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSDate] that points to the same underlying object as [other].
  static NSDate castFrom<T extends _ObjCWrapper>(T other) {
    return NSDate._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSDate] that wraps the given raw object pointer.
  static NSDate castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSDate._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSDate].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSDate1);
  }

  double get timeIntervalSinceReferenceDate {
    return _lib._objc_msgSend_65(
        _id, _lib._sel_timeIntervalSinceReferenceDate1);
  }

  @override
  NSDate init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSDate._(_ret, _lib, retain: true, release: true);
  }

  NSDate initWithTimeIntervalSinceReferenceDate_(double ti) {
    final _ret = _lib._objc_msgSend_234(
        _id, _lib._sel_initWithTimeIntervalSinceReferenceDate_1, ti);
    return NSDate._(_ret, _lib, retain: true, release: true);
  }

  NSDate initWithCoder_(NSCoder? coder) {
    final _ret = _lib._objc_msgSend_14(
        _id, _lib._sel_initWithCoder_1, coder?._id ?? ffi.nullptr);
    return NSDate._(_ret, _lib, retain: true, release: true);
  }

  static NSDate new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSDate1, _lib._sel_new1);
    return NSDate._(_ret, _lib, retain: false, release: true);
  }

  static NSDate alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSDate1, _lib._sel_alloc1);
    return NSDate._(_ret, _lib, retain: false, release: true);
  }
}

/// NSURLSessionTask - a cancelable object that refers to the lifetime
/// of processing a given request.
class NSURLSessionTask extends NSObject {
  NSURLSessionTask._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionTask] that points to the same underlying object as [other].
  static NSURLSessionTask castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLSessionTask._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionTask] that wraps the given raw object pointer.
  static NSURLSessionTask castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionTask._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionTask].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionTask1);
  }

  /// an identifier for this task, assigned by and unique to the owning session
  int get taskIdentifier {
    return _lib._objc_msgSend_12(_id, _lib._sel_taskIdentifier1);
  }

  /// may be nil if this is a stream task
  NSURLRequest? get originalRequest {
    final _ret = _lib._objc_msgSend_237(_id, _lib._sel_originalRequest1);
    return _ret.address == 0
        ? null
        : NSURLRequest._(_ret, _lib, retain: true, release: true);
  }

  /// may differ from originalRequest due to http server redirection
  NSURLRequest? get currentRequest {
    final _ret = _lib._objc_msgSend_237(_id, _lib._sel_currentRequest1);
    return _ret.address == 0
        ? null
        : NSURLRequest._(_ret, _lib, retain: true, release: true);
  }

  /// may be nil if no response has been received
  NSURLResponse? get response {
    final _ret = _lib._objc_msgSend_239(_id, _lib._sel_response1);
    return _ret.address == 0
        ? null
        : NSURLResponse._(_ret, _lib, retain: true, release: true);
  }

  /// NSProgress object which represents the task progress.
  /// It can be used for task progress tracking.
  NSProgress? get progress {
    final _ret = _lib._objc_msgSend_240(_id, _lib._sel_progress1);
    return _ret.address == 0
        ? null
        : NSProgress._(_ret, _lib, retain: true, release: true);
  }

  /// Start the network load for this task no earlier than the specified date. If
  /// not specified, no start delay is used.
  ///
  /// Only applies to tasks created from background NSURLSession instances; has no
  /// effect for tasks created from other session types.
  NSDate? get earliestBeginDate {
    final _ret = _lib._objc_msgSend_253(_id, _lib._sel_earliestBeginDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// Start the network load for this task no earlier than the specified date. If
  /// not specified, no start delay is used.
  ///
  /// Only applies to tasks created from background NSURLSession instances; has no
  /// effect for tasks created from other session types.
  set earliestBeginDate(NSDate? value) {
    _lib._objc_msgSend_254(
        _id, _lib._sel_setEarliestBeginDate_1, value?._id ?? ffi.nullptr);
  }

  /// The number of bytes that the client expects (a best-guess upper-bound) will
  /// be sent and received by this task. These values are used by system scheduling
  /// policy. If unspecified, NSURLSessionTransferSizeUnknown is used.
  int get countOfBytesClientExpectsToSend {
    return _lib._objc_msgSend_247(
        _id, _lib._sel_countOfBytesClientExpectsToSend1);
  }

  /// The number of bytes that the client expects (a best-guess upper-bound) will
  /// be sent and received by this task. These values are used by system scheduling
  /// policy. If unspecified, NSURLSessionTransferSizeUnknown is used.
  set countOfBytesClientExpectsToSend(int value) {
    _lib._objc_msgSend_248(
        _id, _lib._sel_setCountOfBytesClientExpectsToSend_1, value);
  }

  int get countOfBytesClientExpectsToReceive {
    return _lib._objc_msgSend_247(
        _id, _lib._sel_countOfBytesClientExpectsToReceive1);
  }

  set countOfBytesClientExpectsToReceive(int value) {
    _lib._objc_msgSend_248(
        _id, _lib._sel_setCountOfBytesClientExpectsToReceive_1, value);
  }

  /// number of body bytes already received
  int get countOfBytesReceived {
    return _lib._objc_msgSend_247(_id, _lib._sel_countOfBytesReceived1);
  }

  /// number of body bytes already sent
  int get countOfBytesSent {
    return _lib._objc_msgSend_247(_id, _lib._sel_countOfBytesSent1);
  }

  /// number of body bytes we expect to send, derived from the Content-Length of the HTTP request
  int get countOfBytesExpectedToSend {
    return _lib._objc_msgSend_247(_id, _lib._sel_countOfBytesExpectedToSend1);
  }

  /// number of byte bytes we expect to receive, usually derived from the Content-Length header of an HTTP response.
  int get countOfBytesExpectedToReceive {
    return _lib._objc_msgSend_247(
        _id, _lib._sel_countOfBytesExpectedToReceive1);
  }

  /// The taskDescription property is available for the developer to
  /// provide a descriptive label for the task.
  NSString? get taskDescription {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_taskDescription1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// The taskDescription property is available for the developer to
  /// provide a descriptive label for the task.
  set taskDescription(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setTaskDescription_1, value?._id ?? ffi.nullptr);
  }

  /// -cancel returns immediately, but marks a task as being canceled.
  /// The task will signal -URLSession:task:didCompleteWithError: with an
  /// error value of { NSURLErrorDomain, NSURLErrorCancelled }.  In some
  /// cases, the task may signal other work before it acknowledges the
  /// cancelation.  -cancel may be sent to a task that has been suspended.
  void cancel() {
    return _lib._objc_msgSend_1(_id, _lib._sel_cancel1);
  }

  /// The current state of the task within the session.
  int get state {
    return _lib._objc_msgSend_255(_id, _lib._sel_state1);
  }

  /// The error, if any, delivered via -URLSession:task:didCompleteWithError:
  /// This property will be nil in the event that no error occured.
  NSError? get error {
    final _ret = _lib._objc_msgSend_256(_id, _lib._sel_error1);
    return _ret.address == 0
        ? null
        : NSError._(_ret, _lib, retain: true, release: true);
  }

  /// Suspending a task will prevent the NSURLSession from continuing to
  /// load data.  There may still be delegate calls made on behalf of
  /// this task (for instance, to report data received while suspending)
  /// but no further transmissions will be made on behalf of the task
  /// until -resume is sent.  The timeout timer associated with the task
  /// will be disabled while a task is suspended. -suspend and -resume are
  /// nestable.
  void suspend() {
    return _lib._objc_msgSend_1(_id, _lib._sel_suspend1);
  }

  void resume() {
    return _lib._objc_msgSend_1(_id, _lib._sel_resume1);
  }

  /// Sets a scaling factor for the priority of the task. The scaling factor is a
  /// value between 0.0 and 1.0 (inclusive), where 0.0 is considered the lowest
  /// priority and 1.0 is considered the highest.
  ///
  /// The priority is a hint and not a hard requirement of task performance. The
  /// priority of a task may be changed using this API at any time, but not all
  /// protocols support this; in these cases, the last priority that took effect
  /// will be used.
  ///
  /// If no priority is specified, the task will operate with the default priority
  /// as defined by the constant NSURLSessionTaskPriorityDefault. Two additional
  /// priority levels are provided: NSURLSessionTaskPriorityLow and
  /// NSURLSessionTaskPriorityHigh, but use is not restricted to these.
  double get priority {
    return _lib._objc_msgSend_64(_id, _lib._sel_priority1);
  }

  /// Sets a scaling factor for the priority of the task. The scaling factor is a
  /// value between 0.0 and 1.0 (inclusive), where 0.0 is considered the lowest
  /// priority and 1.0 is considered the highest.
  ///
  /// The priority is a hint and not a hard requirement of task performance. The
  /// priority of a task may be changed using this API at any time, but not all
  /// protocols support this; in these cases, the last priority that took effect
  /// will be used.
  ///
  /// If no priority is specified, the task will operate with the default priority
  /// as defined by the constant NSURLSessionTaskPriorityDefault. Two additional
  /// priority levels are provided: NSURLSessionTaskPriorityLow and
  /// NSURLSessionTaskPriorityHigh, but use is not restricted to these.
  set priority(double value) {
    _lib._objc_msgSend_257(_id, _lib._sel_setPriority_1, value);
  }

  /// Provides a hint indicating if incremental delivery of a partial response body
  /// would be useful for the application, or if it cannot process the response
  /// until it is complete. Indicating that incremental delivery is not desired may
  /// improve task performance. For example, if a response cannot be decoded until
  /// the entire content is received, set this property to false.
  ///
  /// Defaults to true unless this task is created with completion-handler based
  /// convenience methods, or if it is a download task.
  bool get prefersIncrementalDelivery {
    return _lib._objc_msgSend_11(_id, _lib._sel_prefersIncrementalDelivery1);
  }

  /// Provides a hint indicating if incremental delivery of a partial response body
  /// would be useful for the application, or if it cannot process the response
  /// until it is complete. Indicating that incremental delivery is not desired may
  /// improve task performance. For example, if a response cannot be decoded until
  /// the entire content is received, set this property to false.
  ///
  /// Defaults to true unless this task is created with completion-handler based
  /// convenience methods, or if it is a download task.
  set prefersIncrementalDelivery(bool value) {
    _lib._objc_msgSend_215(
        _id, _lib._sel_setPrefersIncrementalDelivery_1, value);
  }

  @override
  NSURLSessionTask init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSessionTask._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionTask new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLSessionTask1, _lib._sel_new1);
    return NSURLSessionTask._(_ret, _lib, retain: false, release: true);
  }

  static NSURLSessionTask alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLSessionTask1, _lib._sel_alloc1);
    return NSURLSessionTask._(_ret, _lib, retain: false, release: true);
  }
}

class NSURLResponse extends NSObject {
  NSURLResponse._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLResponse] that points to the same underlying object as [other].
  static NSURLResponse castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLResponse._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLResponse] that wraps the given raw object pointer.
  static NSURLResponse castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLResponse._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLResponse].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURLResponse1);
  }

  /// !
  /// @method initWithURL:MIMEType:expectedContentLength:textEncodingName:
  /// @abstract Initialize an NSURLResponse with the provided values.
  /// @param URL the URL
  /// @param MIMEType the MIME content type of the response
  /// @param length the expected content length of the associated data
  /// @param name the name of the text encoding for the associated data, if applicable, else nil
  /// @result The initialized NSURLResponse.
  /// @discussion This is the designated initializer for NSURLResponse.
  NSURLResponse initWithURL_MIMEType_expectedContentLength_textEncodingName_(
      NSURL? URL, NSString? MIMEType, int length, NSString? name) {
    final _ret = _lib._objc_msgSend_238(
        _id,
        _lib._sel_initWithURL_MIMEType_expectedContentLength_textEncodingName_1,
        URL?._id ?? ffi.nullptr,
        MIMEType?._id ?? ffi.nullptr,
        length,
        name?._id ?? ffi.nullptr);
    return NSURLResponse._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the URL of the receiver.
  /// @result The URL of the receiver.
  NSURL? get URL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_URL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the MIME type of the receiver.
  /// @discussion The MIME type is based on the information provided
  /// from an origin source. However, that value may be changed or
  /// corrected by a protocol implementation if it can be determined
  /// that the origin server or source reported the information
  /// incorrectly or imprecisely. An attempt to guess the MIME type may
  /// be made if the origin source did not report any such information.
  /// @result The MIME type of the receiver.
  NSString? get MIMEType {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_MIMEType1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the expected content length of the receiver.
  /// @discussion Some protocol implementations report a content length
  /// as part of delivering load metadata, but not all protocols
  /// guarantee the amount of data that will be delivered in actuality.
  /// Hence, this method returns an expected amount. Clients should use
  /// this value as an advisory, and should be prepared to deal with
  /// either more or less data.
  /// @result The expected content length of the receiver, or -1 if
  /// there is no expectation that can be arrived at regarding expected
  /// content length.
  int get expectedContentLength {
    return _lib._objc_msgSend_62(_id, _lib._sel_expectedContentLength1);
  }

  /// !
  /// @abstract Returns the name of the text encoding of the receiver.
  /// @discussion This name will be the actual string reported by the
  /// origin source during the course of performing a protocol-specific
  /// URL load. Clients can inspect this string and convert it to an
  /// NSStringEncoding or CFStringEncoding using the methods and
  /// functions made available in the appropriate framework.
  /// @result The name of the text encoding of the receiver, or nil if no
  /// text encoding was specified.
  NSString? get textEncodingName {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_textEncodingName1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns a suggested filename if the resource were saved to disk.
  /// @discussion The method first checks if the server has specified a filename using the
  /// content disposition header. If no valid filename is specified using that mechanism,
  /// this method checks the last path component of the URL. If no valid filename can be
  /// obtained using the last path component, this method uses the URL's host as the filename.
  /// If the URL's host can't be converted to a valid filename, the filename "unknown" is used.
  /// In mose cases, this method appends the proper file extension based on the MIME type.
  /// This method always returns a valid filename.
  /// @result A suggested filename to use if saving the resource to disk.
  NSString? get suggestedFilename {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_suggestedFilename1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSURLResponse new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLResponse1, _lib._sel_new1);
    return NSURLResponse._(_ret, _lib, retain: false, release: true);
  }

  static NSURLResponse alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLResponse1, _lib._sel_alloc1);
    return NSURLResponse._(_ret, _lib, retain: false, release: true);
  }
}

class NSProgress extends NSObject {
  NSProgress._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSProgress] that points to the same underlying object as [other].
  static NSProgress castFrom<T extends _ObjCWrapper>(T other) {
    return NSProgress._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSProgress] that wraps the given raw object pointer.
  static NSProgress castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSProgress._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSProgress].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSProgress1);
  }

  static NSProgress currentProgress(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_240(
        _lib._class_NSProgress1, _lib._sel_currentProgress1);
    return NSProgress._(_ret, _lib, retain: true, release: true);
  }

  static NSProgress progressWithTotalUnitCount_(
      NativeCupertinoHttp _lib, int unitCount) {
    final _ret = _lib._objc_msgSend_241(_lib._class_NSProgress1,
        _lib._sel_progressWithTotalUnitCount_1, unitCount);
    return NSProgress._(_ret, _lib, retain: true, release: true);
  }

  static NSProgress discreteProgressWithTotalUnitCount_(
      NativeCupertinoHttp _lib, int unitCount) {
    final _ret = _lib._objc_msgSend_241(_lib._class_NSProgress1,
        _lib._sel_discreteProgressWithTotalUnitCount_1, unitCount);
    return NSProgress._(_ret, _lib, retain: true, release: true);
  }

  static NSProgress progressWithTotalUnitCount_parent_pendingUnitCount_(
      NativeCupertinoHttp _lib,
      int unitCount,
      NSProgress? parent,
      int portionOfParentTotalUnitCount) {
    final _ret = _lib._objc_msgSend_242(
        _lib._class_NSProgress1,
        _lib._sel_progressWithTotalUnitCount_parent_pendingUnitCount_1,
        unitCount,
        parent?._id ?? ffi.nullptr,
        portionOfParentTotalUnitCount);
    return NSProgress._(_ret, _lib, retain: true, release: true);
  }

  NSProgress initWithParent_userInfo_(
      NSProgress? parentProgressOrNil, NSDictionary? userInfoOrNil) {
    final _ret = _lib._objc_msgSend_243(
        _id,
        _lib._sel_initWithParent_userInfo_1,
        parentProgressOrNil?._id ?? ffi.nullptr,
        userInfoOrNil?._id ?? ffi.nullptr);
    return NSProgress._(_ret, _lib, retain: true, release: true);
  }

  void becomeCurrentWithPendingUnitCount_(int unitCount) {
    return _lib._objc_msgSend_244(
        _id, _lib._sel_becomeCurrentWithPendingUnitCount_1, unitCount);
  }

  void performAsCurrentWithPendingUnitCount_usingBlock_(
      int unitCount, ObjCBlock7 work) {
    return _lib._objc_msgSend_245(
        _id,
        _lib._sel_performAsCurrentWithPendingUnitCount_usingBlock_1,
        unitCount,
        work._impl);
  }

  void resignCurrent() {
    return _lib._objc_msgSend_1(_id, _lib._sel_resignCurrent1);
  }

  void addChild_withPendingUnitCount_(NSProgress? child, int inUnitCount) {
    return _lib._objc_msgSend_246(
        _id,
        _lib._sel_addChild_withPendingUnitCount_1,
        child?._id ?? ffi.nullptr,
        inUnitCount);
  }

  int get totalUnitCount {
    return _lib._objc_msgSend_247(_id, _lib._sel_totalUnitCount1);
  }

  set totalUnitCount(int value) {
    _lib._objc_msgSend_248(_id, _lib._sel_setTotalUnitCount_1, value);
  }

  int get completedUnitCount {
    return _lib._objc_msgSend_247(_id, _lib._sel_completedUnitCount1);
  }

  set completedUnitCount(int value) {
    _lib._objc_msgSend_248(_id, _lib._sel_setCompletedUnitCount_1, value);
  }

  NSString? get localizedDescription {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_localizedDescription1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set localizedDescription(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setLocalizedDescription_1, value?._id ?? ffi.nullptr);
  }

  NSString? get localizedAdditionalDescription {
    final _ret =
        _lib._objc_msgSend_19(_id, _lib._sel_localizedAdditionalDescription1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set localizedAdditionalDescription(NSString? value) {
    _lib._objc_msgSend_216(_id, _lib._sel_setLocalizedAdditionalDescription_1,
        value?._id ?? ffi.nullptr);
  }

  bool get cancellable {
    return _lib._objc_msgSend_11(_id, _lib._sel_isCancellable1);
  }

  set cancellable(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setCancellable_1, value);
  }

  bool get pausable {
    return _lib._objc_msgSend_11(_id, _lib._sel_isPausable1);
  }

  set pausable(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setPausable_1, value);
  }

  bool get cancelled {
    return _lib._objc_msgSend_11(_id, _lib._sel_isCancelled1);
  }

  bool get paused {
    return _lib._objc_msgSend_11(_id, _lib._sel_isPaused1);
  }

  ObjCBlock7 get cancellationHandler {
    final _ret = _lib._objc_msgSend_249(_id, _lib._sel_cancellationHandler1);
    return ObjCBlock7._(_ret, _lib);
  }

  set cancellationHandler(ObjCBlock7 value) {
    _lib._objc_msgSend_250(
        _id, _lib._sel_setCancellationHandler_1, value._impl);
  }

  ObjCBlock7 get pausingHandler {
    final _ret = _lib._objc_msgSend_249(_id, _lib._sel_pausingHandler1);
    return ObjCBlock7._(_ret, _lib);
  }

  set pausingHandler(ObjCBlock7 value) {
    _lib._objc_msgSend_250(_id, _lib._sel_setPausingHandler_1, value._impl);
  }

  ObjCBlock7 get resumingHandler {
    final _ret = _lib._objc_msgSend_249(_id, _lib._sel_resumingHandler1);
    return ObjCBlock7._(_ret, _lib);
  }

  set resumingHandler(ObjCBlock7 value) {
    _lib._objc_msgSend_250(_id, _lib._sel_setResumingHandler_1, value._impl);
  }

  void setUserInfoObject_forKey_(
      NSObject objectOrNil, NSProgressUserInfoKey key) {
    return _lib._objc_msgSend_98(
        _id, _lib._sel_setUserInfoObject_forKey_1, objectOrNil._id, key);
  }

  bool get indeterminate {
    return _lib._objc_msgSend_11(_id, _lib._sel_isIndeterminate1);
  }

  double get fractionCompleted {
    return _lib._objc_msgSend_65(_id, _lib._sel_fractionCompleted1);
  }

  bool get finished {
    return _lib._objc_msgSend_11(_id, _lib._sel_isFinished1);
  }

  void cancel() {
    return _lib._objc_msgSend_1(_id, _lib._sel_cancel1);
  }

  void pause() {
    return _lib._objc_msgSend_1(_id, _lib._sel_pause1);
  }

  void resume() {
    return _lib._objc_msgSend_1(_id, _lib._sel_resume1);
  }

  NSDictionary? get userInfo {
    final _ret = _lib._objc_msgSend_89(_id, _lib._sel_userInfo1);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  NSProgressKind get kind {
    return _lib._objc_msgSend_19(_id, _lib._sel_kind1);
  }

  set kind(NSProgressKind value) {
    _lib._objc_msgSend_216(_id, _lib._sel_setKind_1, value);
  }

  NSNumber? get estimatedTimeRemaining {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_estimatedTimeRemaining1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  set estimatedTimeRemaining(NSNumber? value) {
    _lib._objc_msgSend_251(
        _id, _lib._sel_setEstimatedTimeRemaining_1, value?._id ?? ffi.nullptr);
  }

  NSNumber? get throughput {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_throughput1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  set throughput(NSNumber? value) {
    _lib._objc_msgSend_251(
        _id, _lib._sel_setThroughput_1, value?._id ?? ffi.nullptr);
  }

  NSProgressFileOperationKind get fileOperationKind {
    return _lib._objc_msgSend_19(_id, _lib._sel_fileOperationKind1);
  }

  set fileOperationKind(NSProgressFileOperationKind value) {
    _lib._objc_msgSend_216(_id, _lib._sel_setFileOperationKind_1, value);
  }

  NSURL? get fileURL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_fileURL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  set fileURL(NSURL? value) {
    _lib._objc_msgSend_211(
        _id, _lib._sel_setFileURL_1, value?._id ?? ffi.nullptr);
  }

  NSNumber? get fileTotalCount {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_fileTotalCount1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  set fileTotalCount(NSNumber? value) {
    _lib._objc_msgSend_251(
        _id, _lib._sel_setFileTotalCount_1, value?._id ?? ffi.nullptr);
  }

  NSNumber? get fileCompletedCount {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_fileCompletedCount1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  set fileCompletedCount(NSNumber? value) {
    _lib._objc_msgSend_251(
        _id, _lib._sel_setFileCompletedCount_1, value?._id ?? ffi.nullptr);
  }

  void publish() {
    return _lib._objc_msgSend_1(_id, _lib._sel_publish1);
  }

  void unpublish() {
    return _lib._objc_msgSend_1(_id, _lib._sel_unpublish1);
  }

  static NSObject addSubscriberForFileURL_withPublishingHandler_(
      NativeCupertinoHttp _lib,
      NSURL? url,
      NSProgressPublishingHandler publishingHandler) {
    final _ret = _lib._objc_msgSend_252(
        _lib._class_NSProgress1,
        _lib._sel_addSubscriberForFileURL_withPublishingHandler_1,
        url?._id ?? ffi.nullptr,
        publishingHandler);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static void removeSubscriber_(NativeCupertinoHttp _lib, NSObject subscriber) {
    return _lib._objc_msgSend_109(
        _lib._class_NSProgress1, _lib._sel_removeSubscriber_1, subscriber._id);
  }

  bool get old {
    return _lib._objc_msgSend_11(_id, _lib._sel_isOld1);
  }

  static NSProgress new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSProgress1, _lib._sel_new1);
    return NSProgress._(_ret, _lib, retain: false, release: true);
  }

  static NSProgress alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSProgress1, _lib._sel_alloc1);
    return NSProgress._(_ret, _lib, retain: false, release: true);
  }
}

void _ObjCBlock7_fnPtrTrampoline(ffi.Pointer<_ObjCBlock> block) {
  return block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function()>>()
      .asFunction<void Function()>()();
}

final _ObjCBlock7_closureRegistry = <int, Function>{};
int _ObjCBlock7_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock7_registerClosure(Function fn) {
  final id = ++_ObjCBlock7_closureRegistryIndex;
  _ObjCBlock7_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock7_closureTrampoline(ffi.Pointer<_ObjCBlock> block) {
  return _ObjCBlock7_closureRegistry[block.ref.target.address]!();
}

class ObjCBlock7 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock7._(this._impl, this._lib);
  ObjCBlock7.fromFunctionPointer(
      this._lib, ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block)>(
                    _ObjCBlock7_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock7.fromFunction(this._lib, void Function() fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block)>(
                    _ObjCBlock7_closureTrampoline)
                .cast(),
            _ObjCBlock7_registerClosure(fn));
  void call() {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<_ObjCBlock> block)>>()
        .asFunction<void Function(ffi.Pointer<_ObjCBlock> block)>()(_impl);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

typedef NSProgressUserInfoKey = ffi.Pointer<ObjCObject>;
typedef NSProgressKind = ffi.Pointer<ObjCObject>;
typedef NSProgressFileOperationKind = ffi.Pointer<ObjCObject>;
typedef NSProgressPublishingHandler = ffi.Pointer<_ObjCBlock>;
NSProgressUnpublishingHandler _ObjCBlock8_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              NSProgressUnpublishingHandler Function(
                  ffi.Pointer<ObjCObject> arg0)>>()
      .asFunction<
          NSProgressUnpublishingHandler Function(
              ffi.Pointer<ObjCObject> arg0)>()(arg0);
}

final _ObjCBlock8_closureRegistry = <int, Function>{};
int _ObjCBlock8_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock8_registerClosure(Function fn) {
  final id = ++_ObjCBlock8_closureRegistryIndex;
  _ObjCBlock8_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

NSProgressUnpublishingHandler _ObjCBlock8_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0) {
  return _ObjCBlock8_closureRegistry[block.ref.target.address]!(arg0);
}

class ObjCBlock8 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock8._(this._impl, this._lib);
  ObjCBlock8.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  NSProgressUnpublishingHandler Function(
                      ffi.Pointer<ObjCObject> arg0)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        NSProgressUnpublishingHandler Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0)>(
                    _ObjCBlock8_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock8.fromFunction(this._lib,
      NSProgressUnpublishingHandler Function(ffi.Pointer<ObjCObject> arg0) fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        NSProgressUnpublishingHandler Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0)>(
                    _ObjCBlock8_closureTrampoline)
                .cast(),
            _ObjCBlock8_registerClosure(fn));
  NSProgressUnpublishingHandler call(ffi.Pointer<ObjCObject> arg0) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                NSProgressUnpublishingHandler Function(
                    ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0)>>()
        .asFunction<
            NSProgressUnpublishingHandler Function(
                ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0)>()(_impl, arg0);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

typedef NSProgressUnpublishingHandler = ffi.Pointer<_ObjCBlock>;

abstract class NSURLSessionTaskState {
  /// The task is currently being serviced by the session
  static const int NSURLSessionTaskStateRunning = 0;
  static const int NSURLSessionTaskStateSuspended = 1;

  /// The task has been told to cancel.  The session will receive a URLSession:task:didCompleteWithError: message.
  static const int NSURLSessionTaskStateCanceling = 2;

  /// The task has completed and the session will receive no more delegate notifications
  static const int NSURLSessionTaskStateCompleted = 3;
}

void _ObjCBlock9_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ObjCObject> arg0)>>()
      .asFunction<void Function(ffi.Pointer<ObjCObject> arg0)>()(arg0);
}

final _ObjCBlock9_closureRegistry = <int, Function>{};
int _ObjCBlock9_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock9_registerClosure(Function fn) {
  final id = ++_ObjCBlock9_closureRegistryIndex;
  _ObjCBlock9_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock9_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0) {
  return _ObjCBlock9_closureRegistry[block.ref.target.address]!(arg0);
}

class ObjCBlock9 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock9._(this._impl, this._lib);
  ObjCBlock9.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ObjCObject> arg0)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0)>(
                    _ObjCBlock9_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock9.fromFunction(
      this._lib, void Function(ffi.Pointer<ObjCObject> arg0) fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0)>(
                    _ObjCBlock9_closureTrampoline)
                .cast(),
            _ObjCBlock9_registerClosure(fn));
  void call(ffi.Pointer<ObjCObject> arg0) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0)>>()
        .asFunction<
            void Function(ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0)>()(_impl, arg0);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

class NSURLCredentialStorage extends _ObjCWrapper {
  NSURLCredentialStorage._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLCredentialStorage] that points to the same underlying object as [other].
  static NSURLCredentialStorage castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLCredentialStorage._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLCredentialStorage] that wraps the given raw object pointer.
  static NSURLCredentialStorage castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLCredentialStorage._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLCredentialStorage].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLCredentialStorage1);
  }
}

class NSURLCache extends _ObjCWrapper {
  NSURLCache._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLCache] that points to the same underlying object as [other].
  static NSURLCache castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLCache._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLCache] that wraps the given raw object pointer.
  static NSURLCache castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLCache._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLCache].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSURLCache1);
  }
}

/// !
/// @enum NSURLSessionMultipathServiceType
///
/// @discussion The NSURLSessionMultipathServiceType enum defines constants that
/// can be used to specify the multipath service type to associate an NSURLSession.  The
/// multipath service type determines whether multipath TCP should be attempted and the conditions
/// for creating and switching between subflows.  Using these service types requires the appropriate entitlement.  Any connection attempt will fail if the process does not have the required entitlement.
/// A primary interface is a generally less expensive interface in terms of both cost and power (such as WiFi or ethernet).  A secondary interface is more expensive (such as 3G or LTE).
///
/// @constant NSURLSessionMultipathServiceTypeNone Specifies that multipath tcp should not be used.  Connections will use a single flow.
/// This is the default value.  No entitlement is required to set this value.
///
/// @constant NSURLSessionMultipathServiceTypeHandover Specifies that a secondary subflow should only be used
/// when the primary subflow is not performing adequately.   Requires the com.apple.developer.networking.multipath entilement.
///
/// @constant NSURLSessionMultipathServiceTypeInteractive Specifies that a secodary subflow should be used if the
/// primary subflow is not performing adequately (packet loss, high round trip times, bandwidth issues).  The secondary
/// subflow will be created more aggressively than with NSURLSessionMultipathServiceTypeHandover.  Requires the com.apple.developer.networking.multipath entitlement.
///
/// @constant NSURLSessionMultipathServiceTypeAggregate Specifies that multiple subflows across multiple interfaces should be
/// used for better bandwidth.  This mode is only available for experimentation on devices configured for development use.
/// It can be enabled in the Developer section of the Settings app.
abstract class NSURLSessionMultipathServiceType {
  /// None - no multipath (default)
  static const int NSURLSessionMultipathServiceTypeNone = 0;

  /// Handover - secondary flows brought up when primary flow is not performing adequately.
  static const int NSURLSessionMultipathServiceTypeHandover = 1;

  /// Interactive - secondary flows created more aggressively.
  static const int NSURLSessionMultipathServiceTypeInteractive = 2;

  /// Aggregate - multiple subflows used for greater bandwitdh.
  static const int NSURLSessionMultipathServiceTypeAggregate = 3;
}

class NSOperationQueue extends NSObject {
  NSOperationQueue._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSOperationQueue] that points to the same underlying object as [other].
  static NSOperationQueue castFrom<T extends _ObjCWrapper>(T other) {
    return NSOperationQueue._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSOperationQueue] that wraps the given raw object pointer.
  static NSOperationQueue castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSOperationQueue._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSOperationQueue].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSOperationQueue1);
  }

  /// @property progress
  /// @discussion     The `progress` property represents a total progress of the operations executed in the queue. By default NSOperationQueue
  /// does not report progress until the `totalUnitCount` of the progress is set. When the `totalUnitCount` property of the progress is set the
  /// queue then opts into participating in progress reporting. When enabled, each operation will contribute 1 unit of completion to the
  /// overall progress of the queue for operations that are finished by the end of main (operations that override start and do not invoke super
  /// will not contribute to progress). Special attention to race conditions should be made when updating the `totalUnitCount` of the progress
  /// as well as care should be taken to avoid 'backwards progress'. For example; when a NSOperationQueue's progress is 5/10, representing 50%
  /// completed, and there are 90 more operations about to be added and the `totalUnitCount` that would then make the progress report as 5/100
  /// which represents 5%. In this example it would mean that any progress bar would jump from displaying 50% back to 5%, which might not be
  /// desirable. In the cases where the `totalUnitCount` needs to be adjusted it is suggested to do this for thread-safety in a barrier by
  /// using the `addBarrierBlock:` API. This ensures that no un-expected execution state occurs adjusting into a potentially backwards moving
  /// progress scenario.
  ///
  /// @example
  /// NSOperationQueue *queue = [[NSOperationQueue alloc] init];
  /// queue.progress.totalUnitCount = 10;
  NSProgress? get progress {
    final _ret = _lib._objc_msgSend_240(_id, _lib._sel_progress1);
    return _ret.address == 0
        ? null
        : NSProgress._(_ret, _lib, retain: true, release: true);
  }

  void addOperation_(NSOperation? op) {
    return _lib._objc_msgSend_269(
        _id, _lib._sel_addOperation_1, op?._id ?? ffi.nullptr);
  }

  void addOperations_waitUntilFinished_(NSArray? ops, bool wait) {
    return _lib._objc_msgSend_274(
        _id,
        _lib._sel_addOperations_waitUntilFinished_1,
        ops?._id ?? ffi.nullptr,
        wait);
  }

  void addOperationWithBlock_(ObjCBlock7 block) {
    return _lib._objc_msgSend_275(
        _id, _lib._sel_addOperationWithBlock_1, block._impl);
  }

  /// @method addBarrierBlock:
  /// @param barrier      A block to execute
  /// @discussion         The `addBarrierBlock:` method executes the block when the NSOperationQueue has finished all enqueued operations and
  /// prevents any subsequent operations to be executed until the barrier has been completed. This acts similarly to the
  /// `dispatch_barrier_async` function.
  void addBarrierBlock_(ObjCBlock7 barrier) {
    return _lib._objc_msgSend_275(
        _id, _lib._sel_addBarrierBlock_1, barrier._impl);
  }

  int get maxConcurrentOperationCount {
    return _lib._objc_msgSend_61(_id, _lib._sel_maxConcurrentOperationCount1);
  }

  set maxConcurrentOperationCount(int value) {
    _lib._objc_msgSend_230(
        _id, _lib._sel_setMaxConcurrentOperationCount_1, value);
  }

  bool get suspended {
    return _lib._objc_msgSend_11(_id, _lib._sel_isSuspended1);
  }

  set suspended(bool value) {
    _lib._objc_msgSend_215(_id, _lib._sel_setSuspended_1, value);
  }

  NSString? get name {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_name1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set name(NSString? value) {
    _lib._objc_msgSend_216(_id, _lib._sel_setName_1, value?._id ?? ffi.nullptr);
  }

  int get qualityOfService {
    return _lib._objc_msgSend_272(_id, _lib._sel_qualityOfService1);
  }

  set qualityOfService(int value) {
    _lib._objc_msgSend_273(_id, _lib._sel_setQualityOfService_1, value);
  }

  /// actually retain
  dispatch_queue_t get underlyingQueue {
    return _lib._objc_msgSend_276(_id, _lib._sel_underlyingQueue1);
  }

  /// actually retain
  set underlyingQueue(dispatch_queue_t value) {
    _lib._objc_msgSend_277(_id, _lib._sel_setUnderlyingQueue_1, value);
  }

  void cancelAllOperations() {
    return _lib._objc_msgSend_1(_id, _lib._sel_cancelAllOperations1);
  }

  void waitUntilAllOperationsAreFinished() {
    return _lib._objc_msgSend_1(
        _id, _lib._sel_waitUntilAllOperationsAreFinished1);
  }

  static NSOperationQueue? getCurrentQueue(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_278(
        _lib._class_NSOperationQueue1, _lib._sel_currentQueue1);
    return _ret.address == 0
        ? null
        : NSOperationQueue._(_ret, _lib, retain: true, release: true);
  }

  static NSOperationQueue? getMainQueue(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_278(
        _lib._class_NSOperationQueue1, _lib._sel_mainQueue1);
    return _ret.address == 0
        ? null
        : NSOperationQueue._(_ret, _lib, retain: true, release: true);
  }

  /// These two functions are inherently a race condition and should be avoided if possible
  NSArray? get operations {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_operations1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  int get operationCount {
    return _lib._objc_msgSend_12(_id, _lib._sel_operationCount1);
  }

  static NSOperationQueue new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSOperationQueue1, _lib._sel_new1);
    return NSOperationQueue._(_ret, _lib, retain: false, release: true);
  }

  static NSOperationQueue alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSOperationQueue1, _lib._sel_alloc1);
    return NSOperationQueue._(_ret, _lib, retain: false, release: true);
  }
}

class NSOperation extends NSObject {
  NSOperation._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSOperation] that points to the same underlying object as [other].
  static NSOperation castFrom<T extends _ObjCWrapper>(T other) {
    return NSOperation._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSOperation] that wraps the given raw object pointer.
  static NSOperation castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSOperation._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSOperation].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSOperation1);
  }

  void start() {
    return _lib._objc_msgSend_1(_id, _lib._sel_start1);
  }

  void main() {
    return _lib._objc_msgSend_1(_id, _lib._sel_main1);
  }

  bool get cancelled {
    return _lib._objc_msgSend_11(_id, _lib._sel_isCancelled1);
  }

  void cancel() {
    return _lib._objc_msgSend_1(_id, _lib._sel_cancel1);
  }

  bool get executing {
    return _lib._objc_msgSend_11(_id, _lib._sel_isExecuting1);
  }

  bool get finished {
    return _lib._objc_msgSend_11(_id, _lib._sel_isFinished1);
  }

  /// To be deprecated; use and override 'asynchronous' below
  bool get concurrent {
    return _lib._objc_msgSend_11(_id, _lib._sel_isConcurrent1);
  }

  bool get asynchronous {
    return _lib._objc_msgSend_11(_id, _lib._sel_isAsynchronous1);
  }

  bool get ready {
    return _lib._objc_msgSend_11(_id, _lib._sel_isReady1);
  }

  void addDependency_(NSOperation? op) {
    return _lib._objc_msgSend_269(
        _id, _lib._sel_addDependency_1, op?._id ?? ffi.nullptr);
  }

  void removeDependency_(NSOperation? op) {
    return _lib._objc_msgSend_269(
        _id, _lib._sel_removeDependency_1, op?._id ?? ffi.nullptr);
  }

  NSArray? get dependencies {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_dependencies1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  int get queuePriority {
    return _lib._objc_msgSend_270(_id, _lib._sel_queuePriority1);
  }

  set queuePriority(int value) {
    _lib._objc_msgSend_271(_id, _lib._sel_setQueuePriority_1, value);
  }

  ObjCBlock7 get completionBlock {
    final _ret = _lib._objc_msgSend_249(_id, _lib._sel_completionBlock1);
    return ObjCBlock7._(_ret, _lib);
  }

  set completionBlock(ObjCBlock7 value) {
    _lib._objc_msgSend_250(_id, _lib._sel_setCompletionBlock_1, value._impl);
  }

  void waitUntilFinished() {
    return _lib._objc_msgSend_1(_id, _lib._sel_waitUntilFinished1);
  }

  double get threadPriority {
    return _lib._objc_msgSend_65(_id, _lib._sel_threadPriority1);
  }

  set threadPriority(double value) {
    _lib._objc_msgSend_213(_id, _lib._sel_setThreadPriority_1, value);
  }

  int get qualityOfService {
    return _lib._objc_msgSend_272(_id, _lib._sel_qualityOfService1);
  }

  set qualityOfService(int value) {
    _lib._objc_msgSend_273(_id, _lib._sel_setQualityOfService_1, value);
  }

  NSString? get name {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_name1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set name(NSString? value) {
    _lib._objc_msgSend_216(_id, _lib._sel_setName_1, value?._id ?? ffi.nullptr);
  }

  static NSOperation new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(_lib._class_NSOperation1, _lib._sel_new1);
    return NSOperation._(_ret, _lib, retain: false, release: true);
  }

  static NSOperation alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSOperation1, _lib._sel_alloc1);
    return NSOperation._(_ret, _lib, retain: false, release: true);
  }
}

abstract class NSOperationQueuePriority {
  static const int NSOperationQueuePriorityVeryLow = -8;
  static const int NSOperationQueuePriorityLow = -4;
  static const int NSOperationQueuePriorityNormal = 0;
  static const int NSOperationQueuePriorityHigh = 4;
  static const int NSOperationQueuePriorityVeryHigh = 8;
}

abstract class NSQualityOfService {
  static const int NSQualityOfServiceUserInteractive = 33;
  static const int NSQualityOfServiceUserInitiated = 25;
  static const int NSQualityOfServiceUtility = 17;
  static const int NSQualityOfServiceBackground = 9;
  static const int NSQualityOfServiceDefault = -1;
}

typedef dispatch_queue_t = ffi.Pointer<ObjCObject>;
void _ObjCBlock10_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0,
    ffi.Pointer<ObjCObject> arg1,
    ffi.Pointer<ObjCObject> arg2) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ObjCObject> arg0,
                  ffi.Pointer<ObjCObject> arg1,
                  ffi.Pointer<ObjCObject> arg2)>>()
      .asFunction<
          void Function(
              ffi.Pointer<ObjCObject> arg0,
              ffi.Pointer<ObjCObject> arg1,
              ffi.Pointer<ObjCObject> arg2)>()(arg0, arg1, arg2);
}

final _ObjCBlock10_closureRegistry = <int, Function>{};
int _ObjCBlock10_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock10_registerClosure(Function fn) {
  final id = ++_ObjCBlock10_closureRegistryIndex;
  _ObjCBlock10_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock10_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0,
    ffi.Pointer<ObjCObject> arg1,
    ffi.Pointer<ObjCObject> arg2) {
  return _ObjCBlock10_closureRegistry[block.ref.target.address]!(
      arg0, arg1, arg2);
}

class ObjCBlock10 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock10._(this._impl, this._lib);
  ObjCBlock10.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ObjCObject> arg0,
                      ffi.Pointer<ObjCObject> arg1,
                      ffi.Pointer<ObjCObject> arg2)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Pointer<ObjCObject> arg1,
                            ffi.Pointer<ObjCObject> arg2)>(
                    _ObjCBlock10_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock10.fromFunction(
      this._lib,
      void Function(ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1,
              ffi.Pointer<ObjCObject> arg2)
          fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Pointer<ObjCObject> arg1,
                            ffi.Pointer<ObjCObject> arg2)>(
                    _ObjCBlock10_closureTrampoline)
                .cast(),
            _ObjCBlock10_registerClosure(fn));
  void call(ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1,
      ffi.Pointer<ObjCObject> arg2) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0,
                    ffi.Pointer<ObjCObject> arg1,
                    ffi.Pointer<ObjCObject> arg2)>>()
        .asFunction<
            void Function(
                ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0,
                ffi.Pointer<ObjCObject> arg1,
                ffi.Pointer<ObjCObject> arg2)>()(_impl, arg0, arg1, arg2);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

/// An NSURLSessionDataTask does not provide any additional
/// functionality over an NSURLSessionTask and its presence is merely
/// to provide lexical differentiation from download and upload tasks.
class NSURLSessionDataTask extends NSURLSessionTask {
  NSURLSessionDataTask._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionDataTask] that points to the same underlying object as [other].
  static NSURLSessionDataTask castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLSessionDataTask._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionDataTask] that wraps the given raw object pointer.
  static NSURLSessionDataTask castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionDataTask._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionDataTask].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionDataTask1);
  }

  @override
  NSURLSessionDataTask init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSessionDataTask._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionDataTask new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLSessionDataTask1, _lib._sel_new1);
    return NSURLSessionDataTask._(_ret, _lib, retain: false, release: true);
  }

  static NSURLSessionDataTask alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionDataTask1, _lib._sel_alloc1);
    return NSURLSessionDataTask._(_ret, _lib, retain: false, release: true);
  }
}

/// An NSURLSessionUploadTask does not currently provide any additional
/// functionality over an NSURLSessionDataTask.  All delegate messages
/// that may be sent referencing an NSURLSessionDataTask equally apply
/// to NSURLSessionUploadTasks.
class NSURLSessionUploadTask extends NSURLSessionDataTask {
  NSURLSessionUploadTask._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionUploadTask] that points to the same underlying object as [other].
  static NSURLSessionUploadTask castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLSessionUploadTask._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionUploadTask] that wraps the given raw object pointer.
  static NSURLSessionUploadTask castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionUploadTask._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionUploadTask].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionUploadTask1);
  }

  @override
  NSURLSessionUploadTask init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSessionUploadTask._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionUploadTask new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionUploadTask1, _lib._sel_new1);
    return NSURLSessionUploadTask._(_ret, _lib, retain: false, release: true);
  }

  static NSURLSessionUploadTask alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionUploadTask1, _lib._sel_alloc1);
    return NSURLSessionUploadTask._(_ret, _lib, retain: false, release: true);
  }
}

/// NSURLSessionDownloadTask is a task that represents a download to
/// local storage.
class NSURLSessionDownloadTask extends NSURLSessionTask {
  NSURLSessionDownloadTask._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionDownloadTask] that points to the same underlying object as [other].
  static NSURLSessionDownloadTask castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLSessionDownloadTask._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionDownloadTask] that wraps the given raw object pointer.
  static NSURLSessionDownloadTask castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionDownloadTask._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionDownloadTask].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionDownloadTask1);
  }

  /// Cancel the download (and calls the superclass -cancel).  If
  /// conditions will allow for resuming the download in the future, the
  /// callback will be called with an opaque data blob, which may be used
  /// with -downloadTaskWithResumeData: to attempt to resume the download.
  /// If resume data cannot be created, the completion handler will be
  /// called with nil resumeData.
  void cancelByProducingResumeData_(ObjCBlock11 completionHandler) {
    return _lib._objc_msgSend_287(
        _id, _lib._sel_cancelByProducingResumeData_1, completionHandler._impl);
  }

  @override
  NSURLSessionDownloadTask init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSessionDownloadTask._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionDownloadTask new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionDownloadTask1, _lib._sel_new1);
    return NSURLSessionDownloadTask._(_ret, _lib, retain: false, release: true);
  }

  static NSURLSessionDownloadTask alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionDownloadTask1, _lib._sel_alloc1);
    return NSURLSessionDownloadTask._(_ret, _lib, retain: false, release: true);
  }
}

void _ObjCBlock11_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ObjCObject> arg0)>>()
      .asFunction<void Function(ffi.Pointer<ObjCObject> arg0)>()(arg0);
}

final _ObjCBlock11_closureRegistry = <int, Function>{};
int _ObjCBlock11_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock11_registerClosure(Function fn) {
  final id = ++_ObjCBlock11_closureRegistryIndex;
  _ObjCBlock11_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock11_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0) {
  return _ObjCBlock11_closureRegistry[block.ref.target.address]!(arg0);
}

class ObjCBlock11 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock11._(this._impl, this._lib);
  ObjCBlock11.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ObjCObject> arg0)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0)>(
                    _ObjCBlock11_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock11.fromFunction(
      this._lib, void Function(ffi.Pointer<ObjCObject> arg0) fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0)>(
                    _ObjCBlock11_closureTrampoline)
                .cast(),
            _ObjCBlock11_registerClosure(fn));
  void call(ffi.Pointer<ObjCObject> arg0) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0)>>()
        .asFunction<
            void Function(ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0)>()(_impl, arg0);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

/// An NSURLSessionStreamTask provides an interface to perform reads
/// and writes to a TCP/IP stream created via NSURLSession.  This task
/// may be explicitly created from an NSURLSession, or created as a
/// result of the appropriate disposition response to a
/// -URLSession:dataTask:didReceiveResponse: delegate message.
///
/// NSURLSessionStreamTask can be used to perform asynchronous reads
/// and writes.  Reads and writes are enquened and executed serially,
/// with the completion handler being invoked on the sessions delegate
/// queuee.  If an error occurs, or the task is canceled, all
/// outstanding read and write calls will have their completion
/// handlers invoked with an appropriate error.
///
/// It is also possible to create NSInputStream and NSOutputStream
/// instances from an NSURLSessionTask by sending
/// -captureStreams to the task.  All outstanding read and writess are
/// completed before the streams are created.  Once the streams are
/// delivered to the session delegate, the task is considered complete
/// and will receive no more messsages.  These streams are
/// disassociated from the underlying session.
class NSURLSessionStreamTask extends NSURLSessionTask {
  NSURLSessionStreamTask._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionStreamTask] that points to the same underlying object as [other].
  static NSURLSessionStreamTask castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLSessionStreamTask._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionStreamTask] that wraps the given raw object pointer.
  static NSURLSessionStreamTask castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionStreamTask._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionStreamTask].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionStreamTask1);
  }

  /// Read minBytes, or at most maxBytes bytes and invoke the completion
  /// handler on the sessions delegate queue with the data or an error.
  /// If an error occurs, any outstanding reads will also fail, and new
  /// read requests will error out immediately.
  void readDataOfMinLength_maxLength_timeout_completionHandler_(int minBytes,
      int maxBytes, double timeout, ObjCBlock12 completionHandler) {
    return _lib._objc_msgSend_291(
        _id,
        _lib._sel_readDataOfMinLength_maxLength_timeout_completionHandler_1,
        minBytes,
        maxBytes,
        timeout,
        completionHandler._impl);
  }

  /// Write the data completely to the underlying socket.  If all the
  /// bytes have not been written by the timeout, a timeout error will
  /// occur.  Note that invocation of the completion handler does not
  /// guarantee that the remote side has received all the bytes, only
  /// that they have been written to the kernel.
  void writeData_timeout_completionHandler_(
      NSData? data, double timeout, ObjCBlock13 completionHandler) {
    return _lib._objc_msgSend_292(
        _id,
        _lib._sel_writeData_timeout_completionHandler_1,
        data?._id ?? ffi.nullptr,
        timeout,
        completionHandler._impl);
  }

  /// -captureStreams completes any already enqueued reads
  /// and writes, and then invokes the
  /// URLSession:streamTask:didBecomeInputStream:outputStream: delegate
  /// message. When that message is received, the task object is
  /// considered completed and will not receive any more delegate
  /// messages.
  void captureStreams() {
    return _lib._objc_msgSend_1(_id, _lib._sel_captureStreams1);
  }

  /// Enqueue a request to close the write end of the underlying socket.
  /// All outstanding IO will complete before the write side of the
  /// socket is closed.  The server, however, may continue to write bytes
  /// back to the client, so best practice is to continue reading from
  /// the server until you receive EOF.
  void closeWrite() {
    return _lib._objc_msgSend_1(_id, _lib._sel_closeWrite1);
  }

  /// Enqueue a request to close the read side of the underlying socket.
  /// All outstanding IO will complete before the read side is closed.
  /// You may continue writing to the server.
  void closeRead() {
    return _lib._objc_msgSend_1(_id, _lib._sel_closeRead1);
  }

  /// Begin encrypted handshake.  The hanshake begins after all pending
  /// IO has completed.  TLS authentication callbacks are sent to the
  /// session's -URLSession:task:didReceiveChallenge:completionHandler:
  void startSecureConnection() {
    return _lib._objc_msgSend_1(_id, _lib._sel_startSecureConnection1);
  }

  /// Cleanly close a secure connection after all pending secure IO has
  /// completed.
  ///
  /// @warning This API is non-functional.
  void stopSecureConnection() {
    return _lib._objc_msgSend_1(_id, _lib._sel_stopSecureConnection1);
  }

  @override
  NSURLSessionStreamTask init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSessionStreamTask._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionStreamTask new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionStreamTask1, _lib._sel_new1);
    return NSURLSessionStreamTask._(_ret, _lib, retain: false, release: true);
  }

  static NSURLSessionStreamTask alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionStreamTask1, _lib._sel_alloc1);
    return NSURLSessionStreamTask._(_ret, _lib, retain: false, release: true);
  }
}

void _ObjCBlock12_fnPtrTrampoline(ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0, bool arg1, ffi.Pointer<ObjCObject> arg2) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ObjCObject> arg0, ffi.Bool arg1,
                  ffi.Pointer<ObjCObject> arg2)>>()
      .asFunction<
          void Function(ffi.Pointer<ObjCObject> arg0, bool arg1,
              ffi.Pointer<ObjCObject> arg2)>()(arg0, arg1, arg2);
}

final _ObjCBlock12_closureRegistry = <int, Function>{};
int _ObjCBlock12_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock12_registerClosure(Function fn) {
  final id = ++_ObjCBlock12_closureRegistryIndex;
  _ObjCBlock12_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock12_closureTrampoline(ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0, bool arg1, ffi.Pointer<ObjCObject> arg2) {
  return _ObjCBlock12_closureRegistry[block.ref.target.address]!(
      arg0, arg1, arg2);
}

class ObjCBlock12 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock12._(this._impl, this._lib);
  ObjCBlock12.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ObjCObject> arg0, ffi.Bool arg1,
                      ffi.Pointer<ObjCObject> arg2)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Bool arg1,
                            ffi.Pointer<ObjCObject> arg2)>(
                    _ObjCBlock12_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock12.fromFunction(
      this._lib,
      void Function(ffi.Pointer<ObjCObject> arg0, bool arg1,
              ffi.Pointer<ObjCObject> arg2)
          fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Bool arg1,
                            ffi.Pointer<ObjCObject> arg2)>(
                    _ObjCBlock12_closureTrampoline)
                .cast(),
            _ObjCBlock12_registerClosure(fn));
  void call(
      ffi.Pointer<ObjCObject> arg0, bool arg1, ffi.Pointer<ObjCObject> arg2) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0,
                    ffi.Bool arg1,
                    ffi.Pointer<ObjCObject> arg2)>>()
        .asFunction<
            void Function(
                ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0,
                bool arg1,
                ffi.Pointer<ObjCObject> arg2)>()(_impl, arg0, arg1, arg2);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

void _ObjCBlock13_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ObjCObject> arg0)>>()
      .asFunction<void Function(ffi.Pointer<ObjCObject> arg0)>()(arg0);
}

final _ObjCBlock13_closureRegistry = <int, Function>{};
int _ObjCBlock13_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock13_registerClosure(Function fn) {
  final id = ++_ObjCBlock13_closureRegistryIndex;
  _ObjCBlock13_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock13_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block, ffi.Pointer<ObjCObject> arg0) {
  return _ObjCBlock13_closureRegistry[block.ref.target.address]!(arg0);
}

class ObjCBlock13 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock13._(this._impl, this._lib);
  ObjCBlock13.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ObjCObject> arg0)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0)>(
                    _ObjCBlock13_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock13.fromFunction(
      this._lib, void Function(ffi.Pointer<ObjCObject> arg0) fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0)>(
                    _ObjCBlock13_closureTrampoline)
                .cast(),
            _ObjCBlock13_registerClosure(fn));
  void call(ffi.Pointer<ObjCObject> arg0) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0)>>()
        .asFunction<
            void Function(ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0)>()(_impl, arg0);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

class NSNetService extends _ObjCWrapper {
  NSNetService._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSNetService] that points to the same underlying object as [other].
  static NSNetService castFrom<T extends _ObjCWrapper>(T other) {
    return NSNetService._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSNetService] that wraps the given raw object pointer.
  static NSNetService castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSNetService._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSNetService].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSNetService1);
  }
}

/// A WebSocket task can be created with a ws or wss url. A client can also provide
/// a list of protocols it wishes to advertise during the WebSocket handshake phase.
/// Once the handshake is successfully completed the client will be notified through an optional delegate.
/// All reads and writes enqueued before the completion of the handshake will be queued up and
/// executed once the hanshake succeeds. Before the handshake completes, the client can be called to handle
/// redirection or authentication using the same delegates as NSURLSessionTask. WebSocket task will also provide
/// support for cookies and will store cookies to the cookie storage on the session and will attach cookies to
/// outgoing HTTP handshake requests.
class NSURLSessionWebSocketTask extends NSURLSessionTask {
  NSURLSessionWebSocketTask._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionWebSocketTask] that points to the same underlying object as [other].
  static NSURLSessionWebSocketTask castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLSessionWebSocketTask._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionWebSocketTask] that wraps the given raw object pointer.
  static NSURLSessionWebSocketTask castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionWebSocketTask._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionWebSocketTask].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionWebSocketTask1);
  }

  /// Sends a WebSocket message. If an error occurs, any outstanding work will also fail.
  /// Note that invocation of the completion handler does not
  /// guarantee that the remote side has received all the bytes, only
  /// that they have been written to the kernel.
  void sendMessage_completionHandler_(
      NSURLSessionWebSocketMessage? message, ObjCBlock13 completionHandler) {
    return _lib._objc_msgSend_296(
        _id,
        _lib._sel_sendMessage_completionHandler_1,
        message?._id ?? ffi.nullptr,
        completionHandler._impl);
  }

  /// Reads a WebSocket message once all the frames of the message are available.
  /// If the maximumMessage size is hit while buffering the frames, the receiveMessage call will error out
  /// and all outstanding work will also fail resulting in the end of the task.
  void receiveMessageWithCompletionHandler_(ObjCBlock14 completionHandler) {
    return _lib._objc_msgSend_297(
        _id,
        _lib._sel_receiveMessageWithCompletionHandler_1,
        completionHandler._impl);
  }

  /// Sends a ping frame from the client side. The pongReceiveHandler is invoked when the client
  /// receives a pong from the server endpoint. If a connection is lost or an error occurs before receiving
  /// the pong from the endpoint, the pongReceiveHandler block will be invoked with an error.
  /// Note - the pongReceiveHandler will always be called in the order in which the pings were sent.
  void sendPingWithPongReceiveHandler_(ObjCBlock13 pongReceiveHandler) {
    return _lib._objc_msgSend_298(_id,
        _lib._sel_sendPingWithPongReceiveHandler_1, pongReceiveHandler._impl);
  }

  /// Sends a close frame with the given closeCode. An optional reason can be provided while sending the close frame.
  /// Simply calling cancel on the task will result in a cancellation frame being sent without any reason.
  void cancelWithCloseCode_reason_(int closeCode, NSData? reason) {
    return _lib._objc_msgSend_299(_id, _lib._sel_cancelWithCloseCode_reason_1,
        closeCode, reason?._id ?? ffi.nullptr);
  }

  /// The maximum number of bytes to be buffered before erroring out. This includes the sum of all bytes from continuation frames. Recieve calls will error out if this value is reached
  int get maximumMessageSize {
    return _lib._objc_msgSend_61(_id, _lib._sel_maximumMessageSize1);
  }

  /// The maximum number of bytes to be buffered before erroring out. This includes the sum of all bytes from continuation frames. Recieve calls will error out if this value is reached
  set maximumMessageSize(int value) {
    _lib._objc_msgSend_230(_id, _lib._sel_setMaximumMessageSize_1, value);
  }

  /// A task can be queried for it's close code at any point. When the task is not closed, it will be set to NSURLSessionWebSocketCloseCodeInvalid
  int get closeCode {
    return _lib._objc_msgSend_300(_id, _lib._sel_closeCode1);
  }

  /// A task can be queried for it's close reason at any point. A nil value indicates no closeReason or that the task is still running
  NSData? get closeReason {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_closeReason1);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSURLSessionWebSocketTask init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSessionWebSocketTask._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionWebSocketTask new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionWebSocketTask1, _lib._sel_new1);
    return NSURLSessionWebSocketTask._(_ret, _lib,
        retain: false, release: true);
  }

  static NSURLSessionWebSocketTask alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionWebSocketTask1, _lib._sel_alloc1);
    return NSURLSessionWebSocketTask._(_ret, _lib,
        retain: false, release: true);
  }
}

/// The client can create a WebSocket message object that will be passed to the send calls
/// and will be delivered from the receive calls. The message can be initialized with data or string.
/// If initialized with data, the string property will be nil and vice versa.
class NSURLSessionWebSocketMessage extends NSObject {
  NSURLSessionWebSocketMessage._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionWebSocketMessage] that points to the same underlying object as [other].
  static NSURLSessionWebSocketMessage castFrom<T extends _ObjCWrapper>(
      T other) {
    return NSURLSessionWebSocketMessage._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionWebSocketMessage] that wraps the given raw object pointer.
  static NSURLSessionWebSocketMessage castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionWebSocketMessage._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionWebSocketMessage].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionWebSocketMessage1);
  }

  /// Create a message with data type
  NSURLSessionWebSocketMessage initWithData_(NSData? data) {
    final _ret = _lib._objc_msgSend_126(
        _id, _lib._sel_initWithData_1, data?._id ?? ffi.nullptr);
    return NSURLSessionWebSocketMessage._(_ret, _lib,
        retain: true, release: true);
  }

  /// Create a message with string type
  NSURLSessionWebSocketMessage initWithString_(NSString? string) {
    final _ret = _lib._objc_msgSend_29(
        _id, _lib._sel_initWithString_1, string?._id ?? ffi.nullptr);
    return NSURLSessionWebSocketMessage._(_ret, _lib,
        retain: true, release: true);
  }

  int get type {
    return _lib._objc_msgSend_295(_id, _lib._sel_type1);
  }

  NSData? get data {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_data1);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  NSString? get string {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_string1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  @override
  NSURLSessionWebSocketMessage init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSessionWebSocketMessage._(_ret, _lib,
        retain: true, release: true);
  }

  static NSURLSessionWebSocketMessage new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionWebSocketMessage1, _lib._sel_new1);
    return NSURLSessionWebSocketMessage._(_ret, _lib,
        retain: false, release: true);
  }

  static NSURLSessionWebSocketMessage alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionWebSocketMessage1, _lib._sel_alloc1);
    return NSURLSessionWebSocketMessage._(_ret, _lib,
        retain: false, release: true);
  }
}

abstract class NSURLSessionWebSocketMessageType {
  static const int NSURLSessionWebSocketMessageTypeData = 0;
  static const int NSURLSessionWebSocketMessageTypeString = 1;
}

void _ObjCBlock14_fnPtrTrampoline(ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ObjCObject> arg0,
                  ffi.Pointer<ObjCObject> arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<ObjCObject> arg0,
              ffi.Pointer<ObjCObject> arg1)>()(arg0, arg1);
}

final _ObjCBlock14_closureRegistry = <int, Function>{};
int _ObjCBlock14_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock14_registerClosure(Function fn) {
  final id = ++_ObjCBlock14_closureRegistryIndex;
  _ObjCBlock14_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock14_closureTrampoline(ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1) {
  return _ObjCBlock14_closureRegistry[block.ref.target.address]!(arg0, arg1);
}

class ObjCBlock14 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock14._(this._impl, this._lib);
  ObjCBlock14.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ObjCObject> arg0,
                      ffi.Pointer<ObjCObject> arg1)>>
          ptr)
      : _impl =
            _lib._newBlock1(
                ffi.Pointer.fromFunction<
                            ffi.Void Function(
                                ffi.Pointer<_ObjCBlock> block,
                                ffi.Pointer<ObjCObject> arg0,
                                ffi.Pointer<ObjCObject> arg1)>(
                        _ObjCBlock14_fnPtrTrampoline)
                    .cast(),
                ptr.cast());
  ObjCBlock14.fromFunction(
      this._lib,
      void Function(ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1)
          fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Pointer<ObjCObject> arg1)>(
                    _ObjCBlock14_closureTrampoline)
                .cast(),
            _ObjCBlock14_registerClosure(fn));
  void call(ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0,
                    ffi.Pointer<ObjCObject> arg1)>>()
        .asFunction<
            void Function(
                ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0,
                ffi.Pointer<ObjCObject> arg1)>()(_impl, arg0, arg1);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

/// The WebSocket close codes follow the close codes given in the RFC
abstract class NSURLSessionWebSocketCloseCode {
  static const int NSURLSessionWebSocketCloseCodeInvalid = 0;
  static const int NSURLSessionWebSocketCloseCodeNormalClosure = 1000;
  static const int NSURLSessionWebSocketCloseCodeGoingAway = 1001;
  static const int NSURLSessionWebSocketCloseCodeProtocolError = 1002;
  static const int NSURLSessionWebSocketCloseCodeUnsupportedData = 1003;
  static const int NSURLSessionWebSocketCloseCodeNoStatusReceived = 1005;
  static const int NSURLSessionWebSocketCloseCodeAbnormalClosure = 1006;
  static const int NSURLSessionWebSocketCloseCodeInvalidFramePayloadData = 1007;
  static const int NSURLSessionWebSocketCloseCodePolicyViolation = 1008;
  static const int NSURLSessionWebSocketCloseCodeMessageTooBig = 1009;
  static const int NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing =
      1010;
  static const int NSURLSessionWebSocketCloseCodeInternalServerError = 1011;
  static const int NSURLSessionWebSocketCloseCodeTLSHandshakeFailure = 1015;
}

void _ObjCBlock15_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0,
    ffi.Pointer<ObjCObject> arg1,
    ffi.Pointer<ObjCObject> arg2) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ObjCObject> arg0,
                  ffi.Pointer<ObjCObject> arg1,
                  ffi.Pointer<ObjCObject> arg2)>>()
      .asFunction<
          void Function(
              ffi.Pointer<ObjCObject> arg0,
              ffi.Pointer<ObjCObject> arg1,
              ffi.Pointer<ObjCObject> arg2)>()(arg0, arg1, arg2);
}

final _ObjCBlock15_closureRegistry = <int, Function>{};
int _ObjCBlock15_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock15_registerClosure(Function fn) {
  final id = ++_ObjCBlock15_closureRegistryIndex;
  _ObjCBlock15_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock15_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0,
    ffi.Pointer<ObjCObject> arg1,
    ffi.Pointer<ObjCObject> arg2) {
  return _ObjCBlock15_closureRegistry[block.ref.target.address]!(
      arg0, arg1, arg2);
}

class ObjCBlock15 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock15._(this._impl, this._lib);
  ObjCBlock15.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ObjCObject> arg0,
                      ffi.Pointer<ObjCObject> arg1,
                      ffi.Pointer<ObjCObject> arg2)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Pointer<ObjCObject> arg1,
                            ffi.Pointer<ObjCObject> arg2)>(
                    _ObjCBlock15_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock15.fromFunction(
      this._lib,
      void Function(ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1,
              ffi.Pointer<ObjCObject> arg2)
          fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Pointer<ObjCObject> arg1,
                            ffi.Pointer<ObjCObject> arg2)>(
                    _ObjCBlock15_closureTrampoline)
                .cast(),
            _ObjCBlock15_registerClosure(fn));
  void call(ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1,
      ffi.Pointer<ObjCObject> arg2) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0,
                    ffi.Pointer<ObjCObject> arg1,
                    ffi.Pointer<ObjCObject> arg2)>>()
        .asFunction<
            void Function(
                ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0,
                ffi.Pointer<ObjCObject> arg1,
                ffi.Pointer<ObjCObject> arg2)>()(_impl, arg0, arg1, arg2);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

void _ObjCBlock16_fnPtrTrampoline(
    ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0,
    ffi.Pointer<ObjCObject> arg1,
    ffi.Pointer<ObjCObject> arg2) {
  return block.ref.target
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ObjCObject> arg0,
                  ffi.Pointer<ObjCObject> arg1,
                  ffi.Pointer<ObjCObject> arg2)>>()
      .asFunction<
          void Function(
              ffi.Pointer<ObjCObject> arg0,
              ffi.Pointer<ObjCObject> arg1,
              ffi.Pointer<ObjCObject> arg2)>()(arg0, arg1, arg2);
}

final _ObjCBlock16_closureRegistry = <int, Function>{};
int _ObjCBlock16_closureRegistryIndex = 0;
ffi.Pointer<ffi.Void> _ObjCBlock16_registerClosure(Function fn) {
  final id = ++_ObjCBlock16_closureRegistryIndex;
  _ObjCBlock16_closureRegistry[id] = fn;
  return ffi.Pointer<ffi.Void>.fromAddress(id);
}

void _ObjCBlock16_closureTrampoline(
    ffi.Pointer<_ObjCBlock> block,
    ffi.Pointer<ObjCObject> arg0,
    ffi.Pointer<ObjCObject> arg1,
    ffi.Pointer<ObjCObject> arg2) {
  return _ObjCBlock16_closureRegistry[block.ref.target.address]!(
      arg0, arg1, arg2);
}

class ObjCBlock16 {
  final ffi.Pointer<_ObjCBlock> _impl;
  final NativeCupertinoHttp _lib;
  ObjCBlock16._(this._impl, this._lib);
  ObjCBlock16.fromFunctionPointer(
      this._lib,
      ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ObjCObject> arg0,
                      ffi.Pointer<ObjCObject> arg1,
                      ffi.Pointer<ObjCObject> arg2)>>
          ptr)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Pointer<ObjCObject> arg1,
                            ffi.Pointer<ObjCObject> arg2)>(
                    _ObjCBlock16_fnPtrTrampoline)
                .cast(),
            ptr.cast());
  ObjCBlock16.fromFunction(
      this._lib,
      void Function(ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1,
              ffi.Pointer<ObjCObject> arg2)
          fn)
      : _impl = _lib._newBlock1(
            ffi.Pointer.fromFunction<
                        ffi.Void Function(
                            ffi.Pointer<_ObjCBlock> block,
                            ffi.Pointer<ObjCObject> arg0,
                            ffi.Pointer<ObjCObject> arg1,
                            ffi.Pointer<ObjCObject> arg2)>(
                    _ObjCBlock16_closureTrampoline)
                .cast(),
            _ObjCBlock16_registerClosure(fn));
  void call(ffi.Pointer<ObjCObject> arg0, ffi.Pointer<ObjCObject> arg1,
      ffi.Pointer<ObjCObject> arg2) {
    return _impl.ref.invoke
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<_ObjCBlock> block,
                    ffi.Pointer<ObjCObject> arg0,
                    ffi.Pointer<ObjCObject> arg1,
                    ffi.Pointer<ObjCObject> arg2)>>()
        .asFunction<
            void Function(
                ffi.Pointer<_ObjCBlock> block,
                ffi.Pointer<ObjCObject> arg0,
                ffi.Pointer<ObjCObject> arg1,
                ffi.Pointer<ObjCObject> arg2)>()(_impl, arg0, arg1, arg2);
  }

  ffi.Pointer<_ObjCBlock> get pointer => _impl;
}

/// Disposition options for various delegate messages
abstract class NSURLSessionDelayedRequestDisposition {
  /// Use the original request provided when the task was created; the request parameter is ignored.
  static const int NSURLSessionDelayedRequestContinueLoading = 0;

  /// Use the specified request, which may not be nil.
  static const int NSURLSessionDelayedRequestUseNewRequest = 1;

  /// Cancel the task; the request parameter is ignored.
  static const int NSURLSessionDelayedRequestCancel = 2;
}

abstract class NSURLSessionAuthChallengeDisposition {
  /// Use the specified credential, which may be nil
  static const int NSURLSessionAuthChallengeUseCredential = 0;

  /// Default handling for the challenge - as if this delegate were not implemented; the credential parameter is ignored.
  static const int NSURLSessionAuthChallengePerformDefaultHandling = 1;

  /// The entire request will be canceled; the credential parameter is ignored.
  static const int NSURLSessionAuthChallengeCancelAuthenticationChallenge = 2;

  /// This challenge is rejected and the next authentication protection space should be tried; the credential parameter is ignored.
  static const int NSURLSessionAuthChallengeRejectProtectionSpace = 3;
}

abstract class NSURLSessionResponseDisposition {
  /// Cancel the load, this is the same as -[task cancel]
  static const int NSURLSessionResponseCancel = 0;

  /// Allow the load to continue
  static const int NSURLSessionResponseAllow = 1;

  /// Turn this request into a download
  static const int NSURLSessionResponseBecomeDownload = 2;

  /// Turn this task into a stream task
  static const int NSURLSessionResponseBecomeStream = 3;
}

/// The resource fetch type.
abstract class NSURLSessionTaskMetricsResourceFetchType {
  static const int NSURLSessionTaskMetricsResourceFetchTypeUnknown = 0;

  /// The resource was loaded over the network.
  static const int NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad = 1;

  /// The resource was pushed by the server to the client.
  static const int NSURLSessionTaskMetricsResourceFetchTypeServerPush = 2;

  /// The resource was retrieved from the local storage.
  static const int NSURLSessionTaskMetricsResourceFetchTypeLocalCache = 3;
}

/// DNS protocol used for domain resolution.
abstract class NSURLSessionTaskMetricsDomainResolutionProtocol {
  static const int NSURLSessionTaskMetricsDomainResolutionProtocolUnknown = 0;

  /// Resolution used DNS over UDP.
  static const int NSURLSessionTaskMetricsDomainResolutionProtocolUDP = 1;

  /// Resolution used DNS over TCP.
  static const int NSURLSessionTaskMetricsDomainResolutionProtocolTCP = 2;

  /// Resolution used DNS over TLS.
  static const int NSURLSessionTaskMetricsDomainResolutionProtocolTLS = 3;

  /// Resolution used DNS over HTTPS.
  static const int NSURLSessionTaskMetricsDomainResolutionProtocolHTTPS = 4;
}

/// This class defines the performance metrics collected for a request/response transaction during the task execution.
class NSURLSessionTaskTransactionMetrics extends NSObject {
  NSURLSessionTaskTransactionMetrics._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionTaskTransactionMetrics] that points to the same underlying object as [other].
  static NSURLSessionTaskTransactionMetrics castFrom<T extends _ObjCWrapper>(
      T other) {
    return NSURLSessionTaskTransactionMetrics._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionTaskTransactionMetrics] that wraps the given raw object pointer.
  static NSURLSessionTaskTransactionMetrics castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionTaskTransactionMetrics._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionTaskTransactionMetrics].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionTaskTransactionMetrics1);
  }

  /// Represents the transaction request.
  NSURLRequest? get request {
    final _ret = _lib._objc_msgSend_237(_id, _lib._sel_request1);
    return _ret.address == 0
        ? null
        : NSURLRequest._(_ret, _lib, retain: true, release: true);
  }

  /// Represents the transaction response. Can be nil if error occurred and no response was generated.
  NSURLResponse? get response {
    final _ret = _lib._objc_msgSend_239(_id, _lib._sel_response1);
    return _ret.address == 0
        ? null
        : NSURLResponse._(_ret, _lib, retain: true, release: true);
  }

  /// fetchStartDate returns the time when the user agent started fetching the resource, whether or not the resource was retrieved from the server or local resources.
  ///
  /// The following metrics will be set to nil, if a persistent connection was used or the resource was retrieved from local resources:
  ///
  /// domainLookupStartDate
  /// domainLookupEndDate
  /// connectStartDate
  /// connectEndDate
  /// secureConnectionStartDate
  /// secureConnectionEndDate
  NSDate? get fetchStartDate {
    final _ret = _lib._objc_msgSend_253(_id, _lib._sel_fetchStartDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// domainLookupStartDate returns the time immediately before the user agent started the name lookup for the resource.
  NSDate? get domainLookupStartDate {
    final _ret = _lib._objc_msgSend_253(_id, _lib._sel_domainLookupStartDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// domainLookupEndDate returns the time after the name lookup was completed.
  NSDate? get domainLookupEndDate {
    final _ret = _lib._objc_msgSend_253(_id, _lib._sel_domainLookupEndDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// connectStartDate is the time immediately before the user agent started establishing the connection to the server.
  ///
  /// For example, this would correspond to the time immediately before the user agent started trying to establish the TCP connection.
  NSDate? get connectStartDate {
    final _ret = _lib._objc_msgSend_253(_id, _lib._sel_connectStartDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// If an encrypted connection was used, secureConnectionStartDate is the time immediately before the user agent started the security handshake to secure the current connection.
  ///
  /// For example, this would correspond to the time immediately before the user agent started the TLS handshake.
  ///
  /// If an encrypted connection was not used, this attribute is set to nil.
  NSDate? get secureConnectionStartDate {
    final _ret =
        _lib._objc_msgSend_253(_id, _lib._sel_secureConnectionStartDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// If an encrypted connection was used, secureConnectionEndDate is the time immediately after the security handshake completed.
  ///
  /// If an encrypted connection was not used, this attribute is set to nil.
  NSDate? get secureConnectionEndDate {
    final _ret =
        _lib._objc_msgSend_253(_id, _lib._sel_secureConnectionEndDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// connectEndDate is the time immediately after the user agent finished establishing the connection to the server, including completion of security-related and other handshakes.
  NSDate? get connectEndDate {
    final _ret = _lib._objc_msgSend_253(_id, _lib._sel_connectEndDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// requestStartDate is the time immediately before the user agent started requesting the source, regardless of whether the resource was retrieved from the server or local resources.
  ///
  /// For example, this would correspond to the time immediately before the user agent sent an HTTP GET request.
  NSDate? get requestStartDate {
    final _ret = _lib._objc_msgSend_253(_id, _lib._sel_requestStartDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// requestEndDate is the time immediately after the user agent finished requesting the source, regardless of whether the resource was retrieved from the server or local resources.
  ///
  /// For example, this would correspond to the time immediately after the user agent finished sending the last byte of the request.
  NSDate? get requestEndDate {
    final _ret = _lib._objc_msgSend_253(_id, _lib._sel_requestEndDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// responseStartDate is the time immediately after the user agent received the first byte of the response from the server or from local resources.
  ///
  /// For example, this would correspond to the time immediately after the user agent received the first byte of an HTTP response.
  NSDate? get responseStartDate {
    final _ret = _lib._objc_msgSend_253(_id, _lib._sel_responseStartDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// responseEndDate is the time immediately after the user agent received the last byte of the resource.
  NSDate? get responseEndDate {
    final _ret = _lib._objc_msgSend_253(_id, _lib._sel_responseEndDate1);
    return _ret.address == 0
        ? null
        : NSDate._(_ret, _lib, retain: true, release: true);
  }

  /// The network protocol used to fetch the resource, as identified by the ALPN Protocol ID Identification Sequence [RFC7301].
  /// E.g., h2, http/1.1, spdy/3.1.
  ///
  /// When a proxy is configured AND a tunnel connection is established, then this attribute returns the value for the tunneled protocol.
  ///
  /// For example:
  /// If no proxy were used, and HTTP/2 was negotiated, then h2 would be returned.
  /// If HTTP/1.1 were used to the proxy, and the tunneled connection was HTTP/2, then h2 would be returned.
  /// If HTTP/1.1 were used to the proxy, and there were no tunnel, then http/1.1 would be returned.
  NSString? get networkProtocolName {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_networkProtocolName1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// This property is set to YES if a proxy connection was used to fetch the resource.
  bool get proxyConnection {
    return _lib._objc_msgSend_11(_id, _lib._sel_isProxyConnection1);
  }

  /// This property is set to YES if a persistent connection was used to fetch the resource.
  bool get reusedConnection {
    return _lib._objc_msgSend_11(_id, _lib._sel_isReusedConnection1);
  }

  /// Indicates whether the resource was loaded, pushed or retrieved from the local cache.
  int get resourceFetchType {
    return _lib._objc_msgSend_311(_id, _lib._sel_resourceFetchType1);
  }

  /// countOfRequestHeaderBytesSent is the number of bytes transferred for request header.
  int get countOfRequestHeaderBytesSent {
    return _lib._objc_msgSend_247(
        _id, _lib._sel_countOfRequestHeaderBytesSent1);
  }

  /// countOfRequestBodyBytesSent is the number of bytes transferred for request body.
  /// It includes protocol-specific framing, transfer encoding, and content encoding.
  int get countOfRequestBodyBytesSent {
    return _lib._objc_msgSend_247(_id, _lib._sel_countOfRequestBodyBytesSent1);
  }

  /// countOfRequestBodyBytesBeforeEncoding is the size of upload body data, file, or stream.
  int get countOfRequestBodyBytesBeforeEncoding {
    return _lib._objc_msgSend_247(
        _id, _lib._sel_countOfRequestBodyBytesBeforeEncoding1);
  }

  /// countOfResponseHeaderBytesReceived is the number of bytes transferred for response header.
  int get countOfResponseHeaderBytesReceived {
    return _lib._objc_msgSend_247(
        _id, _lib._sel_countOfResponseHeaderBytesReceived1);
  }

  /// countOfResponseBodyBytesReceived is the number of bytes transferred for response header.
  /// It includes protocol-specific framing, transfer encoding, and content encoding.
  int get countOfResponseBodyBytesReceived {
    return _lib._objc_msgSend_247(
        _id, _lib._sel_countOfResponseBodyBytesReceived1);
  }

  /// countOfResponseBodyBytesAfterDecoding is the size of data delivered to your delegate or completion handler.
  int get countOfResponseBodyBytesAfterDecoding {
    return _lib._objc_msgSend_247(
        _id, _lib._sel_countOfResponseBodyBytesAfterDecoding1);
  }

  /// localAddress is the IP address string of the local interface for the connection.
  ///
  /// For multipath protocols, this is the local address of the initial flow.
  ///
  /// If a connection was not used, this attribute is set to nil.
  NSString? get localAddress {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_localAddress1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// localPort is the port number of the local interface for the connection.
  ///
  /// For multipath protocols, this is the local port of the initial flow.
  ///
  /// If a connection was not used, this attribute is set to nil.
  NSNumber? get localPort {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_localPort1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  /// remoteAddress is the IP address string of the remote interface for the connection.
  ///
  /// For multipath protocols, this is the remote address of the initial flow.
  ///
  /// If a connection was not used, this attribute is set to nil.
  NSString? get remoteAddress {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_remoteAddress1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// remotePort is the port number of the remote interface for the connection.
  ///
  /// For multipath protocols, this is the remote port of the initial flow.
  ///
  /// If a connection was not used, this attribute is set to nil.
  NSNumber? get remotePort {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_remotePort1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  /// negotiatedTLSProtocolVersion is the TLS protocol version negotiated for the connection.
  /// It is a 2-byte sequence in host byte order.
  ///
  /// Please refer to tls_protocol_version_t enum in Security/SecProtocolTypes.h
  ///
  /// If an encrypted connection was not used, this attribute is set to nil.
  NSNumber? get negotiatedTLSProtocolVersion {
    final _ret =
        _lib._objc_msgSend_69(_id, _lib._sel_negotiatedTLSProtocolVersion1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  /// negotiatedTLSCipherSuite is the TLS cipher suite negotiated for the connection.
  /// It is a 2-byte sequence in host byte order.
  ///
  /// Please refer to tls_ciphersuite_t enum in Security/SecProtocolTypes.h
  ///
  /// If an encrypted connection was not used, this attribute is set to nil.
  NSNumber? get negotiatedTLSCipherSuite {
    final _ret =
        _lib._objc_msgSend_69(_id, _lib._sel_negotiatedTLSCipherSuite1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  /// Whether the connection is established over a cellular interface.
  bool get cellular {
    return _lib._objc_msgSend_11(_id, _lib._sel_isCellular1);
  }

  /// Whether the connection is established over an expensive interface.
  bool get expensive {
    return _lib._objc_msgSend_11(_id, _lib._sel_isExpensive1);
  }

  /// Whether the connection is established over a constrained interface.
  bool get constrained {
    return _lib._objc_msgSend_11(_id, _lib._sel_isConstrained1);
  }

  /// Whether a multipath protocol is successfully negotiated for the connection.
  bool get multipath {
    return _lib._objc_msgSend_11(_id, _lib._sel_isMultipath1);
  }

  /// DNS protocol used for domain resolution.
  int get domainResolutionProtocol {
    return _lib._objc_msgSend_312(_id, _lib._sel_domainResolutionProtocol1);
  }

  @override
  NSURLSessionTaskTransactionMetrics init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSessionTaskTransactionMetrics._(_ret, _lib,
        retain: true, release: true);
  }

  static NSURLSessionTaskTransactionMetrics new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionTaskTransactionMetrics1, _lib._sel_new1);
    return NSURLSessionTaskTransactionMetrics._(_ret, _lib,
        retain: false, release: true);
  }

  static NSURLSessionTaskTransactionMetrics alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionTaskTransactionMetrics1, _lib._sel_alloc1);
    return NSURLSessionTaskTransactionMetrics._(_ret, _lib,
        retain: false, release: true);
  }
}

class NSURLSessionTaskMetrics extends NSObject {
  NSURLSessionTaskMetrics._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLSessionTaskMetrics] that points to the same underlying object as [other].
  static NSURLSessionTaskMetrics castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLSessionTaskMetrics._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLSessionTaskMetrics] that wraps the given raw object pointer.
  static NSURLSessionTaskMetrics castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLSessionTaskMetrics._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLSessionTaskMetrics].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLSessionTaskMetrics1);
  }

  /// transactionMetrics array contains the metrics collected for every request/response transaction created during the task execution.
  NSArray? get transactionMetrics {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_transactionMetrics1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  /// Interval from the task creation time to the task completion time.
  /// Task creation time is the time when the task was instantiated.
  /// Task completion time is the time when the task is about to change its internal state to completed.
  NSDateInterval? get taskInterval {
    final _ret = _lib._objc_msgSend_313(_id, _lib._sel_taskInterval1);
    return _ret.address == 0
        ? null
        : NSDateInterval._(_ret, _lib, retain: true, release: true);
  }

  /// redirectCount is the number of redirects that were recorded.
  int get redirectCount {
    return _lib._objc_msgSend_12(_id, _lib._sel_redirectCount1);
  }

  @override
  NSURLSessionTaskMetrics init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLSessionTaskMetrics._(_ret, _lib, retain: true, release: true);
  }

  static NSURLSessionTaskMetrics new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionTaskMetrics1, _lib._sel_new1);
    return NSURLSessionTaskMetrics._(_ret, _lib, retain: false, release: true);
  }

  static NSURLSessionTaskMetrics alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSURLSessionTaskMetrics1, _lib._sel_alloc1);
    return NSURLSessionTaskMetrics._(_ret, _lib, retain: false, release: true);
  }
}

class NSDateInterval extends _ObjCWrapper {
  NSDateInterval._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSDateInterval] that points to the same underlying object as [other].
  static NSDateInterval castFrom<T extends _ObjCWrapper>(T other) {
    return NSDateInterval._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSDateInterval] that wraps the given raw object pointer.
  static NSDateInterval castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSDateInterval._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSDateInterval].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSDateInterval1);
  }
}

typedef NSURLFileResourceType = ffi.Pointer<ObjCObject>;
typedef NSURLThumbnailDictionaryItem = ffi.Pointer<ObjCObject>;
typedef NSURLFileProtectionType = ffi.Pointer<ObjCObject>;
typedef NSURLUbiquitousItemDownloadingStatus = ffi.Pointer<ObjCObject>;
typedef NSURLUbiquitousSharedItemRole = ffi.Pointer<ObjCObject>;
typedef NSURLUbiquitousSharedItemPermissions = ffi.Pointer<ObjCObject>;

/// NSURLQueryItem encapsulates a single query name-value pair. The name and value strings of a query name-value pair are not percent encoded. For use with the NSURLComponents queryItems property.
class NSURLQueryItem extends NSObject {
  NSURLQueryItem._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLQueryItem] that points to the same underlying object as [other].
  static NSURLQueryItem castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLQueryItem._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSURLQueryItem] that wraps the given raw object pointer.
  static NSURLQueryItem castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLQueryItem._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLQueryItem].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLQueryItem1);
  }

  NSURLQueryItem initWithName_value_(NSString? name, NSString? value) {
    final _ret = _lib._objc_msgSend_314(_id, _lib._sel_initWithName_value_1,
        name?._id ?? ffi.nullptr, value?._id ?? ffi.nullptr);
    return NSURLQueryItem._(_ret, _lib, retain: true, release: true);
  }

  static NSURLQueryItem queryItemWithName_value_(
      NativeCupertinoHttp _lib, NSString? name, NSString? value) {
    final _ret = _lib._objc_msgSend_314(
        _lib._class_NSURLQueryItem1,
        _lib._sel_queryItemWithName_value_1,
        name?._id ?? ffi.nullptr,
        value?._id ?? ffi.nullptr);
    return NSURLQueryItem._(_ret, _lib, retain: true, release: true);
  }

  NSString? get name {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_name1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  NSString? get value {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_value1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSURLQueryItem new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLQueryItem1, _lib._sel_new1);
    return NSURLQueryItem._(_ret, _lib, retain: false, release: true);
  }

  static NSURLQueryItem alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLQueryItem1, _lib._sel_alloc1);
    return NSURLQueryItem._(_ret, _lib, retain: false, release: true);
  }
}

class NSURLComponents extends NSObject {
  NSURLComponents._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSURLComponents] that points to the same underlying object as [other].
  static NSURLComponents castFrom<T extends _ObjCWrapper>(T other) {
    return NSURLComponents._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSURLComponents] that wraps the given raw object pointer.
  static NSURLComponents castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSURLComponents._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSURLComponents].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSURLComponents1);
  }

  /// Initialize a NSURLComponents with all components undefined. Designated initializer.
  @override
  NSURLComponents init() {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_init1);
    return NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Initialize a NSURLComponents with the components of a URL. If resolvingAgainstBaseURL is YES and url is a relative URL, the components of [url absoluteURL] are used. If the url string from the NSURL is malformed, nil is returned.
  NSURLComponents initWithURL_resolvingAgainstBaseURL_(
      NSURL? url, bool resolve) {
    final _ret = _lib._objc_msgSend_115(
        _id,
        _lib._sel_initWithURL_resolvingAgainstBaseURL_1,
        url?._id ?? ffi.nullptr,
        resolve);
    return NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created NSURLComponents with the components of a URL. If resolvingAgainstBaseURL is YES and url is a relative URL, the components of [url absoluteURL] are used. If the url string from the NSURL is malformed, nil is returned.
  static NSURLComponents componentsWithURL_resolvingAgainstBaseURL_(
      NativeCupertinoHttp _lib, NSURL? url, bool resolve) {
    final _ret = _lib._objc_msgSend_115(
        _lib._class_NSURLComponents1,
        _lib._sel_componentsWithURL_resolvingAgainstBaseURL_1,
        url?._id ?? ffi.nullptr,
        resolve);
    return NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Initialize a NSURLComponents with a URL string. If the URLString is malformed, nil is returned.
  NSURLComponents initWithString_(NSString? URLString) {
    final _ret = _lib._objc_msgSend_29(
        _id, _lib._sel_initWithString_1, URLString?._id ?? ffi.nullptr);
    return NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Initializes and returns a newly created NSURLComponents with a URL string. If the URLString is malformed, nil is returned.
  static NSURLComponents componentsWithString_(
      NativeCupertinoHttp _lib, NSString? URLString) {
    final _ret = _lib._objc_msgSend_29(_lib._class_NSURLComponents1,
        _lib._sel_componentsWithString_1, URLString?._id ?? ffi.nullptr);
    return NSURLComponents._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a URL created from the NSURLComponents. If the NSURLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
  NSURL? get URL {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_URL1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a URL created from the NSURLComponents relative to a base URL. If the NSURLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
  NSURL URLRelativeToURL_(NSURL? baseURL) {
    final _ret = _lib._objc_msgSend_315(
        _id, _lib._sel_URLRelativeToURL_1, baseURL?._id ?? ffi.nullptr);
    return NSURL._(_ret, _lib, retain: true, release: true);
  }

  /// Returns a URL string created from the NSURLComponents. If the NSURLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
  NSString? get string {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_string1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Attempting to set the scheme with an invalid scheme string will cause an exception.
  NSString? get scheme {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_scheme1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Attempting to set the scheme with an invalid scheme string will cause an exception.
  set scheme(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setScheme_1, value?._id ?? ffi.nullptr);
  }

  NSString? get user {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_user1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set user(NSString? value) {
    _lib._objc_msgSend_216(_id, _lib._sel_setUser_1, value?._id ?? ffi.nullptr);
  }

  NSString? get password {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_password1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set password(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setPassword_1, value?._id ?? ffi.nullptr);
  }

  NSString? get host {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_host1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set host(NSString? value) {
    _lib._objc_msgSend_216(_id, _lib._sel_setHost_1, value?._id ?? ffi.nullptr);
  }

  /// Attempting to set a negative port number will cause an exception.
  NSNumber? get port {
    final _ret = _lib._objc_msgSend_69(_id, _lib._sel_port1);
    return _ret.address == 0
        ? null
        : NSNumber._(_ret, _lib, retain: true, release: true);
  }

  /// Attempting to set a negative port number will cause an exception.
  set port(NSNumber? value) {
    _lib._objc_msgSend_251(_id, _lib._sel_setPort_1, value?._id ?? ffi.nullptr);
  }

  NSString? get path {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_path1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set path(NSString? value) {
    _lib._objc_msgSend_216(_id, _lib._sel_setPath_1, value?._id ?? ffi.nullptr);
  }

  NSString? get query {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_query1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set query(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setQuery_1, value?._id ?? ffi.nullptr);
  }

  NSString? get fragment {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_fragment1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set fragment(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setFragment_1, value?._id ?? ffi.nullptr);
  }

  /// Getting these properties retains any percent encoding these components may have. Setting these properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause an exception. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with NSURL (-stringByAddingPercentEncodingWithAllowedCharacters: will percent-encode any ';' characters if you pass the URLPathAllowedCharacterSet).
  NSString? get percentEncodedUser {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_percentEncodedUser1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  /// Getting these properties retains any percent encoding these components may have. Setting these properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause an exception. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with NSURL (-stringByAddingPercentEncodingWithAllowedCharacters: will percent-encode any ';' characters if you pass the URLPathAllowedCharacterSet).
  set percentEncodedUser(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setPercentEncodedUser_1, value?._id ?? ffi.nullptr);
  }

  NSString? get percentEncodedPassword {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_percentEncodedPassword1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set percentEncodedPassword(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setPercentEncodedPassword_1, value?._id ?? ffi.nullptr);
  }

  NSString? get percentEncodedHost {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_percentEncodedHost1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set percentEncodedHost(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setPercentEncodedHost_1, value?._id ?? ffi.nullptr);
  }

  NSString? get percentEncodedPath {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_percentEncodedPath1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set percentEncodedPath(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setPercentEncodedPath_1, value?._id ?? ffi.nullptr);
  }

  NSString? get percentEncodedQuery {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_percentEncodedQuery1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set percentEncodedQuery(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setPercentEncodedQuery_1, value?._id ?? ffi.nullptr);
  }

  NSString? get percentEncodedFragment {
    final _ret = _lib._objc_msgSend_19(_id, _lib._sel_percentEncodedFragment1);
    return _ret.address == 0
        ? null
        : NSString._(_ret, _lib, retain: true, release: true);
  }

  set percentEncodedFragment(NSString? value) {
    _lib._objc_msgSend_216(
        _id, _lib._sel_setPercentEncodedFragment_1, value?._id ?? ffi.nullptr);
  }

  /// These properties return the character range of a component in the URL string returned by -[NSURLComponents string]. If the component does not exist in the NSURLComponents object, {NSNotFound, 0} is returned. Note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
  NSRange get rangeOfScheme {
    return _lib._objc_msgSend_316(_id, _lib._sel_rangeOfScheme1);
  }

  NSRange get rangeOfUser {
    return _lib._objc_msgSend_316(_id, _lib._sel_rangeOfUser1);
  }

  NSRange get rangeOfPassword {
    return _lib._objc_msgSend_316(_id, _lib._sel_rangeOfPassword1);
  }

  NSRange get rangeOfHost {
    return _lib._objc_msgSend_316(_id, _lib._sel_rangeOfHost1);
  }

  NSRange get rangeOfPort {
    return _lib._objc_msgSend_316(_id, _lib._sel_rangeOfPort1);
  }

  NSRange get rangeOfPath {
    return _lib._objc_msgSend_316(_id, _lib._sel_rangeOfPath1);
  }

  NSRange get rangeOfQuery {
    return _lib._objc_msgSend_316(_id, _lib._sel_rangeOfQuery1);
  }

  NSRange get rangeOfFragment {
    return _lib._objc_msgSend_316(_id, _lib._sel_rangeOfFragment1);
  }

  /// The query component as an array of NSURLQueryItems for this NSURLComponents.
  ///
  /// Each NSURLQueryItem represents a single key-value pair,
  ///
  /// Note that a name may appear more than once in a single query string, so the name values are not guaranteed to be unique. If the NSURLComponents has an empty query component, returns an empty array. If the NSURLComponents has no query component, returns nil.
  ///
  /// The queryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is removed.
  ///
  /// The queryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. If the NSURLQueryItems name or value strings contain any characters not allowed in a URL's query component, those characters are percent-encoded. In addition, any '&' and '=' characters in a NSURLQueryItem name are percent-encoded. Passing an empty array sets the query component of the NSURLComponents to an empty string. Passing nil removes the query component of the NSURLComponents.
  ///
  /// - note: If a NSURLQueryItem name-value pair is empty (i.e. the query string starts with '&', ends with '&', or has "&&" within it), you get a NSURLQueryItem with a zero-length name and a nil value. If a NSURLQueryItem name-value pair has nothing before the equals sign, you get a zero-length name. If a NSURLQueryItem name-value pair has nothing after the equals sign, you get a zero-length value. If a NSURLQueryItem name-value pair has no equals sign, the NSURLQueryItem name-value pair string is the name and you get a nil value.
  NSArray? get queryItems {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_queryItems1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  /// The query component as an array of NSURLQueryItems for this NSURLComponents.
  ///
  /// Each NSURLQueryItem represents a single key-value pair,
  ///
  /// Note that a name may appear more than once in a single query string, so the name values are not guaranteed to be unique. If the NSURLComponents has an empty query component, returns an empty array. If the NSURLComponents has no query component, returns nil.
  ///
  /// The queryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is removed.
  ///
  /// The queryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. If the NSURLQueryItems name or value strings contain any characters not allowed in a URL's query component, those characters are percent-encoded. In addition, any '&' and '=' characters in a NSURLQueryItem name are percent-encoded. Passing an empty array sets the query component of the NSURLComponents to an empty string. Passing nil removes the query component of the NSURLComponents.
  ///
  /// - note: If a NSURLQueryItem name-value pair is empty (i.e. the query string starts with '&', ends with '&', or has "&&" within it), you get a NSURLQueryItem with a zero-length name and a nil value. If a NSURLQueryItem name-value pair has nothing before the equals sign, you get a zero-length name. If a NSURLQueryItem name-value pair has nothing after the equals sign, you get a zero-length value. If a NSURLQueryItem name-value pair has no equals sign, the NSURLQueryItem name-value pair string is the name and you get a nil value.
  set queryItems(NSArray? value) {
    _lib._objc_msgSend_265(
        _id, _lib._sel_setQueryItems_1, value?._id ?? ffi.nullptr);
  }

  /// The percentEncodedQueryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is retained.
  ///
  /// The percentEncodedQueryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. This property assumes the NSURLQueryItem names and values are already correctly percent-encoded, and that the NSURLQueryItem names do not contain the query item delimiter characters '&' and '='. Attempting to set an incorrectly percent-encoded NSURLQueryItem or a NSURLQueryItem name with the query item delimiter characters '&' and '=' will cause an exception.
  NSArray? get percentEncodedQueryItems {
    final _ret =
        _lib._objc_msgSend_72(_id, _lib._sel_percentEncodedQueryItems1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  /// The percentEncodedQueryItems getter returns an array of NSURLQueryItems in the order in which they appear in the original query string. Any percent-encoding in a NSURLQueryItem name or value is retained.
  ///
  /// The percentEncodedQueryItems setter combines an array containing any number of NSURLQueryItems, each of which represents a single key-value pair, into a query string and sets the NSURLComponents query property. This property assumes the NSURLQueryItem names and values are already correctly percent-encoded, and that the NSURLQueryItem names do not contain the query item delimiter characters '&' and '='. Attempting to set an incorrectly percent-encoded NSURLQueryItem or a NSURLQueryItem name with the query item delimiter characters '&' and '=' will cause an exception.
  set percentEncodedQueryItems(NSArray? value) {
    _lib._objc_msgSend_265(_id, _lib._sel_setPercentEncodedQueryItems_1,
        value?._id ?? ffi.nullptr);
  }

  static NSURLComponents new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLComponents1, _lib._sel_new1);
    return NSURLComponents._(_ret, _lib, retain: false, release: true);
  }

  static NSURLComponents alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSURLComponents1, _lib._sel_alloc1);
    return NSURLComponents._(_ret, _lib, retain: false, release: true);
  }
}

/// NSFileSecurity encapsulates a file system object's security information. NSFileSecurity and CFFileSecurity are toll-free bridged. Use the CFFileSecurity API for access to the low-level file security properties encapsulated by NSFileSecurity.
class NSFileSecurity extends NSObject {
  NSFileSecurity._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSFileSecurity] that points to the same underlying object as [other].
  static NSFileSecurity castFrom<T extends _ObjCWrapper>(T other) {
    return NSFileSecurity._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSFileSecurity] that wraps the given raw object pointer.
  static NSFileSecurity castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSFileSecurity._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSFileSecurity].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSFileSecurity1);
  }

  NSFileSecurity initWithCoder_(NSCoder? coder) {
    final _ret = _lib._objc_msgSend_14(
        _id, _lib._sel_initWithCoder_1, coder?._id ?? ffi.nullptr);
    return NSFileSecurity._(_ret, _lib, retain: true, release: true);
  }

  static NSFileSecurity new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSFileSecurity1, _lib._sel_new1);
    return NSFileSecurity._(_ret, _lib, retain: false, release: true);
  }

  static NSFileSecurity alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSFileSecurity1, _lib._sel_alloc1);
    return NSFileSecurity._(_ret, _lib, retain: false, release: true);
  }
}

typedef NSProgressUserInfoKey1 = ffi.Pointer<ObjCObject>;
typedef NSProgressKind1 = ffi.Pointer<ObjCObject>;
typedef NSProgressFileOperationKind1 = ffi.Pointer<ObjCObject>;

/// !
/// @class NSHTTPURLResponse
///
/// @abstract An NSHTTPURLResponse object represents a response to an
/// HTTP URL load. It is a specialization of NSURLResponse which
/// provides conveniences for accessing information specific to HTTP
/// protocol responses.
class NSHTTPURLResponse extends NSURLResponse {
  NSHTTPURLResponse._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSHTTPURLResponse] that points to the same underlying object as [other].
  static NSHTTPURLResponse castFrom<T extends _ObjCWrapper>(T other) {
    return NSHTTPURLResponse._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSHTTPURLResponse] that wraps the given raw object pointer.
  static NSHTTPURLResponse castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSHTTPURLResponse._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSHTTPURLResponse].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSHTTPURLResponse1);
  }

  /// !
  /// @method	initWithURL:statusCode:HTTPVersion:headerFields:
  /// @abstract initializer for NSHTTPURLResponse objects.
  /// @param 	url the URL from which the response was generated.
  /// @param	statusCode an HTTP status code.
  /// @param	HTTPVersion The version of the HTTP response as represented by the server.  This is typically represented as "HTTP/1.1".
  /// @param 	headerFields A dictionary representing the header keys and values of the server response.
  /// @result 	the instance of the object, or NULL if an error occurred during initialization.
  /// @discussion This API was introduced in Mac OS X 10.7.2 and iOS 5.0 and is not available prior to those releases.
  NSHTTPURLResponse initWithURL_statusCode_HTTPVersion_headerFields_(NSURL? url,
      int statusCode, NSString? HTTPVersion, NSDictionary? headerFields) {
    final _ret = _lib._objc_msgSend_317(
        _id,
        _lib._sel_initWithURL_statusCode_HTTPVersion_headerFields_1,
        url?._id ?? ffi.nullptr,
        statusCode,
        HTTPVersion?._id ?? ffi.nullptr,
        headerFields?._id ?? ffi.nullptr);
    return NSHTTPURLResponse._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the HTTP status code of the receiver.
  /// @result The HTTP status code of the receiver.
  int get statusCode {
    return _lib._objc_msgSend_61(_id, _lib._sel_statusCode1);
  }

  /// !
  /// @abstract Returns a dictionary containing all the HTTP header fields
  /// of the receiver.
  /// @discussion By examining this header dictionary, clients can see
  /// the "raw" header information which was reported to the protocol
  /// implementation by the HTTP server. This may be of use to
  /// sophisticated or special-purpose HTTP clients.
  /// @result A dictionary containing all the HTTP header fields of the
  /// receiver.
  NSDictionary? get allHeaderFields {
    final _ret = _lib._objc_msgSend_89(_id, _lib._sel_allHeaderFields1);
    return _ret.address == 0
        ? null
        : NSDictionary._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @method valueForHTTPHeaderField:
  /// @abstract Returns the value which corresponds to the given header
  /// field. Note that, in keeping with the HTTP RFC, HTTP header field
  /// names are case-insensitive.
  /// @param field the header field name to use for the lookup
  /// (case-insensitive).
  /// @result the value associated with the given header field, or nil if
  /// there is no value associated with the given header field.
  NSString valueForHTTPHeaderField_(NSString? field) {
    final _ret = _lib._objc_msgSend_149(
        _id, _lib._sel_valueForHTTPHeaderField_1, field?._id ?? ffi.nullptr);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  /// !
  /// @method localizedStringForStatusCode:
  /// @abstract Convenience method which returns a localized string
  /// corresponding to the status code for this response.
  /// @param statusCode the status code to use to produce a localized string.
  /// @result A localized string corresponding to the given status code.
  static NSString localizedStringForStatusCode_(
      NativeCupertinoHttp _lib, int statusCode) {
    final _ret = _lib._objc_msgSend_318(_lib._class_NSHTTPURLResponse1,
        _lib._sel_localizedStringForStatusCode_1, statusCode);
    return NSString._(_ret, _lib, retain: true, release: true);
  }

  static NSHTTPURLResponse new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSHTTPURLResponse1, _lib._sel_new1);
    return NSHTTPURLResponse._(_ret, _lib, retain: false, release: true);
  }

  static NSHTTPURLResponse alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSHTTPURLResponse1, _lib._sel_alloc1);
    return NSHTTPURLResponse._(_ret, _lib, retain: false, release: true);
  }
}

typedef NSNotificationName = ffi.Pointer<ObjCObject>;

class NSBlockOperation extends NSOperation {
  NSBlockOperation._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSBlockOperation] that points to the same underlying object as [other].
  static NSBlockOperation castFrom<T extends _ObjCWrapper>(T other) {
    return NSBlockOperation._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSBlockOperation] that wraps the given raw object pointer.
  static NSBlockOperation castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSBlockOperation._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSBlockOperation].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSBlockOperation1);
  }

  static NSBlockOperation blockOperationWithBlock_(
      NativeCupertinoHttp _lib, ObjCBlock7 block) {
    final _ret = _lib._objc_msgSend_319(_lib._class_NSBlockOperation1,
        _lib._sel_blockOperationWithBlock_1, block._impl);
    return NSBlockOperation._(_ret, _lib, retain: true, release: true);
  }

  void addExecutionBlock_(ObjCBlock7 block) {
    return _lib._objc_msgSend_275(
        _id, _lib._sel_addExecutionBlock_1, block._impl);
  }

  NSArray? get executionBlocks {
    final _ret = _lib._objc_msgSend_72(_id, _lib._sel_executionBlocks1);
    return _ret.address == 0
        ? null
        : NSArray._(_ret, _lib, retain: true, release: true);
  }

  static NSBlockOperation new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSBlockOperation1, _lib._sel_new1);
    return NSBlockOperation._(_ret, _lib, retain: false, release: true);
  }

  static NSBlockOperation alloc(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_NSBlockOperation1, _lib._sel_alloc1);
    return NSBlockOperation._(_ret, _lib, retain: false, release: true);
  }
}

class NSInvocationOperation extends NSOperation {
  NSInvocationOperation._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSInvocationOperation] that points to the same underlying object as [other].
  static NSInvocationOperation castFrom<T extends _ObjCWrapper>(T other) {
    return NSInvocationOperation._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [NSInvocationOperation] that wraps the given raw object pointer.
  static NSInvocationOperation castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSInvocationOperation._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSInvocationOperation].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_NSInvocationOperation1);
  }

  NSInvocationOperation initWithTarget_selector_object_(
      NSObject target, ffi.Pointer<ObjCSel> sel, NSObject arg) {
    final _ret = _lib._objc_msgSend_320(_id,
        _lib._sel_initWithTarget_selector_object_1, target._id, sel, arg._id);
    return NSInvocationOperation._(_ret, _lib, retain: true, release: true);
  }

  NSInvocationOperation initWithInvocation_(NSInvocation? inv) {
    final _ret = _lib._objc_msgSend_321(
        _id, _lib._sel_initWithInvocation_1, inv?._id ?? ffi.nullptr);
    return NSInvocationOperation._(_ret, _lib, retain: true, release: true);
  }

  NSInvocation? get invocation {
    final _ret = _lib._objc_msgSend_322(_id, _lib._sel_invocation1);
    return _ret.address == 0
        ? null
        : NSInvocation._(_ret, _lib, retain: true, release: true);
  }

  NSObject get result {
    final _ret = _lib._objc_msgSend_2(_id, _lib._sel_result1);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  static NSInvocationOperation new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSInvocationOperation1, _lib._sel_new1);
    return NSInvocationOperation._(_ret, _lib, retain: false, release: true);
  }

  static NSInvocationOperation alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_NSInvocationOperation1, _lib._sel_alloc1);
    return NSInvocationOperation._(_ret, _lib, retain: false, release: true);
  }
}

typedef NSExceptionName = ffi.Pointer<ObjCObject>;

class _Dart_Isolate extends ffi.Opaque {}

class _Dart_IsolateGroup extends ffi.Opaque {}

class _Dart_Handle extends ffi.Opaque {}

class _Dart_WeakPersistentHandle extends ffi.Opaque {}

class _Dart_FinalizableHandle extends ffi.Opaque {}

typedef Dart_WeakPersistentHandle = ffi.Pointer<_Dart_WeakPersistentHandle>;

/// These structs are versioned by DART_API_DL_MAJOR_VERSION, bump the
/// version when changing this struct.
typedef Dart_HandleFinalizer = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;
typedef Dart_FinalizableHandle = ffi.Pointer<_Dart_FinalizableHandle>;

class Dart_IsolateFlags extends ffi.Struct {
  @ffi.Int32()
  external int version;

  @ffi.Bool()
  external bool enable_asserts;

  @ffi.Bool()
  external bool use_field_guards;

  @ffi.Bool()
  external bool use_osr;

  @ffi.Bool()
  external bool obfuscate;

  @ffi.Bool()
  external bool load_vmservice_library;

  @ffi.Bool()
  external bool copy_parent_code;

  @ffi.Bool()
  external bool null_safety;

  @ffi.Bool()
  external bool is_system_isolate;
}

/// Forward declaration
class Dart_CodeObserver extends ffi.Struct {
  external ffi.Pointer<ffi.Void> data;

  external Dart_OnNewCodeCallback on_new_code;
}

/// Callback provided by the embedder that is used by the VM to notify on code
/// object creation, *before* it is invoked the first time.
/// This is useful for embedders wanting to e.g. keep track of PCs beyond
/// the lifetime of the garbage collected code objects.
/// Note that an address range may be used by more than one code object over the
/// lifecycle of a process. Clients of this function should record timestamps for
/// these compilation events and when collecting PCs to disambiguate reused
/// address ranges.
typedef Dart_OnNewCodeCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<Dart_CodeObserver>, ffi.Pointer<ffi.Char>,
            uintptr_t, uintptr_t)>>;
typedef uintptr_t = ffi.UnsignedLong;

/// Describes how to initialize the VM. Used with Dart_Initialize.
///
/// \param version Identifies the version of the struct used by the client.
/// should be initialized to DART_INITIALIZE_PARAMS_CURRENT_VERSION.
/// \param vm_isolate_snapshot A buffer containing a snapshot of the VM isolate
/// or NULL if no snapshot is provided. If provided, the buffer must remain
/// valid until Dart_Cleanup returns.
/// \param instructions_snapshot A buffer containing a snapshot of precompiled
/// instructions, or NULL if no snapshot is provided. If provided, the buffer
/// must remain valid until Dart_Cleanup returns.
/// \param initialize_isolate A function to be called during isolate
/// initialization inside an existing isolate group.
/// See Dart_InitializeIsolateCallback.
/// \param create_group A function to be called during isolate group creation.
/// See Dart_IsolateGroupCreateCallback.
/// \param shutdown A function to be called right before an isolate is shutdown.
/// See Dart_IsolateShutdownCallback.
/// \param cleanup A function to be called after an isolate was shutdown.
/// See Dart_IsolateCleanupCallback.
/// \param cleanup_group A function to be called after an isolate group is shutdown.
/// See Dart_IsolateGroupCleanupCallback.
/// \param get_service_assets A function to be called by the service isolate when
/// it requires the vmservice assets archive.
/// See Dart_GetVMServiceAssetsArchive.
/// \param code_observer An external code observer callback function.
/// The observer can be invoked as early as during the Dart_Initialize() call.
class Dart_InitializeParams extends ffi.Struct {
  @ffi.Int32()
  external int version;

  external ffi.Pointer<ffi.Uint8> vm_snapshot_data;

  external ffi.Pointer<ffi.Uint8> vm_snapshot_instructions;

  external Dart_IsolateGroupCreateCallback create_group;

  external Dart_InitializeIsolateCallback initialize_isolate;

  external Dart_IsolateShutdownCallback shutdown_isolate;

  external Dart_IsolateCleanupCallback cleanup_isolate;

  external Dart_IsolateGroupCleanupCallback cleanup_group;

  external Dart_ThreadExitCallback thread_exit;

  external Dart_FileOpenCallback file_open;

  external Dart_FileReadCallback file_read;

  external Dart_FileWriteCallback file_write;

  external Dart_FileCloseCallback file_close;

  external Dart_EntropySource entropy_source;

  external Dart_GetVMServiceAssetsArchive get_service_assets;

  @ffi.Bool()
  external bool start_kernel_isolate;

  external ffi.Pointer<Dart_CodeObserver> code_observer;
}

/// An isolate creation and initialization callback function.
///
/// This callback, provided by the embedder, is called when the VM
/// needs to create an isolate. The callback should create an isolate
/// by calling Dart_CreateIsolateGroup and load any scripts required for
/// execution.
///
/// This callback may be called on a different thread than the one
/// running the parent isolate.
///
/// When the function returns NULL, it is the responsibility of this
/// function to ensure that Dart_ShutdownIsolate has been called if
/// required (for example, if the isolate was created successfully by
/// Dart_CreateIsolateGroup() but the root library fails to load
/// successfully, then the function should call Dart_ShutdownIsolate
/// before returning).
///
/// When the function returns NULL, the function should set *error to
/// a malloc-allocated buffer containing a useful error message.  The
/// caller of this function (the VM) will make sure that the buffer is
/// freed.
///
/// \param script_uri The uri of the main source file or snapshot to load.
/// Either the URI of the parent isolate set in Dart_CreateIsolateGroup for
/// Isolate.spawn, or the argument to Isolate.spawnUri canonicalized by the
/// library tag handler of the parent isolate.
/// The callback is responsible for loading the program by a call to
/// Dart_LoadScriptFromKernel.
/// \param main The name of the main entry point this isolate will
/// eventually run.  This is provided for advisory purposes only to
/// improve debugging messages.  The main function is not invoked by
/// this function.
/// \param package_root Ignored.
/// \param package_config Uri of the package configuration file (either in format
/// of .packages or .dart_tool/package_config.json) for this isolate
/// to resolve package imports against. If this parameter is not passed the
/// package resolution of the parent isolate should be used.
/// \param flags Default flags for this isolate being spawned. Either inherited
/// from the spawning isolate or passed as parameters when spawning the
/// isolate from Dart code.
/// \param isolate_data The isolate data which was passed to the
/// parent isolate when it was created by calling Dart_CreateIsolateGroup().
/// \param error A structure into which the embedder can place a
/// C string containing an error message in the case of failures.
///
/// \return The embedder returns NULL if the creation and
/// initialization was not successful and the isolate if successful.
typedef Dart_IsolateGroupCreateCallback = ffi.Pointer<
    ffi.NativeFunction<
        Dart_Isolate Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<Dart_IsolateFlags>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>)>>;

/// An isolate is the unit of concurrency in Dart. Each isolate has
/// its own memory and thread of control. No state is shared between
/// isolates. Instead, isolates communicate by message passing.
///
/// Each thread keeps track of its current isolate, which is the
/// isolate which is ready to execute on the current thread. The
/// current isolate may be NULL, in which case no isolate is ready to
/// execute. Most of the Dart apis require there to be a current
/// isolate in order to function without error. The current isolate is
/// set by any call to Dart_CreateIsolateGroup or Dart_EnterIsolate.
typedef Dart_Isolate = ffi.Pointer<_Dart_Isolate>;

/// An isolate initialization callback function.
///
/// This callback, provided by the embedder, is called when the VM has created an
/// isolate within an existing isolate group (i.e. from the same source as an
/// existing isolate).
///
/// The callback should setup native resolvers and might want to set a custom
/// message handler via [Dart_SetMessageNotifyCallback] and mark the isolate as
/// runnable.
///
/// This callback may be called on a different thread than the one
/// running the parent isolate.
///
/// When the function returns `false`, it is the responsibility of this
/// function to ensure that `Dart_ShutdownIsolate` has been called.
///
/// When the function returns `false`, the function should set *error to
/// a malloc-allocated buffer containing a useful error message.  The
/// caller of this function (the VM) will make sure that the buffer is
/// freed.
///
/// \param child_isolate_data The callback data to associate with the new
/// child isolate.
/// \param error A structure into which the embedder can place a
/// C string containing an error message in the case the initialization fails.
///
/// \return The embedder returns true if the initialization was successful and
/// false otherwise (in which case the VM will terminate the isolate).
typedef Dart_InitializeIsolateCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Bool Function(ffi.Pointer<ffi.Pointer<ffi.Void>>,
            ffi.Pointer<ffi.Pointer<ffi.Char>>)>>;

/// An isolate shutdown callback function.
///
/// This callback, provided by the embedder, is called before the vm
/// shuts down an isolate.  The isolate being shutdown will be the current
/// isolate. It is safe to run Dart code.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
/// \param isolate_data The same callback data which was passed to the isolate
/// when it was created.
typedef Dart_IsolateShutdownCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;

/// An isolate cleanup callback function.
///
/// This callback, provided by the embedder, is called after the vm
/// shuts down an isolate. There will be no current isolate and it is *not*
/// safe to run Dart code.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
/// \param isolate_data The same callback data which was passed to the isolate
/// when it was created.
typedef Dart_IsolateCleanupCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;

/// An isolate group cleanup callback function.
///
/// This callback, provided by the embedder, is called after the vm
/// shuts down an isolate group.
///
/// This function should be used to dispose of native resources that
/// are allocated to an isolate in order to avoid leaks.
///
/// \param isolate_group_data The same callback data which was passed to the
/// isolate group when it was created.
typedef Dart_IsolateGroupCleanupCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;

/// A thread death callback function.
/// This callback, provided by the embedder, is called before a thread in the
/// vm thread pool exits.
/// This function could be used to dispose of native resources that
/// are associated and attached to the thread, in order to avoid leaks.
typedef Dart_ThreadExitCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;

/// Callbacks provided by the embedder for file operations. If the
/// embedder does not allow file operations these callbacks can be
/// NULL.
///
/// Dart_FileOpenCallback - opens a file for reading or writing.
/// \param name The name of the file to open.
/// \param write A boolean variable which indicates if the file is to
/// opened for writing. If there is an existing file it needs to truncated.
///
/// Dart_FileReadCallback - Read contents of file.
/// \param data Buffer allocated in the callback into which the contents
/// of the file are read into. It is the responsibility of the caller to
/// free this buffer.
/// \param file_length A variable into which the length of the file is returned.
/// In the case of an error this value would be -1.
/// \param stream Handle to the opened file.
///
/// Dart_FileWriteCallback - Write data into file.
/// \param data Buffer which needs to be written into the file.
/// \param length Length of the buffer.
/// \param stream Handle to the opened file.
///
/// Dart_FileCloseCallback - Closes the opened file.
/// \param stream Handle to the opened file.
typedef Dart_FileOpenCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>, ffi.Bool)>>;
typedef Dart_FileReadCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
            ffi.Pointer<ffi.IntPtr>, ffi.Pointer<ffi.Void>)>>;
typedef Dart_FileWriteCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.IntPtr, ffi.Pointer<ffi.Void>)>>;
typedef Dart_FileCloseCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;
typedef Dart_EntropySource = ffi.Pointer<
    ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>;

/// Callback provided by the embedder that is used by the vmservice isolate
/// to request the asset archive. The asset archive must be an uncompressed tar
/// archive that is stored in a Uint8List.
///
/// If the embedder has no vmservice isolate assets, the callback can be NULL.
///
/// \return The embedder must return a handle to a Uint8List containing an
/// uncompressed tar archive or null.
typedef Dart_GetVMServiceAssetsArchive
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function()>>;
typedef Dart_IsolateGroup = ffi.Pointer<_Dart_IsolateGroup>;

/// A message notification callback.
///
/// This callback allows the embedder to provide an alternate wakeup
/// mechanism for the delivery of inter-isolate messages.  It is the
/// responsibility of the embedder to call Dart_HandleMessage to
/// process the message.
typedef Dart_MessageNotifyCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_Isolate)>>;

/// A port is used to send or receive inter-isolate messages
typedef Dart_Port = ffi.Int64;

abstract class Dart_CoreType_Id {
  static const int Dart_CoreType_Dynamic = 0;
  static const int Dart_CoreType_Int = 1;
  static const int Dart_CoreType_String = 2;
}

/// ==========
/// Typed Data
/// ==========
abstract class Dart_TypedData_Type {
  static const int Dart_TypedData_kByteData = 0;
  static const int Dart_TypedData_kInt8 = 1;
  static const int Dart_TypedData_kUint8 = 2;
  static const int Dart_TypedData_kUint8Clamped = 3;
  static const int Dart_TypedData_kInt16 = 4;
  static const int Dart_TypedData_kUint16 = 5;
  static const int Dart_TypedData_kInt32 = 6;
  static const int Dart_TypedData_kUint32 = 7;
  static const int Dart_TypedData_kInt64 = 8;
  static const int Dart_TypedData_kUint64 = 9;
  static const int Dart_TypedData_kFloat32 = 10;
  static const int Dart_TypedData_kFloat64 = 11;
  static const int Dart_TypedData_kInt32x4 = 12;
  static const int Dart_TypedData_kFloat32x4 = 13;
  static const int Dart_TypedData_kFloat64x2 = 14;
  static const int Dart_TypedData_kInvalid = 15;
}

class _Dart_NativeArguments extends ffi.Opaque {}

/// The arguments to a native function.
///
/// This object is passed to a native function to represent its
/// arguments and return value. It allows access to the arguments to a
/// native function by index. It also allows the return value of a
/// native function to be set.
typedef Dart_NativeArguments = ffi.Pointer<_Dart_NativeArguments>;

abstract class Dart_NativeArgument_Type {
  static const int Dart_NativeArgument_kBool = 0;
  static const int Dart_NativeArgument_kInt32 = 1;
  static const int Dart_NativeArgument_kUint32 = 2;
  static const int Dart_NativeArgument_kInt64 = 3;
  static const int Dart_NativeArgument_kUint64 = 4;
  static const int Dart_NativeArgument_kDouble = 5;
  static const int Dart_NativeArgument_kString = 6;
  static const int Dart_NativeArgument_kInstance = 7;
  static const int Dart_NativeArgument_kNativeFields = 8;
}

class _Dart_NativeArgument_Descriptor extends ffi.Struct {
  @ffi.Uint8()
  external int type;

  @ffi.Uint8()
  external int index;
}

class _Dart_NativeArgument_Value extends ffi.Opaque {}

typedef Dart_NativeArgument_Descriptor = _Dart_NativeArgument_Descriptor;
typedef Dart_NativeArgument_Value = _Dart_NativeArgument_Value;

/// An environment lookup callback function.
///
/// \param name The name of the value to lookup in the environment.
///
/// \return A valid handle to a string if the name exists in the
/// current environment or Dart_Null() if not.
typedef Dart_EnvironmentCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>;

/// Native entry resolution callback.
///
/// For libraries and scripts which have native functions, the embedder
/// can provide a native entry resolver. This callback is used to map a
/// name/arity to a Dart_NativeFunction. If no function is found, the
/// callback should return NULL.
///
/// The parameters to the native resolver function are:
/// \param name a Dart string which is the name of the native function.
/// \param num_of_arguments is the number of arguments expected by the
/// native function.
/// \param auto_setup_scope is a boolean flag that can be set by the resolver
/// to indicate if this function needs a Dart API scope (see Dart_EnterScope/
/// Dart_ExitScope) to be setup automatically by the VM before calling into
/// the native function. By default most native functions would require this
/// to be true but some light weight native functions which do not call back
/// into the VM through the Dart API may not require a Dart scope to be
/// setup automatically.
///
/// \return A valid Dart_NativeFunction which resolves to a native entry point
/// for the native function.
///
/// See Dart_SetNativeResolver.
typedef Dart_NativeEntryResolver = ffi.Pointer<
    ffi.NativeFunction<
        Dart_NativeFunction Function(
            ffi.Handle, ffi.Int, ffi.Pointer<ffi.Bool>)>>;

/// A native function.
typedef Dart_NativeFunction
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(Dart_NativeArguments)>>;

/// Native entry symbol lookup callback.
///
/// For libraries and scripts which have native functions, the embedder
/// can provide a callback for mapping a native entry to a symbol. This callback
/// maps a native function entry PC to the native function name. If no native
/// entry symbol can be found, the callback should return NULL.
///
/// The parameters to the native reverse resolver function are:
/// \param nf A Dart_NativeFunction.
///
/// \return A const UTF-8 string containing the symbol name or NULL.
///
/// See Dart_SetNativeResolver.
typedef Dart_NativeEntrySymbol = ffi.Pointer<
    ffi.NativeFunction<ffi.Pointer<ffi.Uint8> Function(Dart_NativeFunction)>>;

/// FFI Native C function pointer resolver callback.
///
/// See Dart_SetFfiNativeResolver.
typedef Dart_FfiNativeResolver = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>, uintptr_t)>>;

/// =====================
/// Scripts and Libraries
/// =====================
abstract class Dart_LibraryTag {
  static const int Dart_kCanonicalizeUrl = 0;
  static const int Dart_kImportTag = 1;
  static const int Dart_kKernelTag = 2;
}

/// The library tag handler is a multi-purpose callback provided by the
/// embedder to the Dart VM. The embedder implements the tag handler to
/// provide the ability to load Dart scripts and imports.
///
/// -- TAGS --
///
/// Dart_kCanonicalizeUrl
///
/// This tag indicates that the embedder should canonicalize 'url' with
/// respect to 'library'.  For most embedders, the
/// Dart_DefaultCanonicalizeUrl function is a sufficient implementation
/// of this tag.  The return value should be a string holding the
/// canonicalized url.
///
/// Dart_kImportTag
///
/// This tag is used to load a library from IsolateMirror.loadUri. The embedder
/// should call Dart_LoadLibraryFromKernel to provide the library to the VM. The
/// return value should be an error or library (the result from
/// Dart_LoadLibraryFromKernel).
///
/// Dart_kKernelTag
///
/// This tag is used to load the intermediate file (kernel) generated by
/// the Dart front end. This tag is typically used when a 'hot-reload'
/// of an application is needed and the VM is 'use dart front end' mode.
/// The dart front end typically compiles all the scripts, imports and part
/// files into one intermediate file hence we don't use the source/import or
/// script tags. The return value should be an error or a TypedData containing
/// the kernel bytes.
typedef Dart_LibraryTagHandler = ffi.Pointer<
    ffi.NativeFunction<ffi.Handle Function(ffi.Int32, ffi.Handle, ffi.Handle)>>;

/// Handles deferred loading requests. When this handler is invoked, it should
/// eventually load the deferred loading unit with the given id and call
/// Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError. It is
/// recommended that the loading occur asynchronously, but it is permitted to
/// call Dart_DeferredLoadComplete or Dart_DeferredLoadCompleteError before the
/// handler returns.
///
/// If an error is returned, it will be propogated through
/// `prefix.loadLibrary()`. This is useful for synchronous
/// implementations, which must propogate any unwind errors from
/// Dart_DeferredLoadComplete or Dart_DeferredLoadComplete. Otherwise the handler
/// should return a non-error such as `Dart_Null()`.
typedef Dart_DeferredLoadHandler
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.IntPtr)>>;

/// TODO(33433): Remove kernel service from the embedding API.
abstract class Dart_KernelCompilationStatus {
  static const int Dart_KernelCompilationStatus_Unknown = -1;
  static const int Dart_KernelCompilationStatus_Ok = 0;
  static const int Dart_KernelCompilationStatus_Error = 1;
  static const int Dart_KernelCompilationStatus_Crash = 2;
  static const int Dart_KernelCompilationStatus_MsgFailed = 3;
}

class Dart_KernelCompilationResult extends ffi.Struct {
  @ffi.Int32()
  external int status;

  @ffi.Bool()
  external bool null_safety;

  external ffi.Pointer<ffi.Char> error;

  external ffi.Pointer<ffi.Uint8> kernel;

  @ffi.IntPtr()
  external int kernel_size;
}

abstract class Dart_KernelCompilationVerbosityLevel {
  static const int Dart_KernelCompilationVerbosityLevel_Error = 0;
  static const int Dart_KernelCompilationVerbosityLevel_Warning = 1;
  static const int Dart_KernelCompilationVerbosityLevel_Info = 2;
  static const int Dart_KernelCompilationVerbosityLevel_All = 3;
}

class Dart_SourceFile extends ffi.Struct {
  external ffi.Pointer<ffi.Char> uri;

  external ffi.Pointer<ffi.Char> source;
}

typedef Dart_StreamingWriteCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Uint8>, ffi.IntPtr)>>;
typedef Dart_CreateLoadingUnitCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            ffi.IntPtr,
            ffi.Pointer<ffi.Pointer<ffi.Void>>,
            ffi.Pointer<ffi.Pointer<ffi.Void>>)>>;
typedef Dart_StreamingCloseCallback
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>;

/// A Dart_CObject is used for representing Dart objects as native C
/// data outside the Dart heap. These objects are totally detached from
/// the Dart heap. Only a subset of the Dart objects have a
/// representation as a Dart_CObject.
///
/// The string encoding in the 'value.as_string' is UTF-8.
///
/// All the different types from dart:typed_data are exposed as type
/// kTypedData. The specific type from dart:typed_data is in the type
/// field of the as_typed_data structure. The length in the
/// as_typed_data structure is always in bytes.
///
/// The data for kTypedData is copied on message send and ownership remains with
/// the caller. The ownership of data for kExternalTyped is passed to the VM on
/// message send and returned when the VM invokes the
/// Dart_HandleFinalizer callback; a non-NULL callback must be provided.
abstract class Dart_CObject_Type {
  static const int Dart_CObject_kNull = 0;
  static const int Dart_CObject_kBool = 1;
  static const int Dart_CObject_kInt32 = 2;
  static const int Dart_CObject_kInt64 = 3;
  static const int Dart_CObject_kDouble = 4;
  static const int Dart_CObject_kString = 5;
  static const int Dart_CObject_kArray = 6;
  static const int Dart_CObject_kTypedData = 7;
  static const int Dart_CObject_kExternalTypedData = 8;
  static const int Dart_CObject_kSendPort = 9;
  static const int Dart_CObject_kCapability = 10;
  static const int Dart_CObject_kNativePointer = 11;
  static const int Dart_CObject_kUnsupported = 12;
  static const int Dart_CObject_kNumberOfTypes = 13;
}

class _Dart_CObject extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external UnnamedUnion1 value;
}

class UnnamedUnion1 extends ffi.Union {
  @ffi.Bool()
  external bool as_bool;

  @ffi.Int32()
  external int as_int32;

  @ffi.Int64()
  external int as_int64;

  @ffi.Double()
  external double as_double;

  external ffi.Pointer<ffi.Char> as_string;

  external UnnamedStruct3 as_send_port;

  external UnnamedStruct4 as_capability;

  external UnnamedStruct5 as_array;

  external UnnamedStruct6 as_typed_data;

  external UnnamedStruct7 as_external_typed_data;

  external UnnamedStruct8 as_native_pointer;
}

class UnnamedStruct3 extends ffi.Struct {
  @Dart_Port()
  external int id;

  @Dart_Port()
  external int origin_id;
}

class UnnamedStruct4 extends ffi.Struct {
  @ffi.Int64()
  external int id;
}

class UnnamedStruct5 extends ffi.Struct {
  @ffi.IntPtr()
  external int length;

  external ffi.Pointer<ffi.Pointer<_Dart_CObject>> values;
}

class UnnamedStruct6 extends ffi.Struct {
  @ffi.Int32()
  external int type;

  /// in elements, not bytes
  @ffi.IntPtr()
  external int length;

  external ffi.Pointer<ffi.Uint8> values;
}

class UnnamedStruct7 extends ffi.Struct {
  @ffi.Int32()
  external int type;

  /// in elements, not bytes
  @ffi.IntPtr()
  external int length;

  external ffi.Pointer<ffi.Uint8> data;

  external ffi.Pointer<ffi.Void> peer;

  external Dart_HandleFinalizer callback;
}

class UnnamedStruct8 extends ffi.Struct {
  @ffi.IntPtr()
  external int ptr;

  @ffi.IntPtr()
  external int size;

  external Dart_HandleFinalizer callback;
}

typedef Dart_CObject = _Dart_CObject;

/// A native message handler.
///
/// This handler is associated with a native port by calling
/// Dart_NewNativePort.
///
/// The message received is decoded into the message structure. The
/// lifetime of the message data is controlled by the caller. All the
/// data references from the message are allocated by the caller and
/// will be reclaimed when returning to it.
typedef Dart_NativeMessageHandler = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(Dart_Port, ffi.Pointer<Dart_CObject>)>>;
typedef Dart_PostCObject_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Bool Function(Dart_Port_DL, ffi.Pointer<Dart_CObject>)>>;

/// ============================================================================
/// IMPORTANT! Never update these signatures without properly updating
/// DART_API_DL_MAJOR_VERSION and DART_API_DL_MINOR_VERSION.
///
/// Verbatim copy of `dart_native_api.h` and `dart_api.h` symbol names and types
/// to trigger compile-time errors if the sybols in those files are updated
/// without updating these.
///
/// Function return and argument types, and typedefs are carbon copied. Structs
/// are typechecked nominally in C/C++, so they are not copied, instead a
/// comment is added to their definition.
typedef Dart_Port_DL = ffi.Int64;
typedef Dart_PostInteger_Type = ffi
    .Pointer<ffi.NativeFunction<ffi.Bool Function(Dart_Port_DL, ffi.Int64)>>;
typedef Dart_NewNativePort_Type = ffi.Pointer<
    ffi.NativeFunction<
        Dart_Port_DL Function(
            ffi.Pointer<ffi.Char>, Dart_NativeMessageHandler_DL, ffi.Bool)>>;
typedef Dart_NativeMessageHandler_DL = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(Dart_Port_DL, ffi.Pointer<Dart_CObject>)>>;
typedef Dart_CloseNativePort_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(Dart_Port_DL)>>;
typedef Dart_IsError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>;
typedef Dart_IsApiError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>;
typedef Dart_IsUnhandledExceptionError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>;
typedef Dart_IsCompilationError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>;
typedef Dart_IsFatalError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>;
typedef Dart_GetError_Type = ffi
    .Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Handle)>>;
typedef Dart_ErrorHasException_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Handle)>>;
typedef Dart_ErrorGetException_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>;
typedef Dart_ErrorGetStackTrace_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>;
typedef Dart_NewApiError_Type = ffi
    .Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>;
typedef Dart_NewCompilationError_Type = ffi
    .Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Pointer<ffi.Char>)>>;
typedef Dart_NewUnhandledExceptionError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>;
typedef Dart_PropagateError_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>;
typedef Dart_HandleFromPersistent_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>;
typedef Dart_HandleFromWeakPersistent_Type = ffi.Pointer<
    ffi.NativeFunction<ffi.Handle Function(Dart_WeakPersistentHandle)>>;
typedef Dart_NewPersistentHandle_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(ffi.Handle)>>;
typedef Dart_SetPersistentHandle_Type = ffi
    .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Handle, ffi.Handle)>>;
typedef Dart_DeletePersistentHandle_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Handle)>>;
typedef Dart_NewWeakPersistentHandle_Type = ffi.Pointer<
    ffi.NativeFunction<
        Dart_WeakPersistentHandle Function(ffi.Handle, ffi.Pointer<ffi.Void>,
            ffi.IntPtr, Dart_HandleFinalizer)>>;
typedef Dart_DeleteWeakPersistentHandle_Type = ffi
    .Pointer<ffi.NativeFunction<ffi.Void Function(Dart_WeakPersistentHandle)>>;
typedef Dart_UpdateExternalSize_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(Dart_WeakPersistentHandle, ffi.IntPtr)>>;
typedef Dart_NewFinalizableHandle_Type = ffi.Pointer<
    ffi.NativeFunction<
        Dart_FinalizableHandle Function(ffi.Handle, ffi.Pointer<ffi.Void>,
            ffi.IntPtr, Dart_HandleFinalizer)>>;
typedef Dart_DeleteFinalizableHandle_Type = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(Dart_FinalizableHandle, ffi.Handle)>>;
typedef Dart_UpdateFinalizableExternalSize_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(Dart_FinalizableHandle, ffi.Handle, ffi.IntPtr)>>;
typedef Dart_Post_Type = ffi
    .Pointer<ffi.NativeFunction<ffi.Bool Function(Dart_Port_DL, ffi.Handle)>>;
typedef Dart_NewSendPort_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Handle Function(Dart_Port_DL)>>;
typedef Dart_SendPortGetId_Type = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Handle Function(ffi.Handle, ffi.Pointer<Dart_Port_DL>)>>;
typedef Dart_EnterScope_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;
typedef Dart_ExitScope_Type
    = ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>;

/// The type of message being sent to a Dart port. See CUPHTTPClientDelegate.
abstract class MessageType {
  static const int ResponseMessage = 0;
  static const int DataMessage = 1;
  static const int CompletedMessage = 2;
  static const int RedirectMessage = 3;
  static const int FinishedDownloading = 4;
}

/// The configuration associated with a NSURLSessionTask.
/// See CUPHTTPClientDelegate.
class CUPHTTPTaskConfiguration extends NSObject {
  CUPHTTPTaskConfiguration._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [CUPHTTPTaskConfiguration] that points to the same underlying object as [other].
  static CUPHTTPTaskConfiguration castFrom<T extends _ObjCWrapper>(T other) {
    return CUPHTTPTaskConfiguration._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [CUPHTTPTaskConfiguration] that wraps the given raw object pointer.
  static CUPHTTPTaskConfiguration castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return CUPHTTPTaskConfiguration._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [CUPHTTPTaskConfiguration].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_CUPHTTPTaskConfiguration1);
  }

  NSObject initWithPort_(int sendPort) {
    final _ret =
        _lib._objc_msgSend_323(_id, _lib._sel_initWithPort_1, sendPort);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  int get sendPort {
    return _lib._objc_msgSend_247(_id, _lib._sel_sendPort1);
  }

  static CUPHTTPTaskConfiguration new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPTaskConfiguration1, _lib._sel_new1);
    return CUPHTTPTaskConfiguration._(_ret, _lib, retain: false, release: true);
  }

  static CUPHTTPTaskConfiguration alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPTaskConfiguration1, _lib._sel_alloc1);
    return CUPHTTPTaskConfiguration._(_ret, _lib, retain: false, release: true);
  }
}

/// A delegate for NSURLSession that forwards events for registered
/// NSURLSessionTasks and forwards them to a port for consumption in Dart.
///
/// The messages sent to the port are contained in a List with one of 3
/// possible formats:
///
/// 1. When the delegate receives a HTTP redirect response:
/// [MessageType::RedirectMessage, <int: pointer to CUPHTTPForwardedRedirect>]
///
/// 2. When the delegate receives a HTTP response:
/// [MessageType::ResponseMessage, <int: pointer to CUPHTTPForwardedResponse>]
///
/// 3. When the delegate receives some HTTP data:
/// [MessageType::DataMessage, <int: pointer to CUPHTTPForwardedData>]
///
/// 4. When the delegate is informed that the response is complete:
/// [MessageType::CompletedMessage, <int: pointer to CUPHTTPForwardedComplete>]
class CUPHTTPClientDelegate extends NSObject {
  CUPHTTPClientDelegate._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [CUPHTTPClientDelegate] that points to the same underlying object as [other].
  static CUPHTTPClientDelegate castFrom<T extends _ObjCWrapper>(T other) {
    return CUPHTTPClientDelegate._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [CUPHTTPClientDelegate] that wraps the given raw object pointer.
  static CUPHTTPClientDelegate castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return CUPHTTPClientDelegate._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [CUPHTTPClientDelegate].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_CUPHTTPClientDelegate1);
  }

  /// Instruct the delegate to forward events for the given task to the port
  /// specified in the configuration.
  void registerTask_withConfiguration_(
      NSURLSessionTask? task, CUPHTTPTaskConfiguration? config) {
    return _lib._objc_msgSend_324(
        _id,
        _lib._sel_registerTask_withConfiguration_1,
        task?._id ?? ffi.nullptr,
        config?._id ?? ffi.nullptr);
  }

  static CUPHTTPClientDelegate new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPClientDelegate1, _lib._sel_new1);
    return CUPHTTPClientDelegate._(_ret, _lib, retain: false, release: true);
  }

  static CUPHTTPClientDelegate alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPClientDelegate1, _lib._sel_alloc1);
    return CUPHTTPClientDelegate._(_ret, _lib, retain: false, release: true);
  }
}

/// An object used to communicate redirect information to Dart code.
///
/// The flow is:
/// 1. CUPHTTPClientDelegate receives a message from the URL Loading System.
/// 2. CUPHTTPClientDelegate creates a new CUPHTTPForwardedDelegate subclass.
/// 3. CUPHTTPClientDelegate sends the CUPHTTPForwardedDelegate to the
/// configured Dart_Port.
/// 4. CUPHTTPClientDelegate waits on CUPHTTPForwardedDelegate.lock
/// 5. When the Dart code is done process the message received on the port,
/// it calls [CUPHTTPForwardedDelegate finish*], which releases the lock.
/// 6. CUPHTTPClientDelegate continues running.
class CUPHTTPForwardedDelegate extends NSObject {
  CUPHTTPForwardedDelegate._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [CUPHTTPForwardedDelegate] that points to the same underlying object as [other].
  static CUPHTTPForwardedDelegate castFrom<T extends _ObjCWrapper>(T other) {
    return CUPHTTPForwardedDelegate._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [CUPHTTPForwardedDelegate] that wraps the given raw object pointer.
  static CUPHTTPForwardedDelegate castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return CUPHTTPForwardedDelegate._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [CUPHTTPForwardedDelegate].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_CUPHTTPForwardedDelegate1);
  }

  NSObject initWithSession_task_(
      NSURLSession? session, NSURLSessionTask? task) {
    final _ret = _lib._objc_msgSend_325(_id, _lib._sel_initWithSession_task_1,
        session?._id ?? ffi.nullptr, task?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// Indicates that the task should continue executing using the given request.
  void finish() {
    return _lib._objc_msgSend_1(_id, _lib._sel_finish1);
  }

  NSURLSession? get session {
    final _ret = _lib._objc_msgSend_221(_id, _lib._sel_session1);
    return _ret.address == 0
        ? null
        : NSURLSession._(_ret, _lib, retain: true, release: true);
  }

  NSURLSessionTask? get task {
    final _ret = _lib._objc_msgSend_326(_id, _lib._sel_task1);
    return _ret.address == 0
        ? null
        : NSURLSessionTask._(_ret, _lib, retain: true, release: true);
  }

  /// This property is meant to be used only by CUPHTTPClientDelegate.
  NSLock? get lock {
    final _ret = _lib._objc_msgSend_327(_id, _lib._sel_lock1);
    return _ret.address == 0
        ? null
        : NSLock._(_ret, _lib, retain: true, release: true);
  }

  static CUPHTTPForwardedDelegate new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedDelegate1, _lib._sel_new1);
    return CUPHTTPForwardedDelegate._(_ret, _lib, retain: false, release: true);
  }

  static CUPHTTPForwardedDelegate alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedDelegate1, _lib._sel_alloc1);
    return CUPHTTPForwardedDelegate._(_ret, _lib, retain: false, release: true);
  }
}

class NSLock extends _ObjCWrapper {
  NSLock._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [NSLock] that points to the same underlying object as [other].
  static NSLock castFrom<T extends _ObjCWrapper>(T other) {
    return NSLock._(other._id, other._lib, retain: true, release: true);
  }

  /// Returns a [NSLock] that wraps the given raw object pointer.
  static NSLock castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return NSLock._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [NSLock].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(
        obj._id, obj._lib._sel_isKindOfClass_1, obj._lib._class_NSLock1);
  }
}

class CUPHTTPForwardedRedirect extends CUPHTTPForwardedDelegate {
  CUPHTTPForwardedRedirect._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [CUPHTTPForwardedRedirect] that points to the same underlying object as [other].
  static CUPHTTPForwardedRedirect castFrom<T extends _ObjCWrapper>(T other) {
    return CUPHTTPForwardedRedirect._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [CUPHTTPForwardedRedirect] that wraps the given raw object pointer.
  static CUPHTTPForwardedRedirect castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return CUPHTTPForwardedRedirect._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [CUPHTTPForwardedRedirect].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_CUPHTTPForwardedRedirect1);
  }

  NSObject initWithSession_task_response_request_(
      NSURLSession? session,
      NSURLSessionTask? task,
      NSHTTPURLResponse? response,
      NSURLRequest? request) {
    final _ret = _lib._objc_msgSend_328(
        _id,
        _lib._sel_initWithSession_task_response_request_1,
        session?._id ?? ffi.nullptr,
        task?._id ?? ffi.nullptr,
        response?._id ?? ffi.nullptr,
        request?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  /// Indicates that the task should continue executing using the given request.
  /// If the request is NIL then the redirect is not followed and the task is
  /// complete.
  void finishWithRequest_(NSURLRequest? request) {
    return _lib._objc_msgSend_329(
        _id, _lib._sel_finishWithRequest_1, request?._id ?? ffi.nullptr);
  }

  NSHTTPURLResponse? get response {
    final _ret = _lib._objc_msgSend_330(_id, _lib._sel_response1);
    return _ret.address == 0
        ? null
        : NSHTTPURLResponse._(_ret, _lib, retain: true, release: true);
  }

  NSURLRequest? get request {
    final _ret = _lib._objc_msgSend_237(_id, _lib._sel_request1);
    return _ret.address == 0
        ? null
        : NSURLRequest._(_ret, _lib, retain: true, release: true);
  }

  /// This property is meant to be used only by CUPHTTPClientDelegate.
  NSURLRequest? get redirectRequest {
    final _ret = _lib._objc_msgSend_237(_id, _lib._sel_redirectRequest1);
    return _ret.address == 0
        ? null
        : NSURLRequest._(_ret, _lib, retain: true, release: true);
  }

  static CUPHTTPForwardedRedirect new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedRedirect1, _lib._sel_new1);
    return CUPHTTPForwardedRedirect._(_ret, _lib, retain: false, release: true);
  }

  static CUPHTTPForwardedRedirect alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedRedirect1, _lib._sel_alloc1);
    return CUPHTTPForwardedRedirect._(_ret, _lib, retain: false, release: true);
  }
}

class CUPHTTPForwardedResponse extends CUPHTTPForwardedDelegate {
  CUPHTTPForwardedResponse._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [CUPHTTPForwardedResponse] that points to the same underlying object as [other].
  static CUPHTTPForwardedResponse castFrom<T extends _ObjCWrapper>(T other) {
    return CUPHTTPForwardedResponse._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [CUPHTTPForwardedResponse] that wraps the given raw object pointer.
  static CUPHTTPForwardedResponse castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return CUPHTTPForwardedResponse._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [CUPHTTPForwardedResponse].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_CUPHTTPForwardedResponse1);
  }

  NSObject initWithSession_task_response_(
      NSURLSession? session, NSURLSessionTask? task, NSURLResponse? response) {
    final _ret = _lib._objc_msgSend_331(
        _id,
        _lib._sel_initWithSession_task_response_1,
        session?._id ?? ffi.nullptr,
        task?._id ?? ffi.nullptr,
        response?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  void finishWithDisposition_(int disposition) {
    return _lib._objc_msgSend_332(
        _id, _lib._sel_finishWithDisposition_1, disposition);
  }

  NSURLResponse? get response {
    final _ret = _lib._objc_msgSend_239(_id, _lib._sel_response1);
    return _ret.address == 0
        ? null
        : NSURLResponse._(_ret, _lib, retain: true, release: true);
  }

  /// This property is meant to be used only by CUPHTTPClientDelegate.
  int get disposition {
    return _lib._objc_msgSend_333(_id, _lib._sel_disposition1);
  }

  static CUPHTTPForwardedResponse new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedResponse1, _lib._sel_new1);
    return CUPHTTPForwardedResponse._(_ret, _lib, retain: false, release: true);
  }

  static CUPHTTPForwardedResponse alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedResponse1, _lib._sel_alloc1);
    return CUPHTTPForwardedResponse._(_ret, _lib, retain: false, release: true);
  }
}

class CUPHTTPForwardedData extends CUPHTTPForwardedDelegate {
  CUPHTTPForwardedData._(ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [CUPHTTPForwardedData] that points to the same underlying object as [other].
  static CUPHTTPForwardedData castFrom<T extends _ObjCWrapper>(T other) {
    return CUPHTTPForwardedData._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [CUPHTTPForwardedData] that wraps the given raw object pointer.
  static CUPHTTPForwardedData castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return CUPHTTPForwardedData._(other, lib, retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [CUPHTTPForwardedData].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_CUPHTTPForwardedData1);
  }

  NSObject initWithSession_task_data_(
      NSURLSession? session, NSURLSessionTask? task, NSData? data) {
    final _ret = _lib._objc_msgSend_334(
        _id,
        _lib._sel_initWithSession_task_data_1,
        session?._id ?? ffi.nullptr,
        task?._id ?? ffi.nullptr,
        data?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSData? get data {
    final _ret = _lib._objc_msgSend_38(_id, _lib._sel_data1);
    return _ret.address == 0
        ? null
        : NSData._(_ret, _lib, retain: true, release: true);
  }

  static CUPHTTPForwardedData new1(NativeCupertinoHttp _lib) {
    final _ret =
        _lib._objc_msgSend_2(_lib._class_CUPHTTPForwardedData1, _lib._sel_new1);
    return CUPHTTPForwardedData._(_ret, _lib, retain: false, release: true);
  }

  static CUPHTTPForwardedData alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedData1, _lib._sel_alloc1);
    return CUPHTTPForwardedData._(_ret, _lib, retain: false, release: true);
  }
}

class CUPHTTPForwardedComplete extends CUPHTTPForwardedDelegate {
  CUPHTTPForwardedComplete._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [CUPHTTPForwardedComplete] that points to the same underlying object as [other].
  static CUPHTTPForwardedComplete castFrom<T extends _ObjCWrapper>(T other) {
    return CUPHTTPForwardedComplete._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [CUPHTTPForwardedComplete] that wraps the given raw object pointer.
  static CUPHTTPForwardedComplete castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return CUPHTTPForwardedComplete._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [CUPHTTPForwardedComplete].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_CUPHTTPForwardedComplete1);
  }

  NSObject initWithSession_task_error_(
      NSURLSession? session, NSURLSessionTask? task, NSError? error) {
    final _ret = _lib._objc_msgSend_335(
        _id,
        _lib._sel_initWithSession_task_error_1,
        session?._id ?? ffi.nullptr,
        task?._id ?? ffi.nullptr,
        error?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSError? get error {
    final _ret = _lib._objc_msgSend_256(_id, _lib._sel_error1);
    return _ret.address == 0
        ? null
        : NSError._(_ret, _lib, retain: true, release: true);
  }

  static CUPHTTPForwardedComplete new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedComplete1, _lib._sel_new1);
    return CUPHTTPForwardedComplete._(_ret, _lib, retain: false, release: true);
  }

  static CUPHTTPForwardedComplete alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedComplete1, _lib._sel_alloc1);
    return CUPHTTPForwardedComplete._(_ret, _lib, retain: false, release: true);
  }
}

class CUPHTTPForwardedFinishedDownloading extends CUPHTTPForwardedDelegate {
  CUPHTTPForwardedFinishedDownloading._(
      ffi.Pointer<ObjCObject> id, NativeCupertinoHttp lib,
      {bool retain = false, bool release = false})
      : super._(id, lib, retain: retain, release: release);

  /// Returns a [CUPHTTPForwardedFinishedDownloading] that points to the same underlying object as [other].
  static CUPHTTPForwardedFinishedDownloading castFrom<T extends _ObjCWrapper>(
      T other) {
    return CUPHTTPForwardedFinishedDownloading._(other._id, other._lib,
        retain: true, release: true);
  }

  /// Returns a [CUPHTTPForwardedFinishedDownloading] that wraps the given raw object pointer.
  static CUPHTTPForwardedFinishedDownloading castFromPointer(
      NativeCupertinoHttp lib, ffi.Pointer<ObjCObject> other,
      {bool retain = false, bool release = false}) {
    return CUPHTTPForwardedFinishedDownloading._(other, lib,
        retain: retain, release: release);
  }

  /// Returns whether [obj] is an instance of [CUPHTTPForwardedFinishedDownloading].
  static bool isInstance(_ObjCWrapper obj) {
    return obj._lib._objc_msgSend_0(obj._id, obj._lib._sel_isKindOfClass_1,
        obj._lib._class_CUPHTTPForwardedFinishedDownloading1);
  }

  NSObject initWithSession_downloadTask_url_(NSURLSession? session,
      NSURLSessionDownloadTask? downloadTask, NSURL? location) {
    final _ret = _lib._objc_msgSend_336(
        _id,
        _lib._sel_initWithSession_downloadTask_url_1,
        session?._id ?? ffi.nullptr,
        downloadTask?._id ?? ffi.nullptr,
        location?._id ?? ffi.nullptr);
    return NSObject._(_ret, _lib, retain: true, release: true);
  }

  NSURL? get location {
    final _ret = _lib._objc_msgSend_39(_id, _lib._sel_location1);
    return _ret.address == 0
        ? null
        : NSURL._(_ret, _lib, retain: true, release: true);
  }

  static CUPHTTPForwardedFinishedDownloading new1(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedFinishedDownloading1, _lib._sel_new1);
    return CUPHTTPForwardedFinishedDownloading._(_ret, _lib,
        retain: false, release: true);
  }

  static CUPHTTPForwardedFinishedDownloading alloc(NativeCupertinoHttp _lib) {
    final _ret = _lib._objc_msgSend_2(
        _lib._class_CUPHTTPForwardedFinishedDownloading1, _lib._sel_alloc1);
    return CUPHTTPForwardedFinishedDownloading._(_ret, _lib,
        retain: false, release: true);
  }
}

const int kNativeArgNumberPos = 0;

const int kNativeArgNumberSize = 8;

const int kNativeArgTypePos = 8;

const int kNativeArgTypeSize = 8;

const int NSURLResponseUnknownLength = -1;

const int NSOperationQualityOfServiceUserInteractive = 33;

const int NSOperationQualityOfServiceUserInitiated = 25;

const int NSOperationQualityOfServiceUtility = 17;

const int NSOperationQualityOfServiceBackground = 9;

const int DART_FLAGS_CURRENT_VERSION = 12;

const int DART_INITIALIZE_PARAMS_CURRENT_VERSION = 4;

const int ILLEGAL_PORT = 0;

const String DART_KERNEL_ISOLATE_NAME = 'kernel-service';

const String DART_VM_SERVICE_ISOLATE_NAME = 'vm-service';

const String kSnapshotBuildIdCSymbol = 'kDartSnapshotBuildId';

const String kVmSnapshotDataCSymbol = 'kDartVmSnapshotData';

const String kVmSnapshotInstructionsCSymbol = 'kDartVmSnapshotInstructions';

const String kVmSnapshotBssCSymbol = 'kDartVmSnapshotBss';

const String kIsolateSnapshotDataCSymbol = 'kDartIsolateSnapshotData';

const String kIsolateSnapshotInstructionsCSymbol =
    'kDartIsolateSnapshotInstructions';

const String kIsolateSnapshotBssCSymbol = 'kDartIsolateSnapshotBss';

const String kSnapshotBuildIdAsmSymbol = '_kDartSnapshotBuildId';

const String kVmSnapshotDataAsmSymbol = '_kDartVmSnapshotData';

const String kVmSnapshotInstructionsAsmSymbol = '_kDartVmSnapshotInstructions';

const String kVmSnapshotBssAsmSymbol = '_kDartVmSnapshotBss';

const String kIsolateSnapshotDataAsmSymbol = '_kDartIsolateSnapshotData';

const String kIsolateSnapshotInstructionsAsmSymbol =
    '_kDartIsolateSnapshotInstructions';

const String kIsolateSnapshotBssAsmSymbol = '_kDartIsolateSnapshotBss';
