// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: return_of_invalid_type

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

/// Bindings for the Foundation URL Loading System and supporting libraries.
///
/// Regenerate bindings with `flutter packages pub run ffigen --config ffigen.yaml`.
///
class NativeCupertinoHttp {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeCupertinoHttp(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeCupertinoHttp.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> signal(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _signal(
      arg0,
      arg1,
    );
  }

  late final _signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
              ffi.Int,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>>('signal');
  late final _signal = _signalPtr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
          int, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>();

  int getpriority(
    int arg0,
    int arg1,
  ) {
    return _getpriority(
      arg0,
      arg1,
    );
  }

  late final _getpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t)>>(
          'getpriority');
  late final _getpriority =
      _getpriorityPtr.asFunction<int Function(int, int)>();

  int getiopolicy_np(
    int arg0,
    int arg1,
  ) {
    return _getiopolicy_np(
      arg0,
      arg1,
    );
  }

  late final _getiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'getiopolicy_np');
  late final _getiopolicy_np =
      _getiopolicy_npPtr.asFunction<int Function(int, int)>();

  int getrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _getrlimit(
      arg0,
      arg1,
    );
  }

  late final _getrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'getrlimit');
  late final _getrlimit =
      _getrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int getrusage(
    int arg0,
    ffi.Pointer<rusage> arg1,
  ) {
    return _getrusage(
      arg0,
      arg1,
    );
  }

  late final _getrusagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rusage>)>>(
      'getrusage');
  late final _getrusage =
      _getrusagePtr.asFunction<int Function(int, ffi.Pointer<rusage>)>();

  int setpriority(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setpriority(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t, ffi.Int)>>(
          'setpriority');
  late final _setpriority =
      _setpriorityPtr.asFunction<int Function(int, int, int)>();

  int setiopolicy_np(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setiopolicy_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'setiopolicy_np');
  late final _setiopolicy_np =
      _setiopolicy_npPtr.asFunction<int Function(int, int, int)>();

  int setrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _setrlimit(
      arg0,
      arg1,
    );
  }

  late final _setrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'setrlimit');
  late final _setrlimit =
      _setrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int wait1(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _wait1(
      arg0,
    );
  }

  late final _wait1Ptr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Pointer<ffi.Int>)>>('wait');
  late final _wait1 =
      _wait1Ptr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int waitpid(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
  ) {
    return _waitpid(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _waitpidPtr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int)>>('waitpid');
  late final _waitpid =
      _waitpidPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>, int)>();

  int waitid(
    idtype_t arg0,
    Dart__uint32_t arg1,
    ffi.Pointer<siginfo_t> arg2,
    int arg3,
  ) {
    return _waitid(
      arg0.value,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _waitidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, id_t, ffi.Pointer<siginfo_t>,
              ffi.Int)>>('waitid');
  late final _waitid = _waitidPtr
      .asFunction<int Function(int, int, ffi.Pointer<siginfo_t>, int)>();

  int wait3(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
    ffi.Pointer<rusage> arg2,
  ) {
    return _wait3(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wait3Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(
              ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<rusage>)>>('wait3');
  late final _wait3 = _wait3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  int wait4(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
    ffi.Pointer<rusage> arg3,
  ) {
    return _wait4(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _wait4Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int,
              ffi.Pointer<rusage>)>>('wait4');
  late final _wait4 = _wait4Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  ffi.Pointer<ffi.Void> alloca(
    int arg0,
  ) {
    return _alloca(
      arg0,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  late final ffi.Pointer<ffi.Int> ___mb_cur_max =
      _lookup<ffi.Int>('__mb_cur_max');

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  ffi.Pointer<ffi.Void> malloc_type_malloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_malloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_malloc');
  late final _malloc_type_malloc = _malloc_type_mallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_calloc(
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_calloc(
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, ffi.Size, malloc_type_id_t)>>('malloc_type_calloc');
  late final _malloc_type_calloc = _malloc_type_callocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  void malloc_type_free(
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_free(
      ptr,
      type_id,
    );
  }

  late final _malloc_type_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, malloc_type_id_t)>>('malloc_type_free');
  late final _malloc_type_free = _malloc_type_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_realloc(
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_realloc(
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_realloc');
  late final _malloc_type_realloc = _malloc_type_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_valloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_valloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_valloc');
  late final _malloc_type_valloc = _malloc_type_vallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_aligned_alloc(
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_aligned_alloc(
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size,
              malloc_type_id_t)>>('malloc_type_aligned_alloc');
  late final _malloc_type_aligned_alloc = _malloc_type_aligned_allocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  int malloc_type_posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> memptr,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_posix_memalign(
      memptr,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_posix_memalign');
  late final _malloc_type_posix_memalign =
      _malloc_type_posix_memalignPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_malloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_malloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_malloc');
  late final _malloc_type_zone_malloc = _malloc_type_zone_mallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_calloc(
    ffi.Pointer<malloc_zone_t> zone,
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_calloc(
      zone,
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_calloc');
  late final _malloc_type_zone_calloc = _malloc_type_zone_callocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<malloc_zone_t>, int, int, int)>();

  void malloc_type_zone_free(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_zone_free(
      zone,
      ptr,
      type_id,
    );
  }

  late final _malloc_type_zone_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>,
              malloc_type_id_t)>>('malloc_type_zone_free');
  late final _malloc_type_zone_free = _malloc_type_zone_freePtr.asFunction<
      void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_realloc(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_realloc(
      zone,
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_realloc');
  late final _malloc_type_zone_realloc =
      _malloc_type_zone_reallocPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_valloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_valloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_valloc');
  late final _malloc_type_zone_valloc = _malloc_type_zone_vallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_memalign(
    ffi.Pointer<malloc_zone_t> zone,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_memalign(
      zone,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_memalign');
  late final _malloc_type_zone_memalign =
      _malloc_type_zone_memalignPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __count,
    int __size,
  ) {
    return _calloc(
      __count,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void free(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _free(
      arg0,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> reallocf(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _reallocf(
      __ptr,
      __size,
    );
  }

  late final _reallocfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('reallocf');
  late final _reallocf = _reallocfPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int abs(
    int arg0,
  ) {
    return _abs(
      arg0,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _atexit(
      arg0,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _at_quick_exit(
      arg0,
    );
  }

  late final _at_quick_exitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>(
      'at_quick_exit');
  late final _at_quick_exit = _at_quick_exitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  double atof(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atof(
      arg0,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoi(
      arg0,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atol(
      arg0,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoll(
      arg0,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  div_t div(
    int arg0,
    int arg1,
  ) {
    return _div(
      arg0,
      arg1,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  void exit(
    int arg0,
  ) {
    return _exit1(
      arg0,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit1 = _exitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getenv(
      arg0,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int labs(
    int arg0,
  ) {
    return _labs(
      arg0,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  ldiv_t ldiv(
    int arg0,
    int arg1,
  ) {
    return _ldiv(
      arg0,
      arg1,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  int llabs(
    int arg0,
  ) {
    return _llabs(
      arg0,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  lldiv_t lldiv(
    int arg0,
    int arg1,
  ) {
    return _lldiv(
      arg0,
      arg1,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbstowcs(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbtowc(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void quick_exit(
    int arg0,
  ) {
    return _quick_exit(
      arg0,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int arg0,
  ) {
    return _srand(
      arg0,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  double strtod(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtod(
      arg0,
      arg1,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtof(
      arg0,
      arg1,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int system(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _system(
      arg0,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.WChar> arg1,
    int arg2,
  ) {
    return _wcstombs(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _wctomb(
      arg0,
      arg1,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void _Exit(
    int arg0,
  ) {
    return __Exit(
      arg0,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _a64l(
      arg0,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  ffi.Pointer<ffi.Char> ecvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _ecvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _erand48(
      arg0,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _fcvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _gcvt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _getsubopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int grantpt(
    int arg0,
  ) {
    return _grantpt(
      arg0,
    );
  }

  late final _grantptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('grantpt');
  late final _grantpt = _grantptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _initstate(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _jrand48(
      arg0,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> l64a(
    int arg0,
  ) {
    return _l64a(
      arg0,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _lcong48(
      arg0,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mktemp(
      arg0,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkstemp(
      arg0,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _nrand48(
      arg0,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int posix_openpt(
    int arg0,
  ) {
    return _posix_openpt(
      arg0,
    );
  }

  late final _posix_openptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('posix_openpt');
  late final _posix_openpt = _posix_openptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> ptsname(
    int arg0,
  ) {
    return _ptsname(
      arg0,
    );
  }

  late final _ptsnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ptsname');
  late final _ptsname =
      _ptsnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int ptsname_r(
    int fildes,
    ffi.Pointer<ffi.Char> buffer,
    int buflen,
  ) {
    return _ptsname_r(
      fildes,
      buffer,
      buflen,
    );
  }

  late final _ptsname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ptsname_r');
  late final _ptsname_r =
      _ptsname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int putenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _putenv(
      arg0,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> arg0,
  ) {
    return _rand_r(
      arg0,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _realpath(
      arg0,
      arg1,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _seed48(
      arg0,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __overwrite,
  ) {
    return _setenv(
      __name,
      __value,
      __overwrite,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void setkey(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setkey(
      arg0,
    );
  }

  late final _setkeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setkey');
  late final _setkey =
      _setkeyPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setstate(
      arg0,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void srand48(
    int arg0,
  ) {
    return _srand48(
      arg0,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  void srandom(
    int arg0,
  ) {
    return _srandom(
      arg0,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  int unlockpt(
    int arg0,
  ) {
    return _unlockpt(
      arg0,
    );
  }

  late final _unlockptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('unlockpt');
  late final _unlockpt = _unlockptPtr.asFunction<int Function(int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unsetenv(
      arg0,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int arc4random() {
    return _arc4random();
  }

  late final _arc4randomPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('arc4random');
  late final _arc4random = _arc4randomPtr.asFunction<int Function()>();

  void arc4random_addrandom(
    ffi.Pointer<ffi.UnsignedChar> arg0,
    int arg1,
  ) {
    return _arc4random_addrandom(
      arg0,
      arg1,
    );
  }

  late final _arc4random_addrandomPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('arc4random_addrandom');
  late final _arc4random_addrandom = _arc4random_addrandomPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  void arc4random_buf(
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _arc4random_buf(
      __buf,
      __nbytes,
    );
  }

  late final _arc4random_bufPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>(
      'arc4random_buf');
  late final _arc4random_buf = _arc4random_bufPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  void arc4random_stir() {
    return _arc4random_stir();
  }

  late final _arc4random_stirPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('arc4random_stir');
  late final _arc4random_stir =
      _arc4random_stirPtr.asFunction<void Function()>();

  int arc4random_uniform(
    int __upper_bound,
  ) {
    return _arc4random_uniform(
      __upper_bound,
    );
  }

  late final _arc4random_uniformPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint32)>>(
          'arc4random_uniform');
  late final _arc4random_uniform =
      _arc4random_uniformPtr.asFunction<int Function(int)>();

  int atexit_b(
    objc.ObjCBlock<ffi.Void Function()> arg0,
  ) {
    return _atexit_b(
      arg0.ref.pointer,
    );
  }

  late final _atexit_bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<objc.ObjCBlockImpl>)>>('atexit_b');
  late final _atexit_b =
      _atexit_bPtr.asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl>)>();

  ffi.Pointer<ffi.Void> bsearch_b(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    objc.ObjCBlock<
            ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
        __compar,
  ) {
    return _bsearch_b(
      __key,
      __base,
      __nel,
      __width,
      __compar.ref.pointer,
    );
  }

  late final _bsearch_bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('bsearch_b');
  late final _bsearch_b = _bsearch_bPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<objc.ObjCBlockImpl>)>();

  ffi.Pointer<ffi.Char> cgetcap(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _cgetcap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetcapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('cgetcap');
  late final _cgetcap = _cgetcapPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int cgetclose() {
    return _cgetclose();
  }

  late final _cgetclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('cgetclose');
  late final _cgetclose = _cgetclosePtr.asFunction<int Function()>();

  int cgetent(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _cgetent(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('cgetent');
  late final _cgetent = _cgetentPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int cgetfirst(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetfirst(
      arg0,
      arg1,
    );
  }

  late final _cgetfirstPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetfirst');
  late final _cgetfirst = _cgetfirstPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetmatch(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _cgetmatch(
      arg0,
      arg1,
    );
  }

  late final _cgetmatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('cgetmatch');
  late final _cgetmatch = _cgetmatchPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int cgetnext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetnext(
      arg0,
      arg1,
    );
  }

  late final _cgetnextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetnext');
  late final _cgetnext = _cgetnextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetnum(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Long> arg2,
  ) {
    return _cgetnum(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetnumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Long>)>>('cgetnum');
  late final _cgetnum = _cgetnumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Long>)>();

  int cgetset(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _cgetset(
      arg0,
    );
  }

  late final _cgetsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'cgetset');
  late final _cgetset =
      _cgetsetPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int cgetstr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetstr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetstr');
  late final _cgetstr = _cgetstrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetustr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetustr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetustrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetustr');
  late final _cgetustr = _cgetustrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int daemon(
    int arg0,
    int arg1,
  ) {
    return _daemon(
      arg0,
      arg1,
    );
  }

  late final _daemonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('daemon');
  late final _daemon = _daemonPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> devname(
    int arg0,
    int arg1,
  ) {
    return _devname(
      arg0,
      arg1,
    );
  }

  late final _devnamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(dev_t, mode_t)>>(
      'devname');
  late final _devname =
      _devnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  ffi.Pointer<ffi.Char> devname_r(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _devname_r(
      arg0,
      arg1,
      buf,
      len,
    );
  }

  late final _devname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              dev_t, mode_t, ffi.Pointer<ffi.Char>, ffi.Int)>>('devname_r');
  late final _devname_r = _devname_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> getbsize(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.Long> arg1,
  ) {
    return _getbsize(
      arg0,
      arg1,
    );
  }

  late final _getbsizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>>('getbsize');
  late final _getbsize = _getbsizePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> arg0,
    int arg1,
  ) {
    return _getloadavg(
      arg0,
      arg1,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  ffi.Pointer<ffi.Char> getprogname() {
    return _getprogname();
  }

  late final _getprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getprogname');
  late final _getprogname =
      _getprognamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setprogname(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setprogname(
      arg0,
    );
  }

  late final _setprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setprogname');
  late final _setprogname =
      _setprognamePtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int heapsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _heapsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _heapsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('heapsort');
  late final _heapsort = _heapsortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int heapsort_b(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    objc.ObjCBlock<
            ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
        __compar,
  ) {
    return _heapsort_b(
      __base,
      __nel,
      __width,
      __compar.ref.pointer,
    );
  }

  late final _heapsort_bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('heapsort_b');
  late final _heapsort_b = _heapsort_bPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<objc.ObjCBlockImpl>)>();

  int mergesort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _mergesort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _mergesortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('mergesort');
  late final _mergesort = _mergesortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int mergesort_b(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    objc.ObjCBlock<
            ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
        __compar,
  ) {
    return _mergesort_b(
      __base,
      __nel,
      __width,
      __compar.ref.pointer,
    );
  }

  late final _mergesort_bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('mergesort_b');
  late final _mergesort_b = _mergesort_bPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<objc.ObjCBlockImpl>)>();

  void psort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _psortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort');
  late final _psort = _psortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort_b(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    objc.ObjCBlock<
            ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
        __compar,
  ) {
    return _psort_b(
      __base,
      __nel,
      __width,
      __compar.ref.pointer,
    );
  }

  late final _psort_bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('psort_b');
  late final _psort_b = _psort_bPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<objc.ObjCBlockImpl>)>();

  void psort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _psort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort_r');
  late final _psort_r = _psort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  void qsort_b(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    objc.ObjCBlock<
            ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
        __compar,
  ) {
    return _qsort_b(
      __base,
      __nel,
      __width,
      __compar.ref.pointer,
    );
  }

  late final _qsort_bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('qsort_b');
  late final _qsort_b = _qsort_bPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<objc.ObjCBlockImpl>)>();

  void qsort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _qsort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort_r');
  late final _qsort_r = _qsort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  int radixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _radixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _radixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('radixsort');
  late final _radixsort = _radixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _rpmatch(
      arg0,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sradixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _sradixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _sradixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('sradixsort');
  late final _sradixsort = _sradixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  void sranddev() {
    return _sranddev();
  }

  late final _sranddevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sranddev');
  late final _sranddev = _sranddevPtr.asFunction<void Function()>();

  void srandomdev() {
    return _srandomdev();
  }

  late final _srandomdevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('srandomdev');
  late final _srandomdev = _srandomdevPtr.asFunction<void Function()>();

  int strtonum(
    ffi.Pointer<ffi.Char> __numstr,
    int __minval,
    int __maxval,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __errstrp,
  ) {
    return _strtonum(
      __numstr,
      __minval,
      __maxval,
      __errstrp,
    );
  }

  late final _strtonumPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>, ffi.LongLong,
              ffi.LongLong, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtonum');
  late final _strtonum = _strtonumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Char>>('suboptarg');

  ffi.Pointer<ffi.Char> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Char> value) => _suboptarg.value = value;

  int __darwin_check_fd_set_overflow(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return ___darwin_check_fd_set_overflow(
      arg0,
      arg1,
      arg2,
    );
  }

  late final ___darwin_check_fd_set_overflowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('__darwin_check_fd_set_overflow');
  late final ___darwin_check_fd_set_overflow =
      ___darwin_check_fd_set_overflowPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> sel_getName(
    ffi.Pointer<objc.ObjCSelector> sel,
  ) {
    return _sel_getName(
      sel,
    );
  }

  late final _sel_getNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<objc.ObjCSelector>)>>('sel_getName');
  late final _sel_getName = _sel_getNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCSelector>)>();

  ffi.Pointer<objc.ObjCSelector> sel_registerName(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _sel_registerName(
      str,
    );
  }

  late final _sel_registerNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCSelector> Function(
              ffi.Pointer<ffi.Char>)>>('sel_registerName');
  late final _sel_registerName = _sel_registerNamePtr.asFunction<
      ffi.Pointer<objc.ObjCSelector> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> object_getClassName(
    objc.ObjCObjectBase? obj,
  ) {
    return _object_getClassName(
      obj?.ref.pointer ?? ffi.nullptr,
    );
  }

  late final _object_getClassNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<objc.ObjCObject>)>>('object_getClassName');
  late final _object_getClassName = _object_getClassNamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObject>)>();

  ffi.Pointer<ffi.Void> object_getIndexedIvars(
    objc.ObjCObjectBase? obj,
  ) {
    return _object_getIndexedIvars(
      obj?.ref.pointer ?? ffi.nullptr,
    );
  }

  late final _object_getIndexedIvarsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<objc.ObjCObject>)>>('object_getIndexedIvars');
  late final _object_getIndexedIvars = _object_getIndexedIvarsPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<objc.ObjCObject>)>();

  bool sel_isMapped(
    ffi.Pointer<objc.ObjCSelector> sel,
  ) {
    return _sel_isMapped(
      sel,
    );
  }

  late final _sel_isMappedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<objc.ObjCSelector>)>>('sel_isMapped');
  late final _sel_isMapped = _sel_isMappedPtr
      .asFunction<bool Function(ffi.Pointer<objc.ObjCSelector>)>();

  ffi.Pointer<objc.ObjCSelector> sel_getUid(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _sel_getUid(
      str,
    );
  }

  late final _sel_getUidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCSelector> Function(
              ffi.Pointer<ffi.Char>)>>('sel_getUid');
  late final _sel_getUid = _sel_getUidPtr.asFunction<
      ffi.Pointer<objc.ObjCSelector> Function(ffi.Pointer<ffi.Char>)>();

  objc.ObjCObjectBase? objc_retainedObject(
    objc_objectptr_t obj,
  ) {
    return _objc_retainedObject(
              obj,
            ).address ==
            0
        ? null
        : objc.ObjCObjectBase(
            _objc_retainedObject(
              obj,
            ),
            retain: true,
            release: true);
  }

  late final _objc_retainedObjectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
              objc_objectptr_t)>>('objc_retainedObject');
  late final _objc_retainedObject = _objc_retainedObjectPtr
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(objc_objectptr_t)>();

  objc.ObjCObjectBase? objc_unretainedObject(
    objc_objectptr_t obj,
  ) {
    return _objc_unretainedObject(
              obj,
            ).address ==
            0
        ? null
        : objc.ObjCObjectBase(
            _objc_unretainedObject(
              obj,
            ),
            retain: true,
            release: true);
  }

  late final _objc_unretainedObjectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
              objc_objectptr_t)>>('objc_unretainedObject');
  late final _objc_unretainedObject = _objc_unretainedObjectPtr
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(objc_objectptr_t)>();

  objc_objectptr_t objc_unretainedPointer(
    objc.ObjCObjectBase? obj,
  ) {
    return _objc_unretainedPointer(
      obj?.ref.pointer ?? ffi.nullptr,
    );
  }

  late final _objc_unretainedPointerPtr = _lookup<
      ffi.NativeFunction<
          objc_objectptr_t Function(
              ffi.Pointer<objc.ObjCObject>)>>('objc_unretainedPointer');
  late final _objc_unretainedPointer = _objc_unretainedPointerPtr
      .asFunction<objc_objectptr_t Function(ffi.Pointer<objc.ObjCObject>)>();

  late final ffi.Pointer<ffi.Double> _NSFoundationVersionNumber =
      _lookup<ffi.Double>('NSFoundationVersionNumber');

  double get NSFoundationVersionNumber => _NSFoundationVersionNumber.value;

  set NSFoundationVersionNumber(double value) =>
      _NSFoundationVersionNumber.value = value;

  objc.NSString NSStringFromSelector(
    ffi.Pointer<objc.ObjCSelector> aSelector,
  ) {
    return objc.NSString.castFromPointer(
        _NSStringFromSelector(
          aSelector,
        ),
        retain: true,
        release: true);
  }

  late final _NSStringFromSelectorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCSelector>)>>('NSStringFromSelector');
  late final _NSStringFromSelector = _NSStringFromSelectorPtr.asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCSelector>)>();

  ffi.Pointer<objc.ObjCSelector> NSSelectorFromString(
    objc.NSString aSelectorName,
  ) {
    return _NSSelectorFromString(
      aSelectorName.ref.pointer,
    );
  }

  late final _NSSelectorFromStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCSelector> Function(
              ffi.Pointer<objc.ObjCObject>)>>('NSSelectorFromString');
  late final _NSSelectorFromString = _NSSelectorFromStringPtr.asFunction<
      ffi.Pointer<objc.ObjCSelector> Function(ffi.Pointer<objc.ObjCObject>)>();

  objc.NSString NSStringFromClass(
    objc.ObjCObjectBase aClass,
  ) {
    return objc.NSString.castFromPointer(
        _NSStringFromClass(
          aClass.ref.pointer,
        ),
        retain: true,
        release: true);
  }

  late final _NSStringFromClassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCObject>)>>('NSStringFromClass');
  late final _NSStringFromClass = _NSStringFromClassPtr.asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)>();

  objc.ObjCObjectBase? NSClassFromString(
    objc.NSString aClassName,
  ) {
    return _NSClassFromString(
              aClassName.ref.pointer,
            ).address ==
            0
        ? null
        : objc.ObjCObjectBase(
            _NSClassFromString(
              aClassName.ref.pointer,
            ),
            retain: true,
            release: true);
  }

  late final _NSClassFromStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCObject>)>>('NSClassFromString');
  late final _NSClassFromString = _NSClassFromStringPtr.asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)>();

  objc.NSString NSStringFromProtocol(
    objc.Protocol proto,
  ) {
    return objc.NSString.castFromPointer(
        _NSStringFromProtocol(
          proto.ref.pointer,
        ),
        retain: true,
        release: true);
  }

  late final _NSStringFromProtocolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCObject>)>>('NSStringFromProtocol');
  late final _NSStringFromProtocol = _NSStringFromProtocolPtr.asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)>();

  objc.Protocol? NSProtocolFromString(
    objc.NSString namestr,
  ) {
    return _NSProtocolFromString(
              namestr.ref.pointer,
            ).address ==
            0
        ? null
        : objc.Protocol.castFromPointer(
            _NSProtocolFromString(
              namestr.ref.pointer,
            ),
            retain: true,
            release: true);
  }

  late final _NSProtocolFromStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCObject>)>>('NSProtocolFromString');
  late final _NSProtocolFromString = _NSProtocolFromStringPtr.asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)>();

  ffi.Pointer<ffi.Char> NSGetSizeAndAlignment(
    ffi.Pointer<ffi.Char> typePtr,
    ffi.Pointer<NSUInteger> sizep,
    ffi.Pointer<NSUInteger> alignp,
  ) {
    return _NSGetSizeAndAlignment(
      typePtr,
      sizep,
      alignp,
    );
  }

  late final _NSGetSizeAndAlignmentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<NSUInteger>,
              ffi.Pointer<NSUInteger>)>>('NSGetSizeAndAlignment');
  late final _NSGetSizeAndAlignment = _NSGetSizeAndAlignmentPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<NSUInteger>, ffi.Pointer<NSUInteger>)>();

  void NSLog(
    objc.NSString format,
  ) {
    return _NSLog(
      format.ref.pointer,
    );
  }

  late final _NSLogPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>>(
      'NSLog');
  late final _NSLog =
      _NSLogPtr.asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>();

  void NSLogv(
    objc.NSString format,
    va_list args,
  ) {
    return _NSLogv(
      format.ref.pointer,
      args,
    );
  }

  late final _NSLogvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>, va_list)>>('NSLogv');
  late final _NSLogv = _NSLogvPtr.asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, va_list)>();

  late final ffi.Pointer<NSInteger> _NSNotFound =
      _lookup<NSInteger>('NSNotFound');

  DartNSInteger get NSNotFound => _NSNotFound.value;

  ffi.Pointer<ffi.Void> _Block_copy(
    ffi.Pointer<ffi.Void> aBlock,
  ) {
    return __Block_copy(
      aBlock,
    );
  }

  late final __Block_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>)>>('_Block_copy');
  late final __Block_copy = __Block_copyPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  void _Block_release(
    ffi.Pointer<ffi.Void> aBlock,
  ) {
    return __Block_release(
      aBlock,
    );
  }

  late final __Block_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          '_Block_release');
  late final __Block_release =
      __Block_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void _Block_object_assign(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return __Block_object_assign(
      arg0,
      arg1,
      arg2,
    );
  }

  late final __Block_object_assignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Int)>>('_Block_object_assign');
  late final __Block_object_assign = __Block_object_assignPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void _Block_object_dispose(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    return __Block_object_dispose(
      arg0,
      arg1,
    );
  }

  late final __Block_object_disposePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int)>>(
      '_Block_object_dispose');
  late final __Block_object_dispose = __Block_object_disposePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Void>>>
      __NSConcreteGlobalBlock =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Void>>>('_NSConcreteGlobalBlock');

  ffi.Pointer<ffi.Pointer<ffi.Void>> get _NSConcreteGlobalBlock =>
      __NSConcreteGlobalBlock.value;

  set _NSConcreteGlobalBlock(ffi.Pointer<ffi.Pointer<ffi.Void>> value) =>
      __NSConcreteGlobalBlock.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Void>>>
      __NSConcreteStackBlock =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Void>>>('_NSConcreteStackBlock');

  ffi.Pointer<ffi.Pointer<ffi.Void>> get _NSConcreteStackBlock =>
      __NSConcreteStackBlock.value;

  set _NSConcreteStackBlock(ffi.Pointer<ffi.Pointer<ffi.Void>> value) =>
      __NSConcreteStackBlock.value = value;

  void Debugger() {
    return _Debugger();
  }

  late final _DebuggerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Debugger');
  late final _Debugger = _DebuggerPtr.asFunction<void Function()>();

  void DebugStr(
    ConstStr255Param debuggerMsg,
  ) {
    return _DebugStr(
      debuggerMsg,
    );
  }

  late final _DebugStrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ConstStr255Param)>>(
          'DebugStr');
  late final _DebugStr =
      _DebugStrPtr.asFunction<void Function(ConstStr255Param)>();

  void SysBreak() {
    return _SysBreak();
  }

  late final _SysBreakPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('SysBreak');
  late final _SysBreak = _SysBreakPtr.asFunction<void Function()>();

  void SysBreakStr(
    ConstStr255Param debuggerMsg,
  ) {
    return _SysBreakStr(
      debuggerMsg,
    );
  }

  late final _SysBreakStrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ConstStr255Param)>>(
          'SysBreakStr');
  late final _SysBreakStr =
      _SysBreakStrPtr.asFunction<void Function(ConstStr255Param)>();

  void SysBreakFunc(
    ConstStr255Param debuggerMsg,
  ) {
    return _SysBreakFunc(
      debuggerMsg,
    );
  }

  late final _SysBreakFuncPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ConstStr255Param)>>(
          'SysBreakFunc');
  late final _SysBreakFunc =
      _SysBreakFuncPtr.asFunction<void Function(ConstStr255Param)>();

  late final ffi.Pointer<ffi.Double> _kCFCoreFoundationVersionNumber =
      _lookup<ffi.Double>('kCFCoreFoundationVersionNumber');

  double get kCFCoreFoundationVersionNumber =>
      _kCFCoreFoundationVersionNumber.value;

  set kCFCoreFoundationVersionNumber(double value) =>
      _kCFCoreFoundationVersionNumber.value = value;

  late final ffi.Pointer<CFIndex> _kCFNotFound =
      _lookup<CFIndex>('kCFNotFound');

  DartCFIndex get kCFNotFound => _kCFNotFound.value;

  CFRange __CFRangeMake(
    int loc,
    int len,
  ) {
    return ___CFRangeMake(
      loc,
      len,
    );
  }

  late final ___CFRangeMakePtr =
      _lookup<ffi.NativeFunction<CFRange Function(CFIndex, CFIndex)>>(
          '__CFRangeMake');
  late final ___CFRangeMake =
      ___CFRangeMakePtr.asFunction<CFRange Function(int, int)>();

  int CFNullGetTypeID() {
    return _CFNullGetTypeID();
  }

  late final _CFNullGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFNullGetTypeID');
  late final _CFNullGetTypeID =
      _CFNullGetTypeIDPtr.asFunction<int Function()>();

  late final ffi.Pointer<CFNullRef> _kCFNull = _lookup<CFNullRef>('kCFNull');

  CFNullRef get kCFNull => _kCFNull.value;

  late final ffi.Pointer<CFAllocatorRef> _kCFAllocatorDefault =
      _lookup<CFAllocatorRef>('kCFAllocatorDefault');

  CFAllocatorRef get kCFAllocatorDefault => _kCFAllocatorDefault.value;

  late final ffi.Pointer<CFAllocatorRef> _kCFAllocatorSystemDefault =
      _lookup<CFAllocatorRef>('kCFAllocatorSystemDefault');

  CFAllocatorRef get kCFAllocatorSystemDefault =>
      _kCFAllocatorSystemDefault.value;

  late final ffi.Pointer<CFAllocatorRef> _kCFAllocatorMalloc =
      _lookup<CFAllocatorRef>('kCFAllocatorMalloc');

  CFAllocatorRef get kCFAllocatorMalloc => _kCFAllocatorMalloc.value;

  late final ffi.Pointer<CFAllocatorRef> _kCFAllocatorMallocZone =
      _lookup<CFAllocatorRef>('kCFAllocatorMallocZone');

  CFAllocatorRef get kCFAllocatorMallocZone => _kCFAllocatorMallocZone.value;

  late final ffi.Pointer<CFAllocatorRef> _kCFAllocatorNull =
      _lookup<CFAllocatorRef>('kCFAllocatorNull');

  CFAllocatorRef get kCFAllocatorNull => _kCFAllocatorNull.value;

  late final ffi.Pointer<CFAllocatorRef> _kCFAllocatorUseContext =
      _lookup<CFAllocatorRef>('kCFAllocatorUseContext');

  CFAllocatorRef get kCFAllocatorUseContext => _kCFAllocatorUseContext.value;

  int CFAllocatorGetTypeID() {
    return _CFAllocatorGetTypeID();
  }

  late final _CFAllocatorGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFAllocatorGetTypeID');
  late final _CFAllocatorGetTypeID =
      _CFAllocatorGetTypeIDPtr.asFunction<int Function()>();

  void CFAllocatorSetDefault(
    CFAllocatorRef allocator,
  ) {
    return _CFAllocatorSetDefault(
      allocator,
    );
  }

  late final _CFAllocatorSetDefaultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFAllocatorRef)>>(
          'CFAllocatorSetDefault');
  late final _CFAllocatorSetDefault =
      _CFAllocatorSetDefaultPtr.asFunction<void Function(CFAllocatorRef)>();

  CFAllocatorRef CFAllocatorGetDefault() {
    return _CFAllocatorGetDefault();
  }

  late final _CFAllocatorGetDefaultPtr =
      _lookup<ffi.NativeFunction<CFAllocatorRef Function()>>(
          'CFAllocatorGetDefault');
  late final _CFAllocatorGetDefault =
      _CFAllocatorGetDefaultPtr.asFunction<CFAllocatorRef Function()>();

  CFAllocatorRef CFAllocatorCreate(
    CFAllocatorRef allocator,
    ffi.Pointer<CFAllocatorContext> context,
  ) {
    return _CFAllocatorCreate(
      allocator,
      context,
    );
  }

  late final _CFAllocatorCreatePtr = _lookup<
      ffi.NativeFunction<
          CFAllocatorRef Function(CFAllocatorRef,
              ffi.Pointer<CFAllocatorContext>)>>('CFAllocatorCreate');
  late final _CFAllocatorCreate = _CFAllocatorCreatePtr.asFunction<
      CFAllocatorRef Function(
          CFAllocatorRef, ffi.Pointer<CFAllocatorContext>)>();

  ffi.Pointer<ffi.Void> CFAllocatorAllocateTyped(
    CFAllocatorRef allocator,
    int size,
    int descriptor,
    int hint,
  ) {
    return _CFAllocatorAllocateTyped(
      allocator,
      size,
      descriptor,
      hint,
    );
  }

  late final _CFAllocatorAllocateTypedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(CFAllocatorRef, CFIndex,
              CFAllocatorTypeID, CFOptionFlags)>>('CFAllocatorAllocateTyped');
  late final _CFAllocatorAllocateTyped =
      _CFAllocatorAllocateTypedPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(CFAllocatorRef, int, int, int)>();

  ffi.Pointer<ffi.Void> CFAllocatorReallocateTyped(
    CFAllocatorRef allocator,
    ffi.Pointer<ffi.Void> ptr,
    int newsize,
    int descriptor,
    int hint,
  ) {
    return _CFAllocatorReallocateTyped(
      allocator,
      ptr,
      newsize,
      descriptor,
      hint,
    );
  }

  late final _CFAllocatorReallocateTypedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              CFAllocatorRef,
              ffi.Pointer<ffi.Void>,
              CFIndex,
              CFAllocatorTypeID,
              CFOptionFlags)>>('CFAllocatorReallocateTyped');
  late final _CFAllocatorReallocateTyped =
      _CFAllocatorReallocateTypedPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              CFAllocatorRef, ffi.Pointer<ffi.Void>, int, int, int)>();

  ffi.Pointer<ffi.Void> CFAllocatorAllocateBytes(
    CFAllocatorRef allocator,
    int size,
    int hint,
  ) {
    return _CFAllocatorAllocateBytes(
      allocator,
      size,
      hint,
    );
  }

  late final _CFAllocatorAllocateBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(CFAllocatorRef, CFIndex,
              CFOptionFlags)>>('CFAllocatorAllocateBytes');
  late final _CFAllocatorAllocateBytes = _CFAllocatorAllocateBytesPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(CFAllocatorRef, int, int)>();

  ffi.Pointer<ffi.Void> CFAllocatorReallocateBytes(
    CFAllocatorRef allocator,
    ffi.Pointer<ffi.Void> ptr,
    int newsize,
    int hint,
  ) {
    return _CFAllocatorReallocateBytes(
      allocator,
      ptr,
      newsize,
      hint,
    );
  }

  late final _CFAllocatorReallocateBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(CFAllocatorRef, ffi.Pointer<ffi.Void>,
              CFIndex, CFOptionFlags)>>('CFAllocatorReallocateBytes');
  late final _CFAllocatorReallocateBytes =
      _CFAllocatorReallocateBytesPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              CFAllocatorRef, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> CFAllocatorAllocate(
    CFAllocatorRef allocator,
    int size,
    int hint,
  ) {
    return _CFAllocatorAllocate(
      allocator,
      size,
      hint,
    );
  }

  late final _CFAllocatorAllocatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              CFAllocatorRef, CFIndex, CFOptionFlags)>>('CFAllocatorAllocate');
  late final _CFAllocatorAllocate = _CFAllocatorAllocatePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(CFAllocatorRef, int, int)>();

  ffi.Pointer<ffi.Void> CFAllocatorReallocate(
    CFAllocatorRef allocator,
    ffi.Pointer<ffi.Void> ptr,
    int newsize,
    int hint,
  ) {
    return _CFAllocatorReallocate(
      allocator,
      ptr,
      newsize,
      hint,
    );
  }

  late final _CFAllocatorReallocatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(CFAllocatorRef, ffi.Pointer<ffi.Void>,
              CFIndex, CFOptionFlags)>>('CFAllocatorReallocate');
  late final _CFAllocatorReallocate = _CFAllocatorReallocatePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          CFAllocatorRef, ffi.Pointer<ffi.Void>, int, int)>();

  void CFAllocatorDeallocate(
    CFAllocatorRef allocator,
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _CFAllocatorDeallocate(
      allocator,
      ptr,
    );
  }

  late final _CFAllocatorDeallocatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFAllocatorRef, ffi.Pointer<ffi.Void>)>>('CFAllocatorDeallocate');
  late final _CFAllocatorDeallocate = _CFAllocatorDeallocatePtr.asFunction<
      void Function(CFAllocatorRef, ffi.Pointer<ffi.Void>)>();

  int CFAllocatorGetPreferredSizeForSize(
    CFAllocatorRef allocator,
    int size,
    int hint,
  ) {
    return _CFAllocatorGetPreferredSizeForSize(
      allocator,
      size,
      hint,
    );
  }

  late final _CFAllocatorGetPreferredSizeForSizePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFAllocatorRef, CFIndex,
              CFOptionFlags)>>('CFAllocatorGetPreferredSizeForSize');
  late final _CFAllocatorGetPreferredSizeForSize =
      _CFAllocatorGetPreferredSizeForSizePtr.asFunction<
          int Function(CFAllocatorRef, int, int)>();

  void CFAllocatorGetContext(
    CFAllocatorRef allocator,
    ffi.Pointer<CFAllocatorContext> context,
  ) {
    return _CFAllocatorGetContext(
      allocator,
      context,
    );
  }

  late final _CFAllocatorGetContextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFAllocatorRef,
              ffi.Pointer<CFAllocatorContext>)>>('CFAllocatorGetContext');
  late final _CFAllocatorGetContext = _CFAllocatorGetContextPtr.asFunction<
      void Function(CFAllocatorRef, ffi.Pointer<CFAllocatorContext>)>();

  int CFGetTypeID(
    CFTypeRef cf,
  ) {
    return _CFGetTypeID(
      cf,
    );
  }

  late final _CFGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function(CFTypeRef)>>('CFGetTypeID');
  late final _CFGetTypeID =
      _CFGetTypeIDPtr.asFunction<int Function(CFTypeRef)>();

  CFStringRef CFCopyTypeIDDescription(
    int type_id,
  ) {
    return _CFCopyTypeIDDescription(
      type_id,
    );
  }

  late final _CFCopyTypeIDDescriptionPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFTypeID)>>(
          'CFCopyTypeIDDescription');
  late final _CFCopyTypeIDDescription =
      _CFCopyTypeIDDescriptionPtr.asFunction<CFStringRef Function(int)>();

  CFTypeRef CFRetain(
    CFTypeRef cf,
  ) {
    return _CFRetain(
      cf,
    );
  }

  late final _CFRetainPtr =
      _lookup<ffi.NativeFunction<CFTypeRef Function(CFTypeRef)>>('CFRetain');
  late final _CFRetain =
      _CFRetainPtr.asFunction<CFTypeRef Function(CFTypeRef)>();

  void CFRelease(
    CFTypeRef cf,
  ) {
    return _CFRelease(
      cf,
    );
  }

  late final _CFReleasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFTypeRef)>>('CFRelease');
  late final _CFRelease = _CFReleasePtr.asFunction<void Function(CFTypeRef)>();

  CFTypeRef CFAutorelease(
    CFTypeRef arg,
  ) {
    return _CFAutorelease(
      arg,
    );
  }

  late final _CFAutoreleasePtr =
      _lookup<ffi.NativeFunction<CFTypeRef Function(CFTypeRef)>>(
          'CFAutorelease');
  late final _CFAutorelease =
      _CFAutoreleasePtr.asFunction<CFTypeRef Function(CFTypeRef)>();

  int CFGetRetainCount(
    CFTypeRef cf,
  ) {
    return _CFGetRetainCount(
      cf,
    );
  }

  late final _CFGetRetainCountPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFTypeRef)>>(
          'CFGetRetainCount');
  late final _CFGetRetainCount =
      _CFGetRetainCountPtr.asFunction<int Function(CFTypeRef)>();

  int CFEqual(
    CFTypeRef cf1,
    CFTypeRef cf2,
  ) {
    return _CFEqual(
      cf1,
      cf2,
    );
  }

  late final _CFEqualPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFTypeRef, CFTypeRef)>>(
          'CFEqual');
  late final _CFEqual =
      _CFEqualPtr.asFunction<int Function(CFTypeRef, CFTypeRef)>();

  int CFHash(
    CFTypeRef cf,
  ) {
    return _CFHash(
      cf,
    );
  }

  late final _CFHashPtr =
      _lookup<ffi.NativeFunction<CFHashCode Function(CFTypeRef)>>('CFHash');
  late final _CFHash = _CFHashPtr.asFunction<int Function(CFTypeRef)>();

  CFStringRef CFCopyDescription(
    CFTypeRef cf,
  ) {
    return _CFCopyDescription(
      cf,
    );
  }

  late final _CFCopyDescriptionPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFTypeRef)>>(
          'CFCopyDescription');
  late final _CFCopyDescription =
      _CFCopyDescriptionPtr.asFunction<CFStringRef Function(CFTypeRef)>();

  CFAllocatorRef CFGetAllocator(
    CFTypeRef cf,
  ) {
    return _CFGetAllocator(
      cf,
    );
  }

  late final _CFGetAllocatorPtr =
      _lookup<ffi.NativeFunction<CFAllocatorRef Function(CFTypeRef)>>(
          'CFGetAllocator');
  late final _CFGetAllocator =
      _CFGetAllocatorPtr.asFunction<CFAllocatorRef Function(CFTypeRef)>();

  CFTypeRef CFMakeCollectable(
    CFTypeRef cf,
  ) {
    return _CFMakeCollectable(
      cf,
    );
  }

  late final _CFMakeCollectablePtr =
      _lookup<ffi.NativeFunction<CFTypeRef Function(CFTypeRef)>>(
          'CFMakeCollectable');
  late final _CFMakeCollectable =
      _CFMakeCollectablePtr.asFunction<CFTypeRef Function(CFTypeRef)>();

  ffi.Pointer<NSZone> NSDefaultMallocZone() {
    return _NSDefaultMallocZone();
  }

  late final _NSDefaultMallocZonePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<NSZone> Function()>>(
          'NSDefaultMallocZone');
  late final _NSDefaultMallocZone =
      _NSDefaultMallocZonePtr.asFunction<ffi.Pointer<NSZone> Function()>();

  ffi.Pointer<NSZone> NSCreateZone(
    int startSize,
    int granularity,
    bool canFree,
  ) {
    return _NSCreateZone(
      startSize,
      granularity,
      canFree,
    );
  }

  late final _NSCreateZonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<NSZone> Function(
              NSUInteger, NSUInteger, ffi.Bool)>>('NSCreateZone');
  late final _NSCreateZone = _NSCreateZonePtr.asFunction<
      ffi.Pointer<NSZone> Function(int, int, bool)>();

  void NSRecycleZone(
    ffi.Pointer<NSZone> zone,
  ) {
    return _NSRecycleZone(
      zone,
    );
  }

  late final _NSRecycleZonePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<NSZone>)>>(
          'NSRecycleZone');
  late final _NSRecycleZone =
      _NSRecycleZonePtr.asFunction<void Function(ffi.Pointer<NSZone>)>();

  void NSSetZoneName(
    ffi.Pointer<NSZone> zone,
    objc.NSString name,
  ) {
    return _NSSetZoneName(
      zone,
      name.ref.pointer,
    );
  }

  late final _NSSetZoneNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<NSZone>,
              ffi.Pointer<objc.ObjCObject>)>>('NSSetZoneName');
  late final _NSSetZoneName = _NSSetZoneNamePtr.asFunction<
      void Function(ffi.Pointer<NSZone>, ffi.Pointer<objc.ObjCObject>)>();

  objc.NSString NSZoneName(
    ffi.Pointer<NSZone> zone,
  ) {
    return objc.NSString.castFromPointer(
        _NSZoneName(
          zone,
        ),
        retain: true,
        release: true);
  }

  late final _NSZoneNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<NSZone>)>>('NSZoneName');
  late final _NSZoneName = _NSZoneNamePtr.asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<NSZone>)>();

  ffi.Pointer<NSZone> NSZoneFromPointer(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _NSZoneFromPointer(
      ptr,
    );
  }

  late final _NSZoneFromPointerPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>>(
      'NSZoneFromPointer');
  late final _NSZoneFromPointer = _NSZoneFromPointerPtr.asFunction<
      ffi.Pointer<NSZone> Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> NSZoneMalloc(
    ffi.Pointer<NSZone> zone,
    int size,
  ) {
    return _NSZoneMalloc(
      zone,
      size,
    );
  }

  late final _NSZoneMallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<NSZone>, NSUInteger)>>('NSZoneMalloc');
  late final _NSZoneMalloc = _NSZoneMallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<NSZone>, int)>();

  ffi.Pointer<ffi.Void> NSZoneCalloc(
    ffi.Pointer<NSZone> zone,
    int numElems,
    int byteSize,
  ) {
    return _NSZoneCalloc(
      zone,
      numElems,
      byteSize,
    );
  }

  late final _NSZoneCallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<NSZone>, NSUInteger, NSUInteger)>>('NSZoneCalloc');
  late final _NSZoneCalloc = _NSZoneCallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<NSZone>, int, int)>();

  ffi.Pointer<ffi.Void> NSZoneRealloc(
    ffi.Pointer<NSZone> zone,
    ffi.Pointer<ffi.Void> ptr,
    int size,
  ) {
    return _NSZoneRealloc(
      zone,
      ptr,
      size,
    );
  }

  late final _NSZoneReallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<NSZone>,
              ffi.Pointer<ffi.Void>, NSUInteger)>>('NSZoneRealloc');
  late final _NSZoneRealloc = _NSZoneReallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<NSZone>, ffi.Pointer<ffi.Void>, int)>();

  void NSZoneFree(
    ffi.Pointer<NSZone> zone,
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _NSZoneFree(
      zone,
      ptr,
    );
  }

  late final _NSZoneFreePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<NSZone>, ffi.Pointer<ffi.Void>)>>('NSZoneFree');
  late final _NSZoneFree = _NSZoneFreePtr.asFunction<
      void Function(ffi.Pointer<NSZone>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> NSAllocateCollectable(
    int size,
    int options,
  ) {
    return _NSAllocateCollectable(
      size,
      options,
    );
  }

  late final _NSAllocateCollectablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              NSUInteger, NSUInteger)>>('NSAllocateCollectable');
  late final _NSAllocateCollectable = _NSAllocateCollectablePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> NSReallocateCollectable(
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int options,
  ) {
    return _NSReallocateCollectable(
      ptr,
      size,
      options,
    );
  }

  late final _NSReallocateCollectablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, NSUInteger,
              NSUInteger)>>('NSReallocateCollectable');
  late final _NSReallocateCollectable = _NSReallocateCollectablePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int NSPageSize() {
    return _NSPageSize();
  }

  late final _NSPageSizePtr =
      _lookup<ffi.NativeFunction<NSUInteger Function()>>('NSPageSize');
  late final _NSPageSize = _NSPageSizePtr.asFunction<int Function()>();

  int NSLogPageSize() {
    return _NSLogPageSize();
  }

  late final _NSLogPageSizePtr =
      _lookup<ffi.NativeFunction<NSUInteger Function()>>('NSLogPageSize');
  late final _NSLogPageSize = _NSLogPageSizePtr.asFunction<int Function()>();

  int NSRoundUpToMultipleOfPageSize(
    int bytes,
  ) {
    return _NSRoundUpToMultipleOfPageSize(
      bytes,
    );
  }

  late final _NSRoundUpToMultipleOfPageSizePtr =
      _lookup<ffi.NativeFunction<NSUInteger Function(NSUInteger)>>(
          'NSRoundUpToMultipleOfPageSize');
  late final _NSRoundUpToMultipleOfPageSize =
      _NSRoundUpToMultipleOfPageSizePtr.asFunction<int Function(int)>();

  int NSRoundDownToMultipleOfPageSize(
    int bytes,
  ) {
    return _NSRoundDownToMultipleOfPageSize(
      bytes,
    );
  }

  late final _NSRoundDownToMultipleOfPageSizePtr =
      _lookup<ffi.NativeFunction<NSUInteger Function(NSUInteger)>>(
          'NSRoundDownToMultipleOfPageSize');
  late final _NSRoundDownToMultipleOfPageSize =
      _NSRoundDownToMultipleOfPageSizePtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Void> NSAllocateMemoryPages(
    int bytes,
  ) {
    return _NSAllocateMemoryPages(
      bytes,
    );
  }

  late final _NSAllocateMemoryPagesPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(NSUInteger)>>(
          'NSAllocateMemoryPages');
  late final _NSAllocateMemoryPages = _NSAllocateMemoryPagesPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(int)>();

  void NSDeallocateMemoryPages(
    ffi.Pointer<ffi.Void> ptr,
    int bytes,
  ) {
    return _NSDeallocateMemoryPages(
      ptr,
      bytes,
    );
  }

  late final _NSDeallocateMemoryPagesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, NSUInteger)>>('NSDeallocateMemoryPages');
  late final _NSDeallocateMemoryPages = _NSDeallocateMemoryPagesPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int)>();

  void NSCopyMemoryPages(
    ffi.Pointer<ffi.Void> source,
    ffi.Pointer<ffi.Void> dest,
    int bytes,
  ) {
    return _NSCopyMemoryPages(
      source,
      dest,
      bytes,
    );
  }

  late final _NSCopyMemoryPagesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              NSUInteger)>>('NSCopyMemoryPages');
  late final _NSCopyMemoryPages = _NSCopyMemoryPagesPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int NSRealMemoryAvailable() {
    return _NSRealMemoryAvailable();
  }

  late final _NSRealMemoryAvailablePtr =
      _lookup<ffi.NativeFunction<NSUInteger Function()>>(
          'NSRealMemoryAvailable');
  late final _NSRealMemoryAvailable =
      _NSRealMemoryAvailablePtr.asFunction<int Function()>();

  objc.ObjCObjectBase NSAllocateObject(
    objc.ObjCObjectBase aClass,
    DartNSUInteger extraBytes,
    ffi.Pointer<NSZone> zone,
  ) {
    return objc.ObjCObjectBase(
        _NSAllocateObject(
          aClass.ref.pointer,
          extraBytes,
          zone,
        ),
        retain: true,
        release: true);
  }

  late final _NSAllocateObjectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
              NSUInteger, ffi.Pointer<NSZone>)>>('NSAllocateObject');
  late final _NSAllocateObject = _NSAllocateObjectPtr.asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>, int, ffi.Pointer<NSZone>)>();

  void NSDeallocateObject(
    objc.ObjCObjectBase object,
  ) {
    return _NSDeallocateObject(
      object.ref.pointer,
    );
  }

  late final _NSDeallocateObjectPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>>(
      'NSDeallocateObject');
  late final _NSDeallocateObject = _NSDeallocateObjectPtr.asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>)>();

  objc.ObjCObjectBase NSCopyObject(
    objc.ObjCObjectBase object,
    DartNSUInteger extraBytes,
    ffi.Pointer<NSZone> zone,
  ) {
    return objc.ObjCObjectBase(
        _NSCopyObject(
          object.ref.pointer,
          extraBytes,
          zone,
        ),
        retain: true,
        release: true);
  }

  late final _NSCopyObjectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
              NSUInteger, ffi.Pointer<NSZone>)>>('NSCopyObject');
  late final _NSCopyObject = _NSCopyObjectPtr.asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>, int, ffi.Pointer<NSZone>)>();

  bool NSShouldRetainWithZone(
    objc.ObjCObjectBase anObject,
    ffi.Pointer<NSZone> requestedZone,
  ) {
    return _NSShouldRetainWithZone(
      anObject.ref.pointer,
      requestedZone,
    );
  }

  late final _NSShouldRetainWithZonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<NSZone>)>>('NSShouldRetainWithZone');
  late final _NSShouldRetainWithZone = _NSShouldRetainWithZonePtr.asFunction<
      bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<NSZone>)>();

  void NSIncrementExtraRefCount(
    objc.ObjCObjectBase object,
  ) {
    return _NSIncrementExtraRefCount(
      object.ref.pointer,
    );
  }

  late final _NSIncrementExtraRefCountPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>>(
      'NSIncrementExtraRefCount');
  late final _NSIncrementExtraRefCount = _NSIncrementExtraRefCountPtr
      .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>();

  bool NSDecrementExtraRefCountWasZero(
    objc.ObjCObjectBase object,
  ) {
    return _NSDecrementExtraRefCountWasZero(
      object.ref.pointer,
    );
  }

  late final _NSDecrementExtraRefCountWasZeroPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>)>>(
      'NSDecrementExtraRefCountWasZero');
  late final _NSDecrementExtraRefCountWasZero =
      _NSDecrementExtraRefCountWasZeroPtr.asFunction<
          bool Function(ffi.Pointer<objc.ObjCObject>)>();

  DartNSUInteger NSExtraRefCount(
    objc.ObjCObjectBase object,
  ) {
    return _NSExtraRefCount(
      object.ref.pointer,
    );
  }

  late final _NSExtraRefCountPtr = _lookup<
          ffi
          .NativeFunction<NSUInteger Function(ffi.Pointer<objc.ObjCObject>)>>(
      'NSExtraRefCount');
  late final _NSExtraRefCount = _NSExtraRefCountPtr.asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>)>();

  late final ffi.Pointer<NSNotificationName>
      _NSSystemClockDidChangeNotification =
      _lookup<NSNotificationName>('NSSystemClockDidChangeNotification');

  DartNSNotificationName get NSSystemClockDidChangeNotification =>
      objc.NSString.castFromPointer(_NSSystemClockDidChangeNotification.value,
          retain: true, release: true);

  set NSSystemClockDidChangeNotification(DartNSNotificationName value) {
    objc.NSString.castFromPointer(_NSSystemClockDidChangeNotification.value,
            retain: false, release: true)
        .ref
        .release();
    _NSSystemClockDidChangeNotification.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSNotificationName>
      _NSHTTPCookieManagerAcceptPolicyChangedNotification =
      _lookup<NSNotificationName>(
          'NSHTTPCookieManagerAcceptPolicyChangedNotification');

  DartNSNotificationName
      get NSHTTPCookieManagerAcceptPolicyChangedNotification =>
          objc.NSString.castFromPointer(
              _NSHTTPCookieManagerAcceptPolicyChangedNotification.value,
              retain: true,
              release: true);

  set NSHTTPCookieManagerAcceptPolicyChangedNotification(
      DartNSNotificationName value) {
    objc.NSString.castFromPointer(
            _NSHTTPCookieManagerAcceptPolicyChangedNotification.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSHTTPCookieManagerAcceptPolicyChangedNotification.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSNotificationName>
      _NSHTTPCookieManagerCookiesChangedNotification =
      _lookup<NSNotificationName>(
          'NSHTTPCookieManagerCookiesChangedNotification');

  DartNSNotificationName get NSHTTPCookieManagerCookiesChangedNotification =>
      objc.NSString.castFromPointer(
          _NSHTTPCookieManagerCookiesChangedNotification.value,
          retain: true,
          release: true);

  set NSHTTPCookieManagerCookiesChangedNotification(
      DartNSNotificationName value) {
    objc.NSString.castFromPointer(
            _NSHTTPCookieManagerCookiesChangedNotification.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSHTTPCookieManagerCookiesChangedNotification.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressUserInfoKey>
      _NSProgressEstimatedTimeRemainingKey =
      _lookup<NSProgressUserInfoKey>('NSProgressEstimatedTimeRemainingKey');

  DartNSProgressUserInfoKey get NSProgressEstimatedTimeRemainingKey =>
      objc.NSString.castFromPointer(_NSProgressEstimatedTimeRemainingKey.value,
          retain: true, release: true);

  set NSProgressEstimatedTimeRemainingKey(DartNSProgressUserInfoKey value) {
    objc.NSString.castFromPointer(_NSProgressEstimatedTimeRemainingKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressEstimatedTimeRemainingKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressUserInfoKey> _NSProgressThroughputKey =
      _lookup<NSProgressUserInfoKey>('NSProgressThroughputKey');

  DartNSProgressUserInfoKey get NSProgressThroughputKey =>
      objc.NSString.castFromPointer(_NSProgressThroughputKey.value,
          retain: true, release: true);

  set NSProgressThroughputKey(DartNSProgressUserInfoKey value) {
    objc.NSString.castFromPointer(_NSProgressThroughputKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressThroughputKey.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressKind> _NSProgressKindFile =
      _lookup<NSProgressKind>('NSProgressKindFile');

  DartNSProgressKind get NSProgressKindFile =>
      objc.NSString.castFromPointer(_NSProgressKindFile.value,
          retain: true, release: true);

  set NSProgressKindFile(DartNSProgressKind value) {
    objc.NSString.castFromPointer(_NSProgressKindFile.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressKindFile.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressUserInfoKey>
      _NSProgressFileOperationKindKey =
      _lookup<NSProgressUserInfoKey>('NSProgressFileOperationKindKey');

  DartNSProgressUserInfoKey get NSProgressFileOperationKindKey =>
      objc.NSString.castFromPointer(_NSProgressFileOperationKindKey.value,
          retain: true, release: true);

  set NSProgressFileOperationKindKey(DartNSProgressUserInfoKey value) {
    objc.NSString.castFromPointer(_NSProgressFileOperationKindKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileOperationKindKey.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressFileOperationKind>
      _NSProgressFileOperationKindDownloading =
      _lookup<NSProgressFileOperationKind>(
          'NSProgressFileOperationKindDownloading');

  DartNSProgressFileOperationKind get NSProgressFileOperationKindDownloading =>
      objc.NSString.castFromPointer(
          _NSProgressFileOperationKindDownloading.value,
          retain: true,
          release: true);

  set NSProgressFileOperationKindDownloading(
      DartNSProgressFileOperationKind value) {
    objc.NSString.castFromPointer(_NSProgressFileOperationKindDownloading.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileOperationKindDownloading.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressFileOperationKind>
      _NSProgressFileOperationKindDecompressingAfterDownloading =
      _lookup<NSProgressFileOperationKind>(
          'NSProgressFileOperationKindDecompressingAfterDownloading');

  DartNSProgressFileOperationKind
      get NSProgressFileOperationKindDecompressingAfterDownloading =>
          objc.NSString.castFromPointer(
              _NSProgressFileOperationKindDecompressingAfterDownloading.value,
              retain: true,
              release: true);

  set NSProgressFileOperationKindDecompressingAfterDownloading(
      DartNSProgressFileOperationKind value) {
    objc.NSString.castFromPointer(
            _NSProgressFileOperationKindDecompressingAfterDownloading.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSProgressFileOperationKindDecompressingAfterDownloading.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressFileOperationKind>
      _NSProgressFileOperationKindReceiving =
      _lookup<NSProgressFileOperationKind>(
          'NSProgressFileOperationKindReceiving');

  DartNSProgressFileOperationKind get NSProgressFileOperationKindReceiving =>
      objc.NSString.castFromPointer(_NSProgressFileOperationKindReceiving.value,
          retain: true, release: true);

  set NSProgressFileOperationKindReceiving(
      DartNSProgressFileOperationKind value) {
    objc.NSString.castFromPointer(_NSProgressFileOperationKindReceiving.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileOperationKindReceiving.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressFileOperationKind>
      _NSProgressFileOperationKindCopying =
      _lookup<NSProgressFileOperationKind>(
          'NSProgressFileOperationKindCopying');

  DartNSProgressFileOperationKind get NSProgressFileOperationKindCopying =>
      objc.NSString.castFromPointer(_NSProgressFileOperationKindCopying.value,
          retain: true, release: true);

  set NSProgressFileOperationKindCopying(
      DartNSProgressFileOperationKind value) {
    objc.NSString.castFromPointer(_NSProgressFileOperationKindCopying.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileOperationKindCopying.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressFileOperationKind>
      _NSProgressFileOperationKindUploading =
      _lookup<NSProgressFileOperationKind>(
          'NSProgressFileOperationKindUploading');

  DartNSProgressFileOperationKind get NSProgressFileOperationKindUploading =>
      objc.NSString.castFromPointer(_NSProgressFileOperationKindUploading.value,
          retain: true, release: true);

  set NSProgressFileOperationKindUploading(
      DartNSProgressFileOperationKind value) {
    objc.NSString.castFromPointer(_NSProgressFileOperationKindUploading.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileOperationKindUploading.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressFileOperationKind>
      _NSProgressFileOperationKindDuplicating =
      _lookup<NSProgressFileOperationKind>(
          'NSProgressFileOperationKindDuplicating');

  DartNSProgressFileOperationKind get NSProgressFileOperationKindDuplicating =>
      objc.NSString.castFromPointer(
          _NSProgressFileOperationKindDuplicating.value,
          retain: true,
          release: true);

  set NSProgressFileOperationKindDuplicating(
      DartNSProgressFileOperationKind value) {
    objc.NSString.castFromPointer(_NSProgressFileOperationKindDuplicating.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileOperationKindDuplicating.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressUserInfoKey> _NSProgressFileURLKey =
      _lookup<NSProgressUserInfoKey>('NSProgressFileURLKey');

  DartNSProgressUserInfoKey get NSProgressFileURLKey =>
      objc.NSString.castFromPointer(_NSProgressFileURLKey.value,
          retain: true, release: true);

  set NSProgressFileURLKey(DartNSProgressUserInfoKey value) {
    objc.NSString.castFromPointer(_NSProgressFileURLKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileURLKey.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressUserInfoKey> _NSProgressFileTotalCountKey =
      _lookup<NSProgressUserInfoKey>('NSProgressFileTotalCountKey');

  DartNSProgressUserInfoKey get NSProgressFileTotalCountKey =>
      objc.NSString.castFromPointer(_NSProgressFileTotalCountKey.value,
          retain: true, release: true);

  set NSProgressFileTotalCountKey(DartNSProgressUserInfoKey value) {
    objc.NSString.castFromPointer(_NSProgressFileTotalCountKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileTotalCountKey.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressUserInfoKey>
      _NSProgressFileCompletedCountKey =
      _lookup<NSProgressUserInfoKey>('NSProgressFileCompletedCountKey');

  DartNSProgressUserInfoKey get NSProgressFileCompletedCountKey =>
      objc.NSString.castFromPointer(_NSProgressFileCompletedCountKey.value,
          retain: true, release: true);

  set NSProgressFileCompletedCountKey(DartNSProgressUserInfoKey value) {
    objc.NSString.castFromPointer(_NSProgressFileCompletedCountKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileCompletedCountKey.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressUserInfoKey>
      _NSProgressFileAnimationImageKey =
      _lookup<NSProgressUserInfoKey>('NSProgressFileAnimationImageKey');

  DartNSProgressUserInfoKey get NSProgressFileAnimationImageKey =>
      objc.NSString.castFromPointer(_NSProgressFileAnimationImageKey.value,
          retain: true, release: true);

  set NSProgressFileAnimationImageKey(DartNSProgressUserInfoKey value) {
    objc.NSString.castFromPointer(_NSProgressFileAnimationImageKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileAnimationImageKey.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressUserInfoKey>
      _NSProgressFileAnimationImageOriginalRectKey =
      _lookup<NSProgressUserInfoKey>(
          'NSProgressFileAnimationImageOriginalRectKey');

  DartNSProgressUserInfoKey get NSProgressFileAnimationImageOriginalRectKey =>
      objc.NSString.castFromPointer(
          _NSProgressFileAnimationImageOriginalRectKey.value,
          retain: true,
          release: true);

  set NSProgressFileAnimationImageOriginalRectKey(
      DartNSProgressUserInfoKey value) {
    objc.NSString.castFromPointer(
            _NSProgressFileAnimationImageOriginalRectKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSProgressFileAnimationImageOriginalRectKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSProgressUserInfoKey> _NSProgressFileIconKey =
      _lookup<NSProgressUserInfoKey>('NSProgressFileIconKey');

  DartNSProgressUserInfoKey get NSProgressFileIconKey =>
      objc.NSString.castFromPointer(_NSProgressFileIconKey.value,
          retain: true, release: true);

  set NSProgressFileIconKey(DartNSProgressUserInfoKey value) {
    objc.NSString.castFromPointer(_NSProgressFileIconKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSProgressFileIconKey.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<CFArrayCallBacks> _kCFTypeArrayCallBacks =
      _lookup<CFArrayCallBacks>('kCFTypeArrayCallBacks');

  CFArrayCallBacks get kCFTypeArrayCallBacks => _kCFTypeArrayCallBacks.ref;

  int CFArrayGetTypeID() {
    return _CFArrayGetTypeID();
  }

  late final _CFArrayGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFArrayGetTypeID');
  late final _CFArrayGetTypeID =
      _CFArrayGetTypeIDPtr.asFunction<int Function()>();

  CFArrayRef CFArrayCreate(
    CFAllocatorRef allocator,
    ffi.Pointer<ffi.Pointer<ffi.Void>> values,
    int numValues,
    ffi.Pointer<CFArrayCallBacks> callBacks,
  ) {
    return _CFArrayCreate(
      allocator,
      values,
      numValues,
      callBacks,
    );
  }

  late final _CFArrayCreatePtr = _lookup<
      ffi.NativeFunction<
          CFArrayRef Function(
              CFAllocatorRef,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              CFIndex,
              ffi.Pointer<CFArrayCallBacks>)>>('CFArrayCreate');
  late final _CFArrayCreate = _CFArrayCreatePtr.asFunction<
      CFArrayRef Function(CFAllocatorRef, ffi.Pointer<ffi.Pointer<ffi.Void>>,
          int, ffi.Pointer<CFArrayCallBacks>)>();

  CFArrayRef CFArrayCreateCopy(
    CFAllocatorRef allocator,
    CFArrayRef theArray,
  ) {
    return _CFArrayCreateCopy(
      allocator,
      theArray,
    );
  }

  late final _CFArrayCreateCopyPtr = _lookup<
          ffi.NativeFunction<CFArrayRef Function(CFAllocatorRef, CFArrayRef)>>(
      'CFArrayCreateCopy');
  late final _CFArrayCreateCopy = _CFArrayCreateCopyPtr.asFunction<
      CFArrayRef Function(CFAllocatorRef, CFArrayRef)>();

  CFMutableArrayRef CFArrayCreateMutable(
    CFAllocatorRef allocator,
    int capacity,
    ffi.Pointer<CFArrayCallBacks> callBacks,
  ) {
    return _CFArrayCreateMutable(
      allocator,
      capacity,
      callBacks,
    );
  }

  late final _CFArrayCreateMutablePtr = _lookup<
      ffi.NativeFunction<
          CFMutableArrayRef Function(CFAllocatorRef, CFIndex,
              ffi.Pointer<CFArrayCallBacks>)>>('CFArrayCreateMutable');
  late final _CFArrayCreateMutable = _CFArrayCreateMutablePtr.asFunction<
      CFMutableArrayRef Function(
          CFAllocatorRef, int, ffi.Pointer<CFArrayCallBacks>)>();

  CFMutableArrayRef CFArrayCreateMutableCopy(
    CFAllocatorRef allocator,
    int capacity,
    CFArrayRef theArray,
  ) {
    return _CFArrayCreateMutableCopy(
      allocator,
      capacity,
      theArray,
    );
  }

  late final _CFArrayCreateMutableCopyPtr = _lookup<
      ffi.NativeFunction<
          CFMutableArrayRef Function(CFAllocatorRef, CFIndex,
              CFArrayRef)>>('CFArrayCreateMutableCopy');
  late final _CFArrayCreateMutableCopy =
      _CFArrayCreateMutableCopyPtr.asFunction<
          CFMutableArrayRef Function(CFAllocatorRef, int, CFArrayRef)>();

  int CFArrayGetCount(
    CFArrayRef theArray,
  ) {
    return _CFArrayGetCount(
      theArray,
    );
  }

  late final _CFArrayGetCountPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFArrayRef)>>(
          'CFArrayGetCount');
  late final _CFArrayGetCount =
      _CFArrayGetCountPtr.asFunction<int Function(CFArrayRef)>();

  int CFArrayGetCountOfValue(
    CFArrayRef theArray,
    CFRange range,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFArrayGetCountOfValue(
      theArray,
      range,
      value,
    );
  }

  late final _CFArrayGetCountOfValuePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFArrayRef, CFRange,
              ffi.Pointer<ffi.Void>)>>('CFArrayGetCountOfValue');
  late final _CFArrayGetCountOfValue = _CFArrayGetCountOfValuePtr.asFunction<
      int Function(CFArrayRef, CFRange, ffi.Pointer<ffi.Void>)>();

  int CFArrayContainsValue(
    CFArrayRef theArray,
    CFRange range,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFArrayContainsValue(
      theArray,
      range,
      value,
    );
  }

  late final _CFArrayContainsValuePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFArrayRef, CFRange,
              ffi.Pointer<ffi.Void>)>>('CFArrayContainsValue');
  late final _CFArrayContainsValue = _CFArrayContainsValuePtr.asFunction<
      int Function(CFArrayRef, CFRange, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> CFArrayGetValueAtIndex(
    CFArrayRef theArray,
    int idx,
  ) {
    return _CFArrayGetValueAtIndex(
      theArray,
      idx,
    );
  }

  late final _CFArrayGetValueAtIndexPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ffi.Void> Function(CFArrayRef, CFIndex)>>(
      'CFArrayGetValueAtIndex');
  late final _CFArrayGetValueAtIndex = _CFArrayGetValueAtIndexPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(CFArrayRef, int)>();

  void CFArrayGetValues(
    CFArrayRef theArray,
    CFRange range,
    ffi.Pointer<ffi.Pointer<ffi.Void>> values,
  ) {
    return _CFArrayGetValues(
      theArray,
      range,
      values,
    );
  }

  late final _CFArrayGetValuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFArrayRef, CFRange,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('CFArrayGetValues');
  late final _CFArrayGetValues = _CFArrayGetValuesPtr.asFunction<
      void Function(CFArrayRef, CFRange, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  void CFArrayApplyFunction(
    CFArrayRef theArray,
    CFRange range,
    CFArrayApplierFunction applier,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CFArrayApplyFunction(
      theArray,
      range,
      applier,
      context,
    );
  }

  late final _CFArrayApplyFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFArrayRef, CFRange, CFArrayApplierFunction,
              ffi.Pointer<ffi.Void>)>>('CFArrayApplyFunction');
  late final _CFArrayApplyFunction = _CFArrayApplyFunctionPtr.asFunction<
      void Function(CFArrayRef, CFRange, CFArrayApplierFunction,
          ffi.Pointer<ffi.Void>)>();

  int CFArrayGetFirstIndexOfValue(
    CFArrayRef theArray,
    CFRange range,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFArrayGetFirstIndexOfValue(
      theArray,
      range,
      value,
    );
  }

  late final _CFArrayGetFirstIndexOfValuePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFArrayRef, CFRange,
              ffi.Pointer<ffi.Void>)>>('CFArrayGetFirstIndexOfValue');
  late final _CFArrayGetFirstIndexOfValue = _CFArrayGetFirstIndexOfValuePtr
      .asFunction<int Function(CFArrayRef, CFRange, ffi.Pointer<ffi.Void>)>();

  int CFArrayGetLastIndexOfValue(
    CFArrayRef theArray,
    CFRange range,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFArrayGetLastIndexOfValue(
      theArray,
      range,
      value,
    );
  }

  late final _CFArrayGetLastIndexOfValuePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFArrayRef, CFRange,
              ffi.Pointer<ffi.Void>)>>('CFArrayGetLastIndexOfValue');
  late final _CFArrayGetLastIndexOfValue = _CFArrayGetLastIndexOfValuePtr
      .asFunction<int Function(CFArrayRef, CFRange, ffi.Pointer<ffi.Void>)>();

  int CFArrayBSearchValues(
    CFArrayRef theArray,
    CFRange range,
    ffi.Pointer<ffi.Void> value,
    CFComparatorFunction comparator,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CFArrayBSearchValues(
      theArray,
      range,
      value,
      comparator,
      context,
    );
  }

  late final _CFArrayBSearchValuesPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(
              CFArrayRef,
              CFRange,
              ffi.Pointer<ffi.Void>,
              CFComparatorFunction,
              ffi.Pointer<ffi.Void>)>>('CFArrayBSearchValues');
  late final _CFArrayBSearchValues = _CFArrayBSearchValuesPtr.asFunction<
      int Function(CFArrayRef, CFRange, ffi.Pointer<ffi.Void>,
          CFComparatorFunction, ffi.Pointer<ffi.Void>)>();

  void CFArrayAppendValue(
    CFMutableArrayRef theArray,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFArrayAppendValue(
      theArray,
      value,
    );
  }

  late final _CFArrayAppendValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableArrayRef, ffi.Pointer<ffi.Void>)>>('CFArrayAppendValue');
  late final _CFArrayAppendValue = _CFArrayAppendValuePtr.asFunction<
      void Function(CFMutableArrayRef, ffi.Pointer<ffi.Void>)>();

  void CFArrayInsertValueAtIndex(
    CFMutableArrayRef theArray,
    int idx,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFArrayInsertValueAtIndex(
      theArray,
      idx,
      value,
    );
  }

  late final _CFArrayInsertValueAtIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableArrayRef, CFIndex,
              ffi.Pointer<ffi.Void>)>>('CFArrayInsertValueAtIndex');
  late final _CFArrayInsertValueAtIndex =
      _CFArrayInsertValueAtIndexPtr.asFunction<
          void Function(CFMutableArrayRef, int, ffi.Pointer<ffi.Void>)>();

  void CFArraySetValueAtIndex(
    CFMutableArrayRef theArray,
    int idx,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFArraySetValueAtIndex(
      theArray,
      idx,
      value,
    );
  }

  late final _CFArraySetValueAtIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableArrayRef, CFIndex,
              ffi.Pointer<ffi.Void>)>>('CFArraySetValueAtIndex');
  late final _CFArraySetValueAtIndex = _CFArraySetValueAtIndexPtr.asFunction<
      void Function(CFMutableArrayRef, int, ffi.Pointer<ffi.Void>)>();

  void CFArrayRemoveValueAtIndex(
    CFMutableArrayRef theArray,
    int idx,
  ) {
    return _CFArrayRemoveValueAtIndex(
      theArray,
      idx,
    );
  }

  late final _CFArrayRemoveValueAtIndexPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFMutableArrayRef, CFIndex)>>(
      'CFArrayRemoveValueAtIndex');
  late final _CFArrayRemoveValueAtIndex = _CFArrayRemoveValueAtIndexPtr
      .asFunction<void Function(CFMutableArrayRef, int)>();

  void CFArrayRemoveAllValues(
    CFMutableArrayRef theArray,
  ) {
    return _CFArrayRemoveAllValues(
      theArray,
    );
  }

  late final _CFArrayRemoveAllValuesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMutableArrayRef)>>(
          'CFArrayRemoveAllValues');
  late final _CFArrayRemoveAllValues =
      _CFArrayRemoveAllValuesPtr.asFunction<void Function(CFMutableArrayRef)>();

  void CFArrayReplaceValues(
    CFMutableArrayRef theArray,
    CFRange range,
    ffi.Pointer<ffi.Pointer<ffi.Void>> newValues,
    int newCount,
  ) {
    return _CFArrayReplaceValues(
      theArray,
      range,
      newValues,
      newCount,
    );
  }

  late final _CFArrayReplaceValuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableArrayRef,
              CFRange,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              CFIndex)>>('CFArrayReplaceValues');
  late final _CFArrayReplaceValues = _CFArrayReplaceValuesPtr.asFunction<
      void Function(CFMutableArrayRef, CFRange,
          ffi.Pointer<ffi.Pointer<ffi.Void>>, int)>();

  void CFArrayExchangeValuesAtIndices(
    CFMutableArrayRef theArray,
    int idx1,
    int idx2,
  ) {
    return _CFArrayExchangeValuesAtIndices(
      theArray,
      idx1,
      idx2,
    );
  }

  late final _CFArrayExchangeValuesAtIndicesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableArrayRef, CFIndex,
              CFIndex)>>('CFArrayExchangeValuesAtIndices');
  late final _CFArrayExchangeValuesAtIndices =
      _CFArrayExchangeValuesAtIndicesPtr.asFunction<
          void Function(CFMutableArrayRef, int, int)>();

  void CFArraySortValues(
    CFMutableArrayRef theArray,
    CFRange range,
    CFComparatorFunction comparator,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CFArraySortValues(
      theArray,
      range,
      comparator,
      context,
    );
  }

  late final _CFArraySortValuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableArrayRef, CFRange, CFComparatorFunction,
              ffi.Pointer<ffi.Void>)>>('CFArraySortValues');
  late final _CFArraySortValues = _CFArraySortValuesPtr.asFunction<
      void Function(CFMutableArrayRef, CFRange, CFComparatorFunction,
          ffi.Pointer<ffi.Void>)>();

  void CFArrayAppendArray(
    CFMutableArrayRef theArray,
    CFArrayRef otherArray,
    CFRange otherRange,
  ) {
    return _CFArrayAppendArray(
      theArray,
      otherArray,
      otherRange,
    );
  }

  late final _CFArrayAppendArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableArrayRef, CFArrayRef, CFRange)>>('CFArrayAppendArray');
  late final _CFArrayAppendArray = _CFArrayAppendArrayPtr.asFunction<
      void Function(CFMutableArrayRef, CFArrayRef, CFRange)>();

  ffi.Pointer<ffi.Void> os_retain(
    ffi.Pointer<ffi.Void> object,
  ) {
    return _os_retain(
      object,
    );
  }

  late final _os_retainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('os_retain');
  late final _os_retain = _os_retainPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  void os_release(
    ffi.Pointer<ffi.Void> object,
  ) {
    return _os_release(
      object,
    );
  }

  late final _os_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'os_release');
  late final _os_release =
      _os_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> sec_retain(
    ffi.Pointer<ffi.Void> obj,
  ) {
    return _sec_retain(
      obj,
    );
  }

  late final _sec_retainPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('sec_retain');
  late final _sec_retain = _sec_retainPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  void sec_release(
    ffi.Pointer<ffi.Void> obj,
  ) {
    return _sec_release(
      obj,
    );
  }

  late final _sec_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'sec_release');
  late final _sec_release =
      _sec_releasePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  CFStringRef SecCopyErrorMessageString(
    int status,
    ffi.Pointer<ffi.Void> reserved,
  ) {
    return _SecCopyErrorMessageString(
      status,
      reserved,
    );
  }

  late final _SecCopyErrorMessageStringPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(
              OSStatus, ffi.Pointer<ffi.Void>)>>('SecCopyErrorMessageString');
  late final _SecCopyErrorMessageString = _SecCopyErrorMessageStringPtr
      .asFunction<CFStringRef Function(int, ffi.Pointer<ffi.Void>)>();

  void __assert_rtn(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return ___assert_rtn(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final ___assert_rtnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<ffi.Char>)>>('__assert_rtn');
  late final ___assert_rtn = ___assert_rtnPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Char>)>();

  late final ffi.Pointer<_RuneLocale> __DefaultRuneLocale =
      _lookup<_RuneLocale>('_DefaultRuneLocale');

  _RuneLocale get _DefaultRuneLocale => __DefaultRuneLocale.ref;

  late final ffi.Pointer<ffi.Pointer<_RuneLocale>> __CurrentRuneLocale =
      _lookup<ffi.Pointer<_RuneLocale>>('_CurrentRuneLocale');

  ffi.Pointer<_RuneLocale> get _CurrentRuneLocale => __CurrentRuneLocale.value;

  set _CurrentRuneLocale(ffi.Pointer<_RuneLocale> value) =>
      __CurrentRuneLocale.value = value;

  int ___runetype(
    int arg0,
  ) {
    return ____runetype(
      arg0,
    );
  }

  late final ____runetypePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(__darwin_ct_rune_t)>>(
      '___runetype');
  late final ____runetype = ____runetypePtr.asFunction<int Function(int)>();

  int ___tolower(
    int arg0,
  ) {
    return ____tolower(
      arg0,
    );
  }

  late final ____tolowerPtr = _lookup<
          ffi.NativeFunction<__darwin_ct_rune_t Function(__darwin_ct_rune_t)>>(
      '___tolower');
  late final ____tolower = ____tolowerPtr.asFunction<int Function(int)>();

  int ___toupper(
    int arg0,
  ) {
    return ____toupper(
      arg0,
    );
  }

  late final ____toupperPtr = _lookup<
          ffi.NativeFunction<__darwin_ct_rune_t Function(__darwin_ct_rune_t)>>(
      '___toupper');
  late final ____toupper = ____toupperPtr.asFunction<int Function(int)>();

  int __maskrune(
    int arg0,
    int arg1,
  ) {
    return ___maskrune(
      arg0,
      arg1,
    );
  }

  late final ___maskrunePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              __darwin_ct_rune_t, ffi.UnsignedLong)>>('__maskrune');
  late final ___maskrune = ___maskrunePtr.asFunction<int Function(int, int)>();

  int __toupper(
    int arg0,
  ) {
    return ___toupper1(
      arg0,
    );
  }

  late final ___toupperPtr = _lookup<
          ffi.NativeFunction<__darwin_ct_rune_t Function(__darwin_ct_rune_t)>>(
      '__toupper');
  late final ___toupper1 = ___toupperPtr.asFunction<int Function(int)>();

  int __tolower(
    int arg0,
  ) {
    return ___tolower1(
      arg0,
    );
  }

  late final ___tolowerPtr = _lookup<
          ffi.NativeFunction<__darwin_ct_rune_t Function(__darwin_ct_rune_t)>>(
      '__tolower');
  late final ___tolower1 = ___tolowerPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Int> __error() {
    return ___error();
  }

  late final ___errorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function()>>('__error');
  late final ___error =
      ___errorPtr.asFunction<ffi.Pointer<ffi.Int> Function()>();

  ffi.Pointer<lconv> localeconv() {
    return _localeconv();
  }

  late final _localeconvPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<lconv> Function()>>('localeconv');
  late final _localeconv =
      _localeconvPtr.asFunction<ffi.Pointer<lconv> Function()>();

  ffi.Pointer<ffi.Char> setlocale(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _setlocale(
      arg0,
      arg1,
    );
  }

  late final _setlocalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('setlocale');
  late final _setlocale = _setlocalePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>)>();

  int __math_errhandling() {
    return ___math_errhandling();
  }

  late final ___math_errhandlingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('__math_errhandling');
  late final ___math_errhandling =
      ___math_errhandlingPtr.asFunction<int Function()>();

  int __fpclassifyf(
    double arg0,
  ) {
    return ___fpclassifyf(
      arg0,
    );
  }

  late final ___fpclassifyfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('__fpclassifyf');
  late final ___fpclassifyf =
      ___fpclassifyfPtr.asFunction<int Function(double)>();

  int __fpclassifyd(
    double arg0,
  ) {
    return ___fpclassifyd(
      arg0,
    );
  }

  late final ___fpclassifydPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Double)>>(
          '__fpclassifyd');
  late final ___fpclassifyd =
      ___fpclassifydPtr.asFunction<int Function(double)>();

  double acosf(
    double arg0,
  ) {
    return _acosf(
      arg0,
    );
  }

  late final _acosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('acosf');
  late final _acosf = _acosfPtr.asFunction<double Function(double)>();

  double acos(
    double arg0,
  ) {
    return _acos(
      arg0,
    );
  }

  late final _acosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('acos');
  late final _acos = _acosPtr.asFunction<double Function(double)>();

  double asinf(
    double arg0,
  ) {
    return _asinf(
      arg0,
    );
  }

  late final _asinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('asinf');
  late final _asinf = _asinfPtr.asFunction<double Function(double)>();

  double asin(
    double arg0,
  ) {
    return _asin(
      arg0,
    );
  }

  late final _asinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('asin');
  late final _asin = _asinPtr.asFunction<double Function(double)>();

  double atanf(
    double arg0,
  ) {
    return _atanf(
      arg0,
    );
  }

  late final _atanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('atanf');
  late final _atanf = _atanfPtr.asFunction<double Function(double)>();

  double atan(
    double arg0,
  ) {
    return _atan(
      arg0,
    );
  }

  late final _atanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('atan');
  late final _atan = _atanPtr.asFunction<double Function(double)>();

  double atan2f(
    double arg0,
    double arg1,
  ) {
    return _atan2f(
      arg0,
      arg1,
    );
  }

  late final _atan2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'atan2f');
  late final _atan2f = _atan2fPtr.asFunction<double Function(double, double)>();

  double atan2(
    double arg0,
    double arg1,
  ) {
    return _atan2(
      arg0,
      arg1,
    );
  }

  late final _atan2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'atan2');
  late final _atan2 = _atan2Ptr.asFunction<double Function(double, double)>();

  double cosf(
    double arg0,
  ) {
    return _cosf(
      arg0,
    );
  }

  late final _cosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('cosf');
  late final _cosf = _cosfPtr.asFunction<double Function(double)>();

  double cos(
    double arg0,
  ) {
    return _cos(
      arg0,
    );
  }

  late final _cosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cos');
  late final _cos = _cosPtr.asFunction<double Function(double)>();

  double sinf(
    double arg0,
  ) {
    return _sinf(
      arg0,
    );
  }

  late final _sinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sinf');
  late final _sinf = _sinfPtr.asFunction<double Function(double)>();

  double sin(
    double arg0,
  ) {
    return _sin(
      arg0,
    );
  }

  late final _sinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sin');
  late final _sin = _sinPtr.asFunction<double Function(double)>();

  double tanf(
    double arg0,
  ) {
    return _tanf(
      arg0,
    );
  }

  late final _tanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tanf');
  late final _tanf = _tanfPtr.asFunction<double Function(double)>();

  double tan(
    double arg0,
  ) {
    return _tan(
      arg0,
    );
  }

  late final _tanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tan');
  late final _tan = _tanPtr.asFunction<double Function(double)>();

  double acoshf(
    double arg0,
  ) {
    return _acoshf(
      arg0,
    );
  }

  late final _acoshfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('acoshf');
  late final _acoshf = _acoshfPtr.asFunction<double Function(double)>();

  double acosh(
    double arg0,
  ) {
    return _acosh(
      arg0,
    );
  }

  late final _acoshPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('acosh');
  late final _acosh = _acoshPtr.asFunction<double Function(double)>();

  double asinhf(
    double arg0,
  ) {
    return _asinhf(
      arg0,
    );
  }

  late final _asinhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('asinhf');
  late final _asinhf = _asinhfPtr.asFunction<double Function(double)>();

  double asinh(
    double arg0,
  ) {
    return _asinh(
      arg0,
    );
  }

  late final _asinhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('asinh');
  late final _asinh = _asinhPtr.asFunction<double Function(double)>();

  double atanhf(
    double arg0,
  ) {
    return _atanhf(
      arg0,
    );
  }

  late final _atanhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('atanhf');
  late final _atanhf = _atanhfPtr.asFunction<double Function(double)>();

  double atanh(
    double arg0,
  ) {
    return _atanh(
      arg0,
    );
  }

  late final _atanhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('atanh');
  late final _atanh = _atanhPtr.asFunction<double Function(double)>();

  double coshf(
    double arg0,
  ) {
    return _coshf(
      arg0,
    );
  }

  late final _coshfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('coshf');
  late final _coshf = _coshfPtr.asFunction<double Function(double)>();

  double cosh(
    double arg0,
  ) {
    return _cosh(
      arg0,
    );
  }

  late final _coshPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cosh');
  late final _cosh = _coshPtr.asFunction<double Function(double)>();

  double sinhf(
    double arg0,
  ) {
    return _sinhf(
      arg0,
    );
  }

  late final _sinhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sinhf');
  late final _sinhf = _sinhfPtr.asFunction<double Function(double)>();

  double sinh(
    double arg0,
  ) {
    return _sinh(
      arg0,
    );
  }

  late final _sinhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sinh');
  late final _sinh = _sinhPtr.asFunction<double Function(double)>();

  double tanhf(
    double arg0,
  ) {
    return _tanhf(
      arg0,
    );
  }

  late final _tanhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tanhf');
  late final _tanhf = _tanhfPtr.asFunction<double Function(double)>();

  double tanh(
    double arg0,
  ) {
    return _tanh(
      arg0,
    );
  }

  late final _tanhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tanh');
  late final _tanh = _tanhPtr.asFunction<double Function(double)>();

  double expf(
    double arg0,
  ) {
    return _expf(
      arg0,
    );
  }

  late final _expfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('expf');
  late final _expf = _expfPtr.asFunction<double Function(double)>();

  double exp(
    double arg0,
  ) {
    return _exp(
      arg0,
    );
  }

  late final _expPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('exp');
  late final _exp = _expPtr.asFunction<double Function(double)>();

  double exp2f(
    double arg0,
  ) {
    return _exp2f(
      arg0,
    );
  }

  late final _exp2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('exp2f');
  late final _exp2f = _exp2fPtr.asFunction<double Function(double)>();

  double exp2(
    double arg0,
  ) {
    return _exp2(
      arg0,
    );
  }

  late final _exp2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('exp2');
  late final _exp2 = _exp2Ptr.asFunction<double Function(double)>();

  double expm1f(
    double arg0,
  ) {
    return _expm1f(
      arg0,
    );
  }

  late final _expm1fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('expm1f');
  late final _expm1f = _expm1fPtr.asFunction<double Function(double)>();

  double expm1(
    double arg0,
  ) {
    return _expm1(
      arg0,
    );
  }

  late final _expm1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('expm1');
  late final _expm1 = _expm1Ptr.asFunction<double Function(double)>();

  double logf(
    double arg0,
  ) {
    return _logf(
      arg0,
    );
  }

  late final _logfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('logf');
  late final _logf = _logfPtr.asFunction<double Function(double)>();

  double log(
    double arg0,
  ) {
    return _log(
      arg0,
    );
  }

  late final _logPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log');
  late final _log = _logPtr.asFunction<double Function(double)>();

  double log10f(
    double arg0,
  ) {
    return _log10f(
      arg0,
    );
  }

  late final _log10fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log10f');
  late final _log10f = _log10fPtr.asFunction<double Function(double)>();

  double log10(
    double arg0,
  ) {
    return _log10(
      arg0,
    );
  }

  late final _log10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log10');
  late final _log10 = _log10Ptr.asFunction<double Function(double)>();

  double log2f(
    double arg0,
  ) {
    return _log2f(
      arg0,
    );
  }

  late final _log2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log2f');
  late final _log2f = _log2fPtr.asFunction<double Function(double)>();

  double log2(
    double arg0,
  ) {
    return _log2(
      arg0,
    );
  }

  late final _log2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log2');
  late final _log2 = _log2Ptr.asFunction<double Function(double)>();

  double log1pf(
    double arg0,
  ) {
    return _log1pf(
      arg0,
    );
  }

  late final _log1pfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log1pf');
  late final _log1pf = _log1pfPtr.asFunction<double Function(double)>();

  double log1p(
    double arg0,
  ) {
    return _log1p(
      arg0,
    );
  }

  late final _log1pPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log1p');
  late final _log1p = _log1pPtr.asFunction<double Function(double)>();

  double logbf(
    double arg0,
  ) {
    return _logbf(
      arg0,
    );
  }

  late final _logbfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('logbf');
  late final _logbf = _logbfPtr.asFunction<double Function(double)>();

  double logb(
    double arg0,
  ) {
    return _logb(
      arg0,
    );
  }

  late final _logbPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('logb');
  late final _logb = _logbPtr.asFunction<double Function(double)>();

  double modff(
    double arg0,
    ffi.Pointer<ffi.Float> arg1,
  ) {
    return _modff(
      arg0,
      arg1,
    );
  }

  late final _modffPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Pointer<ffi.Float>)>>('modff');
  late final _modff =
      _modffPtr.asFunction<double Function(double, ffi.Pointer<ffi.Float>)>();

  double modf(
    double arg0,
    ffi.Pointer<ffi.Double> arg1,
  ) {
    return _modf(
      arg0,
      arg1,
    );
  }

  late final _modfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Pointer<ffi.Double>)>>('modf');
  late final _modf =
      _modfPtr.asFunction<double Function(double, ffi.Pointer<ffi.Double>)>();

  double ldexpf(
    double arg0,
    int arg1,
  ) {
    return _ldexpf(
      arg0,
      arg1,
    );
  }

  late final _ldexpfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'ldexpf');
  late final _ldexpf = _ldexpfPtr.asFunction<double Function(double, int)>();

  double ldexp(
    double arg0,
    int arg1,
  ) {
    return _ldexp(
      arg0,
      arg1,
    );
  }

  late final _ldexpPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'ldexp');
  late final _ldexp = _ldexpPtr.asFunction<double Function(double, int)>();

  double frexpf(
    double arg0,
    ffi.Pointer<ffi.Int> arg1,
  ) {
    return _frexpf(
      arg0,
      arg1,
    );
  }

  late final _frexpfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Pointer<ffi.Int>)>>('frexpf');
  late final _frexpf =
      _frexpfPtr.asFunction<double Function(double, ffi.Pointer<ffi.Int>)>();

  double frexp(
    double arg0,
    ffi.Pointer<ffi.Int> arg1,
  ) {
    return _frexp(
      arg0,
      arg1,
    );
  }

  late final _frexpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Pointer<ffi.Int>)>>('frexp');
  late final _frexp =
      _frexpPtr.asFunction<double Function(double, ffi.Pointer<ffi.Int>)>();

  int ilogbf(
    double arg0,
  ) {
    return _ilogbf(
      arg0,
    );
  }

  late final _ilogbfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('ilogbf');
  late final _ilogbf = _ilogbfPtr.asFunction<int Function(double)>();

  int ilogb(
    double arg0,
  ) {
    return _ilogb(
      arg0,
    );
  }

  late final _ilogbPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Double)>>('ilogb');
  late final _ilogb = _ilogbPtr.asFunction<int Function(double)>();

  double scalbnf(
    double arg0,
    int arg1,
  ) {
    return _scalbnf(
      arg0,
      arg1,
    );
  }

  late final _scalbnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'scalbnf');
  late final _scalbnf = _scalbnfPtr.asFunction<double Function(double, int)>();

  double scalbn(
    double arg0,
    int arg1,
  ) {
    return _scalbn(
      arg0,
      arg1,
    );
  }

  late final _scalbnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'scalbn');
  late final _scalbn = _scalbnPtr.asFunction<double Function(double, int)>();

  double scalblnf(
    double arg0,
    int arg1,
  ) {
    return _scalblnf(
      arg0,
      arg1,
    );
  }

  late final _scalblnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Long)>>(
          'scalblnf');
  late final _scalblnf =
      _scalblnfPtr.asFunction<double Function(double, int)>();

  double scalbln(
    double arg0,
    int arg1,
  ) {
    return _scalbln(
      arg0,
      arg1,
    );
  }

  late final _scalblnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Long)>>(
          'scalbln');
  late final _scalbln = _scalblnPtr.asFunction<double Function(double, int)>();

  double fabsf(
    double arg0,
  ) {
    return _fabsf(
      arg0,
    );
  }

  late final _fabsfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('fabsf');
  late final _fabsf = _fabsfPtr.asFunction<double Function(double)>();

  double fabs(
    double arg0,
  ) {
    return _fabs(
      arg0,
    );
  }

  late final _fabsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('fabs');
  late final _fabs = _fabsPtr.asFunction<double Function(double)>();

  double cbrtf(
    double arg0,
  ) {
    return _cbrtf(
      arg0,
    );
  }

  late final _cbrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('cbrtf');
  late final _cbrtf = _cbrtfPtr.asFunction<double Function(double)>();

  double cbrt(
    double arg0,
  ) {
    return _cbrt(
      arg0,
    );
  }

  late final _cbrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cbrt');
  late final _cbrt = _cbrtPtr.asFunction<double Function(double)>();

  double hypotf(
    double arg0,
    double arg1,
  ) {
    return _hypotf(
      arg0,
      arg1,
    );
  }

  late final _hypotfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'hypotf');
  late final _hypotf = _hypotfPtr.asFunction<double Function(double, double)>();

  double hypot(
    double arg0,
    double arg1,
  ) {
    return _hypot(
      arg0,
      arg1,
    );
  }

  late final _hypotPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'hypot');
  late final _hypot = _hypotPtr.asFunction<double Function(double, double)>();

  double powf(
    double arg0,
    double arg1,
  ) {
    return _powf(
      arg0,
      arg1,
    );
  }

  late final _powfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'powf');
  late final _powf = _powfPtr.asFunction<double Function(double, double)>();

  double pow(
    double arg0,
    double arg1,
  ) {
    return _pow(
      arg0,
      arg1,
    );
  }

  late final _powPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'pow');
  late final _pow = _powPtr.asFunction<double Function(double, double)>();

  double sqrtf(
    double arg0,
  ) {
    return _sqrtf(
      arg0,
    );
  }

  late final _sqrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sqrtf');
  late final _sqrtf = _sqrtfPtr.asFunction<double Function(double)>();

  double sqrt(
    double arg0,
  ) {
    return _sqrt(
      arg0,
    );
  }

  late final _sqrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sqrt');
  late final _sqrt = _sqrtPtr.asFunction<double Function(double)>();

  double erff(
    double arg0,
  ) {
    return _erff(
      arg0,
    );
  }

  late final _erffPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('erff');
  late final _erff = _erffPtr.asFunction<double Function(double)>();

  double erf(
    double arg0,
  ) {
    return _erf(
      arg0,
    );
  }

  late final _erfPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('erf');
  late final _erf = _erfPtr.asFunction<double Function(double)>();

  double erfcf(
    double arg0,
  ) {
    return _erfcf(
      arg0,
    );
  }

  late final _erfcfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('erfcf');
  late final _erfcf = _erfcfPtr.asFunction<double Function(double)>();

  double erfc(
    double arg0,
  ) {
    return _erfc(
      arg0,
    );
  }

  late final _erfcPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('erfc');
  late final _erfc = _erfcPtr.asFunction<double Function(double)>();

  double lgammaf(
    double arg0,
  ) {
    return _lgammaf(
      arg0,
    );
  }

  late final _lgammafPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('lgammaf');
  late final _lgammaf = _lgammafPtr.asFunction<double Function(double)>();

  double lgamma(
    double arg0,
  ) {
    return _lgamma(
      arg0,
    );
  }

  late final _lgammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('lgamma');
  late final _lgamma = _lgammaPtr.asFunction<double Function(double)>();

  double tgammaf(
    double arg0,
  ) {
    return _tgammaf(
      arg0,
    );
  }

  late final _tgammafPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tgammaf');
  late final _tgammaf = _tgammafPtr.asFunction<double Function(double)>();

  double tgamma(
    double arg0,
  ) {
    return _tgamma(
      arg0,
    );
  }

  late final _tgammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tgamma');
  late final _tgamma = _tgammaPtr.asFunction<double Function(double)>();

  double ceilf(
    double arg0,
  ) {
    return _ceilf(
      arg0,
    );
  }

  late final _ceilfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('ceilf');
  late final _ceilf = _ceilfPtr.asFunction<double Function(double)>();

  double ceil(
    double arg0,
  ) {
    return _ceil(
      arg0,
    );
  }

  late final _ceilPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('ceil');
  late final _ceil = _ceilPtr.asFunction<double Function(double)>();

  double floorf(
    double arg0,
  ) {
    return _floorf(
      arg0,
    );
  }

  late final _floorfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('floorf');
  late final _floorf = _floorfPtr.asFunction<double Function(double)>();

  double floor(
    double arg0,
  ) {
    return _floor(
      arg0,
    );
  }

  late final _floorPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('floor');
  late final _floor = _floorPtr.asFunction<double Function(double)>();

  double nearbyintf(
    double arg0,
  ) {
    return _nearbyintf(
      arg0,
    );
  }

  late final _nearbyintfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('nearbyintf');
  late final _nearbyintf = _nearbyintfPtr.asFunction<double Function(double)>();

  double nearbyint(
    double arg0,
  ) {
    return _nearbyint(
      arg0,
    );
  }

  late final _nearbyintPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('nearbyint');
  late final _nearbyint = _nearbyintPtr.asFunction<double Function(double)>();

  double rintf(
    double arg0,
  ) {
    return _rintf(
      arg0,
    );
  }

  late final _rintfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('rintf');
  late final _rintf = _rintfPtr.asFunction<double Function(double)>();

  double rint(
    double arg0,
  ) {
    return _rint(
      arg0,
    );
  }

  late final _rintPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('rint');
  late final _rint = _rintPtr.asFunction<double Function(double)>();

  int lrintf(
    double arg0,
  ) {
    return _lrintf(
      arg0,
    );
  }

  late final _lrintfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('lrintf');
  late final _lrintf = _lrintfPtr.asFunction<int Function(double)>();

  int lrint(
    double arg0,
  ) {
    return _lrint(
      arg0,
    );
  }

  late final _lrintPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('lrint');
  late final _lrint = _lrintPtr.asFunction<int Function(double)>();

  double roundf(
    double arg0,
  ) {
    return _roundf(
      arg0,
    );
  }

  late final _roundfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('roundf');
  late final _roundf = _roundfPtr.asFunction<double Function(double)>();

  double round(
    double arg0,
  ) {
    return _round(
      arg0,
    );
  }

  late final _roundPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('round');
  late final _round = _roundPtr.asFunction<double Function(double)>();

  int lroundf(
    double arg0,
  ) {
    return _lroundf(
      arg0,
    );
  }

  late final _lroundfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('lroundf');
  late final _lroundf = _lroundfPtr.asFunction<int Function(double)>();

  int lround(
    double arg0,
  ) {
    return _lround(
      arg0,
    );
  }

  late final _lroundPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('lround');
  late final _lround = _lroundPtr.asFunction<int Function(double)>();

  int llrintf(
    double arg0,
  ) {
    return _llrintf(
      arg0,
    );
  }

  late final _llrintfPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Float)>>('llrintf');
  late final _llrintf = _llrintfPtr.asFunction<int Function(double)>();

  int llrint(
    double arg0,
  ) {
    return _llrint(
      arg0,
    );
  }

  late final _llrintPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Double)>>('llrint');
  late final _llrint = _llrintPtr.asFunction<int Function(double)>();

  int llroundf(
    double arg0,
  ) {
    return _llroundf(
      arg0,
    );
  }

  late final _llroundfPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Float)>>('llroundf');
  late final _llroundf = _llroundfPtr.asFunction<int Function(double)>();

  int llround(
    double arg0,
  ) {
    return _llround(
      arg0,
    );
  }

  late final _llroundPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Double)>>('llround');
  late final _llround = _llroundPtr.asFunction<int Function(double)>();

  double truncf(
    double arg0,
  ) {
    return _truncf(
      arg0,
    );
  }

  late final _truncfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('truncf');
  late final _truncf = _truncfPtr.asFunction<double Function(double)>();

  double trunc(
    double arg0,
  ) {
    return _trunc(
      arg0,
    );
  }

  late final _truncPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('trunc');
  late final _trunc = _truncPtr.asFunction<double Function(double)>();

  double fmodf(
    double arg0,
    double arg1,
  ) {
    return _fmodf(
      arg0,
      arg1,
    );
  }

  late final _fmodfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fmodf');
  late final _fmodf = _fmodfPtr.asFunction<double Function(double, double)>();

  double fmod(
    double arg0,
    double arg1,
  ) {
    return _fmod(
      arg0,
      arg1,
    );
  }

  late final _fmodPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmod');
  late final _fmod = _fmodPtr.asFunction<double Function(double, double)>();

  double remainderf(
    double arg0,
    double arg1,
  ) {
    return _remainderf(
      arg0,
      arg1,
    );
  }

  late final _remainderfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'remainderf');
  late final _remainderf =
      _remainderfPtr.asFunction<double Function(double, double)>();

  double remainder(
    double arg0,
    double arg1,
  ) {
    return _remainder(
      arg0,
      arg1,
    );
  }

  late final _remainderPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'remainder');
  late final _remainder =
      _remainderPtr.asFunction<double Function(double, double)>();

  double remquof(
    double arg0,
    double arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return _remquof(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _remquofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Float, ffi.Float, ffi.Pointer<ffi.Int>)>>('remquof');
  late final _remquof = _remquofPtr
      .asFunction<double Function(double, double, ffi.Pointer<ffi.Int>)>();

  double remquo(
    double arg0,
    double arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return _remquo(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _remquoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Double, ffi.Double, ffi.Pointer<ffi.Int>)>>('remquo');
  late final _remquo = _remquoPtr
      .asFunction<double Function(double, double, ffi.Pointer<ffi.Int>)>();

  double copysignf(
    double arg0,
    double arg1,
  ) {
    return _copysignf(
      arg0,
      arg1,
    );
  }

  late final _copysignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'copysignf');
  late final _copysignf =
      _copysignfPtr.asFunction<double Function(double, double)>();

  double copysign(
    double arg0,
    double arg1,
  ) {
    return _copysign(
      arg0,
      arg1,
    );
  }

  late final _copysignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'copysign');
  late final _copysign =
      _copysignPtr.asFunction<double Function(double, double)>();

  double nanf(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _nanf(
      arg0,
    );
  }

  late final _nanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Char>)>>(
          'nanf');
  late final _nanf =
      _nanfPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  double nan(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _nan(
      arg0,
    );
  }

  late final _nanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'nan');
  late final _nan =
      _nanPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  double nextafterf(
    double arg0,
    double arg1,
  ) {
    return _nextafterf(
      arg0,
      arg1,
    );
  }

  late final _nextafterfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'nextafterf');
  late final _nextafterf =
      _nextafterfPtr.asFunction<double Function(double, double)>();

  double nextafter(
    double arg0,
    double arg1,
  ) {
    return _nextafter(
      arg0,
      arg1,
    );
  }

  late final _nextafterPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'nextafter');
  late final _nextafter =
      _nextafterPtr.asFunction<double Function(double, double)>();

  double fdimf(
    double arg0,
    double arg1,
  ) {
    return _fdimf(
      arg0,
      arg1,
    );
  }

  late final _fdimfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fdimf');
  late final _fdimf = _fdimfPtr.asFunction<double Function(double, double)>();

  double fdim(
    double arg0,
    double arg1,
  ) {
    return _fdim(
      arg0,
      arg1,
    );
  }

  late final _fdimPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fdim');
  late final _fdim = _fdimPtr.asFunction<double Function(double, double)>();

  double fmaxf(
    double arg0,
    double arg1,
  ) {
    return _fmaxf(
      arg0,
      arg1,
    );
  }

  late final _fmaxfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fmaxf');
  late final _fmaxf = _fmaxfPtr.asFunction<double Function(double, double)>();

  double fmax(
    double arg0,
    double arg1,
  ) {
    return _fmax(
      arg0,
      arg1,
    );
  }

  late final _fmaxPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmax');
  late final _fmax = _fmaxPtr.asFunction<double Function(double, double)>();

  double fminf(
    double arg0,
    double arg1,
  ) {
    return _fminf(
      arg0,
      arg1,
    );
  }

  late final _fminfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fminf');
  late final _fminf = _fminfPtr.asFunction<double Function(double, double)>();

  double fmin(
    double arg0,
    double arg1,
  ) {
    return _fmin(
      arg0,
      arg1,
    );
  }

  late final _fminPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmin');
  late final _fmin = _fminPtr.asFunction<double Function(double, double)>();

  double fmaf(
    double arg0,
    double arg1,
    double arg2,
  ) {
    return _fmaf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fmafPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Float, ffi.Float)>>('fmaf');
  late final _fmaf =
      _fmafPtr.asFunction<double Function(double, double, double)>();

  double fma(
    double arg0,
    double arg1,
    double arg2,
  ) {
    return _fma(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fmaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Double, ffi.Double)>>('fma');
  late final _fma =
      _fmaPtr.asFunction<double Function(double, double, double)>();

  double __exp10f(
    double arg0,
  ) {
    return ___exp10f(
      arg0,
    );
  }

  late final ___exp10fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__exp10f');
  late final ___exp10f = ___exp10fPtr.asFunction<double Function(double)>();

  double __exp10(
    double arg0,
  ) {
    return ___exp10(
      arg0,
    );
  }

  late final ___exp10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__exp10');
  late final ___exp10 = ___exp10Ptr.asFunction<double Function(double)>();

  double __cospif(
    double arg0,
  ) {
    return ___cospif(
      arg0,
    );
  }

  late final ___cospifPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__cospif');
  late final ___cospif = ___cospifPtr.asFunction<double Function(double)>();

  double __cospi(
    double arg0,
  ) {
    return ___cospi(
      arg0,
    );
  }

  late final ___cospiPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__cospi');
  late final ___cospi = ___cospiPtr.asFunction<double Function(double)>();

  double __sinpif(
    double arg0,
  ) {
    return ___sinpif(
      arg0,
    );
  }

  late final ___sinpifPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__sinpif');
  late final ___sinpif = ___sinpifPtr.asFunction<double Function(double)>();

  double __sinpi(
    double arg0,
  ) {
    return ___sinpi(
      arg0,
    );
  }

  late final ___sinpiPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__sinpi');
  late final ___sinpi = ___sinpiPtr.asFunction<double Function(double)>();

  double __tanpif(
    double arg0,
  ) {
    return ___tanpif(
      arg0,
    );
  }

  late final ___tanpifPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__tanpif');
  late final ___tanpif = ___tanpifPtr.asFunction<double Function(double)>();

  double __tanpi(
    double arg0,
  ) {
    return ___tanpi(
      arg0,
    );
  }

  late final ___tanpiPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__tanpi');
  late final ___tanpi = ___tanpiPtr.asFunction<double Function(double)>();

  __float2 __sincosf_stret(
    double arg0,
  ) {
    return ___sincosf_stret(
      arg0,
    );
  }

  late final ___sincosf_stretPtr =
      _lookup<ffi.NativeFunction<__float2 Function(ffi.Float)>>(
          '__sincosf_stret');
  late final ___sincosf_stret =
      ___sincosf_stretPtr.asFunction<__float2 Function(double)>();

  __double2 __sincos_stret(
    double arg0,
  ) {
    return ___sincos_stret(
      arg0,
    );
  }

  late final ___sincos_stretPtr =
      _lookup<ffi.NativeFunction<__double2 Function(ffi.Double)>>(
          '__sincos_stret');
  late final ___sincos_stret =
      ___sincos_stretPtr.asFunction<__double2 Function(double)>();

  __float2 __sincospif_stret(
    double arg0,
  ) {
    return ___sincospif_stret(
      arg0,
    );
  }

  late final ___sincospif_stretPtr =
      _lookup<ffi.NativeFunction<__float2 Function(ffi.Float)>>(
          '__sincospif_stret');
  late final ___sincospif_stret =
      ___sincospif_stretPtr.asFunction<__float2 Function(double)>();

  __double2 __sincospi_stret(
    double arg0,
  ) {
    return ___sincospi_stret(
      arg0,
    );
  }

  late final ___sincospi_stretPtr =
      _lookup<ffi.NativeFunction<__double2 Function(ffi.Double)>>(
          '__sincospi_stret');
  late final ___sincospi_stret =
      ___sincospi_stretPtr.asFunction<__double2 Function(double)>();

  double j0(
    double arg0,
  ) {
    return _j0(
      arg0,
    );
  }

  late final _j0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('j0');
  late final _j0 = _j0Ptr.asFunction<double Function(double)>();

  double j1(
    double arg0,
  ) {
    return _j1(
      arg0,
    );
  }

  late final _j1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('j1');
  late final _j1 = _j1Ptr.asFunction<double Function(double)>();

  double jn(
    int arg0,
    double arg1,
  ) {
    return _jn(
      arg0,
      arg1,
    );
  }

  late final _jnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Double)>>(
          'jn');
  late final _jn = _jnPtr.asFunction<double Function(int, double)>();

  double y0(
    double arg0,
  ) {
    return _y0(
      arg0,
    );
  }

  late final _y0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('y0');
  late final _y0 = _y0Ptr.asFunction<double Function(double)>();

  double y1(
    double arg0,
  ) {
    return _y1(
      arg0,
    );
  }

  late final _y1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('y1');
  late final _y1 = _y1Ptr.asFunction<double Function(double)>();

  double yn(
    int arg0,
    double arg1,
  ) {
    return _yn(
      arg0,
      arg1,
    );
  }

  late final _ynPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Double)>>(
          'yn');
  late final _yn = _ynPtr.asFunction<double Function(int, double)>();

  double scalb(
    double arg0,
    double arg1,
  ) {
    return _scalb(
      arg0,
      arg1,
    );
  }

  late final _scalbPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'scalb');
  late final _scalb = _scalbPtr.asFunction<double Function(double, double)>();

  late final ffi.Pointer<ffi.Int> _signgam = _lookup<ffi.Int>('signgam');

  int get signgam => _signgam.value;

  set signgam(int value) => _signgam.value = value;

  int setjmp(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _setjmp1(
      arg0,
    );
  }

  late final _setjmpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>)>>(
          'setjmp');
  late final _setjmp1 =
      _setjmpPtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  void longjmp(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
  ) {
    return _longjmp1(
      arg0,
      arg1,
    );
  }

  late final _longjmpPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int>, ffi.Int)>>(
      'longjmp');
  late final _longjmp1 =
      _longjmpPtr.asFunction<void Function(ffi.Pointer<ffi.Int>, int)>();

  int _setjmp(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return __setjmp(
      arg0,
    );
  }

  late final __setjmpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>)>>(
          '_setjmp');
  late final __setjmp =
      __setjmpPtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  void _longjmp(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
  ) {
    return __longjmp(
      arg0,
      arg1,
    );
  }

  late final __longjmpPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int>, ffi.Int)>>(
      '_longjmp');
  late final __longjmp =
      __longjmpPtr.asFunction<void Function(ffi.Pointer<ffi.Int>, int)>();

  int sigsetjmp(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
  ) {
    return _sigsetjmp(
      arg0,
      arg1,
    );
  }

  late final _sigsetjmpPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Int)>>(
      'sigsetjmp');
  late final _sigsetjmp =
      _sigsetjmpPtr.asFunction<int Function(ffi.Pointer<ffi.Int>, int)>();

  void siglongjmp(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
  ) {
    return _siglongjmp(
      arg0,
      arg1,
    );
  }

  late final _siglongjmpPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int>, ffi.Int)>>(
      'siglongjmp');
  late final _siglongjmp =
      _siglongjmpPtr.asFunction<void Function(ffi.Pointer<ffi.Int>, int)>();

  void longjmperror() {
    return _longjmperror();
  }

  late final _longjmperrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('longjmperror');
  late final _longjmperror = _longjmperrorPtr.asFunction<void Function()>();

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _sys_signame =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('sys_signame');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get sys_signame => _sys_signame.value;

  set sys_signame(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      _sys_signame.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _sys_siglist =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('sys_siglist');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get sys_siglist => _sys_siglist.value;

  set sys_siglist(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      _sys_siglist.value = value;

  int raise(
    int arg0,
  ) {
    return _raise(
      arg0,
    );
  }

  late final _raisePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('raise');
  late final _raise = _raisePtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> bsd_signal(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _bsd_signal(
      arg0,
      arg1,
    );
  }

  late final _bsd_signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
              ffi.Int,
              ffi.Pointer<
                  ffi
                  .NativeFunction<ffi.Void Function(ffi.Int)>>)>>('bsd_signal');
  late final _bsd_signal = _bsd_signalPtr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
          int, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>();

  int kill(
    int arg0,
    int arg1,
  ) {
    return _kill(
      arg0,
      arg1,
    );
  }

  late final _killPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(pid_t, ffi.Int)>>('kill');
  late final _kill = _killPtr.asFunction<int Function(int, int)>();

  int killpg(
    int arg0,
    int arg1,
  ) {
    return _killpg(
      arg0,
      arg1,
    );
  }

  late final _killpgPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(pid_t, ffi.Int)>>('killpg');
  late final _killpg = _killpgPtr.asFunction<int Function(int, int)>();

  int pthread_kill(
    pthread_t arg0,
    int arg1,
  ) {
    return _pthread_kill(
      arg0,
      arg1,
    );
  }

  late final _pthread_killPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(pthread_t, ffi.Int)>>(
          'pthread_kill');
  late final _pthread_kill =
      _pthread_killPtr.asFunction<int Function(pthread_t, int)>();

  int pthread_sigmask(
    int arg0,
    ffi.Pointer<sigset_t> arg1,
    ffi.Pointer<sigset_t> arg2,
  ) {
    return _pthread_sigmask(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _pthread_sigmaskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<sigset_t>,
              ffi.Pointer<sigset_t>)>>('pthread_sigmask');
  late final _pthread_sigmask = _pthread_sigmaskPtr.asFunction<
      int Function(int, ffi.Pointer<sigset_t>, ffi.Pointer<sigset_t>)>();

  int sigaction1(
    int arg0,
    ffi.Pointer<sigaction> arg1,
    ffi.Pointer<sigaction> arg2,
  ) {
    return _sigaction1(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _sigaction1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<sigaction>,
              ffi.Pointer<sigaction>)>>('sigaction');
  late final _sigaction1 = _sigaction1Ptr.asFunction<
      int Function(int, ffi.Pointer<sigaction>, ffi.Pointer<sigaction>)>();

  int sigaddset(
    ffi.Pointer<sigset_t> arg0,
    int arg1,
  ) {
    return _sigaddset(
      arg0,
      arg1,
    );
  }

  late final _sigaddsetPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>, ffi.Int)>>(
      'sigaddset');
  late final _sigaddset =
      _sigaddsetPtr.asFunction<int Function(ffi.Pointer<sigset_t>, int)>();

  int sigaltstack(
    ffi.Pointer<stack_t> arg0,
    ffi.Pointer<stack_t> arg1,
  ) {
    return _sigaltstack(
      arg0,
      arg1,
    );
  }

  late final _sigaltstackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<stack_t>, ffi.Pointer<stack_t>)>>('sigaltstack');
  late final _sigaltstack = _sigaltstackPtr
      .asFunction<int Function(ffi.Pointer<stack_t>, ffi.Pointer<stack_t>)>();

  int sigdelset(
    ffi.Pointer<sigset_t> arg0,
    int arg1,
  ) {
    return _sigdelset(
      arg0,
      arg1,
    );
  }

  late final _sigdelsetPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>, ffi.Int)>>(
      'sigdelset');
  late final _sigdelset =
      _sigdelsetPtr.asFunction<int Function(ffi.Pointer<sigset_t>, int)>();

  int sigemptyset(
    ffi.Pointer<sigset_t> arg0,
  ) {
    return _sigemptyset(
      arg0,
    );
  }

  late final _sigemptysetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>)>>(
          'sigemptyset');
  late final _sigemptyset =
      _sigemptysetPtr.asFunction<int Function(ffi.Pointer<sigset_t>)>();

  int sigfillset(
    ffi.Pointer<sigset_t> arg0,
  ) {
    return _sigfillset(
      arg0,
    );
  }

  late final _sigfillsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>)>>(
          'sigfillset');
  late final _sigfillset =
      _sigfillsetPtr.asFunction<int Function(ffi.Pointer<sigset_t>)>();

  int sighold(
    int arg0,
  ) {
    return _sighold(
      arg0,
    );
  }

  late final _sigholdPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('sighold');
  late final _sighold = _sigholdPtr.asFunction<int Function(int)>();

  int sigignore(
    int arg0,
  ) {
    return _sigignore(
      arg0,
    );
  }

  late final _sigignorePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('sigignore');
  late final _sigignore = _sigignorePtr.asFunction<int Function(int)>();

  int siginterrupt(
    int arg0,
    int arg1,
  ) {
    return _siginterrupt(
      arg0,
      arg1,
    );
  }

  late final _siginterruptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'siginterrupt');
  late final _siginterrupt =
      _siginterruptPtr.asFunction<int Function(int, int)>();

  int sigismember(
    ffi.Pointer<sigset_t> arg0,
    int arg1,
  ) {
    return _sigismember(
      arg0,
      arg1,
    );
  }

  late final _sigismemberPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>, ffi.Int)>>(
      'sigismember');
  late final _sigismember =
      _sigismemberPtr.asFunction<int Function(ffi.Pointer<sigset_t>, int)>();

  int sigpause(
    int arg0,
  ) {
    return _sigpause(
      arg0,
    );
  }

  late final _sigpausePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('sigpause');
  late final _sigpause = _sigpausePtr.asFunction<int Function(int)>();

  int sigpending(
    ffi.Pointer<sigset_t> arg0,
  ) {
    return _sigpending(
      arg0,
    );
  }

  late final _sigpendingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>)>>(
          'sigpending');
  late final _sigpending =
      _sigpendingPtr.asFunction<int Function(ffi.Pointer<sigset_t>)>();

  int sigprocmask(
    int arg0,
    ffi.Pointer<sigset_t> arg1,
    ffi.Pointer<sigset_t> arg2,
  ) {
    return _sigprocmask(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _sigprocmaskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<sigset_t>,
              ffi.Pointer<sigset_t>)>>('sigprocmask');
  late final _sigprocmask = _sigprocmaskPtr.asFunction<
      int Function(int, ffi.Pointer<sigset_t>, ffi.Pointer<sigset_t>)>();

  int sigrelse(
    int arg0,
  ) {
    return _sigrelse(
      arg0,
    );
  }

  late final _sigrelsePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('sigrelse');
  late final _sigrelse = _sigrelsePtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> sigset(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _sigset(
      arg0,
      arg1,
    );
  }

  late final _sigsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
              ffi.Int,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>>('sigset');
  late final _sigset = _sigsetPtr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
          int, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>();

  int sigsuspend(
    ffi.Pointer<sigset_t> arg0,
  ) {
    return _sigsuspend(
      arg0,
    );
  }

  late final _sigsuspendPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<sigset_t>)>>(
          'sigsuspend');
  late final _sigsuspend =
      _sigsuspendPtr.asFunction<int Function(ffi.Pointer<sigset_t>)>();

  int sigwait(
    ffi.Pointer<sigset_t> arg0,
    ffi.Pointer<ffi.Int> arg1,
  ) {
    return _sigwait(
      arg0,
      arg1,
    );
  }

  late final _sigwaitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<sigset_t>, ffi.Pointer<ffi.Int>)>>('sigwait');
  late final _sigwait = _sigwaitPtr
      .asFunction<int Function(ffi.Pointer<sigset_t>, ffi.Pointer<ffi.Int>)>();

  void psignal(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _psignal(
      arg0,
      arg1,
    );
  }

  late final _psignalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('psignal');
  late final _psignal =
      _psignalPtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  int sigblock(
    int arg0,
  ) {
    return _sigblock(
      arg0,
    );
  }

  late final _sigblockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('sigblock');
  late final _sigblock = _sigblockPtr.asFunction<int Function(int)>();

  int sigsetmask(
    int arg0,
  ) {
    return _sigsetmask(
      arg0,
    );
  }

  late final _sigsetmaskPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('sigsetmask');
  late final _sigsetmask = _sigsetmaskPtr.asFunction<int Function(int)>();

  int sigvec1(
    int arg0,
    ffi.Pointer<sigvec> arg1,
    ffi.Pointer<sigvec> arg2,
  ) {
    return _sigvec1(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _sigvec1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<sigvec>, ffi.Pointer<sigvec>)>>('sigvec');
  late final _sigvec1 = _sigvec1Ptr.asFunction<
      int Function(int, ffi.Pointer<sigvec>, ffi.Pointer<sigvec>)>();

  int renameat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return _renameat(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _renameatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('renameat');
  late final _renameat = _renameatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int renamex_np(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _renamex_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _renamex_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('renamex_np');
  late final _renamex_np = _renamex_npPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int renameatx_np(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    int arg4,
  ) {
    return _renameatx_np(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _renameatx_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('renameatx_np');
  late final _renameatx_np = _renameatx_npPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  int printf(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _printf(
      arg0,
    );
  }

  late final _printfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'printf');
  late final _printf =
      _printfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stdinp =
      _lookup<ffi.Pointer<FILE>>('__stdinp');

  ffi.Pointer<FILE> get __stdinp => ___stdinp.value;

  set __stdinp(ffi.Pointer<FILE> value) => ___stdinp.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stdoutp =
      _lookup<ffi.Pointer<FILE>>('__stdoutp');

  ffi.Pointer<FILE> get __stdoutp => ___stdoutp.value;

  set __stdoutp(ffi.Pointer<FILE> value) => ___stdoutp.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stderrp =
      _lookup<ffi.Pointer<FILE>>('__stderrp');

  ffi.Pointer<FILE> get __stderrp => ___stderrp.value;

  set __stderrp(ffi.Pointer<FILE> value) => ___stderrp.value = value;

  void clearerr(
    ffi.Pointer<FILE> arg0,
  ) {
    return _clearerr(
      arg0,
    );
  }

  late final _clearerrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr');
  late final _clearerr =
      _clearerrPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fclose(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fclose(
      arg0,
    );
  }

  late final _fclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fclose');
  late final _fclose = _fclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int feof(
    ffi.Pointer<FILE> arg0,
  ) {
    return _feof(
      arg0,
    );
  }

  late final _feofPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('feof');
  late final _feof = _feofPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror(
    ffi.Pointer<FILE> arg0,
  ) {
    return _ferror(
      arg0,
    );
  }

  late final _ferrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror');
  late final _ferror = _ferrorPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fflush(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fflush(
      arg0,
    );
  }

  late final _fflushPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush');
  late final _fflush = _fflushPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetc(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fgetc(
      arg0,
    );
  }

  late final _fgetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('fgetc');
  late final _fgetc = _fgetcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetpos(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<fpos_t> arg1,
  ) {
    return _fgetpos(
      arg0,
      arg1,
    );
  }

  late final _fgetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fgetpos');
  late final _fgetpos = _fgetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  ffi.Pointer<ffi.Char> fgets(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<FILE> arg2,
  ) {
    return _fgets(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fgetsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<FILE>)>>('fgets');
  late final _fgets = _fgetsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __mode,
  ) {
    return _fopen(
      __filename,
      __mode,
    );
  }

  late final _fopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fopen');
  late final _fopen = _fopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fprintf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fprintf(
      arg0,
      arg1,
    );
  }

  late final _fprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fprintf');
  late final _fprintf = _fprintfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int fputc(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _fputc(
      arg0,
      arg1,
    );
  }

  late final _fputcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc');
  late final _fputc =
      _fputcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int fputs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _fputs(
      arg0,
      arg1,
    );
  }

  late final _fputsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('fputs');
  late final _fputs = _fputsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int fread(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __nitems,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread(
      __ptr,
      __size,
      __nitems,
      __stream,
    );
  }

  late final _freadPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fread');
  late final _fread = _freadPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> freopen(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<FILE> arg2,
  ) {
    return _freopen(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _freopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('freopen');
  late final _freopen = _freopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int fscanf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fscanf(
      arg0,
      arg1,
    );
  }

  late final _fscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fscanf');
  late final _fscanf = _fscanfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int fseek(
    ffi.Pointer<FILE> arg0,
    int arg1,
    int arg2,
  ) {
    return _fseek(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fseekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Long, ffi.Int)>>('fseek');
  late final _fseek =
      _fseekPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int fsetpos(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<fpos_t> arg1,
  ) {
    return _fsetpos(
      arg0,
      arg1,
    );
  }

  late final _fsetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fsetpos');
  late final _fsetpos = _fsetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  int ftell(
    ffi.Pointer<FILE> arg0,
  ) {
    return _ftell(
      arg0,
    );
  }

  late final _ftellPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<FILE>)>>(
          'ftell');
  late final _ftell = _ftellPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fwrite(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __nitems,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fwrite(
      __ptr,
      __size,
      __nitems,
      __stream,
    );
  }

  late final _fwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fwrite');
  late final _fwrite = _fwritePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int getc(
    ffi.Pointer<FILE> arg0,
  ) {
    return _getc(
      arg0,
    );
  }

  late final _getcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getc');
  late final _getc = _getcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar() {
    return _getchar();
  }

  late final _getcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar');
  late final _getchar = _getcharPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> gets(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _gets(
      arg0,
    );
  }

  late final _getsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('gets');
  late final _gets = _getsPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void perror(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _perror(
      arg0,
    );
  }

  late final _perrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'perror');
  late final _perror =
      _perrorPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int putc(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _putc(
      arg0,
      arg1,
    );
  }

  late final _putcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc');
  late final _putc =
      _putcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar(
    int arg0,
  ) {
    return _putchar(
      arg0,
    );
  }

  late final _putcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('putchar');
  late final _putchar = _putcharPtr.asFunction<int Function(int)>();

  int puts(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _puts(
      arg0,
    );
  }

  late final _putsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'puts');
  late final _puts = _putsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int remove(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _remove(
      arg0,
    );
  }

  late final _removePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'remove');
  late final _remove =
      _removePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int rename(
    ffi.Pointer<ffi.Char> __old,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _rename(
      __old,
      __new,
    );
  }

  late final _renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('rename');
  late final _rename = _renamePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  void rewind(
    ffi.Pointer<FILE> arg0,
  ) {
    return _rewind(
      arg0,
    );
  }

  late final _rewindPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'rewind');
  late final _rewind =
      _rewindPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int scanf(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _scanf(
      arg0,
    );
  }

  late final _scanfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'scanf');
  late final _scanf =
      _scanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  void setbuf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _setbuf(
      arg0,
      arg1,
    );
  }

  late final _setbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('setbuf');
  late final _setbuf = _setbufPtr
      .asFunction<void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int setvbuf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
  ) {
    return _setvbuf(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _setvbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Size)>>('setvbuf');
  late final _setvbuf = _setvbufPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int, int)>();

  int sprintf(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _sprintf(
      arg0,
      arg1,
    );
  }

  late final _sprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sprintf');
  late final _sprintf = _sprintfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int sscanf(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _sscanf(
      arg0,
      arg1,
    );
  }

  late final _sscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sscanf');
  late final _sscanf = _sscanfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> tmpfile() {
    return _tmpfile();
  }

  late final _tmpfilePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FILE> Function()>>('tmpfile');
  late final _tmpfile = _tmpfilePtr.asFunction<ffi.Pointer<FILE> Function()>();

  ffi.Pointer<ffi.Char> tmpnam(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _tmpnam(
      arg0,
    );
  }

  late final _tmpnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam');
  late final _tmpnam = _tmpnamPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int ungetc(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _ungetc(
      arg0,
      arg1,
    );
  }

  late final _ungetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'ungetc');
  late final _ungetc =
      _ungetcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int vfprintf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vfprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vfprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>>('vfprintf');
  late final _vfprintf = _vfprintfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>();

  int vprintf(
    ffi.Pointer<ffi.Char> arg0,
    va_list arg1,
  ) {
    return _vprintf(
      arg0,
      arg1,
    );
  }

  late final _vprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, va_list)>>(
      'vprintf');
  late final _vprintf =
      _vprintfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, va_list)>();

  int vsprintf(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vsprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vsprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('vsprintf');
  late final _vsprintf = _vsprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  ffi.Pointer<ffi.Char> ctermid(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _ctermid(
      arg0,
    );
  }

  late final _ctermidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid');
  late final _ctermid = _ctermidPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> fdopen(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fdopen(
      arg0,
      arg1,
    );
  }

  late final _fdopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('fdopen');
  late final _fdopen = _fdopenPtr
      .asFunction<ffi.Pointer<FILE> Function(int, ffi.Pointer<ffi.Char>)>();

  int fileno(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fileno(
      arg0,
    );
  }

  late final _filenoPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno');
  late final _fileno = _filenoPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int pclose(
    ffi.Pointer<FILE> arg0,
  ) {
    return _pclose(
      arg0,
    );
  }

  late final _pclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'pclose');
  late final _pclose = _pclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> popen(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _popen(
      arg0,
      arg1,
    );
  }

  late final _popenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('popen');
  late final _popen = _popenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int __srget(
    ffi.Pointer<FILE> arg0,
  ) {
    return ___srget(
      arg0,
    );
  }

  late final ___srgetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '__srget');
  late final ___srget =
      ___srgetPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int __svfscanf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return ___svfscanf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final ___svfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              va_list)>>('__svfscanf');
  late final ___svfscanf = ___svfscanfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>();

  int __swbuf(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return ___swbuf(
      arg0,
      arg1,
    );
  }

  late final ___swbufPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          '__swbuf');
  late final ___swbuf =
      ___swbufPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  void flockfile(
    ffi.Pointer<FILE> arg0,
  ) {
    return _flockfile(
      arg0,
    );
  }

  late final _flockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'flockfile');
  late final _flockfile =
      _flockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int ftrylockfile(
    ffi.Pointer<FILE> arg0,
  ) {
    return _ftrylockfile(
      arg0,
    );
  }

  late final _ftrylockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ftrylockfile');
  late final _ftrylockfile =
      _ftrylockfilePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void funlockfile(
    ffi.Pointer<FILE> arg0,
  ) {
    return _funlockfile(
      arg0,
    );
  }

  late final _funlockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'funlockfile');
  late final _funlockfile =
      _funlockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int getc_unlocked(
    ffi.Pointer<FILE> arg0,
  ) {
    return _getc_unlocked(
      arg0,
    );
  }

  late final _getc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'getc_unlocked');
  late final _getc_unlocked =
      _getc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar_unlocked() {
    return _getchar_unlocked();
  }

  late final _getchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar_unlocked');
  late final _getchar_unlocked =
      _getchar_unlockedPtr.asFunction<int Function()>();

  int putc_unlocked(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _putc_unlocked(
      arg0,
      arg1,
    );
  }

  late final _putc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc_unlocked');
  late final _putc_unlocked =
      _putc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar_unlocked(
    int arg0,
  ) {
    return _putchar_unlocked(
      arg0,
    );
  }

  late final _putchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'putchar_unlocked');
  late final _putchar_unlocked =
      _putchar_unlockedPtr.asFunction<int Function(int)>();

  int getw(
    ffi.Pointer<FILE> arg0,
  ) {
    return _getw(
      arg0,
    );
  }

  late final _getwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getw');
  late final _getw = _getwPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int putw(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _putw(
      arg0,
      arg1,
    );
  }

  late final _putwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putw');
  late final _putw =
      _putwPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  ffi.Pointer<ffi.Char> tempnam(
    ffi.Pointer<ffi.Char> __dir,
    ffi.Pointer<ffi.Char> __prefix,
  ) {
    return _tempnam(
      __dir,
      __prefix,
    );
  }

  late final _tempnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('tempnam');
  late final _tempnam = _tempnamPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fseeko(
    ffi.Pointer<FILE> __stream,
    int __offset,
    int __whence,
  ) {
    return _fseeko(
      __stream,
      __offset,
      __whence,
    );
  }

  late final _fseekoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, off_t, ffi.Int)>>('fseeko');
  late final _fseeko =
      _fseekoPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftello(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftello(
      __stream,
    );
  }

  late final _ftelloPtr =
      _lookup<ffi.NativeFunction<off_t Function(ffi.Pointer<FILE>)>>('ftello');
  late final _ftello = _ftelloPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int snprintf(
    ffi.Pointer<ffi.Char> __str,
    int __size,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _snprintf(
      __str,
      __size,
      __format,
    );
  }

  late final _snprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('snprintf');
  late final _snprintf = _snprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int vfscanf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
    va_list arg2,
  ) {
    return _vfscanf(
      __stream,
      __format,
      arg2,
    );
  }

  late final _vfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>>('vfscanf');
  late final _vfscanf = _vfscanfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>();

  int vscanf(
    ffi.Pointer<ffi.Char> __format,
    va_list arg1,
  ) {
    return _vscanf(
      __format,
      arg1,
    );
  }

  late final _vscanfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, va_list)>>(
      'vscanf');
  late final _vscanf =
      _vscanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, va_list)>();

  int vsnprintf(
    ffi.Pointer<ffi.Char> __str,
    int __size,
    ffi.Pointer<ffi.Char> __format,
    va_list arg3,
  ) {
    return _vsnprintf(
      __str,
      __size,
      __format,
      arg3,
    );
  }

  late final _vsnprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('vsnprintf');
  late final _vsnprintf = _vsnprintfPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int vsscanf(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __format,
    va_list arg2,
  ) {
    return _vsscanf(
      __str,
      __format,
      arg2,
    );
  }

  late final _vsscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('vsscanf');
  late final _vsscanf = _vsscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int dprintf(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _dprintf(
      arg0,
      arg1,
    );
  }

  late final _dprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'dprintf');
  late final _dprintf =
      _dprintfPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  int vdprintf(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vdprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vdprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, va_list)>>('vdprintf');
  late final _vdprintf = _vdprintfPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, va_list)>();

  int getdelim(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __linep,
    ffi.Pointer<ffi.Size> __linecapp,
    int __delimiter,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getdelim(
      __linep,
      __linecapp,
      __delimiter,
      __stream,
    );
  }

  late final _getdelimPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Int, ffi.Pointer<FILE>)>>('getdelim');
  late final _getdelim = _getdelimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          int, ffi.Pointer<FILE>)>();

  int getline(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __linep,
    ffi.Pointer<ffi.Size> __linecapp,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getline(
      __linep,
      __linecapp,
      __stream,
    );
  }

  late final _getlinePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Pointer<FILE>)>>('getline');
  late final _getline = _getlinePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fmemopen(
    ffi.Pointer<ffi.Void> __buf,
    int __size,
    ffi.Pointer<ffi.Char> __mode,
  ) {
    return _fmemopen(
      __buf,
      __size,
      __mode,
    );
  }

  late final _fmemopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('fmemopen');
  late final _fmemopen = _fmemopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> open_memstream(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __bufp,
    ffi.Pointer<ffi.Size> __sizep,
  ) {
    return _open_memstream(
      __bufp,
      __sizep,
    );
  }

  late final _open_memstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('open_memstream');
  late final _open_memstream = _open_memstreamPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>)>();

  late final ffi.Pointer<ffi.Int> _sys_nerr = _lookup<ffi.Int>('sys_nerr');

  int get sys_nerr => _sys_nerr.value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _sys_errlist =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('sys_errlist');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get sys_errlist => _sys_errlist.value;

  set sys_errlist(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      _sys_errlist.value = value;

  int asprintf(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _asprintf(
      arg0,
      arg1,
    );
  }

  late final _asprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('asprintf');
  late final _asprintf = _asprintfPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctermid_r(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _ctermid_r(
      arg0,
    );
  }

  late final _ctermid_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid_r');
  late final _ctermid_r = _ctermid_rPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> fgetln(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Size> arg1,
  ) {
    return _fgetln(
      arg0,
      arg1,
    );
  }

  late final _fgetlnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Size>)>>('fgetln');
  late final _fgetln = _fgetlnPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<FILE>, ffi.Pointer<ffi.Size>)>();

  ffi.Pointer<ffi.Char> fmtcheck(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fmtcheck(
      arg0,
      arg1,
    );
  }

  late final _fmtcheckPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fmtcheck');
  late final _fmtcheck = _fmtcheckPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fpurge(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fpurge(
      arg0,
    );
  }

  late final _fpurgePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fpurge');
  late final _fpurge = _fpurgePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void setbuffer(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _setbuffer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setbufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int)>>('setbuffer');
  late final _setbuffer = _setbufferPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int)>();

  int setlinebuf(
    ffi.Pointer<FILE> arg0,
  ) {
    return _setlinebuf(
      arg0,
    );
  }

  late final _setlinebufPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'setlinebuf');
  late final _setlinebuf =
      _setlinebufPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int vasprintf(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vasprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vasprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('vasprintf');
  late final _vasprintf = _vasprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  ffi.Pointer<FILE> funopen(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>
        arg1,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>
        arg2,
    ffi.Pointer<
            ffi.NativeFunction<
                fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>>
        arg3,
    ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
        arg4,
  ) {
    return _funopen(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _funopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Char>, ffi.Int)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Char>, ffi.Int)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>)>>)>>('funopen');
  late final _funopen = _funopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>)>();

  int __sprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return ___sprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final ___sprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('__sprintf_chk');
  late final ___sprintf_chk = ___sprintf_chkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Char>)>();

  int __snprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
    ffi.Pointer<ffi.Char> arg4,
  ) {
    return ___snprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final ___snprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('__snprintf_chk');
  late final ___snprintf_chk = ___snprintf_chkPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, int, int, ffi.Pointer<ffi.Char>)>();

  int __vsprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    va_list arg4,
  ) {
    return ___vsprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final ___vsprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('__vsprintf_chk');
  late final ___vsprintf_chk = ___vsprintf_chkPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Char>, va_list)>();

  int __vsnprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
    ffi.Pointer<ffi.Char> arg4,
    va_list arg5,
  ) {
    return ___vsnprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final ___vsnprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('__vsnprintf_chk');
  late final ___vsnprintf_chk = ___vsnprintf_chkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int, int, ffi.Pointer<ffi.Char>,
          va_list)>();

  ffi.Pointer<ffi.Void> memchr(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memchr(
      __s,
      __c,
      __n,
    );
  }

  late final _memchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memchr');
  late final _memchr = _memchrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int memcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _memcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memcmp');
  late final _memcmp = _memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memcpy(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memcpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memcpy');
  late final _memcpy = _memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memmove(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __len,
  ) {
    return _memmove(
      __dst,
      __src,
      __len,
    );
  }

  late final _memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmove');
  late final _memmove = _memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memset(
    ffi.Pointer<ffi.Void> __b,
    int __c,
    int __len,
  ) {
    return _memset(
      __b,
      __c,
      __len,
    );
  }

  late final _memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memset');
  late final _memset = _memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strcat(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcat(
      __s1,
      __s2,
    );
  }

  late final _strcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcat');
  late final _strcat = _strcatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strchr(
      __s,
      __c,
    );
  }

  late final _strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strchr');
  late final _strchr = _strchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strcmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcmp(
      __s1,
      __s2,
    );
  }

  late final _strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmp');
  late final _strcmp = _strcmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcoll(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcoll(
      __s1,
      __s2,
    );
  }

  late final _strcollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcoll');
  late final _strcoll = _strcollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcpy(
      __dst,
      __src,
    );
  }

  late final _strcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcpy');
  late final _strcpy = _strcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strcspn(
      __s,
      __charset,
    );
  }

  late final _strcspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcspn');
  late final _strcspn = _strcspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strerror(
    int __errnum,
  ) {
    return _strerror(
      __errnum,
    );
  }

  late final _strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strerror');
  late final _strerror =
      _strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int strlen(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strlen(
      __s,
    );
  }

  late final _strlenPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>)>>(
      'strlen');
  late final _strlen =
      _strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncat(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncat(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncat');
  late final _strncat = _strncatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strncmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncmp');
  late final _strncmp = _strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strncpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _strncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncpy');
  late final _strncpy = _strncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strpbrk(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strpbrk(
      __s,
      __charset,
    );
  }

  late final _strpbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strpbrk');
  late final _strpbrk = _strpbrkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strrchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strrchr(
      __s,
      __c,
    );
  }

  late final _strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strrchr');
  late final _strrchr = _strrchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strspn(
      __s,
      __charset,
    );
  }

  late final _strspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strspn');
  late final _strspn = _strspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strstr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
  ) {
    return _strstr(
      __big,
      __little,
    );
  }

  late final _strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strstr');
  late final _strstr = _strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __sep,
  ) {
    return _strtok(
      __str,
      __sep,
    );
  }

  late final _strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strtok');
  late final _strtok = _strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strxfrm(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strxfrm(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strxfrm');
  late final _strxfrm = _strxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strtok_r(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __sep,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lasts,
  ) {
    return _strtok_r(
      __str,
      __sep,
      __lasts,
    );
  }

  late final _strtok_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtok_r');
  late final _strtok_r = _strtok_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strerror_r(
    int __errnum,
    ffi.Pointer<ffi.Char> __strerrbuf,
    int __buflen,
  ) {
    return _strerror_r(
      __errnum,
      __strerrbuf,
      __buflen,
    );
  }

  late final _strerror_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strerror_r');
  late final _strerror_r = _strerror_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strdup(
    ffi.Pointer<ffi.Char> __s1,
  ) {
    return _strdup(
      __s1,
    );
  }

  late final _strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strdup');
  late final _strdup = _strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> memccpy(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __c,
    int __n,
  ) {
    return _memccpy(
      __dst,
      __src,
      __c,
      __n,
    );
  }

  late final _memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memccpy');
  late final _memccpy = _memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> stpcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _stpcpy(
      __dst,
      __src,
    );
  }

  late final _stpcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('stpcpy');
  late final _stpcpy = _stpcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> stpncpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _stpncpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _stpncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('stpncpy');
  late final _stpncpy = _stpncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strndup(
    ffi.Pointer<ffi.Char> __s1,
    int __n,
  ) {
    return _strndup(
      __s1,
      __n,
    );
  }

  late final _strndupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strndup');
  late final _strndup = _strndupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strnlen(
    ffi.Pointer<ffi.Char> __s1,
    int __n,
  ) {
    return _strnlen(
      __s1,
      __n,
    );
  }

  late final _strnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('strnlen');
  late final _strnlen =
      _strnlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strsignal(
    int __sig,
  ) {
    return _strsignal(
      __sig,
    );
  }

  late final _strsignalPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strsignal');
  late final _strsignal =
      _strsignalPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int memset_s(
    ffi.Pointer<ffi.Void> __s,
    int __smax,
    int __c,
    int __n,
  ) {
    return _memset_s(
      __s,
      __smax,
      __c,
      __n,
    );
  }

  late final _memset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Void>, rsize_t, ffi.Int, rsize_t)>>('memset_s');
  late final _memset_s = _memset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  ffi.Pointer<ffi.Void> memmem(
    ffi.Pointer<ffi.Void> __big,
    int __big_len,
    ffi.Pointer<ffi.Void> __little,
    int __little_len,
  ) {
    return _memmem(
      __big,
      __big_len,
      __little,
      __little_len,
    );
  }

  late final _memmemPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmem');
  late final _memmem = _memmemPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern4(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern4,
    int __len,
  ) {
    return _memset_pattern4(
      __b,
      __pattern4,
      __len,
    );
  }

  late final _memset_pattern4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern4');
  late final _memset_pattern4 = _memset_pattern4Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern8(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern8,
    int __len,
  ) {
    return _memset_pattern8(
      __b,
      __pattern8,
      __len,
    );
  }

  late final _memset_pattern8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern8');
  late final _memset_pattern8 = _memset_pattern8Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern16(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern16,
    int __len,
  ) {
    return _memset_pattern16(
      __b,
      __pattern16,
      __len,
    );
  }

  late final _memset_pattern16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern16');
  late final _memset_pattern16 = _memset_pattern16Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> strcasestr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
  ) {
    return _strcasestr(
      __big,
      __little,
    );
  }

  late final _strcasestrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasestr');
  late final _strcasestr = _strcasestrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strnstr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
    int __len,
  ) {
    return _strnstr(
      __big,
      __little,
      __len,
    );
  }

  late final _strnstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strnstr');
  late final _strnstr = _strnstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strlcat(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __source,
    int __size,
  ) {
    return _strlcat(
      __dst,
      __source,
      __size,
    );
  }

  late final _strlcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strlcat');
  late final _strlcat = _strlcatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strlcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __source,
    int __size,
  ) {
    return _strlcpy(
      __dst,
      __source,
      __size,
    );
  }

  late final _strlcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strlcpy');
  late final _strlcpy = _strlcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void strmode(
    int __mode,
    ffi.Pointer<ffi.Char> __bp,
  ) {
    return _strmode(
      __mode,
      __bp,
    );
  }

  late final _strmodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('strmode');
  late final _strmode =
      _strmodePtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strsep(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __stringp,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strsep(
      __stringp,
      __delim,
    );
  }

  late final _strsepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('strsep');
  late final _strsep = _strsepPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  void swab(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _swab(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _swabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ssize_t)>>('swab');
  late final _swab = _swabPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int timingsafe_bcmp(
    ffi.Pointer<ffi.Void> __b1,
    ffi.Pointer<ffi.Void> __b2,
    int __len,
  ) {
    return _timingsafe_bcmp(
      __b1,
      __b2,
      __len,
    );
  }

  late final _timingsafe_bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('timingsafe_bcmp');
  late final _timingsafe_bcmp = _timingsafe_bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int strsignal_r(
    int __sig,
    ffi.Pointer<ffi.Char> __strsignalbuf,
    int __buflen,
  ) {
    return _strsignal_r(
      __sig,
      __strsignalbuf,
      __buflen,
    );
  }

  late final _strsignal_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strsignal_r');
  late final _strsignal_r = _strsignal_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int bcmp(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _bcmp(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Size)>>('bcmp');
  late final _bcmp = _bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bcopy(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _bcopy(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _bcopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('bcopy');
  late final _bcopy = _bcopyPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bzero(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    return _bzero(
      arg0,
      arg1,
    );
  }

  late final _bzeroPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>('bzero');
  late final _bzero =
      _bzeroPtr.asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> index(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _index(
      arg0,
      arg1,
    );
  }

  late final _indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('index');
  late final _index = _indexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> rindex(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _rindex(
      arg0,
      arg1,
    );
  }

  late final _rindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('rindex');
  late final _rindex = _rindexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int ffs(
    int arg0,
  ) {
    return _ffs(
      arg0,
    );
  }

  late final _ffsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('ffs');
  late final _ffs = _ffsPtr.asFunction<int Function(int)>();

  int strcasecmp(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _strcasecmp(
      arg0,
      arg1,
    );
  }

  late final _strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasecmp');
  late final _strcasecmp = _strcasecmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncasecmp(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _strncasecmp(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncasecmp');
  late final _strncasecmp = _strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int ffsl(
    int arg0,
  ) {
    return _ffsl(
      arg0,
    );
  }

  late final _ffslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('ffsl');
  late final _ffsl = _ffslPtr.asFunction<int Function(int)>();

  int ffsll(
    int arg0,
  ) {
    return _ffsll(
      arg0,
    );
  }

  late final _ffsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('ffsll');
  late final _ffsll = _ffsllPtr.asFunction<int Function(int)>();

  int fls(
    int arg0,
  ) {
    return _fls(
      arg0,
    );
  }

  late final _flsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fls');
  late final _fls = _flsPtr.asFunction<int Function(int)>();

  int flsl(
    int arg0,
  ) {
    return _flsl(
      arg0,
    );
  }

  late final _flslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('flsl');
  late final _flsl = _flslPtr.asFunction<int Function(int)>();

  int flsll(
    int arg0,
  ) {
    return _flsll(
      arg0,
    );
  }

  late final _flsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('flsll');
  late final _flsll = _flsllPtr.asFunction<int Function(int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('tzname');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get tzname => _tzname.value;

  set tzname(ffi.Pointer<ffi.Pointer<ffi.Char>> value) => _tzname.value = value;

  late final ffi.Pointer<ffi.Int> _getdate_err =
      _lookup<ffi.Int>('getdate_err');

  int get getdate_err => _getdate_err.value;

  set getdate_err(int value) => _getdate_err.value = value;

  late final ffi.Pointer<ffi.Long> _timezone = _lookup<ffi.Long>('timezone');

  int get timezone => _timezone.value;

  set timezone(int value) => _timezone.value = value;

  late final ffi.Pointer<ffi.Int> _daylight = _lookup<ffi.Int>('daylight');

  int get daylight => _daylight.value;

  set daylight(int value) => _daylight.value = value;

  ffi.Pointer<ffi.Char> asctime(
    ffi.Pointer<tm> arg0,
  ) {
    return _asctime(
      arg0,
    );
  }

  late final _asctimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>)>>(
      'asctime');
  late final _asctime =
      _asctimePtr.asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>)>();

  int clock() {
    return _clock();
  }

  late final _clockPtr =
      _lookup<ffi.NativeFunction<clock_t Function()>>('clock');
  late final _clock = _clockPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> ctime(
    ffi.Pointer<time_t> arg0,
  ) {
    return _ctime(
      arg0,
    );
  }

  late final _ctimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<time_t>)>>('ctime');
  late final _ctime = _ctimePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<time_t>)>();

  double difftime(
    int arg0,
    int arg1,
  ) {
    return _difftime(
      arg0,
      arg1,
    );
  }

  late final _difftimePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(time_t, time_t)>>(
          'difftime');
  late final _difftime = _difftimePtr.asFunction<double Function(int, int)>();

  ffi.Pointer<tm> getdate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getdate(
      arg0,
    );
  }

  late final _getdatePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<ffi.Char>)>>(
      'getdate');
  late final _getdate =
      _getdatePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<tm> gmtime(
    ffi.Pointer<time_t> arg0,
  ) {
    return _gmtime(
      arg0,
    );
  }

  late final _gmtimePtr = _lookup<
      ffi
      .NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>>('gmtime');
  late final _gmtime =
      _gmtimePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>();

  ffi.Pointer<tm> localtime(
    ffi.Pointer<time_t> arg0,
  ) {
    return _localtime(
      arg0,
    );
  }

  late final _localtimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>>(
      'localtime');
  late final _localtime =
      _localtimePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>();

  int mktime(
    ffi.Pointer<tm> arg0,
  ) {
    return _mktime(
      arg0,
    );
  }

  late final _mktimePtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>('mktime');
  late final _mktime = _mktimePtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int strftime(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<tm> arg3,
  ) {
    return _strftime(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _strftimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>>('strftime');
  late final _strftime = _strftimePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<tm>)>();

  ffi.Pointer<ffi.Char> strptime(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<tm> arg2,
  ) {
    return _strptime(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _strptimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>>('strptime');
  late final _strptime = _strptimePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>();

  int time(
    ffi.Pointer<time_t> arg0,
  ) {
    return _time(
      arg0,
    );
  }

  late final _timePtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<time_t>)>>('time');
  late final _time = _timePtr.asFunction<int Function(ffi.Pointer<time_t>)>();

  void tzset() {
    return _tzset();
  }

  late final _tzsetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('tzset');
  late final _tzset = _tzsetPtr.asFunction<void Function()>();

  ffi.Pointer<ffi.Char> asctime_r(
    ffi.Pointer<tm> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _asctime_r(
      arg0,
      arg1,
    );
  }

  late final _asctime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<tm>, ffi.Pointer<ffi.Char>)>>('asctime_r');
  late final _asctime_r = _asctime_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctime_r(
    ffi.Pointer<time_t> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _ctime_r(
      arg0,
      arg1,
    );
  }

  late final _ctime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<time_t>, ffi.Pointer<ffi.Char>)>>('ctime_r');
  late final _ctime_r = _ctime_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<time_t>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<tm> gmtime_r(
    ffi.Pointer<time_t> arg0,
    ffi.Pointer<tm> arg1,
  ) {
    return _gmtime_r(
      arg0,
      arg1,
    );
  }

  late final _gmtime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tm> Function(
              ffi.Pointer<time_t>, ffi.Pointer<tm>)>>('gmtime_r');
  late final _gmtime_r = _gmtime_rPtr.asFunction<
      ffi.Pointer<tm> Function(ffi.Pointer<time_t>, ffi.Pointer<tm>)>();

  ffi.Pointer<tm> localtime_r(
    ffi.Pointer<time_t> arg0,
    ffi.Pointer<tm> arg1,
  ) {
    return _localtime_r(
      arg0,
      arg1,
    );
  }

  late final _localtime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tm> Function(
              ffi.Pointer<time_t>, ffi.Pointer<tm>)>>('localtime_r');
  late final _localtime_r = _localtime_rPtr.asFunction<
      ffi.Pointer<tm> Function(ffi.Pointer<time_t>, ffi.Pointer<tm>)>();

  int posix2time(
    int arg0,
  ) {
    return _posix2time(
      arg0,
    );
  }

  late final _posix2timePtr =
      _lookup<ffi.NativeFunction<time_t Function(time_t)>>('posix2time');
  late final _posix2time = _posix2timePtr.asFunction<int Function(int)>();

  void tzsetwall() {
    return _tzsetwall();
  }

  late final _tzsetwallPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('tzsetwall');
  late final _tzsetwall = _tzsetwallPtr.asFunction<void Function()>();

  int time2posix(
    int arg0,
  ) {
    return _time2posix(
      arg0,
    );
  }

  late final _time2posixPtr =
      _lookup<ffi.NativeFunction<time_t Function(time_t)>>('time2posix');
  late final _time2posix = _time2posixPtr.asFunction<int Function(int)>();

  int timelocal(
    ffi.Pointer<tm> arg0,
  ) {
    return _timelocal(
      arg0,
    );
  }

  late final _timelocalPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>(
          'timelocal');
  late final _timelocal =
      _timelocalPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int timegm(
    ffi.Pointer<tm> arg0,
  ) {
    return _timegm(
      arg0,
    );
  }

  late final _timegmPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>('timegm');
  late final _timegm = _timegmPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int nanosleep(
    ffi.Pointer<timespec> __rqtp,
    ffi.Pointer<timespec> __rmtp,
  ) {
    return _nanosleep(
      __rqtp,
      __rmtp,
    );
  }

  late final _nanosleepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<timespec>, ffi.Pointer<timespec>)>>('nanosleep');
  late final _nanosleep = _nanosleepPtr
      .asFunction<int Function(ffi.Pointer<timespec>, ffi.Pointer<timespec>)>();

  int clock_getres(
    clockid_t __clock_id,
    ffi.Pointer<timespec> __res,
  ) {
    return _clock_getres(
      __clock_id.value,
      __res,
    );
  }

  late final _clock_getresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<timespec>)>>('clock_getres');
  late final _clock_getres =
      _clock_getresPtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int clock_gettime(
    clockid_t __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_gettime(
      __clock_id.value,
      __tp,
    );
  }

  late final _clock_gettimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<timespec>)>>('clock_gettime');
  late final _clock_gettime =
      _clock_gettimePtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  Dart__uint64_t clock_gettime_nsec_np(
    clockid_t __clock_id,
  ) {
    return _clock_gettime_nsec_np(
      __clock_id.value,
    );
  }

  late final _clock_gettime_nsec_npPtr =
      _lookup<ffi.NativeFunction<__uint64_t Function(ffi.UnsignedInt)>>(
          'clock_gettime_nsec_np');
  late final _clock_gettime_nsec_np =
      _clock_gettime_nsec_npPtr.asFunction<int Function(int)>();

  int clock_settime(
    clockid_t __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_settime(
      __clock_id.value,
      __tp,
    );
  }

  late final _clock_settimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<timespec>)>>('clock_settime');
  late final _clock_settime =
      _clock_settimePtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int timespec_get(
    ffi.Pointer<timespec> ts,
    int base,
  ) {
    return _timespec_get(
      ts,
      base,
    );
  }

  late final _timespec_getPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<timespec>, ffi.Int)>>(
      'timespec_get');
  late final _timespec_get =
      _timespec_getPtr.asFunction<int Function(ffi.Pointer<timespec>, int)>();

  int imaxabs(
    int j,
  ) {
    return _imaxabs(
      j,
    );
  }

  late final _imaxabsPtr =
      _lookup<ffi.NativeFunction<intmax_t Function(intmax_t)>>('imaxabs');
  late final _imaxabs = _imaxabsPtr.asFunction<int Function(int)>();

  imaxdiv_t imaxdiv(
    int __numer,
    int __denom,
  ) {
    return _imaxdiv(
      __numer,
      __denom,
    );
  }

  late final _imaxdivPtr =
      _lookup<ffi.NativeFunction<imaxdiv_t Function(intmax_t, intmax_t)>>(
          'imaxdiv');
  late final _imaxdiv = _imaxdivPtr.asFunction<imaxdiv_t Function(int, int)>();

  int strtoimax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoimax');
  late final _strtoimax = _strtoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoumax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoumax');
  late final _strtoumax = _strtoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int wcstoimax(
    ffi.Pointer<ffi.WChar> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> __endptr,
    int __base,
  ) {
    return _wcstoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>, ffi.Int)>>('wcstoimax');
  late final _wcstoimax = _wcstoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>, int)>();

  int wcstoumax(
    ffi.Pointer<ffi.WChar> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> __endptr,
    int __base,
  ) {
    return _wcstoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>, ffi.Int)>>('wcstoumax');
  late final _wcstoumax = _wcstoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>, int)>();

  late final ffi.Pointer<CFBagCallBacks> _kCFTypeBagCallBacks =
      _lookup<CFBagCallBacks>('kCFTypeBagCallBacks');

  CFBagCallBacks get kCFTypeBagCallBacks => _kCFTypeBagCallBacks.ref;

  late final ffi.Pointer<CFBagCallBacks> _kCFCopyStringBagCallBacks =
      _lookup<CFBagCallBacks>('kCFCopyStringBagCallBacks');

  CFBagCallBacks get kCFCopyStringBagCallBacks =>
      _kCFCopyStringBagCallBacks.ref;

  int CFBagGetTypeID() {
    return _CFBagGetTypeID();
  }

  late final _CFBagGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFBagGetTypeID');
  late final _CFBagGetTypeID = _CFBagGetTypeIDPtr.asFunction<int Function()>();

  CFBagRef CFBagCreate(
    CFAllocatorRef allocator,
    ffi.Pointer<ffi.Pointer<ffi.Void>> values,
    int numValues,
    ffi.Pointer<CFBagCallBacks> callBacks,
  ) {
    return _CFBagCreate(
      allocator,
      values,
      numValues,
      callBacks,
    );
  }

  late final _CFBagCreatePtr = _lookup<
      ffi.NativeFunction<
          CFBagRef Function(CFAllocatorRef, ffi.Pointer<ffi.Pointer<ffi.Void>>,
              CFIndex, ffi.Pointer<CFBagCallBacks>)>>('CFBagCreate');
  late final _CFBagCreate = _CFBagCreatePtr.asFunction<
      CFBagRef Function(CFAllocatorRef, ffi.Pointer<ffi.Pointer<ffi.Void>>, int,
          ffi.Pointer<CFBagCallBacks>)>();

  CFBagRef CFBagCreateCopy(
    CFAllocatorRef allocator,
    CFBagRef theBag,
  ) {
    return _CFBagCreateCopy(
      allocator,
      theBag,
    );
  }

  late final _CFBagCreateCopyPtr =
      _lookup<ffi.NativeFunction<CFBagRef Function(CFAllocatorRef, CFBagRef)>>(
          'CFBagCreateCopy');
  late final _CFBagCreateCopy = _CFBagCreateCopyPtr.asFunction<
      CFBagRef Function(CFAllocatorRef, CFBagRef)>();

  CFMutableBagRef CFBagCreateMutable(
    CFAllocatorRef allocator,
    int capacity,
    ffi.Pointer<CFBagCallBacks> callBacks,
  ) {
    return _CFBagCreateMutable(
      allocator,
      capacity,
      callBacks,
    );
  }

  late final _CFBagCreateMutablePtr = _lookup<
      ffi.NativeFunction<
          CFMutableBagRef Function(CFAllocatorRef, CFIndex,
              ffi.Pointer<CFBagCallBacks>)>>('CFBagCreateMutable');
  late final _CFBagCreateMutable = _CFBagCreateMutablePtr.asFunction<
      CFMutableBagRef Function(
          CFAllocatorRef, int, ffi.Pointer<CFBagCallBacks>)>();

  CFMutableBagRef CFBagCreateMutableCopy(
    CFAllocatorRef allocator,
    int capacity,
    CFBagRef theBag,
  ) {
    return _CFBagCreateMutableCopy(
      allocator,
      capacity,
      theBag,
    );
  }

  late final _CFBagCreateMutableCopyPtr = _lookup<
      ffi.NativeFunction<
          CFMutableBagRef Function(
              CFAllocatorRef, CFIndex, CFBagRef)>>('CFBagCreateMutableCopy');
  late final _CFBagCreateMutableCopy = _CFBagCreateMutableCopyPtr.asFunction<
      CFMutableBagRef Function(CFAllocatorRef, int, CFBagRef)>();

  int CFBagGetCount(
    CFBagRef theBag,
  ) {
    return _CFBagGetCount(
      theBag,
    );
  }

  late final _CFBagGetCountPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFBagRef)>>('CFBagGetCount');
  late final _CFBagGetCount =
      _CFBagGetCountPtr.asFunction<int Function(CFBagRef)>();

  int CFBagGetCountOfValue(
    CFBagRef theBag,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFBagGetCountOfValue(
      theBag,
      value,
    );
  }

  late final _CFBagGetCountOfValuePtr = _lookup<
          ffi
          .NativeFunction<CFIndex Function(CFBagRef, ffi.Pointer<ffi.Void>)>>(
      'CFBagGetCountOfValue');
  late final _CFBagGetCountOfValue = _CFBagGetCountOfValuePtr.asFunction<
      int Function(CFBagRef, ffi.Pointer<ffi.Void>)>();

  int CFBagContainsValue(
    CFBagRef theBag,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFBagContainsValue(
      theBag,
      value,
    );
  }

  late final _CFBagContainsValuePtr = _lookup<
          ffi
          .NativeFunction<Boolean Function(CFBagRef, ffi.Pointer<ffi.Void>)>>(
      'CFBagContainsValue');
  late final _CFBagContainsValue = _CFBagContainsValuePtr.asFunction<
      int Function(CFBagRef, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> CFBagGetValue(
    CFBagRef theBag,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFBagGetValue(
      theBag,
      value,
    );
  }

  late final _CFBagGetValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              CFBagRef, ffi.Pointer<ffi.Void>)>>('CFBagGetValue');
  late final _CFBagGetValue = _CFBagGetValuePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(CFBagRef, ffi.Pointer<ffi.Void>)>();

  int CFBagGetValueIfPresent(
    CFBagRef theBag,
    ffi.Pointer<ffi.Void> candidate,
    ffi.Pointer<ffi.Pointer<ffi.Void>> value,
  ) {
    return _CFBagGetValueIfPresent(
      theBag,
      candidate,
      value,
    );
  }

  late final _CFBagGetValueIfPresentPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFBagRef, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('CFBagGetValueIfPresent');
  late final _CFBagGetValueIfPresent = _CFBagGetValueIfPresentPtr.asFunction<
      int Function(CFBagRef, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  void CFBagGetValues(
    CFBagRef theBag,
    ffi.Pointer<ffi.Pointer<ffi.Void>> values,
  ) {
    return _CFBagGetValues(
      theBag,
      values,
    );
  }

  late final _CFBagGetValuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFBagRef, ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('CFBagGetValues');
  late final _CFBagGetValues = _CFBagGetValuesPtr.asFunction<
      void Function(CFBagRef, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  void CFBagApplyFunction(
    CFBagRef theBag,
    CFBagApplierFunction applier,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CFBagApplyFunction(
      theBag,
      applier,
      context,
    );
  }

  late final _CFBagApplyFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFBagRef, CFBagApplierFunction,
              ffi.Pointer<ffi.Void>)>>('CFBagApplyFunction');
  late final _CFBagApplyFunction = _CFBagApplyFunctionPtr.asFunction<
      void Function(CFBagRef, CFBagApplierFunction, ffi.Pointer<ffi.Void>)>();

  void CFBagAddValue(
    CFMutableBagRef theBag,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFBagAddValue(
      theBag,
      value,
    );
  }

  late final _CFBagAddValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableBagRef, ffi.Pointer<ffi.Void>)>>('CFBagAddValue');
  late final _CFBagAddValue = _CFBagAddValuePtr.asFunction<
      void Function(CFMutableBagRef, ffi.Pointer<ffi.Void>)>();

  void CFBagReplaceValue(
    CFMutableBagRef theBag,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFBagReplaceValue(
      theBag,
      value,
    );
  }

  late final _CFBagReplaceValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableBagRef, ffi.Pointer<ffi.Void>)>>('CFBagReplaceValue');
  late final _CFBagReplaceValue = _CFBagReplaceValuePtr.asFunction<
      void Function(CFMutableBagRef, ffi.Pointer<ffi.Void>)>();

  void CFBagSetValue(
    CFMutableBagRef theBag,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFBagSetValue(
      theBag,
      value,
    );
  }

  late final _CFBagSetValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableBagRef, ffi.Pointer<ffi.Void>)>>('CFBagSetValue');
  late final _CFBagSetValue = _CFBagSetValuePtr.asFunction<
      void Function(CFMutableBagRef, ffi.Pointer<ffi.Void>)>();

  void CFBagRemoveValue(
    CFMutableBagRef theBag,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFBagRemoveValue(
      theBag,
      value,
    );
  }

  late final _CFBagRemoveValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableBagRef, ffi.Pointer<ffi.Void>)>>('CFBagRemoveValue');
  late final _CFBagRemoveValue = _CFBagRemoveValuePtr.asFunction<
      void Function(CFMutableBagRef, ffi.Pointer<ffi.Void>)>();

  void CFBagRemoveAllValues(
    CFMutableBagRef theBag,
  ) {
    return _CFBagRemoveAllValues(
      theBag,
    );
  }

  late final _CFBagRemoveAllValuesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMutableBagRef)>>(
          'CFBagRemoveAllValues');
  late final _CFBagRemoveAllValues =
      _CFBagRemoveAllValuesPtr.asFunction<void Function(CFMutableBagRef)>();

  late final ffi.Pointer<CFBinaryHeapCallBacks> _kCFStringBinaryHeapCallBacks =
      _lookup<CFBinaryHeapCallBacks>('kCFStringBinaryHeapCallBacks');

  CFBinaryHeapCallBacks get kCFStringBinaryHeapCallBacks =>
      _kCFStringBinaryHeapCallBacks.ref;

  int CFBinaryHeapGetTypeID() {
    return _CFBinaryHeapGetTypeID();
  }

  late final _CFBinaryHeapGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFBinaryHeapGetTypeID');
  late final _CFBinaryHeapGetTypeID =
      _CFBinaryHeapGetTypeIDPtr.asFunction<int Function()>();

  CFBinaryHeapRef CFBinaryHeapCreate(
    CFAllocatorRef allocator,
    int capacity,
    ffi.Pointer<CFBinaryHeapCallBacks> callBacks,
    ffi.Pointer<CFBinaryHeapCompareContext> compareContext,
  ) {
    return _CFBinaryHeapCreate(
      allocator,
      capacity,
      callBacks,
      compareContext,
    );
  }

  late final _CFBinaryHeapCreatePtr = _lookup<
      ffi.NativeFunction<
          CFBinaryHeapRef Function(
              CFAllocatorRef,
              CFIndex,
              ffi.Pointer<CFBinaryHeapCallBacks>,
              ffi.Pointer<CFBinaryHeapCompareContext>)>>('CFBinaryHeapCreate');
  late final _CFBinaryHeapCreate = _CFBinaryHeapCreatePtr.asFunction<
      CFBinaryHeapRef Function(
          CFAllocatorRef,
          int,
          ffi.Pointer<CFBinaryHeapCallBacks>,
          ffi.Pointer<CFBinaryHeapCompareContext>)>();

  CFBinaryHeapRef CFBinaryHeapCreateCopy(
    CFAllocatorRef allocator,
    int capacity,
    CFBinaryHeapRef heap,
  ) {
    return _CFBinaryHeapCreateCopy(
      allocator,
      capacity,
      heap,
    );
  }

  late final _CFBinaryHeapCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          CFBinaryHeapRef Function(CFAllocatorRef, CFIndex,
              CFBinaryHeapRef)>>('CFBinaryHeapCreateCopy');
  late final _CFBinaryHeapCreateCopy = _CFBinaryHeapCreateCopyPtr.asFunction<
      CFBinaryHeapRef Function(CFAllocatorRef, int, CFBinaryHeapRef)>();

  int CFBinaryHeapGetCount(
    CFBinaryHeapRef heap,
  ) {
    return _CFBinaryHeapGetCount(
      heap,
    );
  }

  late final _CFBinaryHeapGetCountPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFBinaryHeapRef)>>(
          'CFBinaryHeapGetCount');
  late final _CFBinaryHeapGetCount =
      _CFBinaryHeapGetCountPtr.asFunction<int Function(CFBinaryHeapRef)>();

  int CFBinaryHeapGetCountOfValue(
    CFBinaryHeapRef heap,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFBinaryHeapGetCountOfValue(
      heap,
      value,
    );
  }

  late final _CFBinaryHeapGetCountOfValuePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFBinaryHeapRef,
              ffi.Pointer<ffi.Void>)>>('CFBinaryHeapGetCountOfValue');
  late final _CFBinaryHeapGetCountOfValue = _CFBinaryHeapGetCountOfValuePtr
      .asFunction<int Function(CFBinaryHeapRef, ffi.Pointer<ffi.Void>)>();

  int CFBinaryHeapContainsValue(
    CFBinaryHeapRef heap,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFBinaryHeapContainsValue(
      heap,
      value,
    );
  }

  late final _CFBinaryHeapContainsValuePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFBinaryHeapRef,
              ffi.Pointer<ffi.Void>)>>('CFBinaryHeapContainsValue');
  late final _CFBinaryHeapContainsValue = _CFBinaryHeapContainsValuePtr
      .asFunction<int Function(CFBinaryHeapRef, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> CFBinaryHeapGetMinimum(
    CFBinaryHeapRef heap,
  ) {
    return _CFBinaryHeapGetMinimum(
      heap,
    );
  }

  late final _CFBinaryHeapGetMinimumPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(CFBinaryHeapRef)>>(
      'CFBinaryHeapGetMinimum');
  late final _CFBinaryHeapGetMinimum = _CFBinaryHeapGetMinimumPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(CFBinaryHeapRef)>();

  int CFBinaryHeapGetMinimumIfPresent(
    CFBinaryHeapRef heap,
    ffi.Pointer<ffi.Pointer<ffi.Void>> value,
  ) {
    return _CFBinaryHeapGetMinimumIfPresent(
      heap,
      value,
    );
  }

  late final _CFBinaryHeapGetMinimumIfPresentPtr = _lookup<
          ffi.NativeFunction<
              Boolean Function(
                  CFBinaryHeapRef, ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'CFBinaryHeapGetMinimumIfPresent');
  late final _CFBinaryHeapGetMinimumIfPresent =
      _CFBinaryHeapGetMinimumIfPresentPtr.asFunction<
          int Function(CFBinaryHeapRef, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  void CFBinaryHeapGetValues(
    CFBinaryHeapRef heap,
    ffi.Pointer<ffi.Pointer<ffi.Void>> values,
  ) {
    return _CFBinaryHeapGetValues(
      heap,
      values,
    );
  }

  late final _CFBinaryHeapGetValuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFBinaryHeapRef,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('CFBinaryHeapGetValues');
  late final _CFBinaryHeapGetValues = _CFBinaryHeapGetValuesPtr.asFunction<
      void Function(CFBinaryHeapRef, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  void CFBinaryHeapApplyFunction(
    CFBinaryHeapRef heap,
    CFBinaryHeapApplierFunction applier,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CFBinaryHeapApplyFunction(
      heap,
      applier,
      context,
    );
  }

  late final _CFBinaryHeapApplyFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFBinaryHeapRef, CFBinaryHeapApplierFunction,
              ffi.Pointer<ffi.Void>)>>('CFBinaryHeapApplyFunction');
  late final _CFBinaryHeapApplyFunction =
      _CFBinaryHeapApplyFunctionPtr.asFunction<
          void Function(CFBinaryHeapRef, CFBinaryHeapApplierFunction,
              ffi.Pointer<ffi.Void>)>();

  void CFBinaryHeapAddValue(
    CFBinaryHeapRef heap,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFBinaryHeapAddValue(
      heap,
      value,
    );
  }

  late final _CFBinaryHeapAddValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFBinaryHeapRef, ffi.Pointer<ffi.Void>)>>('CFBinaryHeapAddValue');
  late final _CFBinaryHeapAddValue = _CFBinaryHeapAddValuePtr.asFunction<
      void Function(CFBinaryHeapRef, ffi.Pointer<ffi.Void>)>();

  void CFBinaryHeapRemoveMinimumValue(
    CFBinaryHeapRef heap,
  ) {
    return _CFBinaryHeapRemoveMinimumValue(
      heap,
    );
  }

  late final _CFBinaryHeapRemoveMinimumValuePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFBinaryHeapRef)>>(
          'CFBinaryHeapRemoveMinimumValue');
  late final _CFBinaryHeapRemoveMinimumValue =
      _CFBinaryHeapRemoveMinimumValuePtr.asFunction<
          void Function(CFBinaryHeapRef)>();

  void CFBinaryHeapRemoveAllValues(
    CFBinaryHeapRef heap,
  ) {
    return _CFBinaryHeapRemoveAllValues(
      heap,
    );
  }

  late final _CFBinaryHeapRemoveAllValuesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFBinaryHeapRef)>>(
          'CFBinaryHeapRemoveAllValues');
  late final _CFBinaryHeapRemoveAllValues = _CFBinaryHeapRemoveAllValuesPtr
      .asFunction<void Function(CFBinaryHeapRef)>();

  int CFBitVectorGetTypeID() {
    return _CFBitVectorGetTypeID();
  }

  late final _CFBitVectorGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFBitVectorGetTypeID');
  late final _CFBitVectorGetTypeID =
      _CFBitVectorGetTypeIDPtr.asFunction<int Function()>();

  CFBitVectorRef CFBitVectorCreate(
    CFAllocatorRef allocator,
    ffi.Pointer<UInt8> bytes,
    int numBits,
  ) {
    return _CFBitVectorCreate(
      allocator,
      bytes,
      numBits,
    );
  }

  late final _CFBitVectorCreatePtr = _lookup<
      ffi.NativeFunction<
          CFBitVectorRef Function(CFAllocatorRef, ffi.Pointer<UInt8>,
              CFIndex)>>('CFBitVectorCreate');
  late final _CFBitVectorCreate = _CFBitVectorCreatePtr.asFunction<
      CFBitVectorRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, int)>();

  CFBitVectorRef CFBitVectorCreateCopy(
    CFAllocatorRef allocator,
    CFBitVectorRef bv,
  ) {
    return _CFBitVectorCreateCopy(
      allocator,
      bv,
    );
  }

  late final _CFBitVectorCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          CFBitVectorRef Function(
              CFAllocatorRef, CFBitVectorRef)>>('CFBitVectorCreateCopy');
  late final _CFBitVectorCreateCopy = _CFBitVectorCreateCopyPtr.asFunction<
      CFBitVectorRef Function(CFAllocatorRef, CFBitVectorRef)>();

  CFMutableBitVectorRef CFBitVectorCreateMutable(
    CFAllocatorRef allocator,
    int capacity,
  ) {
    return _CFBitVectorCreateMutable(
      allocator,
      capacity,
    );
  }

  late final _CFBitVectorCreateMutablePtr = _lookup<
      ffi.NativeFunction<
          CFMutableBitVectorRef Function(
              CFAllocatorRef, CFIndex)>>('CFBitVectorCreateMutable');
  late final _CFBitVectorCreateMutable = _CFBitVectorCreateMutablePtr
      .asFunction<CFMutableBitVectorRef Function(CFAllocatorRef, int)>();

  CFMutableBitVectorRef CFBitVectorCreateMutableCopy(
    CFAllocatorRef allocator,
    int capacity,
    CFBitVectorRef bv,
  ) {
    return _CFBitVectorCreateMutableCopy(
      allocator,
      capacity,
      bv,
    );
  }

  late final _CFBitVectorCreateMutableCopyPtr = _lookup<
      ffi.NativeFunction<
          CFMutableBitVectorRef Function(CFAllocatorRef, CFIndex,
              CFBitVectorRef)>>('CFBitVectorCreateMutableCopy');
  late final _CFBitVectorCreateMutableCopy =
      _CFBitVectorCreateMutableCopyPtr.asFunction<
          CFMutableBitVectorRef Function(
              CFAllocatorRef, int, CFBitVectorRef)>();

  int CFBitVectorGetCount(
    CFBitVectorRef bv,
  ) {
    return _CFBitVectorGetCount(
      bv,
    );
  }

  late final _CFBitVectorGetCountPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFBitVectorRef)>>(
          'CFBitVectorGetCount');
  late final _CFBitVectorGetCount =
      _CFBitVectorGetCountPtr.asFunction<int Function(CFBitVectorRef)>();

  int CFBitVectorGetCountOfBit(
    CFBitVectorRef bv,
    CFRange range,
    int value,
  ) {
    return _CFBitVectorGetCountOfBit(
      bv,
      range,
      value,
    );
  }

  late final _CFBitVectorGetCountOfBitPtr = _lookup<
          ffi.NativeFunction<CFIndex Function(CFBitVectorRef, CFRange, CFBit)>>(
      'CFBitVectorGetCountOfBit');
  late final _CFBitVectorGetCountOfBit = _CFBitVectorGetCountOfBitPtr
      .asFunction<int Function(CFBitVectorRef, CFRange, int)>();

  int CFBitVectorContainsBit(
    CFBitVectorRef bv,
    CFRange range,
    int value,
  ) {
    return _CFBitVectorContainsBit(
      bv,
      range,
      value,
    );
  }

  late final _CFBitVectorContainsBitPtr = _lookup<
          ffi.NativeFunction<Boolean Function(CFBitVectorRef, CFRange, CFBit)>>(
      'CFBitVectorContainsBit');
  late final _CFBitVectorContainsBit = _CFBitVectorContainsBitPtr.asFunction<
      int Function(CFBitVectorRef, CFRange, int)>();

  int CFBitVectorGetBitAtIndex(
    CFBitVectorRef bv,
    int idx,
  ) {
    return _CFBitVectorGetBitAtIndex(
      bv,
      idx,
    );
  }

  late final _CFBitVectorGetBitAtIndexPtr =
      _lookup<ffi.NativeFunction<CFBit Function(CFBitVectorRef, CFIndex)>>(
          'CFBitVectorGetBitAtIndex');
  late final _CFBitVectorGetBitAtIndex = _CFBitVectorGetBitAtIndexPtr
      .asFunction<int Function(CFBitVectorRef, int)>();

  void CFBitVectorGetBits(
    CFBitVectorRef bv,
    CFRange range,
    ffi.Pointer<UInt8> bytes,
  ) {
    return _CFBitVectorGetBits(
      bv,
      range,
      bytes,
    );
  }

  late final _CFBitVectorGetBitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFBitVectorRef, CFRange,
              ffi.Pointer<UInt8>)>>('CFBitVectorGetBits');
  late final _CFBitVectorGetBits = _CFBitVectorGetBitsPtr.asFunction<
      void Function(CFBitVectorRef, CFRange, ffi.Pointer<UInt8>)>();

  int CFBitVectorGetFirstIndexOfBit(
    CFBitVectorRef bv,
    CFRange range,
    int value,
  ) {
    return _CFBitVectorGetFirstIndexOfBit(
      bv,
      range,
      value,
    );
  }

  late final _CFBitVectorGetFirstIndexOfBitPtr = _lookup<
          ffi.NativeFunction<CFIndex Function(CFBitVectorRef, CFRange, CFBit)>>(
      'CFBitVectorGetFirstIndexOfBit');
  late final _CFBitVectorGetFirstIndexOfBit = _CFBitVectorGetFirstIndexOfBitPtr
      .asFunction<int Function(CFBitVectorRef, CFRange, int)>();

  int CFBitVectorGetLastIndexOfBit(
    CFBitVectorRef bv,
    CFRange range,
    int value,
  ) {
    return _CFBitVectorGetLastIndexOfBit(
      bv,
      range,
      value,
    );
  }

  late final _CFBitVectorGetLastIndexOfBitPtr = _lookup<
          ffi.NativeFunction<CFIndex Function(CFBitVectorRef, CFRange, CFBit)>>(
      'CFBitVectorGetLastIndexOfBit');
  late final _CFBitVectorGetLastIndexOfBit = _CFBitVectorGetLastIndexOfBitPtr
      .asFunction<int Function(CFBitVectorRef, CFRange, int)>();

  void CFBitVectorSetCount(
    CFMutableBitVectorRef bv,
    int count,
  ) {
    return _CFBitVectorSetCount(
      bv,
      count,
    );
  }

  late final _CFBitVectorSetCountPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(CFMutableBitVectorRef, CFIndex)>>(
      'CFBitVectorSetCount');
  late final _CFBitVectorSetCount = _CFBitVectorSetCountPtr.asFunction<
      void Function(CFMutableBitVectorRef, int)>();

  void CFBitVectorFlipBitAtIndex(
    CFMutableBitVectorRef bv,
    int idx,
  ) {
    return _CFBitVectorFlipBitAtIndex(
      bv,
      idx,
    );
  }

  late final _CFBitVectorFlipBitAtIndexPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(CFMutableBitVectorRef, CFIndex)>>(
      'CFBitVectorFlipBitAtIndex');
  late final _CFBitVectorFlipBitAtIndex = _CFBitVectorFlipBitAtIndexPtr
      .asFunction<void Function(CFMutableBitVectorRef, int)>();

  void CFBitVectorFlipBits(
    CFMutableBitVectorRef bv,
    CFRange range,
  ) {
    return _CFBitVectorFlipBits(
      bv,
      range,
    );
  }

  late final _CFBitVectorFlipBitsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(CFMutableBitVectorRef, CFRange)>>(
      'CFBitVectorFlipBits');
  late final _CFBitVectorFlipBits = _CFBitVectorFlipBitsPtr.asFunction<
      void Function(CFMutableBitVectorRef, CFRange)>();

  void CFBitVectorSetBitAtIndex(
    CFMutableBitVectorRef bv,
    int idx,
    int value,
  ) {
    return _CFBitVectorSetBitAtIndex(
      bv,
      idx,
      value,
    );
  }

  late final _CFBitVectorSetBitAtIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableBitVectorRef, CFIndex,
              CFBit)>>('CFBitVectorSetBitAtIndex');
  late final _CFBitVectorSetBitAtIndex = _CFBitVectorSetBitAtIndexPtr
      .asFunction<void Function(CFMutableBitVectorRef, int, int)>();

  void CFBitVectorSetBits(
    CFMutableBitVectorRef bv,
    CFRange range,
    int value,
  ) {
    return _CFBitVectorSetBits(
      bv,
      range,
      value,
    );
  }

  late final _CFBitVectorSetBitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableBitVectorRef, CFRange, CFBit)>>('CFBitVectorSetBits');
  late final _CFBitVectorSetBits = _CFBitVectorSetBitsPtr.asFunction<
      void Function(CFMutableBitVectorRef, CFRange, int)>();

  void CFBitVectorSetAllBits(
    CFMutableBitVectorRef bv,
    int value,
  ) {
    return _CFBitVectorSetAllBits(
      bv,
      value,
    );
  }

  late final _CFBitVectorSetAllBitsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFMutableBitVectorRef, CFBit)>>(
      'CFBitVectorSetAllBits');
  late final _CFBitVectorSetAllBits = _CFBitVectorSetAllBitsPtr.asFunction<
      void Function(CFMutableBitVectorRef, int)>();

  late final ffi.Pointer<CFDictionaryKeyCallBacks>
      _kCFTypeDictionaryKeyCallBacks =
      _lookup<CFDictionaryKeyCallBacks>('kCFTypeDictionaryKeyCallBacks');

  CFDictionaryKeyCallBacks get kCFTypeDictionaryKeyCallBacks =>
      _kCFTypeDictionaryKeyCallBacks.ref;

  late final ffi.Pointer<CFDictionaryKeyCallBacks>
      _kCFCopyStringDictionaryKeyCallBacks =
      _lookup<CFDictionaryKeyCallBacks>('kCFCopyStringDictionaryKeyCallBacks');

  CFDictionaryKeyCallBacks get kCFCopyStringDictionaryKeyCallBacks =>
      _kCFCopyStringDictionaryKeyCallBacks.ref;

  late final ffi.Pointer<CFDictionaryValueCallBacks>
      _kCFTypeDictionaryValueCallBacks =
      _lookup<CFDictionaryValueCallBacks>('kCFTypeDictionaryValueCallBacks');

  CFDictionaryValueCallBacks get kCFTypeDictionaryValueCallBacks =>
      _kCFTypeDictionaryValueCallBacks.ref;

  int CFDictionaryGetTypeID() {
    return _CFDictionaryGetTypeID();
  }

  late final _CFDictionaryGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFDictionaryGetTypeID');
  late final _CFDictionaryGetTypeID =
      _CFDictionaryGetTypeIDPtr.asFunction<int Function()>();

  CFDictionaryRef CFDictionaryCreate(
    CFAllocatorRef allocator,
    ffi.Pointer<ffi.Pointer<ffi.Void>> keys,
    ffi.Pointer<ffi.Pointer<ffi.Void>> values,
    int numValues,
    ffi.Pointer<CFDictionaryKeyCallBacks> keyCallBacks,
    ffi.Pointer<CFDictionaryValueCallBacks> valueCallBacks,
  ) {
    return _CFDictionaryCreate(
      allocator,
      keys,
      values,
      numValues,
      keyCallBacks,
      valueCallBacks,
    );
  }

  late final _CFDictionaryCreatePtr = _lookup<
      ffi.NativeFunction<
          CFDictionaryRef Function(
              CFAllocatorRef,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              CFIndex,
              ffi.Pointer<CFDictionaryKeyCallBacks>,
              ffi.Pointer<CFDictionaryValueCallBacks>)>>('CFDictionaryCreate');
  late final _CFDictionaryCreate = _CFDictionaryCreatePtr.asFunction<
      CFDictionaryRef Function(
          CFAllocatorRef,
          ffi.Pointer<ffi.Pointer<ffi.Void>>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>,
          int,
          ffi.Pointer<CFDictionaryKeyCallBacks>,
          ffi.Pointer<CFDictionaryValueCallBacks>)>();

  CFDictionaryRef CFDictionaryCreateCopy(
    CFAllocatorRef allocator,
    CFDictionaryRef theDict,
  ) {
    return _CFDictionaryCreateCopy(
      allocator,
      theDict,
    );
  }

  late final _CFDictionaryCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          CFDictionaryRef Function(
              CFAllocatorRef, CFDictionaryRef)>>('CFDictionaryCreateCopy');
  late final _CFDictionaryCreateCopy = _CFDictionaryCreateCopyPtr.asFunction<
      CFDictionaryRef Function(CFAllocatorRef, CFDictionaryRef)>();

  CFMutableDictionaryRef CFDictionaryCreateMutable(
    CFAllocatorRef allocator,
    int capacity,
    ffi.Pointer<CFDictionaryKeyCallBacks> keyCallBacks,
    ffi.Pointer<CFDictionaryValueCallBacks> valueCallBacks,
  ) {
    return _CFDictionaryCreateMutable(
      allocator,
      capacity,
      keyCallBacks,
      valueCallBacks,
    );
  }

  late final _CFDictionaryCreateMutablePtr = _lookup<
          ffi.NativeFunction<
              CFMutableDictionaryRef Function(
                  CFAllocatorRef,
                  CFIndex,
                  ffi.Pointer<CFDictionaryKeyCallBacks>,
                  ffi.Pointer<CFDictionaryValueCallBacks>)>>(
      'CFDictionaryCreateMutable');
  late final _CFDictionaryCreateMutable =
      _CFDictionaryCreateMutablePtr.asFunction<
          CFMutableDictionaryRef Function(
              CFAllocatorRef,
              int,
              ffi.Pointer<CFDictionaryKeyCallBacks>,
              ffi.Pointer<CFDictionaryValueCallBacks>)>();

  CFMutableDictionaryRef CFDictionaryCreateMutableCopy(
    CFAllocatorRef allocator,
    int capacity,
    CFDictionaryRef theDict,
  ) {
    return _CFDictionaryCreateMutableCopy(
      allocator,
      capacity,
      theDict,
    );
  }

  late final _CFDictionaryCreateMutableCopyPtr = _lookup<
      ffi.NativeFunction<
          CFMutableDictionaryRef Function(CFAllocatorRef, CFIndex,
              CFDictionaryRef)>>('CFDictionaryCreateMutableCopy');
  late final _CFDictionaryCreateMutableCopy =
      _CFDictionaryCreateMutableCopyPtr.asFunction<
          CFMutableDictionaryRef Function(
              CFAllocatorRef, int, CFDictionaryRef)>();

  int CFDictionaryGetCount(
    CFDictionaryRef theDict,
  ) {
    return _CFDictionaryGetCount(
      theDict,
    );
  }

  late final _CFDictionaryGetCountPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFDictionaryRef)>>(
          'CFDictionaryGetCount');
  late final _CFDictionaryGetCount =
      _CFDictionaryGetCountPtr.asFunction<int Function(CFDictionaryRef)>();

  int CFDictionaryGetCountOfKey(
    CFDictionaryRef theDict,
    ffi.Pointer<ffi.Void> key,
  ) {
    return _CFDictionaryGetCountOfKey(
      theDict,
      key,
    );
  }

  late final _CFDictionaryGetCountOfKeyPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFDictionaryRef,
              ffi.Pointer<ffi.Void>)>>('CFDictionaryGetCountOfKey');
  late final _CFDictionaryGetCountOfKey = _CFDictionaryGetCountOfKeyPtr
      .asFunction<int Function(CFDictionaryRef, ffi.Pointer<ffi.Void>)>();

  int CFDictionaryGetCountOfValue(
    CFDictionaryRef theDict,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFDictionaryGetCountOfValue(
      theDict,
      value,
    );
  }

  late final _CFDictionaryGetCountOfValuePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFDictionaryRef,
              ffi.Pointer<ffi.Void>)>>('CFDictionaryGetCountOfValue');
  late final _CFDictionaryGetCountOfValue = _CFDictionaryGetCountOfValuePtr
      .asFunction<int Function(CFDictionaryRef, ffi.Pointer<ffi.Void>)>();

  int CFDictionaryContainsKey(
    CFDictionaryRef theDict,
    ffi.Pointer<ffi.Void> key,
  ) {
    return _CFDictionaryContainsKey(
      theDict,
      key,
    );
  }

  late final _CFDictionaryContainsKeyPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFDictionaryRef,
              ffi.Pointer<ffi.Void>)>>('CFDictionaryContainsKey');
  late final _CFDictionaryContainsKey = _CFDictionaryContainsKeyPtr.asFunction<
      int Function(CFDictionaryRef, ffi.Pointer<ffi.Void>)>();

  int CFDictionaryContainsValue(
    CFDictionaryRef theDict,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFDictionaryContainsValue(
      theDict,
      value,
    );
  }

  late final _CFDictionaryContainsValuePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFDictionaryRef,
              ffi.Pointer<ffi.Void>)>>('CFDictionaryContainsValue');
  late final _CFDictionaryContainsValue = _CFDictionaryContainsValuePtr
      .asFunction<int Function(CFDictionaryRef, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> CFDictionaryGetValue(
    CFDictionaryRef theDict,
    ffi.Pointer<ffi.Void> key,
  ) {
    return _CFDictionaryGetValue(
      theDict,
      key,
    );
  }

  late final _CFDictionaryGetValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              CFDictionaryRef, ffi.Pointer<ffi.Void>)>>('CFDictionaryGetValue');
  late final _CFDictionaryGetValue = _CFDictionaryGetValuePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(CFDictionaryRef, ffi.Pointer<ffi.Void>)>();

  int CFDictionaryGetValueIfPresent(
    CFDictionaryRef theDict,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Pointer<ffi.Void>> value,
  ) {
    return _CFDictionaryGetValueIfPresent(
      theDict,
      key,
      value,
    );
  }

  late final _CFDictionaryGetValueIfPresentPtr = _lookup<
          ffi.NativeFunction<
              Boolean Function(CFDictionaryRef, ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'CFDictionaryGetValueIfPresent');
  late final _CFDictionaryGetValueIfPresent =
      _CFDictionaryGetValueIfPresentPtr.asFunction<
          int Function(CFDictionaryRef, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  void CFDictionaryGetKeysAndValues(
    CFDictionaryRef theDict,
    ffi.Pointer<ffi.Pointer<ffi.Void>> keys,
    ffi.Pointer<ffi.Pointer<ffi.Void>> values,
  ) {
    return _CFDictionaryGetKeysAndValues(
      theDict,
      keys,
      values,
    );
  }

  late final _CFDictionaryGetKeysAndValuesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  CFDictionaryRef,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'CFDictionaryGetKeysAndValues');
  late final _CFDictionaryGetKeysAndValues =
      _CFDictionaryGetKeysAndValuesPtr.asFunction<
          void Function(CFDictionaryRef, ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  void CFDictionaryApplyFunction(
    CFDictionaryRef theDict,
    CFDictionaryApplierFunction applier,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CFDictionaryApplyFunction(
      theDict,
      applier,
      context,
    );
  }

  late final _CFDictionaryApplyFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFDictionaryRef, CFDictionaryApplierFunction,
              ffi.Pointer<ffi.Void>)>>('CFDictionaryApplyFunction');
  late final _CFDictionaryApplyFunction =
      _CFDictionaryApplyFunctionPtr.asFunction<
          void Function(CFDictionaryRef, CFDictionaryApplierFunction,
              ffi.Pointer<ffi.Void>)>();

  void CFDictionaryAddValue(
    CFMutableDictionaryRef theDict,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFDictionaryAddValue(
      theDict,
      key,
      value,
    );
  }

  late final _CFDictionaryAddValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableDictionaryRef, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('CFDictionaryAddValue');
  late final _CFDictionaryAddValue = _CFDictionaryAddValuePtr.asFunction<
      void Function(CFMutableDictionaryRef, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>)>();

  void CFDictionarySetValue(
    CFMutableDictionaryRef theDict,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFDictionarySetValue(
      theDict,
      key,
      value,
    );
  }

  late final _CFDictionarySetValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableDictionaryRef, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('CFDictionarySetValue');
  late final _CFDictionarySetValue = _CFDictionarySetValuePtr.asFunction<
      void Function(CFMutableDictionaryRef, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>)>();

  void CFDictionaryReplaceValue(
    CFMutableDictionaryRef theDict,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFDictionaryReplaceValue(
      theDict,
      key,
      value,
    );
  }

  late final _CFDictionaryReplaceValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableDictionaryRef, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('CFDictionaryReplaceValue');
  late final _CFDictionaryReplaceValue =
      _CFDictionaryReplaceValuePtr.asFunction<
          void Function(CFMutableDictionaryRef, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  void CFDictionaryRemoveValue(
    CFMutableDictionaryRef theDict,
    ffi.Pointer<ffi.Void> key,
  ) {
    return _CFDictionaryRemoveValue(
      theDict,
      key,
    );
  }

  late final _CFDictionaryRemoveValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableDictionaryRef,
              ffi.Pointer<ffi.Void>)>>('CFDictionaryRemoveValue');
  late final _CFDictionaryRemoveValue = _CFDictionaryRemoveValuePtr.asFunction<
      void Function(CFMutableDictionaryRef, ffi.Pointer<ffi.Void>)>();

  void CFDictionaryRemoveAllValues(
    CFMutableDictionaryRef theDict,
  ) {
    return _CFDictionaryRemoveAllValues(
      theDict,
    );
  }

  late final _CFDictionaryRemoveAllValuesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMutableDictionaryRef)>>(
          'CFDictionaryRemoveAllValues');
  late final _CFDictionaryRemoveAllValues = _CFDictionaryRemoveAllValuesPtr
      .asFunction<void Function(CFMutableDictionaryRef)>();

  int CFNotificationCenterGetTypeID() {
    return _CFNotificationCenterGetTypeID();
  }

  late final _CFNotificationCenterGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFNotificationCenterGetTypeID');
  late final _CFNotificationCenterGetTypeID =
      _CFNotificationCenterGetTypeIDPtr.asFunction<int Function()>();

  CFNotificationCenterRef CFNotificationCenterGetLocalCenter() {
    return _CFNotificationCenterGetLocalCenter();
  }

  late final _CFNotificationCenterGetLocalCenterPtr =
      _lookup<ffi.NativeFunction<CFNotificationCenterRef Function()>>(
          'CFNotificationCenterGetLocalCenter');
  late final _CFNotificationCenterGetLocalCenter =
      _CFNotificationCenterGetLocalCenterPtr.asFunction<
          CFNotificationCenterRef Function()>();

  CFNotificationCenterRef CFNotificationCenterGetDistributedCenter() {
    return _CFNotificationCenterGetDistributedCenter();
  }

  late final _CFNotificationCenterGetDistributedCenterPtr =
      _lookup<ffi.NativeFunction<CFNotificationCenterRef Function()>>(
          'CFNotificationCenterGetDistributedCenter');
  late final _CFNotificationCenterGetDistributedCenter =
      _CFNotificationCenterGetDistributedCenterPtr.asFunction<
          CFNotificationCenterRef Function()>();

  CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter() {
    return _CFNotificationCenterGetDarwinNotifyCenter();
  }

  late final _CFNotificationCenterGetDarwinNotifyCenterPtr =
      _lookup<ffi.NativeFunction<CFNotificationCenterRef Function()>>(
          'CFNotificationCenterGetDarwinNotifyCenter');
  late final _CFNotificationCenterGetDarwinNotifyCenter =
      _CFNotificationCenterGetDarwinNotifyCenterPtr.asFunction<
          CFNotificationCenterRef Function()>();

  void CFNotificationCenterAddObserver(
    CFNotificationCenterRef center,
    ffi.Pointer<ffi.Void> observer,
    CFNotificationCallback callBack,
    CFStringRef name,
    ffi.Pointer<ffi.Void> object,
    CFNotificationSuspensionBehavior suspensionBehavior,
  ) {
    return _CFNotificationCenterAddObserver(
      center,
      observer,
      callBack,
      name,
      object,
      suspensionBehavior.value,
    );
  }

  late final _CFNotificationCenterAddObserverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFNotificationCenterRef,
              ffi.Pointer<ffi.Void>,
              CFNotificationCallback,
              CFStringRef,
              ffi.Pointer<ffi.Void>,
              CFIndex)>>('CFNotificationCenterAddObserver');
  late final _CFNotificationCenterAddObserver =
      _CFNotificationCenterAddObserverPtr.asFunction<
          void Function(
              CFNotificationCenterRef,
              ffi.Pointer<ffi.Void>,
              CFNotificationCallback,
              CFStringRef,
              ffi.Pointer<ffi.Void>,
              int)>();

  void CFNotificationCenterRemoveObserver(
    CFNotificationCenterRef center,
    ffi.Pointer<ffi.Void> observer,
    CFNotificationName name,
    ffi.Pointer<ffi.Void> object,
  ) {
    return _CFNotificationCenterRemoveObserver(
      center,
      observer,
      name,
      object,
    );
  }

  late final _CFNotificationCenterRemoveObserverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFNotificationCenterRef,
              ffi.Pointer<ffi.Void>,
              CFNotificationName,
              ffi.Pointer<ffi.Void>)>>('CFNotificationCenterRemoveObserver');
  late final _CFNotificationCenterRemoveObserver =
      _CFNotificationCenterRemoveObserverPtr.asFunction<
          void Function(CFNotificationCenterRef, ffi.Pointer<ffi.Void>,
              CFNotificationName, ffi.Pointer<ffi.Void>)>();

  void CFNotificationCenterRemoveEveryObserver(
    CFNotificationCenterRef center,
    ffi.Pointer<ffi.Void> observer,
  ) {
    return _CFNotificationCenterRemoveEveryObserver(
      center,
      observer,
    );
  }

  late final _CFNotificationCenterRemoveEveryObserverPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  CFNotificationCenterRef, ffi.Pointer<ffi.Void>)>>(
      'CFNotificationCenterRemoveEveryObserver');
  late final _CFNotificationCenterRemoveEveryObserver =
      _CFNotificationCenterRemoveEveryObserverPtr.asFunction<
          void Function(CFNotificationCenterRef, ffi.Pointer<ffi.Void>)>();

  void CFNotificationCenterPostNotification(
    CFNotificationCenterRef center,
    CFNotificationName name,
    ffi.Pointer<ffi.Void> object,
    CFDictionaryRef userInfo,
    int deliverImmediately,
  ) {
    return _CFNotificationCenterPostNotification(
      center,
      name,
      object,
      userInfo,
      deliverImmediately,
    );
  }

  late final _CFNotificationCenterPostNotificationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFNotificationCenterRef,
              CFNotificationName,
              ffi.Pointer<ffi.Void>,
              CFDictionaryRef,
              Boolean)>>('CFNotificationCenterPostNotification');
  late final _CFNotificationCenterPostNotification =
      _CFNotificationCenterPostNotificationPtr.asFunction<
          void Function(CFNotificationCenterRef, CFNotificationName,
              ffi.Pointer<ffi.Void>, CFDictionaryRef, int)>();

  void CFNotificationCenterPostNotificationWithOptions(
    CFNotificationCenterRef center,
    CFNotificationName name,
    ffi.Pointer<ffi.Void> object,
    CFDictionaryRef userInfo,
    int options,
  ) {
    return _CFNotificationCenterPostNotificationWithOptions(
      center,
      name,
      object,
      userInfo,
      options,
    );
  }

  late final _CFNotificationCenterPostNotificationWithOptionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(CFNotificationCenterRef, CFNotificationName,
                  ffi.Pointer<ffi.Void>, CFDictionaryRef, CFOptionFlags)>>(
      'CFNotificationCenterPostNotificationWithOptions');
  late final _CFNotificationCenterPostNotificationWithOptions =
      _CFNotificationCenterPostNotificationWithOptionsPtr.asFunction<
          void Function(CFNotificationCenterRef, CFNotificationName,
              ffi.Pointer<ffi.Void>, CFDictionaryRef, int)>();

  int CFLocaleGetTypeID() {
    return _CFLocaleGetTypeID();
  }

  late final _CFLocaleGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFLocaleGetTypeID');
  late final _CFLocaleGetTypeID =
      _CFLocaleGetTypeIDPtr.asFunction<int Function()>();

  CFLocaleRef CFLocaleGetSystem() {
    return _CFLocaleGetSystem();
  }

  late final _CFLocaleGetSystemPtr =
      _lookup<ffi.NativeFunction<CFLocaleRef Function()>>('CFLocaleGetSystem');
  late final _CFLocaleGetSystem =
      _CFLocaleGetSystemPtr.asFunction<CFLocaleRef Function()>();

  CFLocaleRef CFLocaleCopyCurrent() {
    return _CFLocaleCopyCurrent();
  }

  late final _CFLocaleCopyCurrentPtr =
      _lookup<ffi.NativeFunction<CFLocaleRef Function()>>(
          'CFLocaleCopyCurrent');
  late final _CFLocaleCopyCurrent =
      _CFLocaleCopyCurrentPtr.asFunction<CFLocaleRef Function()>();

  CFArrayRef CFLocaleCopyAvailableLocaleIdentifiers() {
    return _CFLocaleCopyAvailableLocaleIdentifiers();
  }

  late final _CFLocaleCopyAvailableLocaleIdentifiersPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function()>>(
          'CFLocaleCopyAvailableLocaleIdentifiers');
  late final _CFLocaleCopyAvailableLocaleIdentifiers =
      _CFLocaleCopyAvailableLocaleIdentifiersPtr.asFunction<
          CFArrayRef Function()>();

  CFArrayRef CFLocaleCopyISOLanguageCodes() {
    return _CFLocaleCopyISOLanguageCodes();
  }

  late final _CFLocaleCopyISOLanguageCodesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function()>>(
          'CFLocaleCopyISOLanguageCodes');
  late final _CFLocaleCopyISOLanguageCodes =
      _CFLocaleCopyISOLanguageCodesPtr.asFunction<CFArrayRef Function()>();

  CFArrayRef CFLocaleCopyISOCountryCodes() {
    return _CFLocaleCopyISOCountryCodes();
  }

  late final _CFLocaleCopyISOCountryCodesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function()>>(
          'CFLocaleCopyISOCountryCodes');
  late final _CFLocaleCopyISOCountryCodes =
      _CFLocaleCopyISOCountryCodesPtr.asFunction<CFArrayRef Function()>();

  CFArrayRef CFLocaleCopyISOCurrencyCodes() {
    return _CFLocaleCopyISOCurrencyCodes();
  }

  late final _CFLocaleCopyISOCurrencyCodesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function()>>(
          'CFLocaleCopyISOCurrencyCodes');
  late final _CFLocaleCopyISOCurrencyCodes =
      _CFLocaleCopyISOCurrencyCodesPtr.asFunction<CFArrayRef Function()>();

  CFArrayRef CFLocaleCopyCommonISOCurrencyCodes() {
    return _CFLocaleCopyCommonISOCurrencyCodes();
  }

  late final _CFLocaleCopyCommonISOCurrencyCodesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function()>>(
          'CFLocaleCopyCommonISOCurrencyCodes');
  late final _CFLocaleCopyCommonISOCurrencyCodes =
      _CFLocaleCopyCommonISOCurrencyCodesPtr.asFunction<
          CFArrayRef Function()>();

  CFArrayRef CFLocaleCopyPreferredLanguages() {
    return _CFLocaleCopyPreferredLanguages();
  }

  late final _CFLocaleCopyPreferredLanguagesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function()>>(
          'CFLocaleCopyPreferredLanguages');
  late final _CFLocaleCopyPreferredLanguages =
      _CFLocaleCopyPreferredLanguagesPtr.asFunction<CFArrayRef Function()>();

  CFLocaleIdentifier CFLocaleCreateCanonicalLanguageIdentifierFromString(
    CFAllocatorRef allocator,
    CFStringRef localeIdentifier,
  ) {
    return _CFLocaleCreateCanonicalLanguageIdentifierFromString(
      allocator,
      localeIdentifier,
    );
  }

  late final _CFLocaleCreateCanonicalLanguageIdentifierFromStringPtr = _lookup<
          ffi.NativeFunction<
              CFLocaleIdentifier Function(CFAllocatorRef, CFStringRef)>>(
      'CFLocaleCreateCanonicalLanguageIdentifierFromString');
  late final _CFLocaleCreateCanonicalLanguageIdentifierFromString =
      _CFLocaleCreateCanonicalLanguageIdentifierFromStringPtr.asFunction<
          CFLocaleIdentifier Function(CFAllocatorRef, CFStringRef)>();

  CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromString(
    CFAllocatorRef allocator,
    CFStringRef localeIdentifier,
  ) {
    return _CFLocaleCreateCanonicalLocaleIdentifierFromString(
      allocator,
      localeIdentifier,
    );
  }

  late final _CFLocaleCreateCanonicalLocaleIdentifierFromStringPtr = _lookup<
          ffi.NativeFunction<
              CFLocaleIdentifier Function(CFAllocatorRef, CFStringRef)>>(
      'CFLocaleCreateCanonicalLocaleIdentifierFromString');
  late final _CFLocaleCreateCanonicalLocaleIdentifierFromString =
      _CFLocaleCreateCanonicalLocaleIdentifierFromStringPtr.asFunction<
          CFLocaleIdentifier Function(CFAllocatorRef, CFStringRef)>();

  CFLocaleIdentifier
      CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(
    CFAllocatorRef allocator,
    int lcode,
    int rcode,
  ) {
    return _CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(
      allocator,
      lcode,
      rcode,
    );
  }

  late final _CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodesPtr =
      _lookup<
              ffi.NativeFunction<
                  CFLocaleIdentifier Function(
                      CFAllocatorRef, LangCode, RegionCode)>>(
          'CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes');
  late final _CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes =
      _CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodesPtr
          .asFunction<CFLocaleIdentifier Function(CFAllocatorRef, int, int)>();

  CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(
    CFAllocatorRef allocator,
    int lcid,
  ) {
    return _CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(
      allocator,
      lcid,
    );
  }

  late final _CFLocaleCreateLocaleIdentifierFromWindowsLocaleCodePtr = _lookup<
          ffi.NativeFunction<
              CFLocaleIdentifier Function(CFAllocatorRef, ffi.Uint32)>>(
      'CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode');
  late final _CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode =
      _CFLocaleCreateLocaleIdentifierFromWindowsLocaleCodePtr.asFunction<
          CFLocaleIdentifier Function(CFAllocatorRef, int)>();

  int CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier(
    CFLocaleIdentifier localeIdentifier,
  ) {
    return _CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier(
      localeIdentifier,
    );
  }

  late final _CFLocaleGetWindowsLocaleCodeFromLocaleIdentifierPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(CFLocaleIdentifier)>>(
          'CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier');
  late final _CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier =
      _CFLocaleGetWindowsLocaleCodeFromLocaleIdentifierPtr.asFunction<
          int Function(CFLocaleIdentifier)>();

  CFLocaleLanguageDirection CFLocaleGetLanguageCharacterDirection(
    CFStringRef isoLangCode,
  ) {
    return CFLocaleLanguageDirection.fromValue(
        _CFLocaleGetLanguageCharacterDirection(
      isoLangCode,
    ));
  }

  late final _CFLocaleGetLanguageCharacterDirectionPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFStringRef)>>(
          'CFLocaleGetLanguageCharacterDirection');
  late final _CFLocaleGetLanguageCharacterDirection =
      _CFLocaleGetLanguageCharacterDirectionPtr.asFunction<
          int Function(CFStringRef)>();

  CFLocaleLanguageDirection CFLocaleGetLanguageLineDirection(
    CFStringRef isoLangCode,
  ) {
    return CFLocaleLanguageDirection.fromValue(
        _CFLocaleGetLanguageLineDirection(
      isoLangCode,
    ));
  }

  late final _CFLocaleGetLanguageLineDirectionPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFStringRef)>>(
          'CFLocaleGetLanguageLineDirection');
  late final _CFLocaleGetLanguageLineDirection =
      _CFLocaleGetLanguageLineDirectionPtr.asFunction<
          int Function(CFStringRef)>();

  CFDictionaryRef CFLocaleCreateComponentsFromLocaleIdentifier(
    CFAllocatorRef allocator,
    CFLocaleIdentifier localeID,
  ) {
    return _CFLocaleCreateComponentsFromLocaleIdentifier(
      allocator,
      localeID,
    );
  }

  late final _CFLocaleCreateComponentsFromLocaleIdentifierPtr = _lookup<
          ffi.NativeFunction<
              CFDictionaryRef Function(CFAllocatorRef, CFLocaleIdentifier)>>(
      'CFLocaleCreateComponentsFromLocaleIdentifier');
  late final _CFLocaleCreateComponentsFromLocaleIdentifier =
      _CFLocaleCreateComponentsFromLocaleIdentifierPtr.asFunction<
          CFDictionaryRef Function(CFAllocatorRef, CFLocaleIdentifier)>();

  CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromComponents(
    CFAllocatorRef allocator,
    CFDictionaryRef dictionary,
  ) {
    return _CFLocaleCreateLocaleIdentifierFromComponents(
      allocator,
      dictionary,
    );
  }

  late final _CFLocaleCreateLocaleIdentifierFromComponentsPtr = _lookup<
          ffi.NativeFunction<
              CFLocaleIdentifier Function(CFAllocatorRef, CFDictionaryRef)>>(
      'CFLocaleCreateLocaleIdentifierFromComponents');
  late final _CFLocaleCreateLocaleIdentifierFromComponents =
      _CFLocaleCreateLocaleIdentifierFromComponentsPtr.asFunction<
          CFLocaleIdentifier Function(CFAllocatorRef, CFDictionaryRef)>();

  CFLocaleRef CFLocaleCreate(
    CFAllocatorRef allocator,
    CFLocaleIdentifier localeIdentifier,
  ) {
    return _CFLocaleCreate(
      allocator,
      localeIdentifier,
    );
  }

  late final _CFLocaleCreatePtr = _lookup<
      ffi.NativeFunction<
          CFLocaleRef Function(
              CFAllocatorRef, CFLocaleIdentifier)>>('CFLocaleCreate');
  late final _CFLocaleCreate = _CFLocaleCreatePtr.asFunction<
      CFLocaleRef Function(CFAllocatorRef, CFLocaleIdentifier)>();

  CFLocaleRef CFLocaleCreateCopy(
    CFAllocatorRef allocator,
    CFLocaleRef locale,
  ) {
    return _CFLocaleCreateCopy(
      allocator,
      locale,
    );
  }

  late final _CFLocaleCreateCopyPtr = _lookup<
          ffi
          .NativeFunction<CFLocaleRef Function(CFAllocatorRef, CFLocaleRef)>>(
      'CFLocaleCreateCopy');
  late final _CFLocaleCreateCopy = _CFLocaleCreateCopyPtr.asFunction<
      CFLocaleRef Function(CFAllocatorRef, CFLocaleRef)>();

  CFLocaleIdentifier CFLocaleGetIdentifier(
    CFLocaleRef locale,
  ) {
    return _CFLocaleGetIdentifier(
      locale,
    );
  }

  late final _CFLocaleGetIdentifierPtr =
      _lookup<ffi.NativeFunction<CFLocaleIdentifier Function(CFLocaleRef)>>(
          'CFLocaleGetIdentifier');
  late final _CFLocaleGetIdentifier = _CFLocaleGetIdentifierPtr.asFunction<
      CFLocaleIdentifier Function(CFLocaleRef)>();

  CFTypeRef CFLocaleGetValue(
    CFLocaleRef locale,
    CFLocaleKey key,
  ) {
    return _CFLocaleGetValue(
      locale,
      key,
    );
  }

  late final _CFLocaleGetValuePtr =
      _lookup<ffi.NativeFunction<CFTypeRef Function(CFLocaleRef, CFLocaleKey)>>(
          'CFLocaleGetValue');
  late final _CFLocaleGetValue = _CFLocaleGetValuePtr.asFunction<
      CFTypeRef Function(CFLocaleRef, CFLocaleKey)>();

  CFStringRef CFLocaleCopyDisplayNameForPropertyValue(
    CFLocaleRef displayLocale,
    CFLocaleKey key,
    CFStringRef value,
  ) {
    return _CFLocaleCopyDisplayNameForPropertyValue(
      displayLocale,
      key,
      value,
    );
  }

  late final _CFLocaleCopyDisplayNameForPropertyValuePtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFLocaleRef, CFLocaleKey,
              CFStringRef)>>('CFLocaleCopyDisplayNameForPropertyValue');
  late final _CFLocaleCopyDisplayNameForPropertyValue =
      _CFLocaleCopyDisplayNameForPropertyValuePtr.asFunction<
          CFStringRef Function(CFLocaleRef, CFLocaleKey, CFStringRef)>();

  late final ffi.Pointer<CFNotificationName>
      _kCFLocaleCurrentLocaleDidChangeNotification =
      _lookup<CFNotificationName>(
          'kCFLocaleCurrentLocaleDidChangeNotification');

  CFNotificationName get kCFLocaleCurrentLocaleDidChangeNotification =>
      _kCFLocaleCurrentLocaleDidChangeNotification.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleIdentifier =
      _lookup<CFLocaleKey>('kCFLocaleIdentifier');

  CFLocaleKey get kCFLocaleIdentifier => _kCFLocaleIdentifier.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleLanguageCode =
      _lookup<CFLocaleKey>('kCFLocaleLanguageCode');

  CFLocaleKey get kCFLocaleLanguageCode => _kCFLocaleLanguageCode.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleCountryCode =
      _lookup<CFLocaleKey>('kCFLocaleCountryCode');

  CFLocaleKey get kCFLocaleCountryCode => _kCFLocaleCountryCode.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleScriptCode =
      _lookup<CFLocaleKey>('kCFLocaleScriptCode');

  CFLocaleKey get kCFLocaleScriptCode => _kCFLocaleScriptCode.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleVariantCode =
      _lookup<CFLocaleKey>('kCFLocaleVariantCode');

  CFLocaleKey get kCFLocaleVariantCode => _kCFLocaleVariantCode.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleExemplarCharacterSet =
      _lookup<CFLocaleKey>('kCFLocaleExemplarCharacterSet');

  CFLocaleKey get kCFLocaleExemplarCharacterSet =>
      _kCFLocaleExemplarCharacterSet.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleCalendarIdentifier =
      _lookup<CFLocaleKey>('kCFLocaleCalendarIdentifier');

  CFLocaleKey get kCFLocaleCalendarIdentifier =>
      _kCFLocaleCalendarIdentifier.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleCalendar =
      _lookup<CFLocaleKey>('kCFLocaleCalendar');

  CFLocaleKey get kCFLocaleCalendar => _kCFLocaleCalendar.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleCollationIdentifier =
      _lookup<CFLocaleKey>('kCFLocaleCollationIdentifier');

  CFLocaleKey get kCFLocaleCollationIdentifier =>
      _kCFLocaleCollationIdentifier.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleUsesMetricSystem =
      _lookup<CFLocaleKey>('kCFLocaleUsesMetricSystem');

  CFLocaleKey get kCFLocaleUsesMetricSystem => _kCFLocaleUsesMetricSystem.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleMeasurementSystem =
      _lookup<CFLocaleKey>('kCFLocaleMeasurementSystem');

  CFLocaleKey get kCFLocaleMeasurementSystem =>
      _kCFLocaleMeasurementSystem.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleDecimalSeparator =
      _lookup<CFLocaleKey>('kCFLocaleDecimalSeparator');

  CFLocaleKey get kCFLocaleDecimalSeparator => _kCFLocaleDecimalSeparator.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleGroupingSeparator =
      _lookup<CFLocaleKey>('kCFLocaleGroupingSeparator');

  CFLocaleKey get kCFLocaleGroupingSeparator =>
      _kCFLocaleGroupingSeparator.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleCurrencySymbol =
      _lookup<CFLocaleKey>('kCFLocaleCurrencySymbol');

  CFLocaleKey get kCFLocaleCurrencySymbol => _kCFLocaleCurrencySymbol.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleCurrencyCode =
      _lookup<CFLocaleKey>('kCFLocaleCurrencyCode');

  CFLocaleKey get kCFLocaleCurrencyCode => _kCFLocaleCurrencyCode.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleCollatorIdentifier =
      _lookup<CFLocaleKey>('kCFLocaleCollatorIdentifier');

  CFLocaleKey get kCFLocaleCollatorIdentifier =>
      _kCFLocaleCollatorIdentifier.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleQuotationBeginDelimiterKey =
      _lookup<CFLocaleKey>('kCFLocaleQuotationBeginDelimiterKey');

  CFLocaleKey get kCFLocaleQuotationBeginDelimiterKey =>
      _kCFLocaleQuotationBeginDelimiterKey.value;

  late final ffi.Pointer<CFLocaleKey> _kCFLocaleQuotationEndDelimiterKey =
      _lookup<CFLocaleKey>('kCFLocaleQuotationEndDelimiterKey');

  CFLocaleKey get kCFLocaleQuotationEndDelimiterKey =>
      _kCFLocaleQuotationEndDelimiterKey.value;

  late final ffi.Pointer<CFLocaleKey>
      _kCFLocaleAlternateQuotationBeginDelimiterKey =
      _lookup<CFLocaleKey>('kCFLocaleAlternateQuotationBeginDelimiterKey');

  CFLocaleKey get kCFLocaleAlternateQuotationBeginDelimiterKey =>
      _kCFLocaleAlternateQuotationBeginDelimiterKey.value;

  late final ffi.Pointer<CFLocaleKey>
      _kCFLocaleAlternateQuotationEndDelimiterKey =
      _lookup<CFLocaleKey>('kCFLocaleAlternateQuotationEndDelimiterKey');

  CFLocaleKey get kCFLocaleAlternateQuotationEndDelimiterKey =>
      _kCFLocaleAlternateQuotationEndDelimiterKey.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFGregorianCalendar =
      _lookup<CFCalendarIdentifier>('kCFGregorianCalendar');

  CFCalendarIdentifier get kCFGregorianCalendar => _kCFGregorianCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFBuddhistCalendar =
      _lookup<CFCalendarIdentifier>('kCFBuddhistCalendar');

  CFCalendarIdentifier get kCFBuddhistCalendar => _kCFBuddhistCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFChineseCalendar =
      _lookup<CFCalendarIdentifier>('kCFChineseCalendar');

  CFCalendarIdentifier get kCFChineseCalendar => _kCFChineseCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFHebrewCalendar =
      _lookup<CFCalendarIdentifier>('kCFHebrewCalendar');

  CFCalendarIdentifier get kCFHebrewCalendar => _kCFHebrewCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFIslamicCalendar =
      _lookup<CFCalendarIdentifier>('kCFIslamicCalendar');

  CFCalendarIdentifier get kCFIslamicCalendar => _kCFIslamicCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFIslamicCivilCalendar =
      _lookup<CFCalendarIdentifier>('kCFIslamicCivilCalendar');

  CFCalendarIdentifier get kCFIslamicCivilCalendar =>
      _kCFIslamicCivilCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFJapaneseCalendar =
      _lookup<CFCalendarIdentifier>('kCFJapaneseCalendar');

  CFCalendarIdentifier get kCFJapaneseCalendar => _kCFJapaneseCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFRepublicOfChinaCalendar =
      _lookup<CFCalendarIdentifier>('kCFRepublicOfChinaCalendar');

  CFCalendarIdentifier get kCFRepublicOfChinaCalendar =>
      _kCFRepublicOfChinaCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFPersianCalendar =
      _lookup<CFCalendarIdentifier>('kCFPersianCalendar');

  CFCalendarIdentifier get kCFPersianCalendar => _kCFPersianCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFIndianCalendar =
      _lookup<CFCalendarIdentifier>('kCFIndianCalendar');

  CFCalendarIdentifier get kCFIndianCalendar => _kCFIndianCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFISO8601Calendar =
      _lookup<CFCalendarIdentifier>('kCFISO8601Calendar');

  CFCalendarIdentifier get kCFISO8601Calendar => _kCFISO8601Calendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFIslamicTabularCalendar =
      _lookup<CFCalendarIdentifier>('kCFIslamicTabularCalendar');

  CFCalendarIdentifier get kCFIslamicTabularCalendar =>
      _kCFIslamicTabularCalendar.value;

  late final ffi.Pointer<CFCalendarIdentifier> _kCFIslamicUmmAlQuraCalendar =
      _lookup<CFCalendarIdentifier>('kCFIslamicUmmAlQuraCalendar');

  CFCalendarIdentifier get kCFIslamicUmmAlQuraCalendar =>
      _kCFIslamicUmmAlQuraCalendar.value;

  double CFAbsoluteTimeGetCurrent() {
    return _CFAbsoluteTimeGetCurrent();
  }

  late final _CFAbsoluteTimeGetCurrentPtr =
      _lookup<ffi.NativeFunction<CFAbsoluteTime Function()>>(
          'CFAbsoluteTimeGetCurrent');
  late final _CFAbsoluteTimeGetCurrent =
      _CFAbsoluteTimeGetCurrentPtr.asFunction<double Function()>();

  late final ffi.Pointer<CFTimeInterval> _kCFAbsoluteTimeIntervalSince1970 =
      _lookup<CFTimeInterval>('kCFAbsoluteTimeIntervalSince1970');

  DartCFTimeInterval get kCFAbsoluteTimeIntervalSince1970 =>
      _kCFAbsoluteTimeIntervalSince1970.value;

  late final ffi.Pointer<CFTimeInterval> _kCFAbsoluteTimeIntervalSince1904 =
      _lookup<CFTimeInterval>('kCFAbsoluteTimeIntervalSince1904');

  DartCFTimeInterval get kCFAbsoluteTimeIntervalSince1904 =>
      _kCFAbsoluteTimeIntervalSince1904.value;

  int CFDateGetTypeID() {
    return _CFDateGetTypeID();
  }

  late final _CFDateGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFDateGetTypeID');
  late final _CFDateGetTypeID =
      _CFDateGetTypeIDPtr.asFunction<int Function()>();

  CFDateRef CFDateCreate(
    CFAllocatorRef allocator,
    double at,
  ) {
    return _CFDateCreate(
      allocator,
      at,
    );
  }

  late final _CFDateCreatePtr = _lookup<
      ffi.NativeFunction<
          CFDateRef Function(CFAllocatorRef, CFAbsoluteTime)>>('CFDateCreate');
  late final _CFDateCreate =
      _CFDateCreatePtr.asFunction<CFDateRef Function(CFAllocatorRef, double)>();

  double CFDateGetAbsoluteTime(
    CFDateRef theDate,
  ) {
    return _CFDateGetAbsoluteTime(
      theDate,
    );
  }

  late final _CFDateGetAbsoluteTimePtr =
      _lookup<ffi.NativeFunction<CFAbsoluteTime Function(CFDateRef)>>(
          'CFDateGetAbsoluteTime');
  late final _CFDateGetAbsoluteTime =
      _CFDateGetAbsoluteTimePtr.asFunction<double Function(CFDateRef)>();

  double CFDateGetTimeIntervalSinceDate(
    CFDateRef theDate,
    CFDateRef otherDate,
  ) {
    return _CFDateGetTimeIntervalSinceDate(
      theDate,
      otherDate,
    );
  }

  late final _CFDateGetTimeIntervalSinceDatePtr = _lookup<
          ffi.NativeFunction<CFTimeInterval Function(CFDateRef, CFDateRef)>>(
      'CFDateGetTimeIntervalSinceDate');
  late final _CFDateGetTimeIntervalSinceDate =
      _CFDateGetTimeIntervalSinceDatePtr.asFunction<
          double Function(CFDateRef, CFDateRef)>();

  CFComparisonResult CFDateCompare(
    CFDateRef theDate,
    CFDateRef otherDate,
    ffi.Pointer<ffi.Void> context,
  ) {
    return CFComparisonResult.fromValue(_CFDateCompare(
      theDate,
      otherDate,
      context,
    ));
  }

  late final _CFDateComparePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(
              CFDateRef, CFDateRef, ffi.Pointer<ffi.Void>)>>('CFDateCompare');
  late final _CFDateCompare = _CFDateComparePtr.asFunction<
      int Function(CFDateRef, CFDateRef, ffi.Pointer<ffi.Void>)>();

  int CFGregorianDateIsValid(
    CFGregorianDate gdate,
    int unitFlags,
  ) {
    return _CFGregorianDateIsValid(
      gdate,
      unitFlags,
    );
  }

  late final _CFGregorianDateIsValidPtr = _lookup<
          ffi.NativeFunction<Boolean Function(CFGregorianDate, CFOptionFlags)>>(
      'CFGregorianDateIsValid');
  late final _CFGregorianDateIsValid = _CFGregorianDateIsValidPtr.asFunction<
      int Function(CFGregorianDate, int)>();

  double CFGregorianDateGetAbsoluteTime(
    CFGregorianDate gdate,
    CFTimeZoneRef tz,
  ) {
    return _CFGregorianDateGetAbsoluteTime(
      gdate,
      tz,
    );
  }

  late final _CFGregorianDateGetAbsoluteTimePtr = _lookup<
      ffi.NativeFunction<
          CFAbsoluteTime Function(CFGregorianDate,
              CFTimeZoneRef)>>('CFGregorianDateGetAbsoluteTime');
  late final _CFGregorianDateGetAbsoluteTime =
      _CFGregorianDateGetAbsoluteTimePtr.asFunction<
          double Function(CFGregorianDate, CFTimeZoneRef)>();

  CFGregorianDate CFAbsoluteTimeGetGregorianDate(
    double at,
    CFTimeZoneRef tz,
  ) {
    return _CFAbsoluteTimeGetGregorianDate(
      at,
      tz,
    );
  }

  late final _CFAbsoluteTimeGetGregorianDatePtr = _lookup<
      ffi.NativeFunction<
          CFGregorianDate Function(CFAbsoluteTime,
              CFTimeZoneRef)>>('CFAbsoluteTimeGetGregorianDate');
  late final _CFAbsoluteTimeGetGregorianDate =
      _CFAbsoluteTimeGetGregorianDatePtr.asFunction<
          CFGregorianDate Function(double, CFTimeZoneRef)>();

  double CFAbsoluteTimeAddGregorianUnits(
    double at,
    CFTimeZoneRef tz,
    CFGregorianUnits units,
  ) {
    return _CFAbsoluteTimeAddGregorianUnits(
      at,
      tz,
      units,
    );
  }

  late final _CFAbsoluteTimeAddGregorianUnitsPtr = _lookup<
      ffi.NativeFunction<
          CFAbsoluteTime Function(CFAbsoluteTime, CFTimeZoneRef,
              CFGregorianUnits)>>('CFAbsoluteTimeAddGregorianUnits');
  late final _CFAbsoluteTimeAddGregorianUnits =
      _CFAbsoluteTimeAddGregorianUnitsPtr.asFunction<
          double Function(double, CFTimeZoneRef, CFGregorianUnits)>();

  CFGregorianUnits CFAbsoluteTimeGetDifferenceAsGregorianUnits(
    double at1,
    double at2,
    CFTimeZoneRef tz,
    int unitFlags,
  ) {
    return _CFAbsoluteTimeGetDifferenceAsGregorianUnits(
      at1,
      at2,
      tz,
      unitFlags,
    );
  }

  late final _CFAbsoluteTimeGetDifferenceAsGregorianUnitsPtr = _lookup<
      ffi.NativeFunction<
          CFGregorianUnits Function(
              CFAbsoluteTime,
              CFAbsoluteTime,
              CFTimeZoneRef,
              CFOptionFlags)>>('CFAbsoluteTimeGetDifferenceAsGregorianUnits');
  late final _CFAbsoluteTimeGetDifferenceAsGregorianUnits =
      _CFAbsoluteTimeGetDifferenceAsGregorianUnitsPtr.asFunction<
          CFGregorianUnits Function(double, double, CFTimeZoneRef, int)>();

  int CFAbsoluteTimeGetDayOfWeek(
    double at,
    CFTimeZoneRef tz,
  ) {
    return _CFAbsoluteTimeGetDayOfWeek(
      at,
      tz,
    );
  }

  late final _CFAbsoluteTimeGetDayOfWeekPtr = _lookup<
          ffi.NativeFunction<SInt32 Function(CFAbsoluteTime, CFTimeZoneRef)>>(
      'CFAbsoluteTimeGetDayOfWeek');
  late final _CFAbsoluteTimeGetDayOfWeek = _CFAbsoluteTimeGetDayOfWeekPtr
      .asFunction<int Function(double, CFTimeZoneRef)>();

  int CFAbsoluteTimeGetDayOfYear(
    double at,
    CFTimeZoneRef tz,
  ) {
    return _CFAbsoluteTimeGetDayOfYear(
      at,
      tz,
    );
  }

  late final _CFAbsoluteTimeGetDayOfYearPtr = _lookup<
          ffi.NativeFunction<SInt32 Function(CFAbsoluteTime, CFTimeZoneRef)>>(
      'CFAbsoluteTimeGetDayOfYear');
  late final _CFAbsoluteTimeGetDayOfYear = _CFAbsoluteTimeGetDayOfYearPtr
      .asFunction<int Function(double, CFTimeZoneRef)>();

  int CFAbsoluteTimeGetWeekOfYear(
    double at,
    CFTimeZoneRef tz,
  ) {
    return _CFAbsoluteTimeGetWeekOfYear(
      at,
      tz,
    );
  }

  late final _CFAbsoluteTimeGetWeekOfYearPtr = _lookup<
          ffi.NativeFunction<SInt32 Function(CFAbsoluteTime, CFTimeZoneRef)>>(
      'CFAbsoluteTimeGetWeekOfYear');
  late final _CFAbsoluteTimeGetWeekOfYear = _CFAbsoluteTimeGetWeekOfYearPtr
      .asFunction<int Function(double, CFTimeZoneRef)>();

  int CFDataGetTypeID() {
    return _CFDataGetTypeID();
  }

  late final _CFDataGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFDataGetTypeID');
  late final _CFDataGetTypeID =
      _CFDataGetTypeIDPtr.asFunction<int Function()>();

  CFDataRef CFDataCreate(
    CFAllocatorRef allocator,
    ffi.Pointer<UInt8> bytes,
    int length,
  ) {
    return _CFDataCreate(
      allocator,
      bytes,
      length,
    );
  }

  late final _CFDataCreatePtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(
              CFAllocatorRef, ffi.Pointer<UInt8>, CFIndex)>>('CFDataCreate');
  late final _CFDataCreate = _CFDataCreatePtr.asFunction<
      CFDataRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, int)>();

  CFDataRef CFDataCreateWithBytesNoCopy(
    CFAllocatorRef allocator,
    ffi.Pointer<UInt8> bytes,
    int length,
    CFAllocatorRef bytesDeallocator,
  ) {
    return _CFDataCreateWithBytesNoCopy(
      allocator,
      bytes,
      length,
      bytesDeallocator,
    );
  }

  late final _CFDataCreateWithBytesNoCopyPtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, CFIndex,
              CFAllocatorRef)>>('CFDataCreateWithBytesNoCopy');
  late final _CFDataCreateWithBytesNoCopy =
      _CFDataCreateWithBytesNoCopyPtr.asFunction<
          CFDataRef Function(
              CFAllocatorRef, ffi.Pointer<UInt8>, int, CFAllocatorRef)>();

  CFDataRef CFDataCreateCopy(
    CFAllocatorRef allocator,
    CFDataRef theData,
  ) {
    return _CFDataCreateCopy(
      allocator,
      theData,
    );
  }

  late final _CFDataCreateCopyPtr = _lookup<
          ffi.NativeFunction<CFDataRef Function(CFAllocatorRef, CFDataRef)>>(
      'CFDataCreateCopy');
  late final _CFDataCreateCopy = _CFDataCreateCopyPtr.asFunction<
      CFDataRef Function(CFAllocatorRef, CFDataRef)>();

  CFMutableDataRef CFDataCreateMutable(
    CFAllocatorRef allocator,
    int capacity,
  ) {
    return _CFDataCreateMutable(
      allocator,
      capacity,
    );
  }

  late final _CFDataCreateMutablePtr = _lookup<
          ffi
          .NativeFunction<CFMutableDataRef Function(CFAllocatorRef, CFIndex)>>(
      'CFDataCreateMutable');
  late final _CFDataCreateMutable = _CFDataCreateMutablePtr.asFunction<
      CFMutableDataRef Function(CFAllocatorRef, int)>();

  CFMutableDataRef CFDataCreateMutableCopy(
    CFAllocatorRef allocator,
    int capacity,
    CFDataRef theData,
  ) {
    return _CFDataCreateMutableCopy(
      allocator,
      capacity,
      theData,
    );
  }

  late final _CFDataCreateMutableCopyPtr = _lookup<
      ffi.NativeFunction<
          CFMutableDataRef Function(
              CFAllocatorRef, CFIndex, CFDataRef)>>('CFDataCreateMutableCopy');
  late final _CFDataCreateMutableCopy = _CFDataCreateMutableCopyPtr.asFunction<
      CFMutableDataRef Function(CFAllocatorRef, int, CFDataRef)>();

  int CFDataGetLength(
    CFDataRef theData,
  ) {
    return _CFDataGetLength(
      theData,
    );
  }

  late final _CFDataGetLengthPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFDataRef)>>(
          'CFDataGetLength');
  late final _CFDataGetLength =
      _CFDataGetLengthPtr.asFunction<int Function(CFDataRef)>();

  ffi.Pointer<UInt8> CFDataGetBytePtr(
    CFDataRef theData,
  ) {
    return _CFDataGetBytePtr(
      theData,
    );
  }

  late final _CFDataGetBytePtrPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<UInt8> Function(CFDataRef)>>(
          'CFDataGetBytePtr');
  late final _CFDataGetBytePtr =
      _CFDataGetBytePtrPtr.asFunction<ffi.Pointer<UInt8> Function(CFDataRef)>();

  ffi.Pointer<UInt8> CFDataGetMutableBytePtr(
    CFMutableDataRef theData,
  ) {
    return _CFDataGetMutableBytePtr(
      theData,
    );
  }

  late final _CFDataGetMutableBytePtrPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<UInt8> Function(CFMutableDataRef)>>(
      'CFDataGetMutableBytePtr');
  late final _CFDataGetMutableBytePtr = _CFDataGetMutableBytePtrPtr.asFunction<
      ffi.Pointer<UInt8> Function(CFMutableDataRef)>();

  void CFDataGetBytes(
    CFDataRef theData,
    CFRange range,
    ffi.Pointer<UInt8> buffer,
  ) {
    return _CFDataGetBytes(
      theData,
      range,
      buffer,
    );
  }

  late final _CFDataGetBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFDataRef, CFRange, ffi.Pointer<UInt8>)>>('CFDataGetBytes');
  late final _CFDataGetBytes = _CFDataGetBytesPtr.asFunction<
      void Function(CFDataRef, CFRange, ffi.Pointer<UInt8>)>();

  void CFDataSetLength(
    CFMutableDataRef theData,
    int length,
  ) {
    return _CFDataSetLength(
      theData,
      length,
    );
  }

  late final _CFDataSetLengthPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMutableDataRef, CFIndex)>>(
          'CFDataSetLength');
  late final _CFDataSetLength =
      _CFDataSetLengthPtr.asFunction<void Function(CFMutableDataRef, int)>();

  void CFDataIncreaseLength(
    CFMutableDataRef theData,
    int extraLength,
  ) {
    return _CFDataIncreaseLength(
      theData,
      extraLength,
    );
  }

  late final _CFDataIncreaseLengthPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMutableDataRef, CFIndex)>>(
          'CFDataIncreaseLength');
  late final _CFDataIncreaseLength = _CFDataIncreaseLengthPtr.asFunction<
      void Function(CFMutableDataRef, int)>();

  void CFDataAppendBytes(
    CFMutableDataRef theData,
    ffi.Pointer<UInt8> bytes,
    int length,
  ) {
    return _CFDataAppendBytes(
      theData,
      bytes,
      length,
    );
  }

  late final _CFDataAppendBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableDataRef, ffi.Pointer<UInt8>,
              CFIndex)>>('CFDataAppendBytes');
  late final _CFDataAppendBytes = _CFDataAppendBytesPtr.asFunction<
      void Function(CFMutableDataRef, ffi.Pointer<UInt8>, int)>();

  void CFDataReplaceBytes(
    CFMutableDataRef theData,
    CFRange range,
    ffi.Pointer<UInt8> newBytes,
    int newLength,
  ) {
    return _CFDataReplaceBytes(
      theData,
      range,
      newBytes,
      newLength,
    );
  }

  late final _CFDataReplaceBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableDataRef, CFRange, ffi.Pointer<UInt8>,
              CFIndex)>>('CFDataReplaceBytes');
  late final _CFDataReplaceBytes = _CFDataReplaceBytesPtr.asFunction<
      void Function(CFMutableDataRef, CFRange, ffi.Pointer<UInt8>, int)>();

  void CFDataDeleteBytes(
    CFMutableDataRef theData,
    CFRange range,
  ) {
    return _CFDataDeleteBytes(
      theData,
      range,
    );
  }

  late final _CFDataDeleteBytesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMutableDataRef, CFRange)>>(
          'CFDataDeleteBytes');
  late final _CFDataDeleteBytes = _CFDataDeleteBytesPtr.asFunction<
      void Function(CFMutableDataRef, CFRange)>();

  CFRange CFDataFind(
    CFDataRef theData,
    CFDataRef dataToFind,
    CFRange searchRange,
    CFDataSearchFlags compareOptions,
  ) {
    return _CFDataFind(
      theData,
      dataToFind,
      searchRange,
      compareOptions.value,
    );
  }

  late final _CFDataFindPtr = _lookup<
      ffi.NativeFunction<
          CFRange Function(
              CFDataRef, CFDataRef, CFRange, CFOptionFlags)>>('CFDataFind');
  late final _CFDataFind = _CFDataFindPtr.asFunction<
      CFRange Function(CFDataRef, CFDataRef, CFRange, int)>();

  int CFCharacterSetGetTypeID() {
    return _CFCharacterSetGetTypeID();
  }

  late final _CFCharacterSetGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFCharacterSetGetTypeID');
  late final _CFCharacterSetGetTypeID =
      _CFCharacterSetGetTypeIDPtr.asFunction<int Function()>();

  CFCharacterSetRef CFCharacterSetGetPredefined(
    CFCharacterSetPredefinedSet theSetIdentifier,
  ) {
    return _CFCharacterSetGetPredefined(
      theSetIdentifier.value,
    );
  }

  late final _CFCharacterSetGetPredefinedPtr =
      _lookup<ffi.NativeFunction<CFCharacterSetRef Function(CFIndex)>>(
          'CFCharacterSetGetPredefined');
  late final _CFCharacterSetGetPredefined = _CFCharacterSetGetPredefinedPtr
      .asFunction<CFCharacterSetRef Function(int)>();

  CFCharacterSetRef CFCharacterSetCreateWithCharactersInRange(
    CFAllocatorRef alloc,
    CFRange theRange,
  ) {
    return _CFCharacterSetCreateWithCharactersInRange(
      alloc,
      theRange,
    );
  }

  late final _CFCharacterSetCreateWithCharactersInRangePtr = _lookup<
          ffi
          .NativeFunction<CFCharacterSetRef Function(CFAllocatorRef, CFRange)>>(
      'CFCharacterSetCreateWithCharactersInRange');
  late final _CFCharacterSetCreateWithCharactersInRange =
      _CFCharacterSetCreateWithCharactersInRangePtr.asFunction<
          CFCharacterSetRef Function(CFAllocatorRef, CFRange)>();

  CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(
    CFAllocatorRef alloc,
    CFStringRef theString,
  ) {
    return _CFCharacterSetCreateWithCharactersInString(
      alloc,
      theString,
    );
  }

  late final _CFCharacterSetCreateWithCharactersInStringPtr = _lookup<
      ffi.NativeFunction<
          CFCharacterSetRef Function(CFAllocatorRef,
              CFStringRef)>>('CFCharacterSetCreateWithCharactersInString');
  late final _CFCharacterSetCreateWithCharactersInString =
      _CFCharacterSetCreateWithCharactersInStringPtr.asFunction<
          CFCharacterSetRef Function(CFAllocatorRef, CFStringRef)>();

  CFCharacterSetRef CFCharacterSetCreateWithBitmapRepresentation(
    CFAllocatorRef alloc,
    CFDataRef theData,
  ) {
    return _CFCharacterSetCreateWithBitmapRepresentation(
      alloc,
      theData,
    );
  }

  late final _CFCharacterSetCreateWithBitmapRepresentationPtr = _lookup<
      ffi.NativeFunction<
          CFCharacterSetRef Function(CFAllocatorRef,
              CFDataRef)>>('CFCharacterSetCreateWithBitmapRepresentation');
  late final _CFCharacterSetCreateWithBitmapRepresentation =
      _CFCharacterSetCreateWithBitmapRepresentationPtr.asFunction<
          CFCharacterSetRef Function(CFAllocatorRef, CFDataRef)>();

  CFCharacterSetRef CFCharacterSetCreateInvertedSet(
    CFAllocatorRef alloc,
    CFCharacterSetRef theSet,
  ) {
    return _CFCharacterSetCreateInvertedSet(
      alloc,
      theSet,
    );
  }

  late final _CFCharacterSetCreateInvertedSetPtr = _lookup<
      ffi.NativeFunction<
          CFCharacterSetRef Function(CFAllocatorRef,
              CFCharacterSetRef)>>('CFCharacterSetCreateInvertedSet');
  late final _CFCharacterSetCreateInvertedSet =
      _CFCharacterSetCreateInvertedSetPtr.asFunction<
          CFCharacterSetRef Function(CFAllocatorRef, CFCharacterSetRef)>();

  int CFCharacterSetIsSupersetOfSet(
    CFCharacterSetRef theSet,
    CFCharacterSetRef theOtherset,
  ) {
    return _CFCharacterSetIsSupersetOfSet(
      theSet,
      theOtherset,
    );
  }

  late final _CFCharacterSetIsSupersetOfSetPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFCharacterSetRef,
              CFCharacterSetRef)>>('CFCharacterSetIsSupersetOfSet');
  late final _CFCharacterSetIsSupersetOfSet = _CFCharacterSetIsSupersetOfSetPtr
      .asFunction<int Function(CFCharacterSetRef, CFCharacterSetRef)>();

  int CFCharacterSetHasMemberInPlane(
    CFCharacterSetRef theSet,
    int thePlane,
  ) {
    return _CFCharacterSetHasMemberInPlane(
      theSet,
      thePlane,
    );
  }

  late final _CFCharacterSetHasMemberInPlanePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFCharacterSetRef, CFIndex)>>(
          'CFCharacterSetHasMemberInPlane');
  late final _CFCharacterSetHasMemberInPlane =
      _CFCharacterSetHasMemberInPlanePtr.asFunction<
          int Function(CFCharacterSetRef, int)>();

  CFMutableCharacterSetRef CFCharacterSetCreateMutable(
    CFAllocatorRef alloc,
  ) {
    return _CFCharacterSetCreateMutable(
      alloc,
    );
  }

  late final _CFCharacterSetCreateMutablePtr = _lookup<
          ffi
          .NativeFunction<CFMutableCharacterSetRef Function(CFAllocatorRef)>>(
      'CFCharacterSetCreateMutable');
  late final _CFCharacterSetCreateMutable = _CFCharacterSetCreateMutablePtr
      .asFunction<CFMutableCharacterSetRef Function(CFAllocatorRef)>();

  CFCharacterSetRef CFCharacterSetCreateCopy(
    CFAllocatorRef alloc,
    CFCharacterSetRef theSet,
  ) {
    return _CFCharacterSetCreateCopy(
      alloc,
      theSet,
    );
  }

  late final _CFCharacterSetCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          CFCharacterSetRef Function(
              CFAllocatorRef, CFCharacterSetRef)>>('CFCharacterSetCreateCopy');
  late final _CFCharacterSetCreateCopy =
      _CFCharacterSetCreateCopyPtr.asFunction<
          CFCharacterSetRef Function(CFAllocatorRef, CFCharacterSetRef)>();

  CFMutableCharacterSetRef CFCharacterSetCreateMutableCopy(
    CFAllocatorRef alloc,
    CFCharacterSetRef theSet,
  ) {
    return _CFCharacterSetCreateMutableCopy(
      alloc,
      theSet,
    );
  }

  late final _CFCharacterSetCreateMutableCopyPtr = _lookup<
      ffi.NativeFunction<
          CFMutableCharacterSetRef Function(CFAllocatorRef,
              CFCharacterSetRef)>>('CFCharacterSetCreateMutableCopy');
  late final _CFCharacterSetCreateMutableCopy =
      _CFCharacterSetCreateMutableCopyPtr.asFunction<
          CFMutableCharacterSetRef Function(
              CFAllocatorRef, CFCharacterSetRef)>();

  int CFCharacterSetIsCharacterMember(
    CFCharacterSetRef theSet,
    int theChar,
  ) {
    return _CFCharacterSetIsCharacterMember(
      theSet,
      theChar,
    );
  }

  late final _CFCharacterSetIsCharacterMemberPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFCharacterSetRef, UniChar)>>(
          'CFCharacterSetIsCharacterMember');
  late final _CFCharacterSetIsCharacterMember =
      _CFCharacterSetIsCharacterMemberPtr.asFunction<
          int Function(CFCharacterSetRef, int)>();

  int CFCharacterSetIsLongCharacterMember(
    CFCharacterSetRef theSet,
    int theChar,
  ) {
    return _CFCharacterSetIsLongCharacterMember(
      theSet,
      theChar,
    );
  }

  late final _CFCharacterSetIsLongCharacterMemberPtr = _lookup<
          ffi.NativeFunction<Boolean Function(CFCharacterSetRef, UTF32Char)>>(
      'CFCharacterSetIsLongCharacterMember');
  late final _CFCharacterSetIsLongCharacterMember =
      _CFCharacterSetIsLongCharacterMemberPtr.asFunction<
          int Function(CFCharacterSetRef, int)>();

  CFDataRef CFCharacterSetCreateBitmapRepresentation(
    CFAllocatorRef alloc,
    CFCharacterSetRef theSet,
  ) {
    return _CFCharacterSetCreateBitmapRepresentation(
      alloc,
      theSet,
    );
  }

  late final _CFCharacterSetCreateBitmapRepresentationPtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(CFAllocatorRef,
              CFCharacterSetRef)>>('CFCharacterSetCreateBitmapRepresentation');
  late final _CFCharacterSetCreateBitmapRepresentation =
      _CFCharacterSetCreateBitmapRepresentationPtr.asFunction<
          CFDataRef Function(CFAllocatorRef, CFCharacterSetRef)>();

  void CFCharacterSetAddCharactersInRange(
    CFMutableCharacterSetRef theSet,
    CFRange theRange,
  ) {
    return _CFCharacterSetAddCharactersInRange(
      theSet,
      theRange,
    );
  }

  late final _CFCharacterSetAddCharactersInRangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableCharacterSetRef,
              CFRange)>>('CFCharacterSetAddCharactersInRange');
  late final _CFCharacterSetAddCharactersInRange =
      _CFCharacterSetAddCharactersInRangePtr.asFunction<
          void Function(CFMutableCharacterSetRef, CFRange)>();

  void CFCharacterSetRemoveCharactersInRange(
    CFMutableCharacterSetRef theSet,
    CFRange theRange,
  ) {
    return _CFCharacterSetRemoveCharactersInRange(
      theSet,
      theRange,
    );
  }

  late final _CFCharacterSetRemoveCharactersInRangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableCharacterSetRef,
              CFRange)>>('CFCharacterSetRemoveCharactersInRange');
  late final _CFCharacterSetRemoveCharactersInRange =
      _CFCharacterSetRemoveCharactersInRangePtr.asFunction<
          void Function(CFMutableCharacterSetRef, CFRange)>();

  void CFCharacterSetAddCharactersInString(
    CFMutableCharacterSetRef theSet,
    CFStringRef theString,
  ) {
    return _CFCharacterSetAddCharactersInString(
      theSet,
      theString,
    );
  }

  late final _CFCharacterSetAddCharactersInStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableCharacterSetRef,
              CFStringRef)>>('CFCharacterSetAddCharactersInString');
  late final _CFCharacterSetAddCharactersInString =
      _CFCharacterSetAddCharactersInStringPtr.asFunction<
          void Function(CFMutableCharacterSetRef, CFStringRef)>();

  void CFCharacterSetRemoveCharactersInString(
    CFMutableCharacterSetRef theSet,
    CFStringRef theString,
  ) {
    return _CFCharacterSetRemoveCharactersInString(
      theSet,
      theString,
    );
  }

  late final _CFCharacterSetRemoveCharactersInStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableCharacterSetRef,
              CFStringRef)>>('CFCharacterSetRemoveCharactersInString');
  late final _CFCharacterSetRemoveCharactersInString =
      _CFCharacterSetRemoveCharactersInStringPtr.asFunction<
          void Function(CFMutableCharacterSetRef, CFStringRef)>();

  void CFCharacterSetUnion(
    CFMutableCharacterSetRef theSet,
    CFCharacterSetRef theOtherSet,
  ) {
    return _CFCharacterSetUnion(
      theSet,
      theOtherSet,
    );
  }

  late final _CFCharacterSetUnionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableCharacterSetRef,
              CFCharacterSetRef)>>('CFCharacterSetUnion');
  late final _CFCharacterSetUnion = _CFCharacterSetUnionPtr.asFunction<
      void Function(CFMutableCharacterSetRef, CFCharacterSetRef)>();

  void CFCharacterSetIntersect(
    CFMutableCharacterSetRef theSet,
    CFCharacterSetRef theOtherSet,
  ) {
    return _CFCharacterSetIntersect(
      theSet,
      theOtherSet,
    );
  }

  late final _CFCharacterSetIntersectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableCharacterSetRef,
              CFCharacterSetRef)>>('CFCharacterSetIntersect');
  late final _CFCharacterSetIntersect = _CFCharacterSetIntersectPtr.asFunction<
      void Function(CFMutableCharacterSetRef, CFCharacterSetRef)>();

  void CFCharacterSetInvert(
    CFMutableCharacterSetRef theSet,
  ) {
    return _CFCharacterSetInvert(
      theSet,
    );
  }

  late final _CFCharacterSetInvertPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMutableCharacterSetRef)>>(
          'CFCharacterSetInvert');
  late final _CFCharacterSetInvert = _CFCharacterSetInvertPtr.asFunction<
      void Function(CFMutableCharacterSetRef)>();

  int CFErrorGetTypeID() {
    return _CFErrorGetTypeID();
  }

  late final _CFErrorGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFErrorGetTypeID');
  late final _CFErrorGetTypeID =
      _CFErrorGetTypeIDPtr.asFunction<int Function()>();

  late final ffi.Pointer<CFErrorDomain> _kCFErrorDomainPOSIX =
      _lookup<CFErrorDomain>('kCFErrorDomainPOSIX');

  CFErrorDomain get kCFErrorDomainPOSIX => _kCFErrorDomainPOSIX.value;

  late final ffi.Pointer<CFErrorDomain> _kCFErrorDomainOSStatus =
      _lookup<CFErrorDomain>('kCFErrorDomainOSStatus');

  CFErrorDomain get kCFErrorDomainOSStatus => _kCFErrorDomainOSStatus.value;

  late final ffi.Pointer<CFErrorDomain> _kCFErrorDomainMach =
      _lookup<CFErrorDomain>('kCFErrorDomainMach');

  CFErrorDomain get kCFErrorDomainMach => _kCFErrorDomainMach.value;

  late final ffi.Pointer<CFErrorDomain> _kCFErrorDomainCocoa =
      _lookup<CFErrorDomain>('kCFErrorDomainCocoa');

  CFErrorDomain get kCFErrorDomainCocoa => _kCFErrorDomainCocoa.value;

  late final ffi.Pointer<CFStringRef> _kCFErrorLocalizedDescriptionKey =
      _lookup<CFStringRef>('kCFErrorLocalizedDescriptionKey');

  CFStringRef get kCFErrorLocalizedDescriptionKey =>
      _kCFErrorLocalizedDescriptionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFErrorLocalizedFailureKey =
      _lookup<CFStringRef>('kCFErrorLocalizedFailureKey');

  CFStringRef get kCFErrorLocalizedFailureKey =>
      _kCFErrorLocalizedFailureKey.value;

  late final ffi.Pointer<CFStringRef> _kCFErrorLocalizedFailureReasonKey =
      _lookup<CFStringRef>('kCFErrorLocalizedFailureReasonKey');

  CFStringRef get kCFErrorLocalizedFailureReasonKey =>
      _kCFErrorLocalizedFailureReasonKey.value;

  late final ffi.Pointer<CFStringRef> _kCFErrorLocalizedRecoverySuggestionKey =
      _lookup<CFStringRef>('kCFErrorLocalizedRecoverySuggestionKey');

  CFStringRef get kCFErrorLocalizedRecoverySuggestionKey =>
      _kCFErrorLocalizedRecoverySuggestionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFErrorDescriptionKey =
      _lookup<CFStringRef>('kCFErrorDescriptionKey');

  CFStringRef get kCFErrorDescriptionKey => _kCFErrorDescriptionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFErrorUnderlyingErrorKey =
      _lookup<CFStringRef>('kCFErrorUnderlyingErrorKey');

  CFStringRef get kCFErrorUnderlyingErrorKey =>
      _kCFErrorUnderlyingErrorKey.value;

  late final ffi.Pointer<CFStringRef> _kCFErrorURLKey =
      _lookup<CFStringRef>('kCFErrorURLKey');

  CFStringRef get kCFErrorURLKey => _kCFErrorURLKey.value;

  late final ffi.Pointer<CFStringRef> _kCFErrorFilePathKey =
      _lookup<CFStringRef>('kCFErrorFilePathKey');

  CFStringRef get kCFErrorFilePathKey => _kCFErrorFilePathKey.value;

  CFErrorRef CFErrorCreate(
    CFAllocatorRef allocator,
    CFErrorDomain domain,
    int code,
    CFDictionaryRef userInfo,
  ) {
    return _CFErrorCreate(
      allocator,
      domain,
      code,
      userInfo,
    );
  }

  late final _CFErrorCreatePtr = _lookup<
      ffi.NativeFunction<
          CFErrorRef Function(CFAllocatorRef, CFErrorDomain, CFIndex,
              CFDictionaryRef)>>('CFErrorCreate');
  late final _CFErrorCreate = _CFErrorCreatePtr.asFunction<
      CFErrorRef Function(
          CFAllocatorRef, CFErrorDomain, int, CFDictionaryRef)>();

  CFErrorRef CFErrorCreateWithUserInfoKeysAndValues(
    CFAllocatorRef allocator,
    CFErrorDomain domain,
    int code,
    ffi.Pointer<ffi.Pointer<ffi.Void>> userInfoKeys,
    ffi.Pointer<ffi.Pointer<ffi.Void>> userInfoValues,
    int numUserInfoValues,
  ) {
    return _CFErrorCreateWithUserInfoKeysAndValues(
      allocator,
      domain,
      code,
      userInfoKeys,
      userInfoValues,
      numUserInfoValues,
    );
  }

  late final _CFErrorCreateWithUserInfoKeysAndValuesPtr = _lookup<
      ffi.NativeFunction<
          CFErrorRef Function(
              CFAllocatorRef,
              CFErrorDomain,
              CFIndex,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              CFIndex)>>('CFErrorCreateWithUserInfoKeysAndValues');
  late final _CFErrorCreateWithUserInfoKeysAndValues =
      _CFErrorCreateWithUserInfoKeysAndValuesPtr.asFunction<
          CFErrorRef Function(
              CFAllocatorRef,
              CFErrorDomain,
              int,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              int)>();

  CFErrorDomain CFErrorGetDomain(
    CFErrorRef err,
  ) {
    return _CFErrorGetDomain(
      err,
    );
  }

  late final _CFErrorGetDomainPtr =
      _lookup<ffi.NativeFunction<CFErrorDomain Function(CFErrorRef)>>(
          'CFErrorGetDomain');
  late final _CFErrorGetDomain =
      _CFErrorGetDomainPtr.asFunction<CFErrorDomain Function(CFErrorRef)>();

  int CFErrorGetCode(
    CFErrorRef err,
  ) {
    return _CFErrorGetCode(
      err,
    );
  }

  late final _CFErrorGetCodePtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFErrorRef)>>(
          'CFErrorGetCode');
  late final _CFErrorGetCode =
      _CFErrorGetCodePtr.asFunction<int Function(CFErrorRef)>();

  CFDictionaryRef CFErrorCopyUserInfo(
    CFErrorRef err,
  ) {
    return _CFErrorCopyUserInfo(
      err,
    );
  }

  late final _CFErrorCopyUserInfoPtr =
      _lookup<ffi.NativeFunction<CFDictionaryRef Function(CFErrorRef)>>(
          'CFErrorCopyUserInfo');
  late final _CFErrorCopyUserInfo = _CFErrorCopyUserInfoPtr.asFunction<
      CFDictionaryRef Function(CFErrorRef)>();

  CFStringRef CFErrorCopyDescription(
    CFErrorRef err,
  ) {
    return _CFErrorCopyDescription(
      err,
    );
  }

  late final _CFErrorCopyDescriptionPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFErrorRef)>>(
          'CFErrorCopyDescription');
  late final _CFErrorCopyDescription =
      _CFErrorCopyDescriptionPtr.asFunction<CFStringRef Function(CFErrorRef)>();

  CFStringRef CFErrorCopyFailureReason(
    CFErrorRef err,
  ) {
    return _CFErrorCopyFailureReason(
      err,
    );
  }

  late final _CFErrorCopyFailureReasonPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFErrorRef)>>(
          'CFErrorCopyFailureReason');
  late final _CFErrorCopyFailureReason = _CFErrorCopyFailureReasonPtr
      .asFunction<CFStringRef Function(CFErrorRef)>();

  CFStringRef CFErrorCopyRecoverySuggestion(
    CFErrorRef err,
  ) {
    return _CFErrorCopyRecoverySuggestion(
      err,
    );
  }

  late final _CFErrorCopyRecoverySuggestionPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFErrorRef)>>(
          'CFErrorCopyRecoverySuggestion');
  late final _CFErrorCopyRecoverySuggestion = _CFErrorCopyRecoverySuggestionPtr
      .asFunction<CFStringRef Function(CFErrorRef)>();

  int CFStringGetTypeID() {
    return _CFStringGetTypeID();
  }

  late final _CFStringGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFStringGetTypeID');
  late final _CFStringGetTypeID =
      _CFStringGetTypeIDPtr.asFunction<int Function()>();

  CFStringRef CFStringCreateWithPascalString(
    CFAllocatorRef alloc,
    ConstStr255Param pStr,
    int encoding,
  ) {
    return _CFStringCreateWithPascalString(
      alloc,
      pStr,
      encoding,
    );
  }

  late final _CFStringCreateWithPascalStringPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, ConstStr255Param,
              CFStringEncoding)>>('CFStringCreateWithPascalString');
  late final _CFStringCreateWithPascalString =
      _CFStringCreateWithPascalStringPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, ConstStr255Param, int)>();

  CFStringRef CFStringCreateWithCString(
    CFAllocatorRef alloc,
    ffi.Pointer<ffi.Char> cStr,
    int encoding,
  ) {
    return _CFStringCreateWithCString(
      alloc,
      cStr,
      encoding,
    );
  }

  late final _CFStringCreateWithCStringPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, ffi.Pointer<ffi.Char>,
              CFStringEncoding)>>('CFStringCreateWithCString');
  late final _CFStringCreateWithCString =
      _CFStringCreateWithCStringPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, ffi.Pointer<ffi.Char>, int)>();

  CFStringRef CFStringCreateWithBytes(
    CFAllocatorRef alloc,
    ffi.Pointer<UInt8> bytes,
    int numBytes,
    int encoding,
    int isExternalRepresentation,
  ) {
    return _CFStringCreateWithBytes(
      alloc,
      bytes,
      numBytes,
      encoding,
      isExternalRepresentation,
    );
  }

  late final _CFStringCreateWithBytesPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, CFIndex,
              CFStringEncoding, Boolean)>>('CFStringCreateWithBytes');
  late final _CFStringCreateWithBytes = _CFStringCreateWithBytesPtr.asFunction<
      CFStringRef Function(
          CFAllocatorRef, ffi.Pointer<UInt8>, int, int, int)>();

  CFStringRef CFStringCreateWithCharacters(
    CFAllocatorRef alloc,
    ffi.Pointer<UniChar> chars,
    int numChars,
  ) {
    return _CFStringCreateWithCharacters(
      alloc,
      chars,
      numChars,
    );
  }

  late final _CFStringCreateWithCharactersPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, ffi.Pointer<UniChar>,
              CFIndex)>>('CFStringCreateWithCharacters');
  late final _CFStringCreateWithCharacters =
      _CFStringCreateWithCharactersPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, ffi.Pointer<UniChar>, int)>();

  CFStringRef CFStringCreateWithPascalStringNoCopy(
    CFAllocatorRef alloc,
    ConstStr255Param pStr,
    int encoding,
    CFAllocatorRef contentsDeallocator,
  ) {
    return _CFStringCreateWithPascalStringNoCopy(
      alloc,
      pStr,
      encoding,
      contentsDeallocator,
    );
  }

  late final _CFStringCreateWithPascalStringNoCopyPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(
              CFAllocatorRef,
              ConstStr255Param,
              CFStringEncoding,
              CFAllocatorRef)>>('CFStringCreateWithPascalStringNoCopy');
  late final _CFStringCreateWithPascalStringNoCopy =
      _CFStringCreateWithPascalStringNoCopyPtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, ConstStr255Param, int, CFAllocatorRef)>();

  CFStringRef CFStringCreateWithCStringNoCopy(
    CFAllocatorRef alloc,
    ffi.Pointer<ffi.Char> cStr,
    int encoding,
    CFAllocatorRef contentsDeallocator,
  ) {
    return _CFStringCreateWithCStringNoCopy(
      alloc,
      cStr,
      encoding,
      contentsDeallocator,
    );
  }

  late final _CFStringCreateWithCStringNoCopyPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(
              CFAllocatorRef,
              ffi.Pointer<ffi.Char>,
              CFStringEncoding,
              CFAllocatorRef)>>('CFStringCreateWithCStringNoCopy');
  late final _CFStringCreateWithCStringNoCopy =
      _CFStringCreateWithCStringNoCopyPtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, ffi.Pointer<ffi.Char>, int, CFAllocatorRef)>();

  CFStringRef CFStringCreateWithBytesNoCopy(
    CFAllocatorRef alloc,
    ffi.Pointer<UInt8> bytes,
    int numBytes,
    int encoding,
    int isExternalRepresentation,
    CFAllocatorRef contentsDeallocator,
  ) {
    return _CFStringCreateWithBytesNoCopy(
      alloc,
      bytes,
      numBytes,
      encoding,
      isExternalRepresentation,
      contentsDeallocator,
    );
  }

  late final _CFStringCreateWithBytesNoCopyPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(
              CFAllocatorRef,
              ffi.Pointer<UInt8>,
              CFIndex,
              CFStringEncoding,
              Boolean,
              CFAllocatorRef)>>('CFStringCreateWithBytesNoCopy');
  late final _CFStringCreateWithBytesNoCopy =
      _CFStringCreateWithBytesNoCopyPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, int, int,
              int, CFAllocatorRef)>();

  CFStringRef CFStringCreateWithCharactersNoCopy(
    CFAllocatorRef alloc,
    ffi.Pointer<UniChar> chars,
    int numChars,
    CFAllocatorRef contentsDeallocator,
  ) {
    return _CFStringCreateWithCharactersNoCopy(
      alloc,
      chars,
      numChars,
      contentsDeallocator,
    );
  }

  late final _CFStringCreateWithCharactersNoCopyPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, ffi.Pointer<UniChar>, CFIndex,
              CFAllocatorRef)>>('CFStringCreateWithCharactersNoCopy');
  late final _CFStringCreateWithCharactersNoCopy =
      _CFStringCreateWithCharactersNoCopyPtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, ffi.Pointer<UniChar>, int, CFAllocatorRef)>();

  CFStringRef CFStringCreateWithSubstring(
    CFAllocatorRef alloc,
    CFStringRef str,
    CFRange range,
  ) {
    return _CFStringCreateWithSubstring(
      alloc,
      str,
      range,
    );
  }

  late final _CFStringCreateWithSubstringPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFStringRef,
              CFRange)>>('CFStringCreateWithSubstring');
  late final _CFStringCreateWithSubstring = _CFStringCreateWithSubstringPtr
      .asFunction<CFStringRef Function(CFAllocatorRef, CFStringRef, CFRange)>();

  CFStringRef CFStringCreateCopy(
    CFAllocatorRef alloc,
    CFStringRef theString,
  ) {
    return _CFStringCreateCopy(
      alloc,
      theString,
    );
  }

  late final _CFStringCreateCopyPtr = _lookup<
          ffi
          .NativeFunction<CFStringRef Function(CFAllocatorRef, CFStringRef)>>(
      'CFStringCreateCopy');
  late final _CFStringCreateCopy = _CFStringCreateCopyPtr.asFunction<
      CFStringRef Function(CFAllocatorRef, CFStringRef)>();

  CFStringRef CFStringCreateWithFormat(
    CFAllocatorRef alloc,
    CFDictionaryRef formatOptions,
    CFStringRef format,
  ) {
    return _CFStringCreateWithFormat(
      alloc,
      formatOptions,
      format,
    );
  }

  late final _CFStringCreateWithFormatPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFDictionaryRef,
              CFStringRef)>>('CFStringCreateWithFormat');
  late final _CFStringCreateWithFormat =
      _CFStringCreateWithFormatPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, CFDictionaryRef, CFStringRef)>();

  CFStringRef CFStringCreateWithFormatAndArguments(
    CFAllocatorRef alloc,
    CFDictionaryRef formatOptions,
    CFStringRef format,
    va_list arguments,
  ) {
    return _CFStringCreateWithFormatAndArguments(
      alloc,
      formatOptions,
      format,
      arguments,
    );
  }

  late final _CFStringCreateWithFormatAndArgumentsPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFDictionaryRef, CFStringRef,
              va_list)>>('CFStringCreateWithFormatAndArguments');
  late final _CFStringCreateWithFormatAndArguments =
      _CFStringCreateWithFormatAndArgumentsPtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, CFDictionaryRef, CFStringRef, va_list)>();

  CFStringRef CFStringCreateStringWithValidatedFormat(
    CFAllocatorRef alloc,
    CFDictionaryRef formatOptions,
    CFStringRef validFormatSpecifiers,
    CFStringRef format,
    ffi.Pointer<CFErrorRef> errorPtr,
  ) {
    return _CFStringCreateStringWithValidatedFormat(
      alloc,
      formatOptions,
      validFormatSpecifiers,
      format,
      errorPtr,
    );
  }

  late final _CFStringCreateStringWithValidatedFormatPtr = _lookup<
          ffi.NativeFunction<
              CFStringRef Function(CFAllocatorRef, CFDictionaryRef, CFStringRef,
                  CFStringRef, ffi.Pointer<CFErrorRef>)>>(
      'CFStringCreateStringWithValidatedFormat');
  late final _CFStringCreateStringWithValidatedFormat =
      _CFStringCreateStringWithValidatedFormatPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, CFDictionaryRef, CFStringRef,
              CFStringRef, ffi.Pointer<CFErrorRef>)>();

  CFStringRef CFStringCreateStringWithValidatedFormatAndArguments(
    CFAllocatorRef alloc,
    CFDictionaryRef formatOptions,
    CFStringRef validFormatSpecifiers,
    CFStringRef format,
    va_list arguments,
    ffi.Pointer<CFErrorRef> errorPtr,
  ) {
    return _CFStringCreateStringWithValidatedFormatAndArguments(
      alloc,
      formatOptions,
      validFormatSpecifiers,
      format,
      arguments,
      errorPtr,
    );
  }

  late final _CFStringCreateStringWithValidatedFormatAndArgumentsPtr = _lookup<
          ffi.NativeFunction<
              CFStringRef Function(CFAllocatorRef, CFDictionaryRef, CFStringRef,
                  CFStringRef, va_list, ffi.Pointer<CFErrorRef>)>>(
      'CFStringCreateStringWithValidatedFormatAndArguments');
  late final _CFStringCreateStringWithValidatedFormatAndArguments =
      _CFStringCreateStringWithValidatedFormatAndArgumentsPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, CFDictionaryRef, CFStringRef,
              CFStringRef, va_list, ffi.Pointer<CFErrorRef>)>();

  CFMutableStringRef CFStringCreateMutable(
    CFAllocatorRef alloc,
    int maxLength,
  ) {
    return _CFStringCreateMutable(
      alloc,
      maxLength,
    );
  }

  late final _CFStringCreateMutablePtr = _lookup<
      ffi.NativeFunction<
          CFMutableStringRef Function(
              CFAllocatorRef, CFIndex)>>('CFStringCreateMutable');
  late final _CFStringCreateMutable = _CFStringCreateMutablePtr.asFunction<
      CFMutableStringRef Function(CFAllocatorRef, int)>();

  CFMutableStringRef CFStringCreateMutableCopy(
    CFAllocatorRef alloc,
    int maxLength,
    CFStringRef theString,
  ) {
    return _CFStringCreateMutableCopy(
      alloc,
      maxLength,
      theString,
    );
  }

  late final _CFStringCreateMutableCopyPtr = _lookup<
      ffi.NativeFunction<
          CFMutableStringRef Function(CFAllocatorRef, CFIndex,
              CFStringRef)>>('CFStringCreateMutableCopy');
  late final _CFStringCreateMutableCopy =
      _CFStringCreateMutableCopyPtr.asFunction<
          CFMutableStringRef Function(CFAllocatorRef, int, CFStringRef)>();

  CFMutableStringRef CFStringCreateMutableWithExternalCharactersNoCopy(
    CFAllocatorRef alloc,
    ffi.Pointer<UniChar> chars,
    int numChars,
    int capacity,
    CFAllocatorRef externalCharactersAllocator,
  ) {
    return _CFStringCreateMutableWithExternalCharactersNoCopy(
      alloc,
      chars,
      numChars,
      capacity,
      externalCharactersAllocator,
    );
  }

  late final _CFStringCreateMutableWithExternalCharactersNoCopyPtr = _lookup<
          ffi.NativeFunction<
              CFMutableStringRef Function(CFAllocatorRef, ffi.Pointer<UniChar>,
                  CFIndex, CFIndex, CFAllocatorRef)>>(
      'CFStringCreateMutableWithExternalCharactersNoCopy');
  late final _CFStringCreateMutableWithExternalCharactersNoCopy =
      _CFStringCreateMutableWithExternalCharactersNoCopyPtr.asFunction<
          CFMutableStringRef Function(CFAllocatorRef, ffi.Pointer<UniChar>, int,
              int, CFAllocatorRef)>();

  int CFStringGetLength(
    CFStringRef theString,
  ) {
    return _CFStringGetLength(
      theString,
    );
  }

  late final _CFStringGetLengthPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFStringRef)>>(
          'CFStringGetLength');
  late final _CFStringGetLength =
      _CFStringGetLengthPtr.asFunction<int Function(CFStringRef)>();

  int CFStringGetCharacterAtIndex(
    CFStringRef theString,
    int idx,
  ) {
    return _CFStringGetCharacterAtIndex(
      theString,
      idx,
    );
  }

  late final _CFStringGetCharacterAtIndexPtr =
      _lookup<ffi.NativeFunction<UniChar Function(CFStringRef, CFIndex)>>(
          'CFStringGetCharacterAtIndex');
  late final _CFStringGetCharacterAtIndex = _CFStringGetCharacterAtIndexPtr
      .asFunction<int Function(CFStringRef, int)>();

  void CFStringGetCharacters(
    CFStringRef theString,
    CFRange range,
    ffi.Pointer<UniChar> buffer,
  ) {
    return _CFStringGetCharacters(
      theString,
      range,
      buffer,
    );
  }

  late final _CFStringGetCharactersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFStringRef, CFRange,
              ffi.Pointer<UniChar>)>>('CFStringGetCharacters');
  late final _CFStringGetCharacters = _CFStringGetCharactersPtr.asFunction<
      void Function(CFStringRef, CFRange, ffi.Pointer<UniChar>)>();

  int CFStringGetPascalString(
    CFStringRef theString,
    StringPtr buffer,
    int bufferSize,
    int encoding,
  ) {
    return _CFStringGetPascalString(
      theString,
      buffer,
      bufferSize,
      encoding,
    );
  }

  late final _CFStringGetPascalStringPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFStringRef, StringPtr, CFIndex,
              CFStringEncoding)>>('CFStringGetPascalString');
  late final _CFStringGetPascalString = _CFStringGetPascalStringPtr.asFunction<
      int Function(CFStringRef, StringPtr, int, int)>();

  int CFStringGetCString(
    CFStringRef theString,
    ffi.Pointer<ffi.Char> buffer,
    int bufferSize,
    int encoding,
  ) {
    return _CFStringGetCString(
      theString,
      buffer,
      bufferSize,
      encoding,
    );
  }

  late final _CFStringGetCStringPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFStringRef, ffi.Pointer<ffi.Char>, CFIndex,
              CFStringEncoding)>>('CFStringGetCString');
  late final _CFStringGetCString = _CFStringGetCStringPtr.asFunction<
      int Function(CFStringRef, ffi.Pointer<ffi.Char>, int, int)>();

  ConstStringPtr CFStringGetPascalStringPtr(
    CFStringRef theString,
    int encoding,
  ) {
    return _CFStringGetPascalStringPtr1(
      theString,
      encoding,
    );
  }

  late final _CFStringGetPascalStringPtrPtr = _lookup<
      ffi.NativeFunction<
          ConstStringPtr Function(
              CFStringRef, CFStringEncoding)>>('CFStringGetPascalStringPtr');
  late final _CFStringGetPascalStringPtr1 = _CFStringGetPascalStringPtrPtr
      .asFunction<ConstStringPtr Function(CFStringRef, int)>();

  ffi.Pointer<ffi.Char> CFStringGetCStringPtr(
    CFStringRef theString,
    int encoding,
  ) {
    return _CFStringGetCStringPtr1(
      theString,
      encoding,
    );
  }

  late final _CFStringGetCStringPtrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              CFStringRef, CFStringEncoding)>>('CFStringGetCStringPtr');
  late final _CFStringGetCStringPtr1 = _CFStringGetCStringPtrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(CFStringRef, int)>();

  ffi.Pointer<UniChar> CFStringGetCharactersPtr(
    CFStringRef theString,
  ) {
    return _CFStringGetCharactersPtr1(
      theString,
    );
  }

  late final _CFStringGetCharactersPtrPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<UniChar> Function(CFStringRef)>>(
          'CFStringGetCharactersPtr');
  late final _CFStringGetCharactersPtr1 = _CFStringGetCharactersPtrPtr
      .asFunction<ffi.Pointer<UniChar> Function(CFStringRef)>();

  int CFStringGetBytes(
    CFStringRef theString,
    CFRange range,
    int encoding,
    int lossByte,
    int isExternalRepresentation,
    ffi.Pointer<UInt8> buffer,
    int maxBufLen,
    ffi.Pointer<CFIndex> usedBufLen,
  ) {
    return _CFStringGetBytes(
      theString,
      range,
      encoding,
      lossByte,
      isExternalRepresentation,
      buffer,
      maxBufLen,
      usedBufLen,
    );
  }

  late final _CFStringGetBytesPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(
              CFStringRef,
              CFRange,
              CFStringEncoding,
              UInt8,
              Boolean,
              ffi.Pointer<UInt8>,
              CFIndex,
              ffi.Pointer<CFIndex>)>>('CFStringGetBytes');
  late final _CFStringGetBytes = _CFStringGetBytesPtr.asFunction<
      int Function(CFStringRef, CFRange, int, int, int, ffi.Pointer<UInt8>, int,
          ffi.Pointer<CFIndex>)>();

  CFStringRef CFStringCreateFromExternalRepresentation(
    CFAllocatorRef alloc,
    CFDataRef data,
    int encoding,
  ) {
    return _CFStringCreateFromExternalRepresentation(
      alloc,
      data,
      encoding,
    );
  }

  late final _CFStringCreateFromExternalRepresentationPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFDataRef,
              CFStringEncoding)>>('CFStringCreateFromExternalRepresentation');
  late final _CFStringCreateFromExternalRepresentation =
      _CFStringCreateFromExternalRepresentationPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, CFDataRef, int)>();

  CFDataRef CFStringCreateExternalRepresentation(
    CFAllocatorRef alloc,
    CFStringRef theString,
    int encoding,
    int lossByte,
  ) {
    return _CFStringCreateExternalRepresentation(
      alloc,
      theString,
      encoding,
      lossByte,
    );
  }

  late final _CFStringCreateExternalRepresentationPtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(CFAllocatorRef, CFStringRef, CFStringEncoding,
              UInt8)>>('CFStringCreateExternalRepresentation');
  late final _CFStringCreateExternalRepresentation =
      _CFStringCreateExternalRepresentationPtr.asFunction<
          CFDataRef Function(CFAllocatorRef, CFStringRef, int, int)>();

  int CFStringGetSmallestEncoding(
    CFStringRef theString,
  ) {
    return _CFStringGetSmallestEncoding(
      theString,
    );
  }

  late final _CFStringGetSmallestEncodingPtr =
      _lookup<ffi.NativeFunction<CFStringEncoding Function(CFStringRef)>>(
          'CFStringGetSmallestEncoding');
  late final _CFStringGetSmallestEncoding =
      _CFStringGetSmallestEncodingPtr.asFunction<int Function(CFStringRef)>();

  int CFStringGetFastestEncoding(
    CFStringRef theString,
  ) {
    return _CFStringGetFastestEncoding(
      theString,
    );
  }

  late final _CFStringGetFastestEncodingPtr =
      _lookup<ffi.NativeFunction<CFStringEncoding Function(CFStringRef)>>(
          'CFStringGetFastestEncoding');
  late final _CFStringGetFastestEncoding =
      _CFStringGetFastestEncodingPtr.asFunction<int Function(CFStringRef)>();

  int CFStringGetSystemEncoding() {
    return _CFStringGetSystemEncoding();
  }

  late final _CFStringGetSystemEncodingPtr =
      _lookup<ffi.NativeFunction<CFStringEncoding Function()>>(
          'CFStringGetSystemEncoding');
  late final _CFStringGetSystemEncoding =
      _CFStringGetSystemEncodingPtr.asFunction<int Function()>();

  int CFStringGetMaximumSizeForEncoding(
    int length,
    int encoding,
  ) {
    return _CFStringGetMaximumSizeForEncoding(
      length,
      encoding,
    );
  }

  late final _CFStringGetMaximumSizeForEncodingPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFIndex, CFStringEncoding)>>(
          'CFStringGetMaximumSizeForEncoding');
  late final _CFStringGetMaximumSizeForEncoding =
      _CFStringGetMaximumSizeForEncodingPtr.asFunction<
          int Function(int, int)>();

  int CFStringGetFileSystemRepresentation(
    CFStringRef string,
    ffi.Pointer<ffi.Char> buffer,
    int maxBufLen,
  ) {
    return _CFStringGetFileSystemRepresentation(
      string,
      buffer,
      maxBufLen,
    );
  }

  late final _CFStringGetFileSystemRepresentationPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFStringRef, ffi.Pointer<ffi.Char>,
              CFIndex)>>('CFStringGetFileSystemRepresentation');
  late final _CFStringGetFileSystemRepresentation =
      _CFStringGetFileSystemRepresentationPtr.asFunction<
          int Function(CFStringRef, ffi.Pointer<ffi.Char>, int)>();

  int CFStringGetMaximumSizeOfFileSystemRepresentation(
    CFStringRef string,
  ) {
    return _CFStringGetMaximumSizeOfFileSystemRepresentation(
      string,
    );
  }

  late final _CFStringGetMaximumSizeOfFileSystemRepresentationPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFStringRef)>>(
          'CFStringGetMaximumSizeOfFileSystemRepresentation');
  late final _CFStringGetMaximumSizeOfFileSystemRepresentation =
      _CFStringGetMaximumSizeOfFileSystemRepresentationPtr.asFunction<
          int Function(CFStringRef)>();

  CFStringRef CFStringCreateWithFileSystemRepresentation(
    CFAllocatorRef alloc,
    ffi.Pointer<ffi.Char> buffer,
  ) {
    return _CFStringCreateWithFileSystemRepresentation(
      alloc,
      buffer,
    );
  }

  late final _CFStringCreateWithFileSystemRepresentationPtr = _lookup<
          ffi.NativeFunction<
              CFStringRef Function(CFAllocatorRef, ffi.Pointer<ffi.Char>)>>(
      'CFStringCreateWithFileSystemRepresentation');
  late final _CFStringCreateWithFileSystemRepresentation =
      _CFStringCreateWithFileSystemRepresentationPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, ffi.Pointer<ffi.Char>)>();

  CFComparisonResult CFStringCompareWithOptionsAndLocale(
    CFStringRef theString1,
    CFStringRef theString2,
    CFRange rangeToCompare,
    CFStringCompareFlags compareOptions,
    CFLocaleRef locale,
  ) {
    return CFComparisonResult.fromValue(_CFStringCompareWithOptionsAndLocale(
      theString1,
      theString2,
      rangeToCompare,
      compareOptions.value,
      locale,
    ));
  }

  late final _CFStringCompareWithOptionsAndLocalePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFStringRef, CFStringRef, CFRange, CFOptionFlags,
              CFLocaleRef)>>('CFStringCompareWithOptionsAndLocale');
  late final _CFStringCompareWithOptionsAndLocale =
      _CFStringCompareWithOptionsAndLocalePtr.asFunction<
          int Function(CFStringRef, CFStringRef, CFRange, int, CFLocaleRef)>();

  CFComparisonResult CFStringCompareWithOptions(
    CFStringRef theString1,
    CFStringRef theString2,
    CFRange rangeToCompare,
    CFStringCompareFlags compareOptions,
  ) {
    return CFComparisonResult.fromValue(_CFStringCompareWithOptions(
      theString1,
      theString2,
      rangeToCompare,
      compareOptions.value,
    ));
  }

  late final _CFStringCompareWithOptionsPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFStringRef, CFStringRef, CFRange,
              CFOptionFlags)>>('CFStringCompareWithOptions');
  late final _CFStringCompareWithOptions = _CFStringCompareWithOptionsPtr
      .asFunction<int Function(CFStringRef, CFStringRef, CFRange, int)>();

  CFComparisonResult CFStringCompare(
    CFStringRef theString1,
    CFStringRef theString2,
    CFStringCompareFlags compareOptions,
  ) {
    return CFComparisonResult.fromValue(_CFStringCompare(
      theString1,
      theString2,
      compareOptions.value,
    ));
  }

  late final _CFStringComparePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(
              CFStringRef, CFStringRef, CFOptionFlags)>>('CFStringCompare');
  late final _CFStringCompare = _CFStringComparePtr.asFunction<
      int Function(CFStringRef, CFStringRef, int)>();

  DartBoolean CFStringFindWithOptionsAndLocale(
    CFStringRef theString,
    CFStringRef stringToFind,
    CFRange rangeToSearch,
    CFStringCompareFlags searchOptions,
    CFLocaleRef locale,
    ffi.Pointer<CFRange> result,
  ) {
    return _CFStringFindWithOptionsAndLocale(
      theString,
      stringToFind,
      rangeToSearch,
      searchOptions.value,
      locale,
      result,
    );
  }

  late final _CFStringFindWithOptionsAndLocalePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(
              CFStringRef,
              CFStringRef,
              CFRange,
              CFOptionFlags,
              CFLocaleRef,
              ffi.Pointer<CFRange>)>>('CFStringFindWithOptionsAndLocale');
  late final _CFStringFindWithOptionsAndLocale =
      _CFStringFindWithOptionsAndLocalePtr.asFunction<
          int Function(CFStringRef, CFStringRef, CFRange, int, CFLocaleRef,
              ffi.Pointer<CFRange>)>();

  DartBoolean CFStringFindWithOptions(
    CFStringRef theString,
    CFStringRef stringToFind,
    CFRange rangeToSearch,
    CFStringCompareFlags searchOptions,
    ffi.Pointer<CFRange> result,
  ) {
    return _CFStringFindWithOptions(
      theString,
      stringToFind,
      rangeToSearch,
      searchOptions.value,
      result,
    );
  }

  late final _CFStringFindWithOptionsPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFStringRef, CFStringRef, CFRange, CFOptionFlags,
              ffi.Pointer<CFRange>)>>('CFStringFindWithOptions');
  late final _CFStringFindWithOptions = _CFStringFindWithOptionsPtr.asFunction<
      int Function(
          CFStringRef, CFStringRef, CFRange, int, ffi.Pointer<CFRange>)>();

  CFArrayRef CFStringCreateArrayWithFindResults(
    CFAllocatorRef alloc,
    CFStringRef theString,
    CFStringRef stringToFind,
    CFRange rangeToSearch,
    CFStringCompareFlags compareOptions,
  ) {
    return _CFStringCreateArrayWithFindResults(
      alloc,
      theString,
      stringToFind,
      rangeToSearch,
      compareOptions.value,
    );
  }

  late final _CFStringCreateArrayWithFindResultsPtr = _lookup<
      ffi.NativeFunction<
          CFArrayRef Function(CFAllocatorRef, CFStringRef, CFStringRef, CFRange,
              CFOptionFlags)>>('CFStringCreateArrayWithFindResults');
  late final _CFStringCreateArrayWithFindResults =
      _CFStringCreateArrayWithFindResultsPtr.asFunction<
          CFArrayRef Function(
              CFAllocatorRef, CFStringRef, CFStringRef, CFRange, int)>();

  CFRange CFStringFind(
    CFStringRef theString,
    CFStringRef stringToFind,
    CFStringCompareFlags compareOptions,
  ) {
    return _CFStringFind(
      theString,
      stringToFind,
      compareOptions.value,
    );
  }

  late final _CFStringFindPtr = _lookup<
      ffi.NativeFunction<
          CFRange Function(
              CFStringRef, CFStringRef, CFOptionFlags)>>('CFStringFind');
  late final _CFStringFind = _CFStringFindPtr.asFunction<
      CFRange Function(CFStringRef, CFStringRef, int)>();

  int CFStringHasPrefix(
    CFStringRef theString,
    CFStringRef prefix,
  ) {
    return _CFStringHasPrefix(
      theString,
      prefix,
    );
  }

  late final _CFStringHasPrefixPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFStringRef, CFStringRef)>>(
          'CFStringHasPrefix');
  late final _CFStringHasPrefix = _CFStringHasPrefixPtr.asFunction<
      int Function(CFStringRef, CFStringRef)>();

  int CFStringHasSuffix(
    CFStringRef theString,
    CFStringRef suffix,
  ) {
    return _CFStringHasSuffix(
      theString,
      suffix,
    );
  }

  late final _CFStringHasSuffixPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFStringRef, CFStringRef)>>(
          'CFStringHasSuffix');
  late final _CFStringHasSuffix = _CFStringHasSuffixPtr.asFunction<
      int Function(CFStringRef, CFStringRef)>();

  CFRange CFStringGetRangeOfComposedCharactersAtIndex(
    CFStringRef theString,
    int theIndex,
  ) {
    return _CFStringGetRangeOfComposedCharactersAtIndex(
      theString,
      theIndex,
    );
  }

  late final _CFStringGetRangeOfComposedCharactersAtIndexPtr =
      _lookup<ffi.NativeFunction<CFRange Function(CFStringRef, CFIndex)>>(
          'CFStringGetRangeOfComposedCharactersAtIndex');
  late final _CFStringGetRangeOfComposedCharactersAtIndex =
      _CFStringGetRangeOfComposedCharactersAtIndexPtr.asFunction<
          CFRange Function(CFStringRef, int)>();

  DartBoolean CFStringFindCharacterFromSet(
    CFStringRef theString,
    CFCharacterSetRef theSet,
    CFRange rangeToSearch,
    CFStringCompareFlags searchOptions,
    ffi.Pointer<CFRange> result,
  ) {
    return _CFStringFindCharacterFromSet(
      theString,
      theSet,
      rangeToSearch,
      searchOptions.value,
      result,
    );
  }

  late final _CFStringFindCharacterFromSetPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(
              CFStringRef,
              CFCharacterSetRef,
              CFRange,
              CFOptionFlags,
              ffi.Pointer<CFRange>)>>('CFStringFindCharacterFromSet');
  late final _CFStringFindCharacterFromSet =
      _CFStringFindCharacterFromSetPtr.asFunction<
          int Function(CFStringRef, CFCharacterSetRef, CFRange, int,
              ffi.Pointer<CFRange>)>();

  void CFStringGetLineBounds(
    CFStringRef theString,
    CFRange range,
    ffi.Pointer<CFIndex> lineBeginIndex,
    ffi.Pointer<CFIndex> lineEndIndex,
    ffi.Pointer<CFIndex> contentsEndIndex,
  ) {
    return _CFStringGetLineBounds(
      theString,
      range,
      lineBeginIndex,
      lineEndIndex,
      contentsEndIndex,
    );
  }

  late final _CFStringGetLineBoundsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFStringRef,
              CFRange,
              ffi.Pointer<CFIndex>,
              ffi.Pointer<CFIndex>,
              ffi.Pointer<CFIndex>)>>('CFStringGetLineBounds');
  late final _CFStringGetLineBounds = _CFStringGetLineBoundsPtr.asFunction<
      void Function(CFStringRef, CFRange, ffi.Pointer<CFIndex>,
          ffi.Pointer<CFIndex>, ffi.Pointer<CFIndex>)>();

  void CFStringGetParagraphBounds(
    CFStringRef string,
    CFRange range,
    ffi.Pointer<CFIndex> parBeginIndex,
    ffi.Pointer<CFIndex> parEndIndex,
    ffi.Pointer<CFIndex> contentsEndIndex,
  ) {
    return _CFStringGetParagraphBounds(
      string,
      range,
      parBeginIndex,
      parEndIndex,
      contentsEndIndex,
    );
  }

  late final _CFStringGetParagraphBoundsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFStringRef,
              CFRange,
              ffi.Pointer<CFIndex>,
              ffi.Pointer<CFIndex>,
              ffi.Pointer<CFIndex>)>>('CFStringGetParagraphBounds');
  late final _CFStringGetParagraphBounds =
      _CFStringGetParagraphBoundsPtr.asFunction<
          void Function(CFStringRef, CFRange, ffi.Pointer<CFIndex>,
              ffi.Pointer<CFIndex>, ffi.Pointer<CFIndex>)>();

  int CFStringGetHyphenationLocationBeforeIndex(
    CFStringRef string,
    int location,
    CFRange limitRange,
    int options,
    CFLocaleRef locale,
    ffi.Pointer<UTF32Char> character,
  ) {
    return _CFStringGetHyphenationLocationBeforeIndex(
      string,
      location,
      limitRange,
      options,
      locale,
      character,
    );
  }

  late final _CFStringGetHyphenationLocationBeforeIndexPtr = _lookup<
          ffi.NativeFunction<
              CFIndex Function(CFStringRef, CFIndex, CFRange, CFOptionFlags,
                  CFLocaleRef, ffi.Pointer<UTF32Char>)>>(
      'CFStringGetHyphenationLocationBeforeIndex');
  late final _CFStringGetHyphenationLocationBeforeIndex =
      _CFStringGetHyphenationLocationBeforeIndexPtr.asFunction<
          int Function(CFStringRef, int, CFRange, int, CFLocaleRef,
              ffi.Pointer<UTF32Char>)>();

  int CFStringIsHyphenationAvailableForLocale(
    CFLocaleRef locale,
  ) {
    return _CFStringIsHyphenationAvailableForLocale(
      locale,
    );
  }

  late final _CFStringIsHyphenationAvailableForLocalePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFLocaleRef)>>(
          'CFStringIsHyphenationAvailableForLocale');
  late final _CFStringIsHyphenationAvailableForLocale =
      _CFStringIsHyphenationAvailableForLocalePtr.asFunction<
          int Function(CFLocaleRef)>();

  CFStringRef CFStringCreateByCombiningStrings(
    CFAllocatorRef alloc,
    CFArrayRef theArray,
    CFStringRef separatorString,
  ) {
    return _CFStringCreateByCombiningStrings(
      alloc,
      theArray,
      separatorString,
    );
  }

  late final _CFStringCreateByCombiningStringsPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFArrayRef,
              CFStringRef)>>('CFStringCreateByCombiningStrings');
  late final _CFStringCreateByCombiningStrings =
      _CFStringCreateByCombiningStringsPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, CFArrayRef, CFStringRef)>();

  CFArrayRef CFStringCreateArrayBySeparatingStrings(
    CFAllocatorRef alloc,
    CFStringRef theString,
    CFStringRef separatorString,
  ) {
    return _CFStringCreateArrayBySeparatingStrings(
      alloc,
      theString,
      separatorString,
    );
  }

  late final _CFStringCreateArrayBySeparatingStringsPtr = _lookup<
      ffi.NativeFunction<
          CFArrayRef Function(CFAllocatorRef, CFStringRef,
              CFStringRef)>>('CFStringCreateArrayBySeparatingStrings');
  late final _CFStringCreateArrayBySeparatingStrings =
      _CFStringCreateArrayBySeparatingStringsPtr.asFunction<
          CFArrayRef Function(CFAllocatorRef, CFStringRef, CFStringRef)>();

  int CFStringGetIntValue(
    CFStringRef str,
  ) {
    return _CFStringGetIntValue(
      str,
    );
  }

  late final _CFStringGetIntValuePtr =
      _lookup<ffi.NativeFunction<SInt32 Function(CFStringRef)>>(
          'CFStringGetIntValue');
  late final _CFStringGetIntValue =
      _CFStringGetIntValuePtr.asFunction<int Function(CFStringRef)>();

  double CFStringGetDoubleValue(
    CFStringRef str,
  ) {
    return _CFStringGetDoubleValue(
      str,
    );
  }

  late final _CFStringGetDoubleValuePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(CFStringRef)>>(
          'CFStringGetDoubleValue');
  late final _CFStringGetDoubleValue =
      _CFStringGetDoubleValuePtr.asFunction<double Function(CFStringRef)>();

  void CFStringAppend(
    CFMutableStringRef theString,
    CFStringRef appendedString,
  ) {
    return _CFStringAppend(
      theString,
      appendedString,
    );
  }

  late final _CFStringAppendPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(CFMutableStringRef, CFStringRef)>>(
      'CFStringAppend');
  late final _CFStringAppend = _CFStringAppendPtr.asFunction<
      void Function(CFMutableStringRef, CFStringRef)>();

  void CFStringAppendCharacters(
    CFMutableStringRef theString,
    ffi.Pointer<UniChar> chars,
    int numChars,
  ) {
    return _CFStringAppendCharacters(
      theString,
      chars,
      numChars,
    );
  }

  late final _CFStringAppendCharactersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableStringRef, ffi.Pointer<UniChar>,
              CFIndex)>>('CFStringAppendCharacters');
  late final _CFStringAppendCharacters =
      _CFStringAppendCharactersPtr.asFunction<
          void Function(CFMutableStringRef, ffi.Pointer<UniChar>, int)>();

  void CFStringAppendPascalString(
    CFMutableStringRef theString,
    ConstStr255Param pStr,
    int encoding,
  ) {
    return _CFStringAppendPascalString(
      theString,
      pStr,
      encoding,
    );
  }

  late final _CFStringAppendPascalStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableStringRef, ConstStr255Param,
              CFStringEncoding)>>('CFStringAppendPascalString');
  late final _CFStringAppendPascalString = _CFStringAppendPascalStringPtr
      .asFunction<void Function(CFMutableStringRef, ConstStr255Param, int)>();

  void CFStringAppendCString(
    CFMutableStringRef theString,
    ffi.Pointer<ffi.Char> cStr,
    int encoding,
  ) {
    return _CFStringAppendCString(
      theString,
      cStr,
      encoding,
    );
  }

  late final _CFStringAppendCStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableStringRef, ffi.Pointer<ffi.Char>,
              CFStringEncoding)>>('CFStringAppendCString');
  late final _CFStringAppendCString = _CFStringAppendCStringPtr.asFunction<
      void Function(CFMutableStringRef, ffi.Pointer<ffi.Char>, int)>();

  void CFStringAppendFormat(
    CFMutableStringRef theString,
    CFDictionaryRef formatOptions,
    CFStringRef format,
  ) {
    return _CFStringAppendFormat(
      theString,
      formatOptions,
      format,
    );
  }

  late final _CFStringAppendFormatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableStringRef, CFDictionaryRef,
              CFStringRef)>>('CFStringAppendFormat');
  late final _CFStringAppendFormat = _CFStringAppendFormatPtr.asFunction<
      void Function(CFMutableStringRef, CFDictionaryRef, CFStringRef)>();

  void CFStringAppendFormatAndArguments(
    CFMutableStringRef theString,
    CFDictionaryRef formatOptions,
    CFStringRef format,
    va_list arguments,
  ) {
    return _CFStringAppendFormatAndArguments(
      theString,
      formatOptions,
      format,
      arguments,
    );
  }

  late final _CFStringAppendFormatAndArgumentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableStringRef, CFDictionaryRef, CFStringRef,
              va_list)>>('CFStringAppendFormatAndArguments');
  late final _CFStringAppendFormatAndArguments =
      _CFStringAppendFormatAndArgumentsPtr.asFunction<
          void Function(
              CFMutableStringRef, CFDictionaryRef, CFStringRef, va_list)>();

  void CFStringInsert(
    CFMutableStringRef str,
    int idx,
    CFStringRef insertedStr,
  ) {
    return _CFStringInsert(
      str,
      idx,
      insertedStr,
    );
  }

  late final _CFStringInsertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableStringRef, CFIndex, CFStringRef)>>('CFStringInsert');
  late final _CFStringInsert = _CFStringInsertPtr.asFunction<
      void Function(CFMutableStringRef, int, CFStringRef)>();

  void CFStringDelete(
    CFMutableStringRef theString,
    CFRange range,
  ) {
    return _CFStringDelete(
      theString,
      range,
    );
  }

  late final _CFStringDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFMutableStringRef, CFRange)>>(
      'CFStringDelete');
  late final _CFStringDelete = _CFStringDeletePtr.asFunction<
      void Function(CFMutableStringRef, CFRange)>();

  void CFStringReplace(
    CFMutableStringRef theString,
    CFRange range,
    CFStringRef replacement,
  ) {
    return _CFStringReplace(
      theString,
      range,
      replacement,
    );
  }

  late final _CFStringReplacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableStringRef, CFRange, CFStringRef)>>('CFStringReplace');
  late final _CFStringReplace = _CFStringReplacePtr.asFunction<
      void Function(CFMutableStringRef, CFRange, CFStringRef)>();

  void CFStringReplaceAll(
    CFMutableStringRef theString,
    CFStringRef replacement,
  ) {
    return _CFStringReplaceAll(
      theString,
      replacement,
    );
  }

  late final _CFStringReplaceAllPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(CFMutableStringRef, CFStringRef)>>(
      'CFStringReplaceAll');
  late final _CFStringReplaceAll = _CFStringReplaceAllPtr.asFunction<
      void Function(CFMutableStringRef, CFStringRef)>();

  DartCFIndex CFStringFindAndReplace(
    CFMutableStringRef theString,
    CFStringRef stringToFind,
    CFStringRef replacementString,
    CFRange rangeToSearch,
    CFStringCompareFlags compareOptions,
  ) {
    return _CFStringFindAndReplace(
      theString,
      stringToFind,
      replacementString,
      rangeToSearch,
      compareOptions.value,
    );
  }

  late final _CFStringFindAndReplacePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFMutableStringRef, CFStringRef, CFStringRef,
              CFRange, CFOptionFlags)>>('CFStringFindAndReplace');
  late final _CFStringFindAndReplace = _CFStringFindAndReplacePtr.asFunction<
      int Function(
          CFMutableStringRef, CFStringRef, CFStringRef, CFRange, int)>();

  void CFStringSetExternalCharactersNoCopy(
    CFMutableStringRef theString,
    ffi.Pointer<UniChar> chars,
    int length,
    int capacity,
  ) {
    return _CFStringSetExternalCharactersNoCopy(
      theString,
      chars,
      length,
      capacity,
    );
  }

  late final _CFStringSetExternalCharactersNoCopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableStringRef, ffi.Pointer<UniChar>, CFIndex,
              CFIndex)>>('CFStringSetExternalCharactersNoCopy');
  late final _CFStringSetExternalCharactersNoCopy =
      _CFStringSetExternalCharactersNoCopyPtr.asFunction<
          void Function(CFMutableStringRef, ffi.Pointer<UniChar>, int, int)>();

  void CFStringPad(
    CFMutableStringRef theString,
    CFStringRef padString,
    int length,
    int indexIntoPad,
  ) {
    return _CFStringPad(
      theString,
      padString,
      length,
      indexIntoPad,
    );
  }

  late final _CFStringPadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableStringRef, CFStringRef, CFIndex,
              CFIndex)>>('CFStringPad');
  late final _CFStringPad = _CFStringPadPtr.asFunction<
      void Function(CFMutableStringRef, CFStringRef, int, int)>();

  void CFStringTrim(
    CFMutableStringRef theString,
    CFStringRef trimString,
  ) {
    return _CFStringTrim(
      theString,
      trimString,
    );
  }

  late final _CFStringTrimPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableStringRef, CFStringRef)>>('CFStringTrim');
  late final _CFStringTrim = _CFStringTrimPtr.asFunction<
      void Function(CFMutableStringRef, CFStringRef)>();

  void CFStringTrimWhitespace(
    CFMutableStringRef theString,
  ) {
    return _CFStringTrimWhitespace(
      theString,
    );
  }

  late final _CFStringTrimWhitespacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMutableStringRef)>>(
          'CFStringTrimWhitespace');
  late final _CFStringTrimWhitespace = _CFStringTrimWhitespacePtr.asFunction<
      void Function(CFMutableStringRef)>();

  void CFStringLowercase(
    CFMutableStringRef theString,
    CFLocaleRef locale,
  ) {
    return _CFStringLowercase(
      theString,
      locale,
    );
  }

  late final _CFStringLowercasePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(CFMutableStringRef, CFLocaleRef)>>(
      'CFStringLowercase');
  late final _CFStringLowercase = _CFStringLowercasePtr.asFunction<
      void Function(CFMutableStringRef, CFLocaleRef)>();

  void CFStringUppercase(
    CFMutableStringRef theString,
    CFLocaleRef locale,
  ) {
    return _CFStringUppercase(
      theString,
      locale,
    );
  }

  late final _CFStringUppercasePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(CFMutableStringRef, CFLocaleRef)>>(
      'CFStringUppercase');
  late final _CFStringUppercase = _CFStringUppercasePtr.asFunction<
      void Function(CFMutableStringRef, CFLocaleRef)>();

  void CFStringCapitalize(
    CFMutableStringRef theString,
    CFLocaleRef locale,
  ) {
    return _CFStringCapitalize(
      theString,
      locale,
    );
  }

  late final _CFStringCapitalizePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(CFMutableStringRef, CFLocaleRef)>>(
      'CFStringCapitalize');
  late final _CFStringCapitalize = _CFStringCapitalizePtr.asFunction<
      void Function(CFMutableStringRef, CFLocaleRef)>();

  void CFStringNormalize(
    CFMutableStringRef theString,
    CFStringNormalizationForm theForm,
  ) {
    return _CFStringNormalize(
      theString,
      theForm.value,
    );
  }

  late final _CFStringNormalizePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFMutableStringRef, CFIndex)>>(
      'CFStringNormalize');
  late final _CFStringNormalize = _CFStringNormalizePtr.asFunction<
      void Function(CFMutableStringRef, int)>();

  void CFStringFold(
    CFMutableStringRef theString,
    CFStringCompareFlags theFlags,
    CFLocaleRef theLocale,
  ) {
    return _CFStringFold(
      theString,
      theFlags.value,
      theLocale,
    );
  }

  late final _CFStringFoldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableStringRef, CFOptionFlags, CFLocaleRef)>>('CFStringFold');
  late final _CFStringFold = _CFStringFoldPtr.asFunction<
      void Function(CFMutableStringRef, int, CFLocaleRef)>();

  int CFStringTransform(
    CFMutableStringRef string,
    ffi.Pointer<CFRange> range,
    CFStringRef transform,
    int reverse,
  ) {
    return _CFStringTransform(
      string,
      range,
      transform,
      reverse,
    );
  }

  late final _CFStringTransformPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFMutableStringRef, ffi.Pointer<CFRange>,
              CFStringRef, Boolean)>>('CFStringTransform');
  late final _CFStringTransform = _CFStringTransformPtr.asFunction<
      int Function(
          CFMutableStringRef, ffi.Pointer<CFRange>, CFStringRef, int)>();

  late final ffi.Pointer<CFStringRef> _kCFStringTransformStripCombiningMarks =
      _lookup<CFStringRef>('kCFStringTransformStripCombiningMarks');

  CFStringRef get kCFStringTransformStripCombiningMarks =>
      _kCFStringTransformStripCombiningMarks.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformToLatin =
      _lookup<CFStringRef>('kCFStringTransformToLatin');

  CFStringRef get kCFStringTransformToLatin => _kCFStringTransformToLatin.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformFullwidthHalfwidth =
      _lookup<CFStringRef>('kCFStringTransformFullwidthHalfwidth');

  CFStringRef get kCFStringTransformFullwidthHalfwidth =>
      _kCFStringTransformFullwidthHalfwidth.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformLatinKatakana =
      _lookup<CFStringRef>('kCFStringTransformLatinKatakana');

  CFStringRef get kCFStringTransformLatinKatakana =>
      _kCFStringTransformLatinKatakana.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformLatinHiragana =
      _lookup<CFStringRef>('kCFStringTransformLatinHiragana');

  CFStringRef get kCFStringTransformLatinHiragana =>
      _kCFStringTransformLatinHiragana.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformHiraganaKatakana =
      _lookup<CFStringRef>('kCFStringTransformHiraganaKatakana');

  CFStringRef get kCFStringTransformHiraganaKatakana =>
      _kCFStringTransformHiraganaKatakana.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformMandarinLatin =
      _lookup<CFStringRef>('kCFStringTransformMandarinLatin');

  CFStringRef get kCFStringTransformMandarinLatin =>
      _kCFStringTransformMandarinLatin.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformLatinHangul =
      _lookup<CFStringRef>('kCFStringTransformLatinHangul');

  CFStringRef get kCFStringTransformLatinHangul =>
      _kCFStringTransformLatinHangul.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformLatinArabic =
      _lookup<CFStringRef>('kCFStringTransformLatinArabic');

  CFStringRef get kCFStringTransformLatinArabic =>
      _kCFStringTransformLatinArabic.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformLatinHebrew =
      _lookup<CFStringRef>('kCFStringTransformLatinHebrew');

  CFStringRef get kCFStringTransformLatinHebrew =>
      _kCFStringTransformLatinHebrew.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformLatinThai =
      _lookup<CFStringRef>('kCFStringTransformLatinThai');

  CFStringRef get kCFStringTransformLatinThai =>
      _kCFStringTransformLatinThai.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformLatinCyrillic =
      _lookup<CFStringRef>('kCFStringTransformLatinCyrillic');

  CFStringRef get kCFStringTransformLatinCyrillic =>
      _kCFStringTransformLatinCyrillic.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformLatinGreek =
      _lookup<CFStringRef>('kCFStringTransformLatinGreek');

  CFStringRef get kCFStringTransformLatinGreek =>
      _kCFStringTransformLatinGreek.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformToXMLHex =
      _lookup<CFStringRef>('kCFStringTransformToXMLHex');

  CFStringRef get kCFStringTransformToXMLHex =>
      _kCFStringTransformToXMLHex.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformToUnicodeName =
      _lookup<CFStringRef>('kCFStringTransformToUnicodeName');

  CFStringRef get kCFStringTransformToUnicodeName =>
      _kCFStringTransformToUnicodeName.value;

  late final ffi.Pointer<CFStringRef> _kCFStringTransformStripDiacritics =
      _lookup<CFStringRef>('kCFStringTransformStripDiacritics');

  CFStringRef get kCFStringTransformStripDiacritics =>
      _kCFStringTransformStripDiacritics.value;

  int CFStringIsEncodingAvailable(
    int encoding,
  ) {
    return _CFStringIsEncodingAvailable(
      encoding,
    );
  }

  late final _CFStringIsEncodingAvailablePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFStringEncoding)>>(
          'CFStringIsEncodingAvailable');
  late final _CFStringIsEncodingAvailable =
      _CFStringIsEncodingAvailablePtr.asFunction<int Function(int)>();

  ffi.Pointer<CFStringEncoding> CFStringGetListOfAvailableEncodings() {
    return _CFStringGetListOfAvailableEncodings();
  }

  late final _CFStringGetListOfAvailableEncodingsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<CFStringEncoding> Function()>>(
          'CFStringGetListOfAvailableEncodings');
  late final _CFStringGetListOfAvailableEncodings =
      _CFStringGetListOfAvailableEncodingsPtr.asFunction<
          ffi.Pointer<CFStringEncoding> Function()>();

  CFStringRef CFStringGetNameOfEncoding(
    int encoding,
  ) {
    return _CFStringGetNameOfEncoding(
      encoding,
    );
  }

  late final _CFStringGetNameOfEncodingPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFStringEncoding)>>(
          'CFStringGetNameOfEncoding');
  late final _CFStringGetNameOfEncoding =
      _CFStringGetNameOfEncodingPtr.asFunction<CFStringRef Function(int)>();

  int CFStringConvertEncodingToNSStringEncoding(
    int encoding,
  ) {
    return _CFStringConvertEncodingToNSStringEncoding(
      encoding,
    );
  }

  late final _CFStringConvertEncodingToNSStringEncodingPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function(CFStringEncoding)>>(
          'CFStringConvertEncodingToNSStringEncoding');
  late final _CFStringConvertEncodingToNSStringEncoding =
      _CFStringConvertEncodingToNSStringEncodingPtr.asFunction<
          int Function(int)>();

  int CFStringConvertNSStringEncodingToEncoding(
    int encoding,
  ) {
    return _CFStringConvertNSStringEncodingToEncoding(
      encoding,
    );
  }

  late final _CFStringConvertNSStringEncodingToEncodingPtr =
      _lookup<ffi.NativeFunction<CFStringEncoding Function(ffi.UnsignedLong)>>(
          'CFStringConvertNSStringEncodingToEncoding');
  late final _CFStringConvertNSStringEncodingToEncoding =
      _CFStringConvertNSStringEncodingToEncodingPtr.asFunction<
          int Function(int)>();

  int CFStringConvertEncodingToWindowsCodepage(
    int encoding,
  ) {
    return _CFStringConvertEncodingToWindowsCodepage(
      encoding,
    );
  }

  late final _CFStringConvertEncodingToWindowsCodepagePtr =
      _lookup<ffi.NativeFunction<UInt32 Function(CFStringEncoding)>>(
          'CFStringConvertEncodingToWindowsCodepage');
  late final _CFStringConvertEncodingToWindowsCodepage =
      _CFStringConvertEncodingToWindowsCodepagePtr.asFunction<
          int Function(int)>();

  int CFStringConvertWindowsCodepageToEncoding(
    int codepage,
  ) {
    return _CFStringConvertWindowsCodepageToEncoding(
      codepage,
    );
  }

  late final _CFStringConvertWindowsCodepageToEncodingPtr =
      _lookup<ffi.NativeFunction<CFStringEncoding Function(UInt32)>>(
          'CFStringConvertWindowsCodepageToEncoding');
  late final _CFStringConvertWindowsCodepageToEncoding =
      _CFStringConvertWindowsCodepageToEncodingPtr.asFunction<
          int Function(int)>();

  int CFStringConvertIANACharSetNameToEncoding(
    CFStringRef theString,
  ) {
    return _CFStringConvertIANACharSetNameToEncoding(
      theString,
    );
  }

  late final _CFStringConvertIANACharSetNameToEncodingPtr =
      _lookup<ffi.NativeFunction<CFStringEncoding Function(CFStringRef)>>(
          'CFStringConvertIANACharSetNameToEncoding');
  late final _CFStringConvertIANACharSetNameToEncoding =
      _CFStringConvertIANACharSetNameToEncodingPtr.asFunction<
          int Function(CFStringRef)>();

  CFStringRef CFStringConvertEncodingToIANACharSetName(
    int encoding,
  ) {
    return _CFStringConvertEncodingToIANACharSetName(
      encoding,
    );
  }

  late final _CFStringConvertEncodingToIANACharSetNamePtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFStringEncoding)>>(
          'CFStringConvertEncodingToIANACharSetName');
  late final _CFStringConvertEncodingToIANACharSetName =
      _CFStringConvertEncodingToIANACharSetNamePtr.asFunction<
          CFStringRef Function(int)>();

  int CFStringGetMostCompatibleMacStringEncoding(
    int encoding,
  ) {
    return _CFStringGetMostCompatibleMacStringEncoding(
      encoding,
    );
  }

  late final _CFStringGetMostCompatibleMacStringEncodingPtr =
      _lookup<ffi.NativeFunction<CFStringEncoding Function(CFStringEncoding)>>(
          'CFStringGetMostCompatibleMacStringEncoding');
  late final _CFStringGetMostCompatibleMacStringEncoding =
      _CFStringGetMostCompatibleMacStringEncodingPtr.asFunction<
          int Function(int)>();

  void CFShow(
    CFTypeRef obj,
  ) {
    return _CFShow(
      obj,
    );
  }

  late final _CFShowPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFTypeRef)>>('CFShow');
  late final _CFShow = _CFShowPtr.asFunction<void Function(CFTypeRef)>();

  void CFShowStr(
    CFStringRef str,
  ) {
    return _CFShowStr(
      str,
    );
  }

  late final _CFShowStrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFStringRef)>>('CFShowStr');
  late final _CFShowStr =
      _CFShowStrPtr.asFunction<void Function(CFStringRef)>();

  CFStringRef __CFStringMakeConstantString(
    ffi.Pointer<ffi.Char> cStr,
  ) {
    return ___CFStringMakeConstantString(
      cStr,
    );
  }

  late final ___CFStringMakeConstantStringPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Char>)>>(
          '__CFStringMakeConstantString');
  late final ___CFStringMakeConstantString = ___CFStringMakeConstantStringPtr
      .asFunction<CFStringRef Function(ffi.Pointer<ffi.Char>)>();

  int CFTimeZoneGetTypeID() {
    return _CFTimeZoneGetTypeID();
  }

  late final _CFTimeZoneGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFTimeZoneGetTypeID');
  late final _CFTimeZoneGetTypeID =
      _CFTimeZoneGetTypeIDPtr.asFunction<int Function()>();

  CFTimeZoneRef CFTimeZoneCopySystem() {
    return _CFTimeZoneCopySystem();
  }

  late final _CFTimeZoneCopySystemPtr =
      _lookup<ffi.NativeFunction<CFTimeZoneRef Function()>>(
          'CFTimeZoneCopySystem');
  late final _CFTimeZoneCopySystem =
      _CFTimeZoneCopySystemPtr.asFunction<CFTimeZoneRef Function()>();

  void CFTimeZoneResetSystem() {
    return _CFTimeZoneResetSystem();
  }

  late final _CFTimeZoneResetSystemPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('CFTimeZoneResetSystem');
  late final _CFTimeZoneResetSystem =
      _CFTimeZoneResetSystemPtr.asFunction<void Function()>();

  CFTimeZoneRef CFTimeZoneCopyDefault() {
    return _CFTimeZoneCopyDefault();
  }

  late final _CFTimeZoneCopyDefaultPtr =
      _lookup<ffi.NativeFunction<CFTimeZoneRef Function()>>(
          'CFTimeZoneCopyDefault');
  late final _CFTimeZoneCopyDefault =
      _CFTimeZoneCopyDefaultPtr.asFunction<CFTimeZoneRef Function()>();

  void CFTimeZoneSetDefault(
    CFTimeZoneRef tz,
  ) {
    return _CFTimeZoneSetDefault(
      tz,
    );
  }

  late final _CFTimeZoneSetDefaultPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFTimeZoneRef)>>(
          'CFTimeZoneSetDefault');
  late final _CFTimeZoneSetDefault =
      _CFTimeZoneSetDefaultPtr.asFunction<void Function(CFTimeZoneRef)>();

  CFArrayRef CFTimeZoneCopyKnownNames() {
    return _CFTimeZoneCopyKnownNames();
  }

  late final _CFTimeZoneCopyKnownNamesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function()>>(
          'CFTimeZoneCopyKnownNames');
  late final _CFTimeZoneCopyKnownNames =
      _CFTimeZoneCopyKnownNamesPtr.asFunction<CFArrayRef Function()>();

  CFDictionaryRef CFTimeZoneCopyAbbreviationDictionary() {
    return _CFTimeZoneCopyAbbreviationDictionary();
  }

  late final _CFTimeZoneCopyAbbreviationDictionaryPtr =
      _lookup<ffi.NativeFunction<CFDictionaryRef Function()>>(
          'CFTimeZoneCopyAbbreviationDictionary');
  late final _CFTimeZoneCopyAbbreviationDictionary =
      _CFTimeZoneCopyAbbreviationDictionaryPtr.asFunction<
          CFDictionaryRef Function()>();

  void CFTimeZoneSetAbbreviationDictionary(
    CFDictionaryRef dict,
  ) {
    return _CFTimeZoneSetAbbreviationDictionary(
      dict,
    );
  }

  late final _CFTimeZoneSetAbbreviationDictionaryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFDictionaryRef)>>(
          'CFTimeZoneSetAbbreviationDictionary');
  late final _CFTimeZoneSetAbbreviationDictionary =
      _CFTimeZoneSetAbbreviationDictionaryPtr.asFunction<
          void Function(CFDictionaryRef)>();

  CFTimeZoneRef CFTimeZoneCreate(
    CFAllocatorRef allocator,
    CFStringRef name,
    CFDataRef data,
  ) {
    return _CFTimeZoneCreate(
      allocator,
      name,
      data,
    );
  }

  late final _CFTimeZoneCreatePtr = _lookup<
      ffi.NativeFunction<
          CFTimeZoneRef Function(
              CFAllocatorRef, CFStringRef, CFDataRef)>>('CFTimeZoneCreate');
  late final _CFTimeZoneCreate = _CFTimeZoneCreatePtr.asFunction<
      CFTimeZoneRef Function(CFAllocatorRef, CFStringRef, CFDataRef)>();

  CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(
    CFAllocatorRef allocator,
    double ti,
  ) {
    return _CFTimeZoneCreateWithTimeIntervalFromGMT(
      allocator,
      ti,
    );
  }

  late final _CFTimeZoneCreateWithTimeIntervalFromGMTPtr = _lookup<
      ffi.NativeFunction<
          CFTimeZoneRef Function(CFAllocatorRef,
              CFTimeInterval)>>('CFTimeZoneCreateWithTimeIntervalFromGMT');
  late final _CFTimeZoneCreateWithTimeIntervalFromGMT =
      _CFTimeZoneCreateWithTimeIntervalFromGMTPtr.asFunction<
          CFTimeZoneRef Function(CFAllocatorRef, double)>();

  CFTimeZoneRef CFTimeZoneCreateWithName(
    CFAllocatorRef allocator,
    CFStringRef name,
    int tryAbbrev,
  ) {
    return _CFTimeZoneCreateWithName(
      allocator,
      name,
      tryAbbrev,
    );
  }

  late final _CFTimeZoneCreateWithNamePtr = _lookup<
      ffi.NativeFunction<
          CFTimeZoneRef Function(CFAllocatorRef, CFStringRef,
              Boolean)>>('CFTimeZoneCreateWithName');
  late final _CFTimeZoneCreateWithName = _CFTimeZoneCreateWithNamePtr
      .asFunction<CFTimeZoneRef Function(CFAllocatorRef, CFStringRef, int)>();

  CFStringRef CFTimeZoneGetName(
    CFTimeZoneRef tz,
  ) {
    return _CFTimeZoneGetName(
      tz,
    );
  }

  late final _CFTimeZoneGetNamePtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFTimeZoneRef)>>(
          'CFTimeZoneGetName');
  late final _CFTimeZoneGetName =
      _CFTimeZoneGetNamePtr.asFunction<CFStringRef Function(CFTimeZoneRef)>();

  CFDataRef CFTimeZoneGetData(
    CFTimeZoneRef tz,
  ) {
    return _CFTimeZoneGetData(
      tz,
    );
  }

  late final _CFTimeZoneGetDataPtr =
      _lookup<ffi.NativeFunction<CFDataRef Function(CFTimeZoneRef)>>(
          'CFTimeZoneGetData');
  late final _CFTimeZoneGetData =
      _CFTimeZoneGetDataPtr.asFunction<CFDataRef Function(CFTimeZoneRef)>();

  double CFTimeZoneGetSecondsFromGMT(
    CFTimeZoneRef tz,
    double at,
  ) {
    return _CFTimeZoneGetSecondsFromGMT(
      tz,
      at,
    );
  }

  late final _CFTimeZoneGetSecondsFromGMTPtr = _lookup<
      ffi.NativeFunction<
          CFTimeInterval Function(
              CFTimeZoneRef, CFAbsoluteTime)>>('CFTimeZoneGetSecondsFromGMT');
  late final _CFTimeZoneGetSecondsFromGMT = _CFTimeZoneGetSecondsFromGMTPtr
      .asFunction<double Function(CFTimeZoneRef, double)>();

  CFStringRef CFTimeZoneCopyAbbreviation(
    CFTimeZoneRef tz,
    double at,
  ) {
    return _CFTimeZoneCopyAbbreviation(
      tz,
      at,
    );
  }

  late final _CFTimeZoneCopyAbbreviationPtr = _lookup<
          ffi
          .NativeFunction<CFStringRef Function(CFTimeZoneRef, CFAbsoluteTime)>>(
      'CFTimeZoneCopyAbbreviation');
  late final _CFTimeZoneCopyAbbreviation = _CFTimeZoneCopyAbbreviationPtr
      .asFunction<CFStringRef Function(CFTimeZoneRef, double)>();

  int CFTimeZoneIsDaylightSavingTime(
    CFTimeZoneRef tz,
    double at,
  ) {
    return _CFTimeZoneIsDaylightSavingTime(
      tz,
      at,
    );
  }

  late final _CFTimeZoneIsDaylightSavingTimePtr = _lookup<
          ffi.NativeFunction<Boolean Function(CFTimeZoneRef, CFAbsoluteTime)>>(
      'CFTimeZoneIsDaylightSavingTime');
  late final _CFTimeZoneIsDaylightSavingTime =
      _CFTimeZoneIsDaylightSavingTimePtr.asFunction<
          int Function(CFTimeZoneRef, double)>();

  double CFTimeZoneGetDaylightSavingTimeOffset(
    CFTimeZoneRef tz,
    double at,
  ) {
    return _CFTimeZoneGetDaylightSavingTimeOffset(
      tz,
      at,
    );
  }

  late final _CFTimeZoneGetDaylightSavingTimeOffsetPtr = _lookup<
      ffi.NativeFunction<
          CFTimeInterval Function(CFTimeZoneRef,
              CFAbsoluteTime)>>('CFTimeZoneGetDaylightSavingTimeOffset');
  late final _CFTimeZoneGetDaylightSavingTimeOffset =
      _CFTimeZoneGetDaylightSavingTimeOffsetPtr.asFunction<
          double Function(CFTimeZoneRef, double)>();

  double CFTimeZoneGetNextDaylightSavingTimeTransition(
    CFTimeZoneRef tz,
    double at,
  ) {
    return _CFTimeZoneGetNextDaylightSavingTimeTransition(
      tz,
      at,
    );
  }

  late final _CFTimeZoneGetNextDaylightSavingTimeTransitionPtr = _lookup<
          ffi.NativeFunction<
              CFAbsoluteTime Function(CFTimeZoneRef, CFAbsoluteTime)>>(
      'CFTimeZoneGetNextDaylightSavingTimeTransition');
  late final _CFTimeZoneGetNextDaylightSavingTimeTransition =
      _CFTimeZoneGetNextDaylightSavingTimeTransitionPtr.asFunction<
          double Function(CFTimeZoneRef, double)>();

  CFStringRef CFTimeZoneCopyLocalizedName(
    CFTimeZoneRef tz,
    CFTimeZoneNameStyle style,
    CFLocaleRef locale,
  ) {
    return _CFTimeZoneCopyLocalizedName(
      tz,
      style.value,
      locale,
    );
  }

  late final _CFTimeZoneCopyLocalizedNamePtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFTimeZoneRef, CFIndex,
              CFLocaleRef)>>('CFTimeZoneCopyLocalizedName');
  late final _CFTimeZoneCopyLocalizedName = _CFTimeZoneCopyLocalizedNamePtr
      .asFunction<CFStringRef Function(CFTimeZoneRef, int, CFLocaleRef)>();

  late final ffi.Pointer<CFNotificationName>
      _kCFTimeZoneSystemTimeZoneDidChangeNotification =
      _lookup<CFNotificationName>(
          'kCFTimeZoneSystemTimeZoneDidChangeNotification');

  CFNotificationName get kCFTimeZoneSystemTimeZoneDidChangeNotification =>
      _kCFTimeZoneSystemTimeZoneDidChangeNotification.value;

  int CFCalendarGetTypeID() {
    return _CFCalendarGetTypeID();
  }

  late final _CFCalendarGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFCalendarGetTypeID');
  late final _CFCalendarGetTypeID =
      _CFCalendarGetTypeIDPtr.asFunction<int Function()>();

  CFCalendarRef CFCalendarCopyCurrent() {
    return _CFCalendarCopyCurrent();
  }

  late final _CFCalendarCopyCurrentPtr =
      _lookup<ffi.NativeFunction<CFCalendarRef Function()>>(
          'CFCalendarCopyCurrent');
  late final _CFCalendarCopyCurrent =
      _CFCalendarCopyCurrentPtr.asFunction<CFCalendarRef Function()>();

  CFCalendarRef CFCalendarCreateWithIdentifier(
    CFAllocatorRef allocator,
    CFCalendarIdentifier identifier,
  ) {
    return _CFCalendarCreateWithIdentifier(
      allocator,
      identifier,
    );
  }

  late final _CFCalendarCreateWithIdentifierPtr = _lookup<
      ffi.NativeFunction<
          CFCalendarRef Function(CFAllocatorRef,
              CFCalendarIdentifier)>>('CFCalendarCreateWithIdentifier');
  late final _CFCalendarCreateWithIdentifier =
      _CFCalendarCreateWithIdentifierPtr.asFunction<
          CFCalendarRef Function(CFAllocatorRef, CFCalendarIdentifier)>();

  CFCalendarIdentifier CFCalendarGetIdentifier(
    CFCalendarRef calendar,
  ) {
    return _CFCalendarGetIdentifier(
      calendar,
    );
  }

  late final _CFCalendarGetIdentifierPtr =
      _lookup<ffi.NativeFunction<CFCalendarIdentifier Function(CFCalendarRef)>>(
          'CFCalendarGetIdentifier');
  late final _CFCalendarGetIdentifier = _CFCalendarGetIdentifierPtr.asFunction<
      CFCalendarIdentifier Function(CFCalendarRef)>();

  CFLocaleRef CFCalendarCopyLocale(
    CFCalendarRef calendar,
  ) {
    return _CFCalendarCopyLocale(
      calendar,
    );
  }

  late final _CFCalendarCopyLocalePtr =
      _lookup<ffi.NativeFunction<CFLocaleRef Function(CFCalendarRef)>>(
          'CFCalendarCopyLocale');
  late final _CFCalendarCopyLocale = _CFCalendarCopyLocalePtr.asFunction<
      CFLocaleRef Function(CFCalendarRef)>();

  void CFCalendarSetLocale(
    CFCalendarRef calendar,
    CFLocaleRef locale,
  ) {
    return _CFCalendarSetLocale(
      calendar,
      locale,
    );
  }

  late final _CFCalendarSetLocalePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFCalendarRef, CFLocaleRef)>>(
      'CFCalendarSetLocale');
  late final _CFCalendarSetLocale = _CFCalendarSetLocalePtr.asFunction<
      void Function(CFCalendarRef, CFLocaleRef)>();

  CFTimeZoneRef CFCalendarCopyTimeZone(
    CFCalendarRef calendar,
  ) {
    return _CFCalendarCopyTimeZone(
      calendar,
    );
  }

  late final _CFCalendarCopyTimeZonePtr =
      _lookup<ffi.NativeFunction<CFTimeZoneRef Function(CFCalendarRef)>>(
          'CFCalendarCopyTimeZone');
  late final _CFCalendarCopyTimeZone = _CFCalendarCopyTimeZonePtr.asFunction<
      CFTimeZoneRef Function(CFCalendarRef)>();

  void CFCalendarSetTimeZone(
    CFCalendarRef calendar,
    CFTimeZoneRef tz,
  ) {
    return _CFCalendarSetTimeZone(
      calendar,
      tz,
    );
  }

  late final _CFCalendarSetTimeZonePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFCalendarRef, CFTimeZoneRef)>>(
      'CFCalendarSetTimeZone');
  late final _CFCalendarSetTimeZone = _CFCalendarSetTimeZonePtr.asFunction<
      void Function(CFCalendarRef, CFTimeZoneRef)>();

  int CFCalendarGetFirstWeekday(
    CFCalendarRef calendar,
  ) {
    return _CFCalendarGetFirstWeekday(
      calendar,
    );
  }

  late final _CFCalendarGetFirstWeekdayPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFCalendarRef)>>(
          'CFCalendarGetFirstWeekday');
  late final _CFCalendarGetFirstWeekday =
      _CFCalendarGetFirstWeekdayPtr.asFunction<int Function(CFCalendarRef)>();

  void CFCalendarSetFirstWeekday(
    CFCalendarRef calendar,
    int wkdy,
  ) {
    return _CFCalendarSetFirstWeekday(
      calendar,
      wkdy,
    );
  }

  late final _CFCalendarSetFirstWeekdayPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFCalendarRef, CFIndex)>>(
          'CFCalendarSetFirstWeekday');
  late final _CFCalendarSetFirstWeekday = _CFCalendarSetFirstWeekdayPtr
      .asFunction<void Function(CFCalendarRef, int)>();

  int CFCalendarGetMinimumDaysInFirstWeek(
    CFCalendarRef calendar,
  ) {
    return _CFCalendarGetMinimumDaysInFirstWeek(
      calendar,
    );
  }

  late final _CFCalendarGetMinimumDaysInFirstWeekPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFCalendarRef)>>(
          'CFCalendarGetMinimumDaysInFirstWeek');
  late final _CFCalendarGetMinimumDaysInFirstWeek =
      _CFCalendarGetMinimumDaysInFirstWeekPtr.asFunction<
          int Function(CFCalendarRef)>();

  void CFCalendarSetMinimumDaysInFirstWeek(
    CFCalendarRef calendar,
    int mwd,
  ) {
    return _CFCalendarSetMinimumDaysInFirstWeek(
      calendar,
      mwd,
    );
  }

  late final _CFCalendarSetMinimumDaysInFirstWeekPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFCalendarRef, CFIndex)>>(
          'CFCalendarSetMinimumDaysInFirstWeek');
  late final _CFCalendarSetMinimumDaysInFirstWeek =
      _CFCalendarSetMinimumDaysInFirstWeekPtr.asFunction<
          void Function(CFCalendarRef, int)>();

  CFRange CFCalendarGetMinimumRangeOfUnit(
    CFCalendarRef calendar,
    CFCalendarUnit unit,
  ) {
    return _CFCalendarGetMinimumRangeOfUnit(
      calendar,
      unit.value,
    );
  }

  late final _CFCalendarGetMinimumRangeOfUnitPtr = _lookup<
          ffi.NativeFunction<CFRange Function(CFCalendarRef, CFOptionFlags)>>(
      'CFCalendarGetMinimumRangeOfUnit');
  late final _CFCalendarGetMinimumRangeOfUnit =
      _CFCalendarGetMinimumRangeOfUnitPtr.asFunction<
          CFRange Function(CFCalendarRef, int)>();

  CFRange CFCalendarGetMaximumRangeOfUnit(
    CFCalendarRef calendar,
    CFCalendarUnit unit,
  ) {
    return _CFCalendarGetMaximumRangeOfUnit(
      calendar,
      unit.value,
    );
  }

  late final _CFCalendarGetMaximumRangeOfUnitPtr = _lookup<
          ffi.NativeFunction<CFRange Function(CFCalendarRef, CFOptionFlags)>>(
      'CFCalendarGetMaximumRangeOfUnit');
  late final _CFCalendarGetMaximumRangeOfUnit =
      _CFCalendarGetMaximumRangeOfUnitPtr.asFunction<
          CFRange Function(CFCalendarRef, int)>();

  CFRange CFCalendarGetRangeOfUnit(
    CFCalendarRef calendar,
    CFCalendarUnit smallerUnit,
    CFCalendarUnit biggerUnit,
    DartCFTimeInterval at,
  ) {
    return _CFCalendarGetRangeOfUnit(
      calendar,
      smallerUnit.value,
      biggerUnit.value,
      at,
    );
  }

  late final _CFCalendarGetRangeOfUnitPtr = _lookup<
      ffi.NativeFunction<
          CFRange Function(CFCalendarRef, CFOptionFlags, CFOptionFlags,
              CFAbsoluteTime)>>('CFCalendarGetRangeOfUnit');
  late final _CFCalendarGetRangeOfUnit = _CFCalendarGetRangeOfUnitPtr
      .asFunction<CFRange Function(CFCalendarRef, int, int, double)>();

  DartCFIndex CFCalendarGetOrdinalityOfUnit(
    CFCalendarRef calendar,
    CFCalendarUnit smallerUnit,
    CFCalendarUnit biggerUnit,
    DartCFTimeInterval at,
  ) {
    return _CFCalendarGetOrdinalityOfUnit(
      calendar,
      smallerUnit.value,
      biggerUnit.value,
      at,
    );
  }

  late final _CFCalendarGetOrdinalityOfUnitPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFCalendarRef, CFOptionFlags, CFOptionFlags,
              CFAbsoluteTime)>>('CFCalendarGetOrdinalityOfUnit');
  late final _CFCalendarGetOrdinalityOfUnit = _CFCalendarGetOrdinalityOfUnitPtr
      .asFunction<int Function(CFCalendarRef, int, int, double)>();

  DartBoolean CFCalendarGetTimeRangeOfUnit(
    CFCalendarRef calendar,
    CFCalendarUnit unit,
    DartCFTimeInterval at,
    ffi.Pointer<CFAbsoluteTime> startp,
    ffi.Pointer<CFTimeInterval> tip,
  ) {
    return _CFCalendarGetTimeRangeOfUnit(
      calendar,
      unit.value,
      at,
      startp,
      tip,
    );
  }

  late final _CFCalendarGetTimeRangeOfUnitPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(
              CFCalendarRef,
              CFOptionFlags,
              CFAbsoluteTime,
              ffi.Pointer<CFAbsoluteTime>,
              ffi.Pointer<CFTimeInterval>)>>('CFCalendarGetTimeRangeOfUnit');
  late final _CFCalendarGetTimeRangeOfUnit =
      _CFCalendarGetTimeRangeOfUnitPtr.asFunction<
          int Function(CFCalendarRef, int, double, ffi.Pointer<CFAbsoluteTime>,
              ffi.Pointer<CFTimeInterval>)>();

  int CFCalendarComposeAbsoluteTime(
    CFCalendarRef calendar,
    ffi.Pointer<CFAbsoluteTime> at,
    ffi.Pointer<ffi.Char> componentDesc,
  ) {
    return _CFCalendarComposeAbsoluteTime(
      calendar,
      at,
      componentDesc,
    );
  }

  late final _CFCalendarComposeAbsoluteTimePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFCalendarRef, ffi.Pointer<CFAbsoluteTime>,
              ffi.Pointer<ffi.Char>)>>('CFCalendarComposeAbsoluteTime');
  late final _CFCalendarComposeAbsoluteTime =
      _CFCalendarComposeAbsoluteTimePtr.asFunction<
          int Function(CFCalendarRef, ffi.Pointer<CFAbsoluteTime>,
              ffi.Pointer<ffi.Char>)>();

  int CFCalendarDecomposeAbsoluteTime(
    CFCalendarRef calendar,
    double at,
    ffi.Pointer<ffi.Char> componentDesc,
  ) {
    return _CFCalendarDecomposeAbsoluteTime(
      calendar,
      at,
      componentDesc,
    );
  }

  late final _CFCalendarDecomposeAbsoluteTimePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFCalendarRef, CFAbsoluteTime,
              ffi.Pointer<ffi.Char>)>>('CFCalendarDecomposeAbsoluteTime');
  late final _CFCalendarDecomposeAbsoluteTime =
      _CFCalendarDecomposeAbsoluteTimePtr.asFunction<
          int Function(CFCalendarRef, double, ffi.Pointer<ffi.Char>)>();

  int CFCalendarAddComponents(
    CFCalendarRef calendar,
    ffi.Pointer<CFAbsoluteTime> at,
    int options,
    ffi.Pointer<ffi.Char> componentDesc,
  ) {
    return _CFCalendarAddComponents(
      calendar,
      at,
      options,
      componentDesc,
    );
  }

  late final _CFCalendarAddComponentsPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(
              CFCalendarRef,
              ffi.Pointer<CFAbsoluteTime>,
              CFOptionFlags,
              ffi.Pointer<ffi.Char>)>>('CFCalendarAddComponents');
  late final _CFCalendarAddComponents = _CFCalendarAddComponentsPtr.asFunction<
      int Function(CFCalendarRef, ffi.Pointer<CFAbsoluteTime>, int,
          ffi.Pointer<ffi.Char>)>();

  int CFCalendarGetComponentDifference(
    CFCalendarRef calendar,
    double startingAT,
    double resultAT,
    int options,
    ffi.Pointer<ffi.Char> componentDesc,
  ) {
    return _CFCalendarGetComponentDifference(
      calendar,
      startingAT,
      resultAT,
      options,
      componentDesc,
    );
  }

  late final _CFCalendarGetComponentDifferencePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(
              CFCalendarRef,
              CFAbsoluteTime,
              CFAbsoluteTime,
              CFOptionFlags,
              ffi.Pointer<ffi.Char>)>>('CFCalendarGetComponentDifference');
  late final _CFCalendarGetComponentDifference =
      _CFCalendarGetComponentDifferencePtr.asFunction<
          int Function(
              CFCalendarRef, double, double, int, ffi.Pointer<ffi.Char>)>();

  CFStringRef CFDateFormatterCreateDateFormatFromTemplate(
    CFAllocatorRef allocator,
    CFStringRef tmplate,
    int options,
    CFLocaleRef locale,
  ) {
    return _CFDateFormatterCreateDateFormatFromTemplate(
      allocator,
      tmplate,
      options,
      locale,
    );
  }

  late final _CFDateFormatterCreateDateFormatFromTemplatePtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFStringRef, CFOptionFlags,
              CFLocaleRef)>>('CFDateFormatterCreateDateFormatFromTemplate');
  late final _CFDateFormatterCreateDateFormatFromTemplate =
      _CFDateFormatterCreateDateFormatFromTemplatePtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, CFStringRef, int, CFLocaleRef)>();

  int CFDateFormatterGetTypeID() {
    return _CFDateFormatterGetTypeID();
  }

  late final _CFDateFormatterGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFDateFormatterGetTypeID');
  late final _CFDateFormatterGetTypeID =
      _CFDateFormatterGetTypeIDPtr.asFunction<int Function()>();

  CFDateFormatterRef CFDateFormatterCreateISO8601Formatter(
    CFAllocatorRef allocator,
    CFISO8601DateFormatOptions formatOptions,
  ) {
    return _CFDateFormatterCreateISO8601Formatter(
      allocator,
      formatOptions.value,
    );
  }

  late final _CFDateFormatterCreateISO8601FormatterPtr = _lookup<
      ffi.NativeFunction<
          CFDateFormatterRef Function(CFAllocatorRef,
              CFOptionFlags)>>('CFDateFormatterCreateISO8601Formatter');
  late final _CFDateFormatterCreateISO8601Formatter =
      _CFDateFormatterCreateISO8601FormatterPtr.asFunction<
          CFDateFormatterRef Function(CFAllocatorRef, int)>();

  CFDateFormatterRef CFDateFormatterCreate(
    CFAllocatorRef allocator,
    CFLocaleRef locale,
    CFDateFormatterStyle dateStyle,
    CFDateFormatterStyle timeStyle,
  ) {
    return _CFDateFormatterCreate(
      allocator,
      locale,
      dateStyle.value,
      timeStyle.value,
    );
  }

  late final _CFDateFormatterCreatePtr = _lookup<
      ffi.NativeFunction<
          CFDateFormatterRef Function(CFAllocatorRef, CFLocaleRef, CFIndex,
              CFIndex)>>('CFDateFormatterCreate');
  late final _CFDateFormatterCreate = _CFDateFormatterCreatePtr.asFunction<
      CFDateFormatterRef Function(CFAllocatorRef, CFLocaleRef, int, int)>();

  CFLocaleRef CFDateFormatterGetLocale(
    CFDateFormatterRef formatter,
  ) {
    return _CFDateFormatterGetLocale(
      formatter,
    );
  }

  late final _CFDateFormatterGetLocalePtr =
      _lookup<ffi.NativeFunction<CFLocaleRef Function(CFDateFormatterRef)>>(
          'CFDateFormatterGetLocale');
  late final _CFDateFormatterGetLocale = _CFDateFormatterGetLocalePtr
      .asFunction<CFLocaleRef Function(CFDateFormatterRef)>();

  CFDateFormatterStyle CFDateFormatterGetDateStyle(
    CFDateFormatterRef formatter,
  ) {
    return CFDateFormatterStyle.fromValue(_CFDateFormatterGetDateStyle(
      formatter,
    ));
  }

  late final _CFDateFormatterGetDateStylePtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFDateFormatterRef)>>(
          'CFDateFormatterGetDateStyle');
  late final _CFDateFormatterGetDateStyle = _CFDateFormatterGetDateStylePtr
      .asFunction<int Function(CFDateFormatterRef)>();

  CFDateFormatterStyle CFDateFormatterGetTimeStyle(
    CFDateFormatterRef formatter,
  ) {
    return CFDateFormatterStyle.fromValue(_CFDateFormatterGetTimeStyle(
      formatter,
    ));
  }

  late final _CFDateFormatterGetTimeStylePtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFDateFormatterRef)>>(
          'CFDateFormatterGetTimeStyle');
  late final _CFDateFormatterGetTimeStyle = _CFDateFormatterGetTimeStylePtr
      .asFunction<int Function(CFDateFormatterRef)>();

  CFStringRef CFDateFormatterGetFormat(
    CFDateFormatterRef formatter,
  ) {
    return _CFDateFormatterGetFormat(
      formatter,
    );
  }

  late final _CFDateFormatterGetFormatPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFDateFormatterRef)>>(
          'CFDateFormatterGetFormat');
  late final _CFDateFormatterGetFormat = _CFDateFormatterGetFormatPtr
      .asFunction<CFStringRef Function(CFDateFormatterRef)>();

  void CFDateFormatterSetFormat(
    CFDateFormatterRef formatter,
    CFStringRef formatString,
  ) {
    return _CFDateFormatterSetFormat(
      formatter,
      formatString,
    );
  }

  late final _CFDateFormatterSetFormatPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(CFDateFormatterRef, CFStringRef)>>(
      'CFDateFormatterSetFormat');
  late final _CFDateFormatterSetFormat = _CFDateFormatterSetFormatPtr
      .asFunction<void Function(CFDateFormatterRef, CFStringRef)>();

  CFStringRef CFDateFormatterCreateStringWithDate(
    CFAllocatorRef allocator,
    CFDateFormatterRef formatter,
    CFDateRef date,
  ) {
    return _CFDateFormatterCreateStringWithDate(
      allocator,
      formatter,
      date,
    );
  }

  late final _CFDateFormatterCreateStringWithDatePtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFDateFormatterRef,
              CFDateRef)>>('CFDateFormatterCreateStringWithDate');
  late final _CFDateFormatterCreateStringWithDate =
      _CFDateFormatterCreateStringWithDatePtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, CFDateFormatterRef, CFDateRef)>();

  CFStringRef CFDateFormatterCreateStringWithAbsoluteTime(
    CFAllocatorRef allocator,
    CFDateFormatterRef formatter,
    double at,
  ) {
    return _CFDateFormatterCreateStringWithAbsoluteTime(
      allocator,
      formatter,
      at,
    );
  }

  late final _CFDateFormatterCreateStringWithAbsoluteTimePtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFDateFormatterRef,
              CFAbsoluteTime)>>('CFDateFormatterCreateStringWithAbsoluteTime');
  late final _CFDateFormatterCreateStringWithAbsoluteTime =
      _CFDateFormatterCreateStringWithAbsoluteTimePtr.asFunction<
          CFStringRef Function(CFAllocatorRef, CFDateFormatterRef, double)>();

  CFDateRef CFDateFormatterCreateDateFromString(
    CFAllocatorRef allocator,
    CFDateFormatterRef formatter,
    CFStringRef string,
    ffi.Pointer<CFRange> rangep,
  ) {
    return _CFDateFormatterCreateDateFromString(
      allocator,
      formatter,
      string,
      rangep,
    );
  }

  late final _CFDateFormatterCreateDateFromStringPtr = _lookup<
      ffi.NativeFunction<
          CFDateRef Function(CFAllocatorRef, CFDateFormatterRef, CFStringRef,
              ffi.Pointer<CFRange>)>>('CFDateFormatterCreateDateFromString');
  late final _CFDateFormatterCreateDateFromString =
      _CFDateFormatterCreateDateFromStringPtr.asFunction<
          CFDateRef Function(CFAllocatorRef, CFDateFormatterRef, CFStringRef,
              ffi.Pointer<CFRange>)>();

  int CFDateFormatterGetAbsoluteTimeFromString(
    CFDateFormatterRef formatter,
    CFStringRef string,
    ffi.Pointer<CFRange> rangep,
    ffi.Pointer<CFAbsoluteTime> atp,
  ) {
    return _CFDateFormatterGetAbsoluteTimeFromString(
      formatter,
      string,
      rangep,
      atp,
    );
  }

  late final _CFDateFormatterGetAbsoluteTimeFromStringPtr = _lookup<
          ffi.NativeFunction<
              Boolean Function(CFDateFormatterRef, CFStringRef,
                  ffi.Pointer<CFRange>, ffi.Pointer<CFAbsoluteTime>)>>(
      'CFDateFormatterGetAbsoluteTimeFromString');
  late final _CFDateFormatterGetAbsoluteTimeFromString =
      _CFDateFormatterGetAbsoluteTimeFromStringPtr.asFunction<
          int Function(CFDateFormatterRef, CFStringRef, ffi.Pointer<CFRange>,
              ffi.Pointer<CFAbsoluteTime>)>();

  void CFDateFormatterSetProperty(
    CFDateFormatterRef formatter,
    CFStringRef key,
    CFTypeRef value,
  ) {
    return _CFDateFormatterSetProperty(
      formatter,
      key,
      value,
    );
  }

  late final _CFDateFormatterSetPropertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFDateFormatterRef, CFStringRef,
              CFTypeRef)>>('CFDateFormatterSetProperty');
  late final _CFDateFormatterSetProperty = _CFDateFormatterSetPropertyPtr
      .asFunction<void Function(CFDateFormatterRef, CFStringRef, CFTypeRef)>();

  CFTypeRef CFDateFormatterCopyProperty(
    CFDateFormatterRef formatter,
    CFDateFormatterKey key,
  ) {
    return _CFDateFormatterCopyProperty(
      formatter,
      key,
    );
  }

  late final _CFDateFormatterCopyPropertyPtr = _lookup<
      ffi.NativeFunction<
          CFTypeRef Function(CFDateFormatterRef,
              CFDateFormatterKey)>>('CFDateFormatterCopyProperty');
  late final _CFDateFormatterCopyProperty = _CFDateFormatterCopyPropertyPtr
      .asFunction<CFTypeRef Function(CFDateFormatterRef, CFDateFormatterKey)>();

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterIsLenient =
      _lookup<CFDateFormatterKey>('kCFDateFormatterIsLenient');

  CFDateFormatterKey get kCFDateFormatterIsLenient =>
      _kCFDateFormatterIsLenient.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterTimeZone =
      _lookup<CFDateFormatterKey>('kCFDateFormatterTimeZone');

  CFDateFormatterKey get kCFDateFormatterTimeZone =>
      _kCFDateFormatterTimeZone.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterCalendarName =
      _lookup<CFDateFormatterKey>('kCFDateFormatterCalendarName');

  CFDateFormatterKey get kCFDateFormatterCalendarName =>
      _kCFDateFormatterCalendarName.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterDefaultFormat =
      _lookup<CFDateFormatterKey>('kCFDateFormatterDefaultFormat');

  CFDateFormatterKey get kCFDateFormatterDefaultFormat =>
      _kCFDateFormatterDefaultFormat.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterTwoDigitStartDate =
      _lookup<CFDateFormatterKey>('kCFDateFormatterTwoDigitStartDate');

  CFDateFormatterKey get kCFDateFormatterTwoDigitStartDate =>
      _kCFDateFormatterTwoDigitStartDate.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterDefaultDate =
      _lookup<CFDateFormatterKey>('kCFDateFormatterDefaultDate');

  CFDateFormatterKey get kCFDateFormatterDefaultDate =>
      _kCFDateFormatterDefaultDate.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterCalendar =
      _lookup<CFDateFormatterKey>('kCFDateFormatterCalendar');

  CFDateFormatterKey get kCFDateFormatterCalendar =>
      _kCFDateFormatterCalendar.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterEraSymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterEraSymbols');

  CFDateFormatterKey get kCFDateFormatterEraSymbols =>
      _kCFDateFormatterEraSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterMonthSymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterMonthSymbols');

  CFDateFormatterKey get kCFDateFormatterMonthSymbols =>
      _kCFDateFormatterMonthSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterShortMonthSymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterShortMonthSymbols');

  CFDateFormatterKey get kCFDateFormatterShortMonthSymbols =>
      _kCFDateFormatterShortMonthSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterWeekdaySymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterWeekdaySymbols');

  CFDateFormatterKey get kCFDateFormatterWeekdaySymbols =>
      _kCFDateFormatterWeekdaySymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterShortWeekdaySymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterShortWeekdaySymbols');

  CFDateFormatterKey get kCFDateFormatterShortWeekdaySymbols =>
      _kCFDateFormatterShortWeekdaySymbols.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterAMSymbol =
      _lookup<CFDateFormatterKey>('kCFDateFormatterAMSymbol');

  CFDateFormatterKey get kCFDateFormatterAMSymbol =>
      _kCFDateFormatterAMSymbol.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterPMSymbol =
      _lookup<CFDateFormatterKey>('kCFDateFormatterPMSymbol');

  CFDateFormatterKey get kCFDateFormatterPMSymbol =>
      _kCFDateFormatterPMSymbol.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterLongEraSymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterLongEraSymbols');

  CFDateFormatterKey get kCFDateFormatterLongEraSymbols =>
      _kCFDateFormatterLongEraSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterVeryShortMonthSymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterVeryShortMonthSymbols');

  CFDateFormatterKey get kCFDateFormatterVeryShortMonthSymbols =>
      _kCFDateFormatterVeryShortMonthSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterStandaloneMonthSymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterStandaloneMonthSymbols');

  CFDateFormatterKey get kCFDateFormatterStandaloneMonthSymbols =>
      _kCFDateFormatterStandaloneMonthSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterShortStandaloneMonthSymbols =
      _lookup<CFDateFormatterKey>(
          'kCFDateFormatterShortStandaloneMonthSymbols');

  CFDateFormatterKey get kCFDateFormatterShortStandaloneMonthSymbols =>
      _kCFDateFormatterShortStandaloneMonthSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterVeryShortStandaloneMonthSymbols =
      _lookup<CFDateFormatterKey>(
          'kCFDateFormatterVeryShortStandaloneMonthSymbols');

  CFDateFormatterKey get kCFDateFormatterVeryShortStandaloneMonthSymbols =>
      _kCFDateFormatterVeryShortStandaloneMonthSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterVeryShortWeekdaySymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterVeryShortWeekdaySymbols');

  CFDateFormatterKey get kCFDateFormatterVeryShortWeekdaySymbols =>
      _kCFDateFormatterVeryShortWeekdaySymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterStandaloneWeekdaySymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterStandaloneWeekdaySymbols');

  CFDateFormatterKey get kCFDateFormatterStandaloneWeekdaySymbols =>
      _kCFDateFormatterStandaloneWeekdaySymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterShortStandaloneWeekdaySymbols =
      _lookup<CFDateFormatterKey>(
          'kCFDateFormatterShortStandaloneWeekdaySymbols');

  CFDateFormatterKey get kCFDateFormatterShortStandaloneWeekdaySymbols =>
      _kCFDateFormatterShortStandaloneWeekdaySymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterVeryShortStandaloneWeekdaySymbols =
      _lookup<CFDateFormatterKey>(
          'kCFDateFormatterVeryShortStandaloneWeekdaySymbols');

  CFDateFormatterKey get kCFDateFormatterVeryShortStandaloneWeekdaySymbols =>
      _kCFDateFormatterVeryShortStandaloneWeekdaySymbols.value;

  late final ffi.Pointer<CFDateFormatterKey> _kCFDateFormatterQuarterSymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterQuarterSymbols');

  CFDateFormatterKey get kCFDateFormatterQuarterSymbols =>
      _kCFDateFormatterQuarterSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterShortQuarterSymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterShortQuarterSymbols');

  CFDateFormatterKey get kCFDateFormatterShortQuarterSymbols =>
      _kCFDateFormatterShortQuarterSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterStandaloneQuarterSymbols =
      _lookup<CFDateFormatterKey>('kCFDateFormatterStandaloneQuarterSymbols');

  CFDateFormatterKey get kCFDateFormatterStandaloneQuarterSymbols =>
      _kCFDateFormatterStandaloneQuarterSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterShortStandaloneQuarterSymbols =
      _lookup<CFDateFormatterKey>(
          'kCFDateFormatterShortStandaloneQuarterSymbols');

  CFDateFormatterKey get kCFDateFormatterShortStandaloneQuarterSymbols =>
      _kCFDateFormatterShortStandaloneQuarterSymbols.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterGregorianStartDate =
      _lookup<CFDateFormatterKey>('kCFDateFormatterGregorianStartDate');

  CFDateFormatterKey get kCFDateFormatterGregorianStartDate =>
      _kCFDateFormatterGregorianStartDate.value;

  late final ffi.Pointer<CFDateFormatterKey>
      _kCFDateFormatterDoesRelativeDateFormattingKey =
      _lookup<CFDateFormatterKey>(
          'kCFDateFormatterDoesRelativeDateFormattingKey');

  CFDateFormatterKey get kCFDateFormatterDoesRelativeDateFormattingKey =>
      _kCFDateFormatterDoesRelativeDateFormattingKey.value;

  late final ffi.Pointer<CFBooleanRef> _kCFBooleanTrue =
      _lookup<CFBooleanRef>('kCFBooleanTrue');

  CFBooleanRef get kCFBooleanTrue => _kCFBooleanTrue.value;

  late final ffi.Pointer<CFBooleanRef> _kCFBooleanFalse =
      _lookup<CFBooleanRef>('kCFBooleanFalse');

  CFBooleanRef get kCFBooleanFalse => _kCFBooleanFalse.value;

  int CFBooleanGetTypeID() {
    return _CFBooleanGetTypeID();
  }

  late final _CFBooleanGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFBooleanGetTypeID');
  late final _CFBooleanGetTypeID =
      _CFBooleanGetTypeIDPtr.asFunction<int Function()>();

  int CFBooleanGetValue(
    CFBooleanRef boolean,
  ) {
    return _CFBooleanGetValue(
      boolean,
    );
  }

  late final _CFBooleanGetValuePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFBooleanRef)>>(
          'CFBooleanGetValue');
  late final _CFBooleanGetValue =
      _CFBooleanGetValuePtr.asFunction<int Function(CFBooleanRef)>();

  late final ffi.Pointer<CFNumberRef> _kCFNumberPositiveInfinity =
      _lookup<CFNumberRef>('kCFNumberPositiveInfinity');

  CFNumberRef get kCFNumberPositiveInfinity => _kCFNumberPositiveInfinity.value;

  late final ffi.Pointer<CFNumberRef> _kCFNumberNegativeInfinity =
      _lookup<CFNumberRef>('kCFNumberNegativeInfinity');

  CFNumberRef get kCFNumberNegativeInfinity => _kCFNumberNegativeInfinity.value;

  late final ffi.Pointer<CFNumberRef> _kCFNumberNaN =
      _lookup<CFNumberRef>('kCFNumberNaN');

  CFNumberRef get kCFNumberNaN => _kCFNumberNaN.value;

  int CFNumberGetTypeID() {
    return _CFNumberGetTypeID();
  }

  late final _CFNumberGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFNumberGetTypeID');
  late final _CFNumberGetTypeID =
      _CFNumberGetTypeIDPtr.asFunction<int Function()>();

  CFNumberRef CFNumberCreate(
    CFAllocatorRef allocator,
    CFNumberType theType,
    ffi.Pointer<ffi.Void> valuePtr,
  ) {
    return _CFNumberCreate(
      allocator,
      theType.value,
      valuePtr,
    );
  }

  late final _CFNumberCreatePtr = _lookup<
      ffi.NativeFunction<
          CFNumberRef Function(CFAllocatorRef, CFIndex,
              ffi.Pointer<ffi.Void>)>>('CFNumberCreate');
  late final _CFNumberCreate = _CFNumberCreatePtr.asFunction<
      CFNumberRef Function(CFAllocatorRef, int, ffi.Pointer<ffi.Void>)>();

  CFNumberType CFNumberGetType(
    CFNumberRef number,
  ) {
    return CFNumberType.fromValue(_CFNumberGetType(
      number,
    ));
  }

  late final _CFNumberGetTypePtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFNumberRef)>>(
          'CFNumberGetType');
  late final _CFNumberGetType =
      _CFNumberGetTypePtr.asFunction<int Function(CFNumberRef)>();

  int CFNumberGetByteSize(
    CFNumberRef number,
  ) {
    return _CFNumberGetByteSize(
      number,
    );
  }

  late final _CFNumberGetByteSizePtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFNumberRef)>>(
          'CFNumberGetByteSize');
  late final _CFNumberGetByteSize =
      _CFNumberGetByteSizePtr.asFunction<int Function(CFNumberRef)>();

  int CFNumberIsFloatType(
    CFNumberRef number,
  ) {
    return _CFNumberIsFloatType(
      number,
    );
  }

  late final _CFNumberIsFloatTypePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFNumberRef)>>(
          'CFNumberIsFloatType');
  late final _CFNumberIsFloatType =
      _CFNumberIsFloatTypePtr.asFunction<int Function(CFNumberRef)>();

  DartBoolean CFNumberGetValue(
    CFNumberRef number,
    CFNumberType theType,
    ffi.Pointer<ffi.Void> valuePtr,
  ) {
    return _CFNumberGetValue(
      number,
      theType.value,
      valuePtr,
    );
  }

  late final _CFNumberGetValuePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFNumberRef, CFIndex,
              ffi.Pointer<ffi.Void>)>>('CFNumberGetValue');
  late final _CFNumberGetValue = _CFNumberGetValuePtr.asFunction<
      int Function(CFNumberRef, int, ffi.Pointer<ffi.Void>)>();

  CFComparisonResult CFNumberCompare(
    CFNumberRef number,
    CFNumberRef otherNumber,
    ffi.Pointer<ffi.Void> context,
  ) {
    return CFComparisonResult.fromValue(_CFNumberCompare(
      number,
      otherNumber,
      context,
    ));
  }

  late final _CFNumberComparePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFNumberRef, CFNumberRef,
              ffi.Pointer<ffi.Void>)>>('CFNumberCompare');
  late final _CFNumberCompare = _CFNumberComparePtr.asFunction<
      int Function(CFNumberRef, CFNumberRef, ffi.Pointer<ffi.Void>)>();

  int CFNumberFormatterGetTypeID() {
    return _CFNumberFormatterGetTypeID();
  }

  late final _CFNumberFormatterGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFNumberFormatterGetTypeID');
  late final _CFNumberFormatterGetTypeID =
      _CFNumberFormatterGetTypeIDPtr.asFunction<int Function()>();

  CFNumberFormatterRef CFNumberFormatterCreate(
    CFAllocatorRef allocator,
    CFLocaleRef locale,
    CFNumberFormatterStyle style,
  ) {
    return _CFNumberFormatterCreate(
      allocator,
      locale,
      style.value,
    );
  }

  late final _CFNumberFormatterCreatePtr = _lookup<
      ffi.NativeFunction<
          CFNumberFormatterRef Function(CFAllocatorRef, CFLocaleRef,
              CFIndex)>>('CFNumberFormatterCreate');
  late final _CFNumberFormatterCreate = _CFNumberFormatterCreatePtr.asFunction<
      CFNumberFormatterRef Function(CFAllocatorRef, CFLocaleRef, int)>();

  CFLocaleRef CFNumberFormatterGetLocale(
    CFNumberFormatterRef formatter,
  ) {
    return _CFNumberFormatterGetLocale(
      formatter,
    );
  }

  late final _CFNumberFormatterGetLocalePtr =
      _lookup<ffi.NativeFunction<CFLocaleRef Function(CFNumberFormatterRef)>>(
          'CFNumberFormatterGetLocale');
  late final _CFNumberFormatterGetLocale = _CFNumberFormatterGetLocalePtr
      .asFunction<CFLocaleRef Function(CFNumberFormatterRef)>();

  CFNumberFormatterStyle CFNumberFormatterGetStyle(
    CFNumberFormatterRef formatter,
  ) {
    return CFNumberFormatterStyle.fromValue(_CFNumberFormatterGetStyle(
      formatter,
    ));
  }

  late final _CFNumberFormatterGetStylePtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFNumberFormatterRef)>>(
          'CFNumberFormatterGetStyle');
  late final _CFNumberFormatterGetStyle = _CFNumberFormatterGetStylePtr
      .asFunction<int Function(CFNumberFormatterRef)>();

  CFStringRef CFNumberFormatterGetFormat(
    CFNumberFormatterRef formatter,
  ) {
    return _CFNumberFormatterGetFormat(
      formatter,
    );
  }

  late final _CFNumberFormatterGetFormatPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFNumberFormatterRef)>>(
          'CFNumberFormatterGetFormat');
  late final _CFNumberFormatterGetFormat = _CFNumberFormatterGetFormatPtr
      .asFunction<CFStringRef Function(CFNumberFormatterRef)>();

  void CFNumberFormatterSetFormat(
    CFNumberFormatterRef formatter,
    CFStringRef formatString,
  ) {
    return _CFNumberFormatterSetFormat(
      formatter,
      formatString,
    );
  }

  late final _CFNumberFormatterSetFormatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFNumberFormatterRef,
              CFStringRef)>>('CFNumberFormatterSetFormat');
  late final _CFNumberFormatterSetFormat = _CFNumberFormatterSetFormatPtr
      .asFunction<void Function(CFNumberFormatterRef, CFStringRef)>();

  CFStringRef CFNumberFormatterCreateStringWithNumber(
    CFAllocatorRef allocator,
    CFNumberFormatterRef formatter,
    CFNumberRef number,
  ) {
    return _CFNumberFormatterCreateStringWithNumber(
      allocator,
      formatter,
      number,
    );
  }

  late final _CFNumberFormatterCreateStringWithNumberPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFNumberFormatterRef,
              CFNumberRef)>>('CFNumberFormatterCreateStringWithNumber');
  late final _CFNumberFormatterCreateStringWithNumber =
      _CFNumberFormatterCreateStringWithNumberPtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, CFNumberFormatterRef, CFNumberRef)>();

  CFStringRef CFNumberFormatterCreateStringWithValue(
    CFAllocatorRef allocator,
    CFNumberFormatterRef formatter,
    CFNumberType numberType,
    ffi.Pointer<ffi.Void> valuePtr,
  ) {
    return _CFNumberFormatterCreateStringWithValue(
      allocator,
      formatter,
      numberType.value,
      valuePtr,
    );
  }

  late final _CFNumberFormatterCreateStringWithValuePtr = _lookup<
          ffi.NativeFunction<
              CFStringRef Function(CFAllocatorRef, CFNumberFormatterRef,
                  CFIndex, ffi.Pointer<ffi.Void>)>>(
      'CFNumberFormatterCreateStringWithValue');
  late final _CFNumberFormatterCreateStringWithValue =
      _CFNumberFormatterCreateStringWithValuePtr.asFunction<
          CFStringRef Function(CFAllocatorRef, CFNumberFormatterRef, int,
              ffi.Pointer<ffi.Void>)>();

  CFNumberRef CFNumberFormatterCreateNumberFromString(
    CFAllocatorRef allocator,
    CFNumberFormatterRef formatter,
    CFStringRef string,
    ffi.Pointer<CFRange> rangep,
    int options,
  ) {
    return _CFNumberFormatterCreateNumberFromString(
      allocator,
      formatter,
      string,
      rangep,
      options,
    );
  }

  late final _CFNumberFormatterCreateNumberFromStringPtr = _lookup<
      ffi.NativeFunction<
          CFNumberRef Function(
              CFAllocatorRef,
              CFNumberFormatterRef,
              CFStringRef,
              ffi.Pointer<CFRange>,
              CFOptionFlags)>>('CFNumberFormatterCreateNumberFromString');
  late final _CFNumberFormatterCreateNumberFromString =
      _CFNumberFormatterCreateNumberFromStringPtr.asFunction<
          CFNumberRef Function(CFAllocatorRef, CFNumberFormatterRef,
              CFStringRef, ffi.Pointer<CFRange>, int)>();

  DartBoolean CFNumberFormatterGetValueFromString(
    CFNumberFormatterRef formatter,
    CFStringRef string,
    ffi.Pointer<CFRange> rangep,
    CFNumberType numberType,
    ffi.Pointer<ffi.Void> valuePtr,
  ) {
    return _CFNumberFormatterGetValueFromString(
      formatter,
      string,
      rangep,
      numberType.value,
      valuePtr,
    );
  }

  late final _CFNumberFormatterGetValueFromStringPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(
              CFNumberFormatterRef,
              CFStringRef,
              ffi.Pointer<CFRange>,
              CFIndex,
              ffi.Pointer<ffi.Void>)>>('CFNumberFormatterGetValueFromString');
  late final _CFNumberFormatterGetValueFromString =
      _CFNumberFormatterGetValueFromStringPtr.asFunction<
          int Function(CFNumberFormatterRef, CFStringRef, ffi.Pointer<CFRange>,
              int, ffi.Pointer<ffi.Void>)>();

  void CFNumberFormatterSetProperty(
    CFNumberFormatterRef formatter,
    CFNumberFormatterKey key,
    CFTypeRef value,
  ) {
    return _CFNumberFormatterSetProperty(
      formatter,
      key,
      value,
    );
  }

  late final _CFNumberFormatterSetPropertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFNumberFormatterRef, CFNumberFormatterKey,
              CFTypeRef)>>('CFNumberFormatterSetProperty');
  late final _CFNumberFormatterSetProperty =
      _CFNumberFormatterSetPropertyPtr.asFunction<
          void Function(
              CFNumberFormatterRef, CFNumberFormatterKey, CFTypeRef)>();

  CFTypeRef CFNumberFormatterCopyProperty(
    CFNumberFormatterRef formatter,
    CFNumberFormatterKey key,
  ) {
    return _CFNumberFormatterCopyProperty(
      formatter,
      key,
    );
  }

  late final _CFNumberFormatterCopyPropertyPtr = _lookup<
      ffi.NativeFunction<
          CFTypeRef Function(CFNumberFormatterRef,
              CFNumberFormatterKey)>>('CFNumberFormatterCopyProperty');
  late final _CFNumberFormatterCopyProperty =
      _CFNumberFormatterCopyPropertyPtr.asFunction<
          CFTypeRef Function(CFNumberFormatterRef, CFNumberFormatterKey)>();

  late final ffi.Pointer<CFNumberFormatterKey> _kCFNumberFormatterCurrencyCode =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterCurrencyCode');

  CFNumberFormatterKey get kCFNumberFormatterCurrencyCode =>
      _kCFNumberFormatterCurrencyCode.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterDecimalSeparator =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterDecimalSeparator');

  CFNumberFormatterKey get kCFNumberFormatterDecimalSeparator =>
      _kCFNumberFormatterDecimalSeparator.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterCurrencyDecimalSeparator =
      _lookup<CFNumberFormatterKey>(
          'kCFNumberFormatterCurrencyDecimalSeparator');

  CFNumberFormatterKey get kCFNumberFormatterCurrencyDecimalSeparator =>
      _kCFNumberFormatterCurrencyDecimalSeparator.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterAlwaysShowDecimalSeparator =
      _lookup<CFNumberFormatterKey>(
          'kCFNumberFormatterAlwaysShowDecimalSeparator');

  CFNumberFormatterKey get kCFNumberFormatterAlwaysShowDecimalSeparator =>
      _kCFNumberFormatterAlwaysShowDecimalSeparator.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterGroupingSeparator =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterGroupingSeparator');

  CFNumberFormatterKey get kCFNumberFormatterGroupingSeparator =>
      _kCFNumberFormatterGroupingSeparator.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterUseGroupingSeparator =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterUseGroupingSeparator');

  CFNumberFormatterKey get kCFNumberFormatterUseGroupingSeparator =>
      _kCFNumberFormatterUseGroupingSeparator.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterPercentSymbol =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterPercentSymbol');

  CFNumberFormatterKey get kCFNumberFormatterPercentSymbol =>
      _kCFNumberFormatterPercentSymbol.value;

  late final ffi.Pointer<CFNumberFormatterKey> _kCFNumberFormatterZeroSymbol =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterZeroSymbol');

  CFNumberFormatterKey get kCFNumberFormatterZeroSymbol =>
      _kCFNumberFormatterZeroSymbol.value;

  late final ffi.Pointer<CFNumberFormatterKey> _kCFNumberFormatterNaNSymbol =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterNaNSymbol');

  CFNumberFormatterKey get kCFNumberFormatterNaNSymbol =>
      _kCFNumberFormatterNaNSymbol.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterInfinitySymbol =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterInfinitySymbol');

  CFNumberFormatterKey get kCFNumberFormatterInfinitySymbol =>
      _kCFNumberFormatterInfinitySymbol.value;

  late final ffi.Pointer<CFNumberFormatterKey> _kCFNumberFormatterMinusSign =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterMinusSign');

  CFNumberFormatterKey get kCFNumberFormatterMinusSign =>
      _kCFNumberFormatterMinusSign.value;

  late final ffi.Pointer<CFNumberFormatterKey> _kCFNumberFormatterPlusSign =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterPlusSign');

  CFNumberFormatterKey get kCFNumberFormatterPlusSign =>
      _kCFNumberFormatterPlusSign.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterCurrencySymbol =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterCurrencySymbol');

  CFNumberFormatterKey get kCFNumberFormatterCurrencySymbol =>
      _kCFNumberFormatterCurrencySymbol.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterExponentSymbol =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterExponentSymbol');

  CFNumberFormatterKey get kCFNumberFormatterExponentSymbol =>
      _kCFNumberFormatterExponentSymbol.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterMinIntegerDigits =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterMinIntegerDigits');

  CFNumberFormatterKey get kCFNumberFormatterMinIntegerDigits =>
      _kCFNumberFormatterMinIntegerDigits.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterMaxIntegerDigits =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterMaxIntegerDigits');

  CFNumberFormatterKey get kCFNumberFormatterMaxIntegerDigits =>
      _kCFNumberFormatterMaxIntegerDigits.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterMinFractionDigits =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterMinFractionDigits');

  CFNumberFormatterKey get kCFNumberFormatterMinFractionDigits =>
      _kCFNumberFormatterMinFractionDigits.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterMaxFractionDigits =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterMaxFractionDigits');

  CFNumberFormatterKey get kCFNumberFormatterMaxFractionDigits =>
      _kCFNumberFormatterMaxFractionDigits.value;

  late final ffi.Pointer<CFNumberFormatterKey> _kCFNumberFormatterGroupingSize =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterGroupingSize');

  CFNumberFormatterKey get kCFNumberFormatterGroupingSize =>
      _kCFNumberFormatterGroupingSize.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterSecondaryGroupingSize =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterSecondaryGroupingSize');

  CFNumberFormatterKey get kCFNumberFormatterSecondaryGroupingSize =>
      _kCFNumberFormatterSecondaryGroupingSize.value;

  late final ffi.Pointer<CFNumberFormatterKey> _kCFNumberFormatterRoundingMode =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterRoundingMode');

  CFNumberFormatterKey get kCFNumberFormatterRoundingMode =>
      _kCFNumberFormatterRoundingMode.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterRoundingIncrement =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterRoundingIncrement');

  CFNumberFormatterKey get kCFNumberFormatterRoundingIncrement =>
      _kCFNumberFormatterRoundingIncrement.value;

  late final ffi.Pointer<CFNumberFormatterKey> _kCFNumberFormatterFormatWidth =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterFormatWidth');

  CFNumberFormatterKey get kCFNumberFormatterFormatWidth =>
      _kCFNumberFormatterFormatWidth.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterPaddingPosition =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterPaddingPosition');

  CFNumberFormatterKey get kCFNumberFormatterPaddingPosition =>
      _kCFNumberFormatterPaddingPosition.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterPaddingCharacter =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterPaddingCharacter');

  CFNumberFormatterKey get kCFNumberFormatterPaddingCharacter =>
      _kCFNumberFormatterPaddingCharacter.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterDefaultFormat =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterDefaultFormat');

  CFNumberFormatterKey get kCFNumberFormatterDefaultFormat =>
      _kCFNumberFormatterDefaultFormat.value;

  late final ffi.Pointer<CFNumberFormatterKey> _kCFNumberFormatterMultiplier =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterMultiplier');

  CFNumberFormatterKey get kCFNumberFormatterMultiplier =>
      _kCFNumberFormatterMultiplier.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterPositivePrefix =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterPositivePrefix');

  CFNumberFormatterKey get kCFNumberFormatterPositivePrefix =>
      _kCFNumberFormatterPositivePrefix.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterPositiveSuffix =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterPositiveSuffix');

  CFNumberFormatterKey get kCFNumberFormatterPositiveSuffix =>
      _kCFNumberFormatterPositiveSuffix.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterNegativePrefix =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterNegativePrefix');

  CFNumberFormatterKey get kCFNumberFormatterNegativePrefix =>
      _kCFNumberFormatterNegativePrefix.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterNegativeSuffix =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterNegativeSuffix');

  CFNumberFormatterKey get kCFNumberFormatterNegativeSuffix =>
      _kCFNumberFormatterNegativeSuffix.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterPerMillSymbol =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterPerMillSymbol');

  CFNumberFormatterKey get kCFNumberFormatterPerMillSymbol =>
      _kCFNumberFormatterPerMillSymbol.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterInternationalCurrencySymbol =
      _lookup<CFNumberFormatterKey>(
          'kCFNumberFormatterInternationalCurrencySymbol');

  CFNumberFormatterKey get kCFNumberFormatterInternationalCurrencySymbol =>
      _kCFNumberFormatterInternationalCurrencySymbol.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterCurrencyGroupingSeparator =
      _lookup<CFNumberFormatterKey>(
          'kCFNumberFormatterCurrencyGroupingSeparator');

  CFNumberFormatterKey get kCFNumberFormatterCurrencyGroupingSeparator =>
      _kCFNumberFormatterCurrencyGroupingSeparator.value;

  late final ffi.Pointer<CFNumberFormatterKey> _kCFNumberFormatterIsLenient =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterIsLenient');

  CFNumberFormatterKey get kCFNumberFormatterIsLenient =>
      _kCFNumberFormatterIsLenient.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterUseSignificantDigits =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterUseSignificantDigits');

  CFNumberFormatterKey get kCFNumberFormatterUseSignificantDigits =>
      _kCFNumberFormatterUseSignificantDigits.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterMinSignificantDigits =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterMinSignificantDigits');

  CFNumberFormatterKey get kCFNumberFormatterMinSignificantDigits =>
      _kCFNumberFormatterMinSignificantDigits.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterMaxSignificantDigits =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterMaxSignificantDigits');

  CFNumberFormatterKey get kCFNumberFormatterMaxSignificantDigits =>
      _kCFNumberFormatterMaxSignificantDigits.value;

  late final ffi.Pointer<CFNumberFormatterKey>
      _kCFNumberFormatterMinGroupingDigits =
      _lookup<CFNumberFormatterKey>('kCFNumberFormatterMinGroupingDigits');

  CFNumberFormatterKey get kCFNumberFormatterMinGroupingDigits =>
      _kCFNumberFormatterMinGroupingDigits.value;

  int CFNumberFormatterGetDecimalInfoForCurrencyCode(
    CFStringRef currencyCode,
    ffi.Pointer<ffi.Int32> defaultFractionDigits,
    ffi.Pointer<ffi.Double> roundingIncrement,
  ) {
    return _CFNumberFormatterGetDecimalInfoForCurrencyCode(
      currencyCode,
      defaultFractionDigits,
      roundingIncrement,
    );
  }

  late final _CFNumberFormatterGetDecimalInfoForCurrencyCodePtr = _lookup<
          ffi.NativeFunction<
              Boolean Function(CFStringRef, ffi.Pointer<ffi.Int32>,
                  ffi.Pointer<ffi.Double>)>>(
      'CFNumberFormatterGetDecimalInfoForCurrencyCode');
  late final _CFNumberFormatterGetDecimalInfoForCurrencyCode =
      _CFNumberFormatterGetDecimalInfoForCurrencyCodePtr.asFunction<
          int Function(
              CFStringRef, ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Double>)>();

  late final ffi.Pointer<CFStringRef> _kCFPreferencesAnyApplication =
      _lookup<CFStringRef>('kCFPreferencesAnyApplication');

  CFStringRef get kCFPreferencesAnyApplication =>
      _kCFPreferencesAnyApplication.value;

  set kCFPreferencesAnyApplication(CFStringRef value) =>
      _kCFPreferencesAnyApplication.value = value;

  late final ffi.Pointer<CFStringRef> _kCFPreferencesCurrentApplication =
      _lookup<CFStringRef>('kCFPreferencesCurrentApplication');

  CFStringRef get kCFPreferencesCurrentApplication =>
      _kCFPreferencesCurrentApplication.value;

  set kCFPreferencesCurrentApplication(CFStringRef value) =>
      _kCFPreferencesCurrentApplication.value = value;

  late final ffi.Pointer<CFStringRef> _kCFPreferencesAnyHost =
      _lookup<CFStringRef>('kCFPreferencesAnyHost');

  CFStringRef get kCFPreferencesAnyHost => _kCFPreferencesAnyHost.value;

  set kCFPreferencesAnyHost(CFStringRef value) =>
      _kCFPreferencesAnyHost.value = value;

  late final ffi.Pointer<CFStringRef> _kCFPreferencesCurrentHost =
      _lookup<CFStringRef>('kCFPreferencesCurrentHost');

  CFStringRef get kCFPreferencesCurrentHost => _kCFPreferencesCurrentHost.value;

  set kCFPreferencesCurrentHost(CFStringRef value) =>
      _kCFPreferencesCurrentHost.value = value;

  late final ffi.Pointer<CFStringRef> _kCFPreferencesAnyUser =
      _lookup<CFStringRef>('kCFPreferencesAnyUser');

  CFStringRef get kCFPreferencesAnyUser => _kCFPreferencesAnyUser.value;

  set kCFPreferencesAnyUser(CFStringRef value) =>
      _kCFPreferencesAnyUser.value = value;

  late final ffi.Pointer<CFStringRef> _kCFPreferencesCurrentUser =
      _lookup<CFStringRef>('kCFPreferencesCurrentUser');

  CFStringRef get kCFPreferencesCurrentUser => _kCFPreferencesCurrentUser.value;

  set kCFPreferencesCurrentUser(CFStringRef value) =>
      _kCFPreferencesCurrentUser.value = value;

  CFPropertyListRef CFPreferencesCopyAppValue(
    CFStringRef key,
    CFStringRef applicationID,
  ) {
    return _CFPreferencesCopyAppValue(
      key,
      applicationID,
    );
  }

  late final _CFPreferencesCopyAppValuePtr = _lookup<
      ffi.NativeFunction<
          CFPropertyListRef Function(
              CFStringRef, CFStringRef)>>('CFPreferencesCopyAppValue');
  late final _CFPreferencesCopyAppValue = _CFPreferencesCopyAppValuePtr
      .asFunction<CFPropertyListRef Function(CFStringRef, CFStringRef)>();

  int CFPreferencesGetAppBooleanValue(
    CFStringRef key,
    CFStringRef applicationID,
    ffi.Pointer<Boolean> keyExistsAndHasValidFormat,
  ) {
    return _CFPreferencesGetAppBooleanValue(
      key,
      applicationID,
      keyExistsAndHasValidFormat,
    );
  }

  late final _CFPreferencesGetAppBooleanValuePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFStringRef, CFStringRef,
              ffi.Pointer<Boolean>)>>('CFPreferencesGetAppBooleanValue');
  late final _CFPreferencesGetAppBooleanValue =
      _CFPreferencesGetAppBooleanValuePtr.asFunction<
          int Function(CFStringRef, CFStringRef, ffi.Pointer<Boolean>)>();

  int CFPreferencesGetAppIntegerValue(
    CFStringRef key,
    CFStringRef applicationID,
    ffi.Pointer<Boolean> keyExistsAndHasValidFormat,
  ) {
    return _CFPreferencesGetAppIntegerValue(
      key,
      applicationID,
      keyExistsAndHasValidFormat,
    );
  }

  late final _CFPreferencesGetAppIntegerValuePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFStringRef, CFStringRef,
              ffi.Pointer<Boolean>)>>('CFPreferencesGetAppIntegerValue');
  late final _CFPreferencesGetAppIntegerValue =
      _CFPreferencesGetAppIntegerValuePtr.asFunction<
          int Function(CFStringRef, CFStringRef, ffi.Pointer<Boolean>)>();

  void CFPreferencesSetAppValue(
    CFStringRef key,
    CFPropertyListRef value,
    CFStringRef applicationID,
  ) {
    return _CFPreferencesSetAppValue(
      key,
      value,
      applicationID,
    );
  }

  late final _CFPreferencesSetAppValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFStringRef, CFPropertyListRef,
              CFStringRef)>>('CFPreferencesSetAppValue');
  late final _CFPreferencesSetAppValue = _CFPreferencesSetAppValuePtr
      .asFunction<void Function(CFStringRef, CFPropertyListRef, CFStringRef)>();

  void CFPreferencesAddSuitePreferencesToApp(
    CFStringRef applicationID,
    CFStringRef suiteID,
  ) {
    return _CFPreferencesAddSuitePreferencesToApp(
      applicationID,
      suiteID,
    );
  }

  late final _CFPreferencesAddSuitePreferencesToAppPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFStringRef, CFStringRef)>>(
          'CFPreferencesAddSuitePreferencesToApp');
  late final _CFPreferencesAddSuitePreferencesToApp =
      _CFPreferencesAddSuitePreferencesToAppPtr.asFunction<
          void Function(CFStringRef, CFStringRef)>();

  void CFPreferencesRemoveSuitePreferencesFromApp(
    CFStringRef applicationID,
    CFStringRef suiteID,
  ) {
    return _CFPreferencesRemoveSuitePreferencesFromApp(
      applicationID,
      suiteID,
    );
  }

  late final _CFPreferencesRemoveSuitePreferencesFromAppPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFStringRef, CFStringRef)>>(
          'CFPreferencesRemoveSuitePreferencesFromApp');
  late final _CFPreferencesRemoveSuitePreferencesFromApp =
      _CFPreferencesRemoveSuitePreferencesFromAppPtr.asFunction<
          void Function(CFStringRef, CFStringRef)>();

  int CFPreferencesAppSynchronize(
    CFStringRef applicationID,
  ) {
    return _CFPreferencesAppSynchronize(
      applicationID,
    );
  }

  late final _CFPreferencesAppSynchronizePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFStringRef)>>(
          'CFPreferencesAppSynchronize');
  late final _CFPreferencesAppSynchronize =
      _CFPreferencesAppSynchronizePtr.asFunction<int Function(CFStringRef)>();

  CFPropertyListRef CFPreferencesCopyValue(
    CFStringRef key,
    CFStringRef applicationID,
    CFStringRef userName,
    CFStringRef hostName,
  ) {
    return _CFPreferencesCopyValue(
      key,
      applicationID,
      userName,
      hostName,
    );
  }

  late final _CFPreferencesCopyValuePtr = _lookup<
      ffi.NativeFunction<
          CFPropertyListRef Function(CFStringRef, CFStringRef, CFStringRef,
              CFStringRef)>>('CFPreferencesCopyValue');
  late final _CFPreferencesCopyValue = _CFPreferencesCopyValuePtr.asFunction<
      CFPropertyListRef Function(
          CFStringRef, CFStringRef, CFStringRef, CFStringRef)>();

  CFDictionaryRef CFPreferencesCopyMultiple(
    CFArrayRef keysToFetch,
    CFStringRef applicationID,
    CFStringRef userName,
    CFStringRef hostName,
  ) {
    return _CFPreferencesCopyMultiple(
      keysToFetch,
      applicationID,
      userName,
      hostName,
    );
  }

  late final _CFPreferencesCopyMultiplePtr = _lookup<
      ffi.NativeFunction<
          CFDictionaryRef Function(CFArrayRef, CFStringRef, CFStringRef,
              CFStringRef)>>('CFPreferencesCopyMultiple');
  late final _CFPreferencesCopyMultiple =
      _CFPreferencesCopyMultiplePtr.asFunction<
          CFDictionaryRef Function(
              CFArrayRef, CFStringRef, CFStringRef, CFStringRef)>();

  void CFPreferencesSetValue(
    CFStringRef key,
    CFPropertyListRef value,
    CFStringRef applicationID,
    CFStringRef userName,
    CFStringRef hostName,
  ) {
    return _CFPreferencesSetValue(
      key,
      value,
      applicationID,
      userName,
      hostName,
    );
  }

  late final _CFPreferencesSetValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFStringRef, CFPropertyListRef, CFStringRef,
              CFStringRef, CFStringRef)>>('CFPreferencesSetValue');
  late final _CFPreferencesSetValue = _CFPreferencesSetValuePtr.asFunction<
      void Function(CFStringRef, CFPropertyListRef, CFStringRef, CFStringRef,
          CFStringRef)>();

  void CFPreferencesSetMultiple(
    CFDictionaryRef keysToSet,
    CFArrayRef keysToRemove,
    CFStringRef applicationID,
    CFStringRef userName,
    CFStringRef hostName,
  ) {
    return _CFPreferencesSetMultiple(
      keysToSet,
      keysToRemove,
      applicationID,
      userName,
      hostName,
    );
  }

  late final _CFPreferencesSetMultiplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFDictionaryRef, CFArrayRef, CFStringRef,
              CFStringRef, CFStringRef)>>('CFPreferencesSetMultiple');
  late final _CFPreferencesSetMultiple =
      _CFPreferencesSetMultiplePtr.asFunction<
          void Function(CFDictionaryRef, CFArrayRef, CFStringRef, CFStringRef,
              CFStringRef)>();

  int CFPreferencesSynchronize(
    CFStringRef applicationID,
    CFStringRef userName,
    CFStringRef hostName,
  ) {
    return _CFPreferencesSynchronize(
      applicationID,
      userName,
      hostName,
    );
  }

  late final _CFPreferencesSynchronizePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFStringRef, CFStringRef,
              CFStringRef)>>('CFPreferencesSynchronize');
  late final _CFPreferencesSynchronize = _CFPreferencesSynchronizePtr
      .asFunction<int Function(CFStringRef, CFStringRef, CFStringRef)>();

  CFArrayRef CFPreferencesCopyApplicationList(
    CFStringRef userName,
    CFStringRef hostName,
  ) {
    return _CFPreferencesCopyApplicationList(
      userName,
      hostName,
    );
  }

  late final _CFPreferencesCopyApplicationListPtr = _lookup<
          ffi.NativeFunction<CFArrayRef Function(CFStringRef, CFStringRef)>>(
      'CFPreferencesCopyApplicationList');
  late final _CFPreferencesCopyApplicationList =
      _CFPreferencesCopyApplicationListPtr.asFunction<
          CFArrayRef Function(CFStringRef, CFStringRef)>();

  CFArrayRef CFPreferencesCopyKeyList(
    CFStringRef applicationID,
    CFStringRef userName,
    CFStringRef hostName,
  ) {
    return _CFPreferencesCopyKeyList(
      applicationID,
      userName,
      hostName,
    );
  }

  late final _CFPreferencesCopyKeyListPtr = _lookup<
      ffi.NativeFunction<
          CFArrayRef Function(CFStringRef, CFStringRef,
              CFStringRef)>>('CFPreferencesCopyKeyList');
  late final _CFPreferencesCopyKeyList = _CFPreferencesCopyKeyListPtr
      .asFunction<CFArrayRef Function(CFStringRef, CFStringRef, CFStringRef)>();

  int CFPreferencesAppValueIsForced(
    CFStringRef key,
    CFStringRef applicationID,
  ) {
    return _CFPreferencesAppValueIsForced(
      key,
      applicationID,
    );
  }

  late final _CFPreferencesAppValueIsForcedPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFStringRef, CFStringRef)>>(
          'CFPreferencesAppValueIsForced');
  late final _CFPreferencesAppValueIsForced = _CFPreferencesAppValueIsForcedPtr
      .asFunction<int Function(CFStringRef, CFStringRef)>();

  int CFURLGetTypeID() {
    return _CFURLGetTypeID();
  }

  late final _CFURLGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFURLGetTypeID');
  late final _CFURLGetTypeID = _CFURLGetTypeIDPtr.asFunction<int Function()>();

  CFURLRef CFURLCreateWithBytes(
    CFAllocatorRef allocator,
    ffi.Pointer<UInt8> URLBytes,
    int length,
    int encoding,
    CFURLRef baseURL,
  ) {
    return _CFURLCreateWithBytes(
      allocator,
      URLBytes,
      length,
      encoding,
      baseURL,
    );
  }

  late final _CFURLCreateWithBytesPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, CFIndex,
              CFStringEncoding, CFURLRef)>>('CFURLCreateWithBytes');
  late final _CFURLCreateWithBytes = _CFURLCreateWithBytesPtr.asFunction<
      CFURLRef Function(
          CFAllocatorRef, ffi.Pointer<UInt8>, int, int, CFURLRef)>();

  CFDataRef CFURLCreateData(
    CFAllocatorRef allocator,
    CFURLRef url,
    int encoding,
    int escapeWhitespace,
  ) {
    return _CFURLCreateData(
      allocator,
      url,
      encoding,
      escapeWhitespace,
    );
  }

  late final _CFURLCreateDataPtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(CFAllocatorRef, CFURLRef, CFStringEncoding,
              Boolean)>>('CFURLCreateData');
  late final _CFURLCreateData = _CFURLCreateDataPtr.asFunction<
      CFDataRef Function(CFAllocatorRef, CFURLRef, int, int)>();

  CFURLRef CFURLCreateWithString(
    CFAllocatorRef allocator,
    CFStringRef URLString,
    CFURLRef baseURL,
  ) {
    return _CFURLCreateWithString(
      allocator,
      URLString,
      baseURL,
    );
  }

  late final _CFURLCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(
              CFAllocatorRef, CFStringRef, CFURLRef)>>('CFURLCreateWithString');
  late final _CFURLCreateWithString = _CFURLCreateWithStringPtr.asFunction<
      CFURLRef Function(CFAllocatorRef, CFStringRef, CFURLRef)>();

  CFURLRef CFURLCreateAbsoluteURLWithBytes(
    CFAllocatorRef alloc,
    ffi.Pointer<UInt8> relativeURLBytes,
    int length,
    int encoding,
    CFURLRef baseURL,
    int useCompatibilityMode,
  ) {
    return _CFURLCreateAbsoluteURLWithBytes(
      alloc,
      relativeURLBytes,
      length,
      encoding,
      baseURL,
      useCompatibilityMode,
    );
  }

  late final _CFURLCreateAbsoluteURLWithBytesPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(
              CFAllocatorRef,
              ffi.Pointer<UInt8>,
              CFIndex,
              CFStringEncoding,
              CFURLRef,
              Boolean)>>('CFURLCreateAbsoluteURLWithBytes');
  late final _CFURLCreateAbsoluteURLWithBytes =
      _CFURLCreateAbsoluteURLWithBytesPtr.asFunction<
          CFURLRef Function(
              CFAllocatorRef, ffi.Pointer<UInt8>, int, int, CFURLRef, int)>();

  CFURLRef CFURLCreateWithFileSystemPath(
    CFAllocatorRef allocator,
    CFStringRef filePath,
    CFURLPathStyle pathStyle,
    DartBoolean isDirectory,
  ) {
    return _CFURLCreateWithFileSystemPath(
      allocator,
      filePath,
      pathStyle.value,
      isDirectory,
    );
  }

  late final _CFURLCreateWithFileSystemPathPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFAllocatorRef, CFStringRef, CFIndex,
              Boolean)>>('CFURLCreateWithFileSystemPath');
  late final _CFURLCreateWithFileSystemPath = _CFURLCreateWithFileSystemPathPtr
      .asFunction<CFURLRef Function(CFAllocatorRef, CFStringRef, int, int)>();

  CFURLRef CFURLCreateFromFileSystemRepresentation(
    CFAllocatorRef allocator,
    ffi.Pointer<UInt8> buffer,
    int bufLen,
    int isDirectory,
  ) {
    return _CFURLCreateFromFileSystemRepresentation(
      allocator,
      buffer,
      bufLen,
      isDirectory,
    );
  }

  late final _CFURLCreateFromFileSystemRepresentationPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, CFIndex,
              Boolean)>>('CFURLCreateFromFileSystemRepresentation');
  late final _CFURLCreateFromFileSystemRepresentation =
      _CFURLCreateFromFileSystemRepresentationPtr.asFunction<
          CFURLRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, int, int)>();

  CFURLRef CFURLCreateWithFileSystemPathRelativeToBase(
    CFAllocatorRef allocator,
    CFStringRef filePath,
    CFURLPathStyle pathStyle,
    DartBoolean isDirectory,
    CFURLRef baseURL,
  ) {
    return _CFURLCreateWithFileSystemPathRelativeToBase(
      allocator,
      filePath,
      pathStyle.value,
      isDirectory,
      baseURL,
    );
  }

  late final _CFURLCreateWithFileSystemPathRelativeToBasePtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFAllocatorRef, CFStringRef, CFIndex, Boolean,
              CFURLRef)>>('CFURLCreateWithFileSystemPathRelativeToBase');
  late final _CFURLCreateWithFileSystemPathRelativeToBase =
      _CFURLCreateWithFileSystemPathRelativeToBasePtr.asFunction<
          CFURLRef Function(CFAllocatorRef, CFStringRef, int, int, CFURLRef)>();

  CFURLRef CFURLCreateFromFileSystemRepresentationRelativeToBase(
    CFAllocatorRef allocator,
    ffi.Pointer<UInt8> buffer,
    int bufLen,
    int isDirectory,
    CFURLRef baseURL,
  ) {
    return _CFURLCreateFromFileSystemRepresentationRelativeToBase(
      allocator,
      buffer,
      bufLen,
      isDirectory,
      baseURL,
    );
  }

  late final _CFURLCreateFromFileSystemRepresentationRelativeToBasePtr =
      _lookup<
              ffi.NativeFunction<
                  CFURLRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, CFIndex,
                      Boolean, CFURLRef)>>(
          'CFURLCreateFromFileSystemRepresentationRelativeToBase');
  late final _CFURLCreateFromFileSystemRepresentationRelativeToBase =
      _CFURLCreateFromFileSystemRepresentationRelativeToBasePtr.asFunction<
          CFURLRef Function(
              CFAllocatorRef, ffi.Pointer<UInt8>, int, int, CFURLRef)>();

  int CFURLGetFileSystemRepresentation(
    CFURLRef url,
    int resolveAgainstBase,
    ffi.Pointer<UInt8> buffer,
    int maxBufLen,
  ) {
    return _CFURLGetFileSystemRepresentation(
      url,
      resolveAgainstBase,
      buffer,
      maxBufLen,
    );
  }

  late final _CFURLGetFileSystemRepresentationPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFURLRef, Boolean, ffi.Pointer<UInt8>,
              CFIndex)>>('CFURLGetFileSystemRepresentation');
  late final _CFURLGetFileSystemRepresentation =
      _CFURLGetFileSystemRepresentationPtr.asFunction<
          int Function(CFURLRef, int, ffi.Pointer<UInt8>, int)>();

  CFURLRef CFURLCopyAbsoluteURL(
    CFURLRef relativeURL,
  ) {
    return _CFURLCopyAbsoluteURL(
      relativeURL,
    );
  }

  late final _CFURLCopyAbsoluteURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFURLRef)>>(
          'CFURLCopyAbsoluteURL');
  late final _CFURLCopyAbsoluteURL =
      _CFURLCopyAbsoluteURLPtr.asFunction<CFURLRef Function(CFURLRef)>();

  CFStringRef CFURLGetString(
    CFURLRef anURL,
  ) {
    return _CFURLGetString(
      anURL,
    );
  }

  late final _CFURLGetStringPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef)>>(
          'CFURLGetString');
  late final _CFURLGetString =
      _CFURLGetStringPtr.asFunction<CFStringRef Function(CFURLRef)>();

  CFURLRef CFURLGetBaseURL(
    CFURLRef anURL,
  ) {
    return _CFURLGetBaseURL(
      anURL,
    );
  }

  late final _CFURLGetBaseURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFURLRef)>>(
          'CFURLGetBaseURL');
  late final _CFURLGetBaseURL =
      _CFURLGetBaseURLPtr.asFunction<CFURLRef Function(CFURLRef)>();

  int CFURLCanBeDecomposed(
    CFURLRef anURL,
  ) {
    return _CFURLCanBeDecomposed(
      anURL,
    );
  }

  late final _CFURLCanBeDecomposedPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFURLRef)>>(
          'CFURLCanBeDecomposed');
  late final _CFURLCanBeDecomposed =
      _CFURLCanBeDecomposedPtr.asFunction<int Function(CFURLRef)>();

  CFStringRef CFURLCopyScheme(
    CFURLRef anURL,
  ) {
    return _CFURLCopyScheme(
      anURL,
    );
  }

  late final _CFURLCopySchemePtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef)>>(
          'CFURLCopyScheme');
  late final _CFURLCopyScheme =
      _CFURLCopySchemePtr.asFunction<CFStringRef Function(CFURLRef)>();

  CFStringRef CFURLCopyNetLocation(
    CFURLRef anURL,
  ) {
    return _CFURLCopyNetLocation(
      anURL,
    );
  }

  late final _CFURLCopyNetLocationPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef)>>(
          'CFURLCopyNetLocation');
  late final _CFURLCopyNetLocation =
      _CFURLCopyNetLocationPtr.asFunction<CFStringRef Function(CFURLRef)>();

  CFStringRef CFURLCopyPath(
    CFURLRef anURL,
  ) {
    return _CFURLCopyPath(
      anURL,
    );
  }

  late final _CFURLCopyPathPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef)>>(
          'CFURLCopyPath');
  late final _CFURLCopyPath =
      _CFURLCopyPathPtr.asFunction<CFStringRef Function(CFURLRef)>();

  CFStringRef CFURLCopyStrictPath(
    CFURLRef anURL,
    ffi.Pointer<Boolean> isAbsolute,
  ) {
    return _CFURLCopyStrictPath(
      anURL,
      isAbsolute,
    );
  }

  late final _CFURLCopyStrictPathPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(
              CFURLRef, ffi.Pointer<Boolean>)>>('CFURLCopyStrictPath');
  late final _CFURLCopyStrictPath = _CFURLCopyStrictPathPtr.asFunction<
      CFStringRef Function(CFURLRef, ffi.Pointer<Boolean>)>();

  CFStringRef CFURLCopyFileSystemPath(
    CFURLRef anURL,
    CFURLPathStyle pathStyle,
  ) {
    return _CFURLCopyFileSystemPath(
      anURL,
      pathStyle.value,
    );
  }

  late final _CFURLCopyFileSystemPathPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef, CFIndex)>>(
          'CFURLCopyFileSystemPath');
  late final _CFURLCopyFileSystemPath = _CFURLCopyFileSystemPathPtr.asFunction<
      CFStringRef Function(CFURLRef, int)>();

  int CFURLHasDirectoryPath(
    CFURLRef anURL,
  ) {
    return _CFURLHasDirectoryPath(
      anURL,
    );
  }

  late final _CFURLHasDirectoryPathPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFURLRef)>>(
          'CFURLHasDirectoryPath');
  late final _CFURLHasDirectoryPath =
      _CFURLHasDirectoryPathPtr.asFunction<int Function(CFURLRef)>();

  CFStringRef CFURLCopyResourceSpecifier(
    CFURLRef anURL,
  ) {
    return _CFURLCopyResourceSpecifier(
      anURL,
    );
  }

  late final _CFURLCopyResourceSpecifierPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef)>>(
          'CFURLCopyResourceSpecifier');
  late final _CFURLCopyResourceSpecifier = _CFURLCopyResourceSpecifierPtr
      .asFunction<CFStringRef Function(CFURLRef)>();

  CFStringRef CFURLCopyHostName(
    CFURLRef anURL,
  ) {
    return _CFURLCopyHostName(
      anURL,
    );
  }

  late final _CFURLCopyHostNamePtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef)>>(
          'CFURLCopyHostName');
  late final _CFURLCopyHostName =
      _CFURLCopyHostNamePtr.asFunction<CFStringRef Function(CFURLRef)>();

  int CFURLGetPortNumber(
    CFURLRef anURL,
  ) {
    return _CFURLGetPortNumber(
      anURL,
    );
  }

  late final _CFURLGetPortNumberPtr =
      _lookup<ffi.NativeFunction<SInt32 Function(CFURLRef)>>(
          'CFURLGetPortNumber');
  late final _CFURLGetPortNumber =
      _CFURLGetPortNumberPtr.asFunction<int Function(CFURLRef)>();

  CFStringRef CFURLCopyUserName(
    CFURLRef anURL,
  ) {
    return _CFURLCopyUserName(
      anURL,
    );
  }

  late final _CFURLCopyUserNamePtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef)>>(
          'CFURLCopyUserName');
  late final _CFURLCopyUserName =
      _CFURLCopyUserNamePtr.asFunction<CFStringRef Function(CFURLRef)>();

  CFStringRef CFURLCopyPassword(
    CFURLRef anURL,
  ) {
    return _CFURLCopyPassword(
      anURL,
    );
  }

  late final _CFURLCopyPasswordPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef)>>(
          'CFURLCopyPassword');
  late final _CFURLCopyPassword =
      _CFURLCopyPasswordPtr.asFunction<CFStringRef Function(CFURLRef)>();

  CFStringRef CFURLCopyParameterString(
    CFURLRef anURL,
    CFStringRef charactersToLeaveEscaped,
  ) {
    return _CFURLCopyParameterString(
      anURL,
      charactersToLeaveEscaped,
    );
  }

  late final _CFURLCopyParameterStringPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef, CFStringRef)>>(
          'CFURLCopyParameterString');
  late final _CFURLCopyParameterString = _CFURLCopyParameterStringPtr
      .asFunction<CFStringRef Function(CFURLRef, CFStringRef)>();

  CFStringRef CFURLCopyQueryString(
    CFURLRef anURL,
    CFStringRef charactersToLeaveEscaped,
  ) {
    return _CFURLCopyQueryString(
      anURL,
      charactersToLeaveEscaped,
    );
  }

  late final _CFURLCopyQueryStringPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef, CFStringRef)>>(
          'CFURLCopyQueryString');
  late final _CFURLCopyQueryString = _CFURLCopyQueryStringPtr.asFunction<
      CFStringRef Function(CFURLRef, CFStringRef)>();

  CFStringRef CFURLCopyFragment(
    CFURLRef anURL,
    CFStringRef charactersToLeaveEscaped,
  ) {
    return _CFURLCopyFragment(
      anURL,
      charactersToLeaveEscaped,
    );
  }

  late final _CFURLCopyFragmentPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef, CFStringRef)>>(
          'CFURLCopyFragment');
  late final _CFURLCopyFragment = _CFURLCopyFragmentPtr.asFunction<
      CFStringRef Function(CFURLRef, CFStringRef)>();

  CFStringRef CFURLCopyLastPathComponent(
    CFURLRef url,
  ) {
    return _CFURLCopyLastPathComponent(
      url,
    );
  }

  late final _CFURLCopyLastPathComponentPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef)>>(
          'CFURLCopyLastPathComponent');
  late final _CFURLCopyLastPathComponent = _CFURLCopyLastPathComponentPtr
      .asFunction<CFStringRef Function(CFURLRef)>();

  CFStringRef CFURLCopyPathExtension(
    CFURLRef url,
  ) {
    return _CFURLCopyPathExtension(
      url,
    );
  }

  late final _CFURLCopyPathExtensionPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFURLRef)>>(
          'CFURLCopyPathExtension');
  late final _CFURLCopyPathExtension =
      _CFURLCopyPathExtensionPtr.asFunction<CFStringRef Function(CFURLRef)>();

  CFURLRef CFURLCreateCopyAppendingPathComponent(
    CFAllocatorRef allocator,
    CFURLRef url,
    CFStringRef pathComponent,
    int isDirectory,
  ) {
    return _CFURLCreateCopyAppendingPathComponent(
      allocator,
      url,
      pathComponent,
      isDirectory,
    );
  }

  late final _CFURLCreateCopyAppendingPathComponentPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFAllocatorRef, CFURLRef, CFStringRef,
              Boolean)>>('CFURLCreateCopyAppendingPathComponent');
  late final _CFURLCreateCopyAppendingPathComponent =
      _CFURLCreateCopyAppendingPathComponentPtr.asFunction<
          CFURLRef Function(CFAllocatorRef, CFURLRef, CFStringRef, int)>();

  CFURLRef CFURLCreateCopyDeletingLastPathComponent(
    CFAllocatorRef allocator,
    CFURLRef url,
  ) {
    return _CFURLCreateCopyDeletingLastPathComponent(
      allocator,
      url,
    );
  }

  late final _CFURLCreateCopyDeletingLastPathComponentPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFAllocatorRef, CFURLRef)>>(
          'CFURLCreateCopyDeletingLastPathComponent');
  late final _CFURLCreateCopyDeletingLastPathComponent =
      _CFURLCreateCopyDeletingLastPathComponentPtr.asFunction<
          CFURLRef Function(CFAllocatorRef, CFURLRef)>();

  CFURLRef CFURLCreateCopyAppendingPathExtension(
    CFAllocatorRef allocator,
    CFURLRef url,
    CFStringRef extension1,
  ) {
    return _CFURLCreateCopyAppendingPathExtension(
      allocator,
      url,
      extension1,
    );
  }

  late final _CFURLCreateCopyAppendingPathExtensionPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFAllocatorRef, CFURLRef,
              CFStringRef)>>('CFURLCreateCopyAppendingPathExtension');
  late final _CFURLCreateCopyAppendingPathExtension =
      _CFURLCreateCopyAppendingPathExtensionPtr.asFunction<
          CFURLRef Function(CFAllocatorRef, CFURLRef, CFStringRef)>();

  CFURLRef CFURLCreateCopyDeletingPathExtension(
    CFAllocatorRef allocator,
    CFURLRef url,
  ) {
    return _CFURLCreateCopyDeletingPathExtension(
      allocator,
      url,
    );
  }

  late final _CFURLCreateCopyDeletingPathExtensionPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFAllocatorRef, CFURLRef)>>(
          'CFURLCreateCopyDeletingPathExtension');
  late final _CFURLCreateCopyDeletingPathExtension =
      _CFURLCreateCopyDeletingPathExtensionPtr.asFunction<
          CFURLRef Function(CFAllocatorRef, CFURLRef)>();

  int CFURLGetBytes(
    CFURLRef url,
    ffi.Pointer<UInt8> buffer,
    int bufferLength,
  ) {
    return _CFURLGetBytes(
      url,
      buffer,
      bufferLength,
    );
  }

  late final _CFURLGetBytesPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(
              CFURLRef, ffi.Pointer<UInt8>, CFIndex)>>('CFURLGetBytes');
  late final _CFURLGetBytes = _CFURLGetBytesPtr.asFunction<
      int Function(CFURLRef, ffi.Pointer<UInt8>, int)>();

  CFRange CFURLGetByteRangeForComponent(
    CFURLRef url,
    CFURLComponentType component,
    ffi.Pointer<CFRange> rangeIncludingSeparators,
  ) {
    return _CFURLGetByteRangeForComponent(
      url,
      component.value,
      rangeIncludingSeparators,
    );
  }

  late final _CFURLGetByteRangeForComponentPtr = _lookup<
      ffi.NativeFunction<
          CFRange Function(CFURLRef, CFIndex,
              ffi.Pointer<CFRange>)>>('CFURLGetByteRangeForComponent');
  late final _CFURLGetByteRangeForComponent = _CFURLGetByteRangeForComponentPtr
      .asFunction<CFRange Function(CFURLRef, int, ffi.Pointer<CFRange>)>();

  CFStringRef CFURLCreateStringByReplacingPercentEscapes(
    CFAllocatorRef allocator,
    CFStringRef originalString,
    CFStringRef charactersToLeaveEscaped,
  ) {
    return _CFURLCreateStringByReplacingPercentEscapes(
      allocator,
      originalString,
      charactersToLeaveEscaped,
    );
  }

  late final _CFURLCreateStringByReplacingPercentEscapesPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFStringRef,
              CFStringRef)>>('CFURLCreateStringByReplacingPercentEscapes');
  late final _CFURLCreateStringByReplacingPercentEscapes =
      _CFURLCreateStringByReplacingPercentEscapesPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, CFStringRef, CFStringRef)>();

  CFStringRef CFURLCreateStringByReplacingPercentEscapesUsingEncoding(
    CFAllocatorRef allocator,
    CFStringRef origString,
    CFStringRef charsToLeaveEscaped,
    int encoding,
  ) {
    return _CFURLCreateStringByReplacingPercentEscapesUsingEncoding(
      allocator,
      origString,
      charsToLeaveEscaped,
      encoding,
    );
  }

  late final _CFURLCreateStringByReplacingPercentEscapesUsingEncodingPtr =
      _lookup<
              ffi.NativeFunction<
                  CFStringRef Function(CFAllocatorRef, CFStringRef, CFStringRef,
                      CFStringEncoding)>>(
          'CFURLCreateStringByReplacingPercentEscapesUsingEncoding');
  late final _CFURLCreateStringByReplacingPercentEscapesUsingEncoding =
      _CFURLCreateStringByReplacingPercentEscapesUsingEncodingPtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, CFStringRef, CFStringRef, int)>();

  CFStringRef CFURLCreateStringByAddingPercentEscapes(
    CFAllocatorRef allocator,
    CFStringRef originalString,
    CFStringRef charactersToLeaveUnescaped,
    CFStringRef legalURLCharactersToBeEscaped,
    int encoding,
  ) {
    return _CFURLCreateStringByAddingPercentEscapes(
      allocator,
      originalString,
      charactersToLeaveUnescaped,
      legalURLCharactersToBeEscaped,
      encoding,
    );
  }

  late final _CFURLCreateStringByAddingPercentEscapesPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(
              CFAllocatorRef,
              CFStringRef,
              CFStringRef,
              CFStringRef,
              CFStringEncoding)>>('CFURLCreateStringByAddingPercentEscapes');
  late final _CFURLCreateStringByAddingPercentEscapes =
      _CFURLCreateStringByAddingPercentEscapesPtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, CFStringRef, CFStringRef, CFStringRef, int)>();

  int CFURLIsFileReferenceURL(
    CFURLRef url,
  ) {
    return _CFURLIsFileReferenceURL(
      url,
    );
  }

  late final _CFURLIsFileReferenceURLPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFURLRef)>>(
          'CFURLIsFileReferenceURL');
  late final _CFURLIsFileReferenceURL =
      _CFURLIsFileReferenceURLPtr.asFunction<int Function(CFURLRef)>();

  CFURLRef CFURLCreateFileReferenceURL(
    CFAllocatorRef allocator,
    CFURLRef url,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFURLCreateFileReferenceURL(
      allocator,
      url,
      error,
    );
  }

  late final _CFURLCreateFileReferenceURLPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFAllocatorRef, CFURLRef,
              ffi.Pointer<CFErrorRef>)>>('CFURLCreateFileReferenceURL');
  late final _CFURLCreateFileReferenceURL =
      _CFURLCreateFileReferenceURLPtr.asFunction<
          CFURLRef Function(
              CFAllocatorRef, CFURLRef, ffi.Pointer<CFErrorRef>)>();

  CFURLRef CFURLCreateFilePathURL(
    CFAllocatorRef allocator,
    CFURLRef url,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFURLCreateFilePathURL(
      allocator,
      url,
      error,
    );
  }

  late final _CFURLCreateFilePathURLPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFAllocatorRef, CFURLRef,
              ffi.Pointer<CFErrorRef>)>>('CFURLCreateFilePathURL');
  late final _CFURLCreateFilePathURL = _CFURLCreateFilePathURLPtr.asFunction<
      CFURLRef Function(CFAllocatorRef, CFURLRef, ffi.Pointer<CFErrorRef>)>();

  CFURLRef CFURLCreateFromFSRef(
    CFAllocatorRef allocator,
    ffi.Pointer<FSRef> fsRef,
  ) {
    return _CFURLCreateFromFSRef(
      allocator,
      fsRef,
    );
  }

  late final _CFURLCreateFromFSRefPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(
              CFAllocatorRef, ffi.Pointer<FSRef>)>>('CFURLCreateFromFSRef');
  late final _CFURLCreateFromFSRef = _CFURLCreateFromFSRefPtr.asFunction<
      CFURLRef Function(CFAllocatorRef, ffi.Pointer<FSRef>)>();

  int CFURLGetFSRef(
    CFURLRef url,
    ffi.Pointer<FSRef> fsRef,
  ) {
    return _CFURLGetFSRef(
      url,
      fsRef,
    );
  }

  late final _CFURLGetFSRefPtr = _lookup<
          ffi.NativeFunction<Boolean Function(CFURLRef, ffi.Pointer<FSRef>)>>(
      'CFURLGetFSRef');
  late final _CFURLGetFSRef = _CFURLGetFSRefPtr.asFunction<
      int Function(CFURLRef, ffi.Pointer<FSRef>)>();

  int CFURLCopyResourcePropertyForKey(
    CFURLRef url,
    CFStringRef key,
    ffi.Pointer<ffi.Void> propertyValueTypeRefPtr,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFURLCopyResourcePropertyForKey(
      url,
      key,
      propertyValueTypeRefPtr,
      error,
    );
  }

  late final _CFURLCopyResourcePropertyForKeyPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFURLRef, CFStringRef, ffi.Pointer<ffi.Void>,
              ffi.Pointer<CFErrorRef>)>>('CFURLCopyResourcePropertyForKey');
  late final _CFURLCopyResourcePropertyForKey =
      _CFURLCopyResourcePropertyForKeyPtr.asFunction<
          int Function(CFURLRef, CFStringRef, ffi.Pointer<ffi.Void>,
              ffi.Pointer<CFErrorRef>)>();

  CFDictionaryRef CFURLCopyResourcePropertiesForKeys(
    CFURLRef url,
    CFArrayRef keys,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFURLCopyResourcePropertiesForKeys(
      url,
      keys,
      error,
    );
  }

  late final _CFURLCopyResourcePropertiesForKeysPtr = _lookup<
      ffi.NativeFunction<
          CFDictionaryRef Function(CFURLRef, CFArrayRef,
              ffi.Pointer<CFErrorRef>)>>('CFURLCopyResourcePropertiesForKeys');
  late final _CFURLCopyResourcePropertiesForKeys =
      _CFURLCopyResourcePropertiesForKeysPtr.asFunction<
          CFDictionaryRef Function(
              CFURLRef, CFArrayRef, ffi.Pointer<CFErrorRef>)>();

  int CFURLSetResourcePropertyForKey(
    CFURLRef url,
    CFStringRef key,
    CFTypeRef propertyValue,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFURLSetResourcePropertyForKey(
      url,
      key,
      propertyValue,
      error,
    );
  }

  late final _CFURLSetResourcePropertyForKeyPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFURLRef, CFStringRef, CFTypeRef,
              ffi.Pointer<CFErrorRef>)>>('CFURLSetResourcePropertyForKey');
  late final _CFURLSetResourcePropertyForKey =
      _CFURLSetResourcePropertyForKeyPtr.asFunction<
          int Function(
              CFURLRef, CFStringRef, CFTypeRef, ffi.Pointer<CFErrorRef>)>();

  int CFURLSetResourcePropertiesForKeys(
    CFURLRef url,
    CFDictionaryRef keyedPropertyValues,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFURLSetResourcePropertiesForKeys(
      url,
      keyedPropertyValues,
      error,
    );
  }

  late final _CFURLSetResourcePropertiesForKeysPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFURLRef, CFDictionaryRef,
              ffi.Pointer<CFErrorRef>)>>('CFURLSetResourcePropertiesForKeys');
  late final _CFURLSetResourcePropertiesForKeys =
      _CFURLSetResourcePropertiesForKeysPtr.asFunction<
          int Function(CFURLRef, CFDictionaryRef, ffi.Pointer<CFErrorRef>)>();

  late final ffi.Pointer<CFStringRef> _kCFURLKeysOfUnsetValuesKey =
      _lookup<CFStringRef>('kCFURLKeysOfUnsetValuesKey');

  CFStringRef get kCFURLKeysOfUnsetValuesKey =>
      _kCFURLKeysOfUnsetValuesKey.value;

  void CFURLClearResourcePropertyCacheForKey(
    CFURLRef url,
    CFStringRef key,
  ) {
    return _CFURLClearResourcePropertyCacheForKey(
      url,
      key,
    );
  }

  late final _CFURLClearResourcePropertyCacheForKeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFURLRef, CFStringRef)>>(
          'CFURLClearResourcePropertyCacheForKey');
  late final _CFURLClearResourcePropertyCacheForKey =
      _CFURLClearResourcePropertyCacheForKeyPtr.asFunction<
          void Function(CFURLRef, CFStringRef)>();

  void CFURLClearResourcePropertyCache(
    CFURLRef url,
  ) {
    return _CFURLClearResourcePropertyCache(
      url,
    );
  }

  late final _CFURLClearResourcePropertyCachePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFURLRef)>>(
          'CFURLClearResourcePropertyCache');
  late final _CFURLClearResourcePropertyCache =
      _CFURLClearResourcePropertyCachePtr.asFunction<void Function(CFURLRef)>();

  void CFURLSetTemporaryResourcePropertyForKey(
    CFURLRef url,
    CFStringRef key,
    CFTypeRef propertyValue,
  ) {
    return _CFURLSetTemporaryResourcePropertyForKey(
      url,
      key,
      propertyValue,
    );
  }

  late final _CFURLSetTemporaryResourcePropertyForKeyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(CFURLRef, CFStringRef, CFTypeRef)>>(
      'CFURLSetTemporaryResourcePropertyForKey');
  late final _CFURLSetTemporaryResourcePropertyForKey =
      _CFURLSetTemporaryResourcePropertyForKeyPtr.asFunction<
          void Function(CFURLRef, CFStringRef, CFTypeRef)>();

  int CFURLResourceIsReachable(
    CFURLRef url,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFURLResourceIsReachable(
      url,
      error,
    );
  }

  late final _CFURLResourceIsReachablePtr = _lookup<
          ffi
          .NativeFunction<Boolean Function(CFURLRef, ffi.Pointer<CFErrorRef>)>>(
      'CFURLResourceIsReachable');
  late final _CFURLResourceIsReachable = _CFURLResourceIsReachablePtr
      .asFunction<int Function(CFURLRef, ffi.Pointer<CFErrorRef>)>();

  late final ffi.Pointer<CFStringRef> _kCFURLNameKey =
      _lookup<CFStringRef>('kCFURLNameKey');

  CFStringRef get kCFURLNameKey => _kCFURLNameKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLLocalizedNameKey =
      _lookup<CFStringRef>('kCFURLLocalizedNameKey');

  CFStringRef get kCFURLLocalizedNameKey => _kCFURLLocalizedNameKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsRegularFileKey =
      _lookup<CFStringRef>('kCFURLIsRegularFileKey');

  CFStringRef get kCFURLIsRegularFileKey => _kCFURLIsRegularFileKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsDirectoryKey =
      _lookup<CFStringRef>('kCFURLIsDirectoryKey');

  CFStringRef get kCFURLIsDirectoryKey => _kCFURLIsDirectoryKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsSymbolicLinkKey =
      _lookup<CFStringRef>('kCFURLIsSymbolicLinkKey');

  CFStringRef get kCFURLIsSymbolicLinkKey => _kCFURLIsSymbolicLinkKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsVolumeKey =
      _lookup<CFStringRef>('kCFURLIsVolumeKey');

  CFStringRef get kCFURLIsVolumeKey => _kCFURLIsVolumeKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsPackageKey =
      _lookup<CFStringRef>('kCFURLIsPackageKey');

  CFStringRef get kCFURLIsPackageKey => _kCFURLIsPackageKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsApplicationKey =
      _lookup<CFStringRef>('kCFURLIsApplicationKey');

  CFStringRef get kCFURLIsApplicationKey => _kCFURLIsApplicationKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLApplicationIsScriptableKey =
      _lookup<CFStringRef>('kCFURLApplicationIsScriptableKey');

  CFStringRef get kCFURLApplicationIsScriptableKey =>
      _kCFURLApplicationIsScriptableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsSystemImmutableKey =
      _lookup<CFStringRef>('kCFURLIsSystemImmutableKey');

  CFStringRef get kCFURLIsSystemImmutableKey =>
      _kCFURLIsSystemImmutableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsUserImmutableKey =
      _lookup<CFStringRef>('kCFURLIsUserImmutableKey');

  CFStringRef get kCFURLIsUserImmutableKey => _kCFURLIsUserImmutableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsHiddenKey =
      _lookup<CFStringRef>('kCFURLIsHiddenKey');

  CFStringRef get kCFURLIsHiddenKey => _kCFURLIsHiddenKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLHasHiddenExtensionKey =
      _lookup<CFStringRef>('kCFURLHasHiddenExtensionKey');

  CFStringRef get kCFURLHasHiddenExtensionKey =>
      _kCFURLHasHiddenExtensionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLCreationDateKey =
      _lookup<CFStringRef>('kCFURLCreationDateKey');

  CFStringRef get kCFURLCreationDateKey => _kCFURLCreationDateKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLContentAccessDateKey =
      _lookup<CFStringRef>('kCFURLContentAccessDateKey');

  CFStringRef get kCFURLContentAccessDateKey =>
      _kCFURLContentAccessDateKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLContentModificationDateKey =
      _lookup<CFStringRef>('kCFURLContentModificationDateKey');

  CFStringRef get kCFURLContentModificationDateKey =>
      _kCFURLContentModificationDateKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLAttributeModificationDateKey =
      _lookup<CFStringRef>('kCFURLAttributeModificationDateKey');

  CFStringRef get kCFURLAttributeModificationDateKey =>
      _kCFURLAttributeModificationDateKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileIdentifierKey =
      _lookup<CFStringRef>('kCFURLFileIdentifierKey');

  CFStringRef get kCFURLFileIdentifierKey => _kCFURLFileIdentifierKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileContentIdentifierKey =
      _lookup<CFStringRef>('kCFURLFileContentIdentifierKey');

  CFStringRef get kCFURLFileContentIdentifierKey =>
      _kCFURLFileContentIdentifierKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLMayShareFileContentKey =
      _lookup<CFStringRef>('kCFURLMayShareFileContentKey');

  CFStringRef get kCFURLMayShareFileContentKey =>
      _kCFURLMayShareFileContentKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLMayHaveExtendedAttributesKey =
      _lookup<CFStringRef>('kCFURLMayHaveExtendedAttributesKey');

  CFStringRef get kCFURLMayHaveExtendedAttributesKey =>
      _kCFURLMayHaveExtendedAttributesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsPurgeableKey =
      _lookup<CFStringRef>('kCFURLIsPurgeableKey');

  CFStringRef get kCFURLIsPurgeableKey => _kCFURLIsPurgeableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsSparseKey =
      _lookup<CFStringRef>('kCFURLIsSparseKey');

  CFStringRef get kCFURLIsSparseKey => _kCFURLIsSparseKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLLinkCountKey =
      _lookup<CFStringRef>('kCFURLLinkCountKey');

  CFStringRef get kCFURLLinkCountKey => _kCFURLLinkCountKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLParentDirectoryURLKey =
      _lookup<CFStringRef>('kCFURLParentDirectoryURLKey');

  CFStringRef get kCFURLParentDirectoryURLKey =>
      _kCFURLParentDirectoryURLKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeURLKey =
      _lookup<CFStringRef>('kCFURLVolumeURLKey');

  CFStringRef get kCFURLVolumeURLKey => _kCFURLVolumeURLKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLTypeIdentifierKey =
      _lookup<CFStringRef>('kCFURLTypeIdentifierKey');

  CFStringRef get kCFURLTypeIdentifierKey => _kCFURLTypeIdentifierKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLLocalizedTypeDescriptionKey =
      _lookup<CFStringRef>('kCFURLLocalizedTypeDescriptionKey');

  CFStringRef get kCFURLLocalizedTypeDescriptionKey =>
      _kCFURLLocalizedTypeDescriptionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLLabelNumberKey =
      _lookup<CFStringRef>('kCFURLLabelNumberKey');

  CFStringRef get kCFURLLabelNumberKey => _kCFURLLabelNumberKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLLabelColorKey =
      _lookup<CFStringRef>('kCFURLLabelColorKey');

  CFStringRef get kCFURLLabelColorKey => _kCFURLLabelColorKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLLocalizedLabelKey =
      _lookup<CFStringRef>('kCFURLLocalizedLabelKey');

  CFStringRef get kCFURLLocalizedLabelKey => _kCFURLLocalizedLabelKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLEffectiveIconKey =
      _lookup<CFStringRef>('kCFURLEffectiveIconKey');

  CFStringRef get kCFURLEffectiveIconKey => _kCFURLEffectiveIconKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLCustomIconKey =
      _lookup<CFStringRef>('kCFURLCustomIconKey');

  CFStringRef get kCFURLCustomIconKey => _kCFURLCustomIconKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileResourceIdentifierKey =
      _lookup<CFStringRef>('kCFURLFileResourceIdentifierKey');

  CFStringRef get kCFURLFileResourceIdentifierKey =>
      _kCFURLFileResourceIdentifierKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIdentifierKey =
      _lookup<CFStringRef>('kCFURLVolumeIdentifierKey');

  CFStringRef get kCFURLVolumeIdentifierKey => _kCFURLVolumeIdentifierKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLPreferredIOBlockSizeKey =
      _lookup<CFStringRef>('kCFURLPreferredIOBlockSizeKey');

  CFStringRef get kCFURLPreferredIOBlockSizeKey =>
      _kCFURLPreferredIOBlockSizeKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsReadableKey =
      _lookup<CFStringRef>('kCFURLIsReadableKey');

  CFStringRef get kCFURLIsReadableKey => _kCFURLIsReadableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsWritableKey =
      _lookup<CFStringRef>('kCFURLIsWritableKey');

  CFStringRef get kCFURLIsWritableKey => _kCFURLIsWritableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsExecutableKey =
      _lookup<CFStringRef>('kCFURLIsExecutableKey');

  CFStringRef get kCFURLIsExecutableKey => _kCFURLIsExecutableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileSecurityKey =
      _lookup<CFStringRef>('kCFURLFileSecurityKey');

  CFStringRef get kCFURLFileSecurityKey => _kCFURLFileSecurityKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsExcludedFromBackupKey =
      _lookup<CFStringRef>('kCFURLIsExcludedFromBackupKey');

  CFStringRef get kCFURLIsExcludedFromBackupKey =>
      _kCFURLIsExcludedFromBackupKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLTagNamesKey =
      _lookup<CFStringRef>('kCFURLTagNamesKey');

  CFStringRef get kCFURLTagNamesKey => _kCFURLTagNamesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLPathKey =
      _lookup<CFStringRef>('kCFURLPathKey');

  CFStringRef get kCFURLPathKey => _kCFURLPathKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLCanonicalPathKey =
      _lookup<CFStringRef>('kCFURLCanonicalPathKey');

  CFStringRef get kCFURLCanonicalPathKey => _kCFURLCanonicalPathKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsMountTriggerKey =
      _lookup<CFStringRef>('kCFURLIsMountTriggerKey');

  CFStringRef get kCFURLIsMountTriggerKey => _kCFURLIsMountTriggerKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLGenerationIdentifierKey =
      _lookup<CFStringRef>('kCFURLGenerationIdentifierKey');

  CFStringRef get kCFURLGenerationIdentifierKey =>
      _kCFURLGenerationIdentifierKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLDocumentIdentifierKey =
      _lookup<CFStringRef>('kCFURLDocumentIdentifierKey');

  CFStringRef get kCFURLDocumentIdentifierKey =>
      _kCFURLDocumentIdentifierKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLAddedToDirectoryDateKey =
      _lookup<CFStringRef>('kCFURLAddedToDirectoryDateKey');

  CFStringRef get kCFURLAddedToDirectoryDateKey =>
      _kCFURLAddedToDirectoryDateKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLQuarantinePropertiesKey =
      _lookup<CFStringRef>('kCFURLQuarantinePropertiesKey');

  CFStringRef get kCFURLQuarantinePropertiesKey =>
      _kCFURLQuarantinePropertiesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileResourceTypeKey =
      _lookup<CFStringRef>('kCFURLFileResourceTypeKey');

  CFStringRef get kCFURLFileResourceTypeKey => _kCFURLFileResourceTypeKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileResourceTypeNamedPipe =
      _lookup<CFStringRef>('kCFURLFileResourceTypeNamedPipe');

  CFStringRef get kCFURLFileResourceTypeNamedPipe =>
      _kCFURLFileResourceTypeNamedPipe.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileResourceTypeCharacterSpecial =
      _lookup<CFStringRef>('kCFURLFileResourceTypeCharacterSpecial');

  CFStringRef get kCFURLFileResourceTypeCharacterSpecial =>
      _kCFURLFileResourceTypeCharacterSpecial.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileResourceTypeDirectory =
      _lookup<CFStringRef>('kCFURLFileResourceTypeDirectory');

  CFStringRef get kCFURLFileResourceTypeDirectory =>
      _kCFURLFileResourceTypeDirectory.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileResourceTypeBlockSpecial =
      _lookup<CFStringRef>('kCFURLFileResourceTypeBlockSpecial');

  CFStringRef get kCFURLFileResourceTypeBlockSpecial =>
      _kCFURLFileResourceTypeBlockSpecial.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileResourceTypeRegular =
      _lookup<CFStringRef>('kCFURLFileResourceTypeRegular');

  CFStringRef get kCFURLFileResourceTypeRegular =>
      _kCFURLFileResourceTypeRegular.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileResourceTypeSymbolicLink =
      _lookup<CFStringRef>('kCFURLFileResourceTypeSymbolicLink');

  CFStringRef get kCFURLFileResourceTypeSymbolicLink =>
      _kCFURLFileResourceTypeSymbolicLink.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileResourceTypeSocket =
      _lookup<CFStringRef>('kCFURLFileResourceTypeSocket');

  CFStringRef get kCFURLFileResourceTypeSocket =>
      _kCFURLFileResourceTypeSocket.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileResourceTypeUnknown =
      _lookup<CFStringRef>('kCFURLFileResourceTypeUnknown');

  CFStringRef get kCFURLFileResourceTypeUnknown =>
      _kCFURLFileResourceTypeUnknown.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileSizeKey =
      _lookup<CFStringRef>('kCFURLFileSizeKey');

  CFStringRef get kCFURLFileSizeKey => _kCFURLFileSizeKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileAllocatedSizeKey =
      _lookup<CFStringRef>('kCFURLFileAllocatedSizeKey');

  CFStringRef get kCFURLFileAllocatedSizeKey =>
      _kCFURLFileAllocatedSizeKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLTotalFileSizeKey =
      _lookup<CFStringRef>('kCFURLTotalFileSizeKey');

  CFStringRef get kCFURLTotalFileSizeKey => _kCFURLTotalFileSizeKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLTotalFileAllocatedSizeKey =
      _lookup<CFStringRef>('kCFURLTotalFileAllocatedSizeKey');

  CFStringRef get kCFURLTotalFileAllocatedSizeKey =>
      _kCFURLTotalFileAllocatedSizeKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsAliasFileKey =
      _lookup<CFStringRef>('kCFURLIsAliasFileKey');

  CFStringRef get kCFURLIsAliasFileKey => _kCFURLIsAliasFileKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileProtectionKey =
      _lookup<CFStringRef>('kCFURLFileProtectionKey');

  CFStringRef get kCFURLFileProtectionKey => _kCFURLFileProtectionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileProtectionNone =
      _lookup<CFStringRef>('kCFURLFileProtectionNone');

  CFStringRef get kCFURLFileProtectionNone => _kCFURLFileProtectionNone.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileProtectionComplete =
      _lookup<CFStringRef>('kCFURLFileProtectionComplete');

  CFStringRef get kCFURLFileProtectionComplete =>
      _kCFURLFileProtectionComplete.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileProtectionCompleteUnlessOpen =
      _lookup<CFStringRef>('kCFURLFileProtectionCompleteUnlessOpen');

  CFStringRef get kCFURLFileProtectionCompleteUnlessOpen =>
      _kCFURLFileProtectionCompleteUnlessOpen.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLFileProtectionCompleteUntilFirstUserAuthentication =
      _lookup<CFStringRef>(
          'kCFURLFileProtectionCompleteUntilFirstUserAuthentication');

  CFStringRef get kCFURLFileProtectionCompleteUntilFirstUserAuthentication =>
      _kCFURLFileProtectionCompleteUntilFirstUserAuthentication.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLFileProtectionCompleteWhenUserInactive =
      _lookup<CFStringRef>('kCFURLFileProtectionCompleteWhenUserInactive');

  CFStringRef get kCFURLFileProtectionCompleteWhenUserInactive =>
      _kCFURLFileProtectionCompleteWhenUserInactive.value;

  late final ffi.Pointer<CFStringRef> _kCFURLDirectoryEntryCountKey =
      _lookup<CFStringRef>('kCFURLDirectoryEntryCountKey');

  CFStringRef get kCFURLDirectoryEntryCountKey =>
      _kCFURLDirectoryEntryCountKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLVolumeLocalizedFormatDescriptionKey =
      _lookup<CFStringRef>('kCFURLVolumeLocalizedFormatDescriptionKey');

  CFStringRef get kCFURLVolumeLocalizedFormatDescriptionKey =>
      _kCFURLVolumeLocalizedFormatDescriptionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeTotalCapacityKey =
      _lookup<CFStringRef>('kCFURLVolumeTotalCapacityKey');

  CFStringRef get kCFURLVolumeTotalCapacityKey =>
      _kCFURLVolumeTotalCapacityKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeAvailableCapacityKey =
      _lookup<CFStringRef>('kCFURLVolumeAvailableCapacityKey');

  CFStringRef get kCFURLVolumeAvailableCapacityKey =>
      _kCFURLVolumeAvailableCapacityKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLVolumeAvailableCapacityForImportantUsageKey =
      _lookup<CFStringRef>('kCFURLVolumeAvailableCapacityForImportantUsageKey');

  CFStringRef get kCFURLVolumeAvailableCapacityForImportantUsageKey =>
      _kCFURLVolumeAvailableCapacityForImportantUsageKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLVolumeAvailableCapacityForOpportunisticUsageKey =
      _lookup<CFStringRef>(
          'kCFURLVolumeAvailableCapacityForOpportunisticUsageKey');

  CFStringRef get kCFURLVolumeAvailableCapacityForOpportunisticUsageKey =>
      _kCFURLVolumeAvailableCapacityForOpportunisticUsageKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeResourceCountKey =
      _lookup<CFStringRef>('kCFURLVolumeResourceCountKey');

  CFStringRef get kCFURLVolumeResourceCountKey =>
      _kCFURLVolumeResourceCountKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsPersistentIDsKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsPersistentIDsKey');

  CFStringRef get kCFURLVolumeSupportsPersistentIDsKey =>
      _kCFURLVolumeSupportsPersistentIDsKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsSymbolicLinksKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsSymbolicLinksKey');

  CFStringRef get kCFURLVolumeSupportsSymbolicLinksKey =>
      _kCFURLVolumeSupportsSymbolicLinksKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsHardLinksKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsHardLinksKey');

  CFStringRef get kCFURLVolumeSupportsHardLinksKey =>
      _kCFURLVolumeSupportsHardLinksKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsJournalingKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsJournalingKey');

  CFStringRef get kCFURLVolumeSupportsJournalingKey =>
      _kCFURLVolumeSupportsJournalingKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIsJournalingKey =
      _lookup<CFStringRef>('kCFURLVolumeIsJournalingKey');

  CFStringRef get kCFURLVolumeIsJournalingKey =>
      _kCFURLVolumeIsJournalingKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsSparseFilesKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsSparseFilesKey');

  CFStringRef get kCFURLVolumeSupportsSparseFilesKey =>
      _kCFURLVolumeSupportsSparseFilesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsZeroRunsKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsZeroRunsKey');

  CFStringRef get kCFURLVolumeSupportsZeroRunsKey =>
      _kCFURLVolumeSupportsZeroRunsKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLVolumeSupportsCaseSensitiveNamesKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsCaseSensitiveNamesKey');

  CFStringRef get kCFURLVolumeSupportsCaseSensitiveNamesKey =>
      _kCFURLVolumeSupportsCaseSensitiveNamesKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLVolumeSupportsCasePreservedNamesKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsCasePreservedNamesKey');

  CFStringRef get kCFURLVolumeSupportsCasePreservedNamesKey =>
      _kCFURLVolumeSupportsCasePreservedNamesKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLVolumeSupportsRootDirectoryDatesKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsRootDirectoryDatesKey');

  CFStringRef get kCFURLVolumeSupportsRootDirectoryDatesKey =>
      _kCFURLVolumeSupportsRootDirectoryDatesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsVolumeSizesKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsVolumeSizesKey');

  CFStringRef get kCFURLVolumeSupportsVolumeSizesKey =>
      _kCFURLVolumeSupportsVolumeSizesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsRenamingKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsRenamingKey');

  CFStringRef get kCFURLVolumeSupportsRenamingKey =>
      _kCFURLVolumeSupportsRenamingKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLVolumeSupportsAdvisoryFileLockingKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsAdvisoryFileLockingKey');

  CFStringRef get kCFURLVolumeSupportsAdvisoryFileLockingKey =>
      _kCFURLVolumeSupportsAdvisoryFileLockingKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsExtendedSecurityKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsExtendedSecurityKey');

  CFStringRef get kCFURLVolumeSupportsExtendedSecurityKey =>
      _kCFURLVolumeSupportsExtendedSecurityKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIsBrowsableKey =
      _lookup<CFStringRef>('kCFURLVolumeIsBrowsableKey');

  CFStringRef get kCFURLVolumeIsBrowsableKey =>
      _kCFURLVolumeIsBrowsableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeMaximumFileSizeKey =
      _lookup<CFStringRef>('kCFURLVolumeMaximumFileSizeKey');

  CFStringRef get kCFURLVolumeMaximumFileSizeKey =>
      _kCFURLVolumeMaximumFileSizeKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIsEjectableKey =
      _lookup<CFStringRef>('kCFURLVolumeIsEjectableKey');

  CFStringRef get kCFURLVolumeIsEjectableKey =>
      _kCFURLVolumeIsEjectableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIsRemovableKey =
      _lookup<CFStringRef>('kCFURLVolumeIsRemovableKey');

  CFStringRef get kCFURLVolumeIsRemovableKey =>
      _kCFURLVolumeIsRemovableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIsInternalKey =
      _lookup<CFStringRef>('kCFURLVolumeIsInternalKey');

  CFStringRef get kCFURLVolumeIsInternalKey => _kCFURLVolumeIsInternalKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIsAutomountedKey =
      _lookup<CFStringRef>('kCFURLVolumeIsAutomountedKey');

  CFStringRef get kCFURLVolumeIsAutomountedKey =>
      _kCFURLVolumeIsAutomountedKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIsLocalKey =
      _lookup<CFStringRef>('kCFURLVolumeIsLocalKey');

  CFStringRef get kCFURLVolumeIsLocalKey => _kCFURLVolumeIsLocalKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIsReadOnlyKey =
      _lookup<CFStringRef>('kCFURLVolumeIsReadOnlyKey');

  CFStringRef get kCFURLVolumeIsReadOnlyKey => _kCFURLVolumeIsReadOnlyKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeCreationDateKey =
      _lookup<CFStringRef>('kCFURLVolumeCreationDateKey');

  CFStringRef get kCFURLVolumeCreationDateKey =>
      _kCFURLVolumeCreationDateKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeURLForRemountingKey =
      _lookup<CFStringRef>('kCFURLVolumeURLForRemountingKey');

  CFStringRef get kCFURLVolumeURLForRemountingKey =>
      _kCFURLVolumeURLForRemountingKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeUUIDStringKey =
      _lookup<CFStringRef>('kCFURLVolumeUUIDStringKey');

  CFStringRef get kCFURLVolumeUUIDStringKey => _kCFURLVolumeUUIDStringKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeNameKey =
      _lookup<CFStringRef>('kCFURLVolumeNameKey');

  CFStringRef get kCFURLVolumeNameKey => _kCFURLVolumeNameKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeLocalizedNameKey =
      _lookup<CFStringRef>('kCFURLVolumeLocalizedNameKey');

  CFStringRef get kCFURLVolumeLocalizedNameKey =>
      _kCFURLVolumeLocalizedNameKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIsEncryptedKey =
      _lookup<CFStringRef>('kCFURLVolumeIsEncryptedKey');

  CFStringRef get kCFURLVolumeIsEncryptedKey =>
      _kCFURLVolumeIsEncryptedKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeIsRootFileSystemKey =
      _lookup<CFStringRef>('kCFURLVolumeIsRootFileSystemKey');

  CFStringRef get kCFURLVolumeIsRootFileSystemKey =>
      _kCFURLVolumeIsRootFileSystemKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsCompressionKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsCompressionKey');

  CFStringRef get kCFURLVolumeSupportsCompressionKey =>
      _kCFURLVolumeSupportsCompressionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsFileCloningKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsFileCloningKey');

  CFStringRef get kCFURLVolumeSupportsFileCloningKey =>
      _kCFURLVolumeSupportsFileCloningKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsSwapRenamingKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsSwapRenamingKey');

  CFStringRef get kCFURLVolumeSupportsSwapRenamingKey =>
      _kCFURLVolumeSupportsSwapRenamingKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLVolumeSupportsExclusiveRenamingKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsExclusiveRenamingKey');

  CFStringRef get kCFURLVolumeSupportsExclusiveRenamingKey =>
      _kCFURLVolumeSupportsExclusiveRenamingKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsImmutableFilesKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsImmutableFilesKey');

  CFStringRef get kCFURLVolumeSupportsImmutableFilesKey =>
      _kCFURLVolumeSupportsImmutableFilesKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLVolumeSupportsAccessPermissionsKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsAccessPermissionsKey');

  CFStringRef get kCFURLVolumeSupportsAccessPermissionsKey =>
      _kCFURLVolumeSupportsAccessPermissionsKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSupportsFileProtectionKey =
      _lookup<CFStringRef>('kCFURLVolumeSupportsFileProtectionKey');

  CFStringRef get kCFURLVolumeSupportsFileProtectionKey =>
      _kCFURLVolumeSupportsFileProtectionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeTypeNameKey =
      _lookup<CFStringRef>('kCFURLVolumeTypeNameKey');

  CFStringRef get kCFURLVolumeTypeNameKey => _kCFURLVolumeTypeNameKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeSubtypeKey =
      _lookup<CFStringRef>('kCFURLVolumeSubtypeKey');

  CFStringRef get kCFURLVolumeSubtypeKey => _kCFURLVolumeSubtypeKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLVolumeMountFromLocationKey =
      _lookup<CFStringRef>('kCFURLVolumeMountFromLocationKey');

  CFStringRef get kCFURLVolumeMountFromLocationKey =>
      _kCFURLVolumeMountFromLocationKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLIsUbiquitousItemKey =
      _lookup<CFStringRef>('kCFURLIsUbiquitousItemKey');

  CFStringRef get kCFURLIsUbiquitousItemKey => _kCFURLIsUbiquitousItemKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLUbiquitousItemHasUnresolvedConflictsKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemHasUnresolvedConflictsKey');

  CFStringRef get kCFURLUbiquitousItemHasUnresolvedConflictsKey =>
      _kCFURLUbiquitousItemHasUnresolvedConflictsKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLUbiquitousItemIsDownloadedKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemIsDownloadedKey');

  CFStringRef get kCFURLUbiquitousItemIsDownloadedKey =>
      _kCFURLUbiquitousItemIsDownloadedKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLUbiquitousItemIsDownloadingKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemIsDownloadingKey');

  CFStringRef get kCFURLUbiquitousItemIsDownloadingKey =>
      _kCFURLUbiquitousItemIsDownloadingKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLUbiquitousItemIsUploadedKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemIsUploadedKey');

  CFStringRef get kCFURLUbiquitousItemIsUploadedKey =>
      _kCFURLUbiquitousItemIsUploadedKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLUbiquitousItemIsUploadingKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemIsUploadingKey');

  CFStringRef get kCFURLUbiquitousItemIsUploadingKey =>
      _kCFURLUbiquitousItemIsUploadingKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLUbiquitousItemPercentDownloadedKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemPercentDownloadedKey');

  CFStringRef get kCFURLUbiquitousItemPercentDownloadedKey =>
      _kCFURLUbiquitousItemPercentDownloadedKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLUbiquitousItemPercentUploadedKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemPercentUploadedKey');

  CFStringRef get kCFURLUbiquitousItemPercentUploadedKey =>
      _kCFURLUbiquitousItemPercentUploadedKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLUbiquitousItemDownloadingStatusKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemDownloadingStatusKey');

  CFStringRef get kCFURLUbiquitousItemDownloadingStatusKey =>
      _kCFURLUbiquitousItemDownloadingStatusKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLUbiquitousItemDownloadingErrorKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemDownloadingErrorKey');

  CFStringRef get kCFURLUbiquitousItemDownloadingErrorKey =>
      _kCFURLUbiquitousItemDownloadingErrorKey.value;

  late final ffi.Pointer<CFStringRef> _kCFURLUbiquitousItemUploadingErrorKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemUploadingErrorKey');

  CFStringRef get kCFURLUbiquitousItemUploadingErrorKey =>
      _kCFURLUbiquitousItemUploadingErrorKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLUbiquitousItemIsExcludedFromSyncKey =
      _lookup<CFStringRef>('kCFURLUbiquitousItemIsExcludedFromSyncKey');

  CFStringRef get kCFURLUbiquitousItemIsExcludedFromSyncKey =>
      _kCFURLUbiquitousItemIsExcludedFromSyncKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLUbiquitousItemDownloadingStatusNotDownloaded =
      _lookup<CFStringRef>(
          'kCFURLUbiquitousItemDownloadingStatusNotDownloaded');

  CFStringRef get kCFURLUbiquitousItemDownloadingStatusNotDownloaded =>
      _kCFURLUbiquitousItemDownloadingStatusNotDownloaded.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLUbiquitousItemDownloadingStatusDownloaded =
      _lookup<CFStringRef>('kCFURLUbiquitousItemDownloadingStatusDownloaded');

  CFStringRef get kCFURLUbiquitousItemDownloadingStatusDownloaded =>
      _kCFURLUbiquitousItemDownloadingStatusDownloaded.value;

  late final ffi.Pointer<CFStringRef>
      _kCFURLUbiquitousItemDownloadingStatusCurrent =
      _lookup<CFStringRef>('kCFURLUbiquitousItemDownloadingStatusCurrent');

  CFStringRef get kCFURLUbiquitousItemDownloadingStatusCurrent =>
      _kCFURLUbiquitousItemDownloadingStatusCurrent.value;

  CFDataRef CFURLCreateBookmarkData(
    CFAllocatorRef allocator,
    CFURLRef url,
    CFURLBookmarkCreationOptions options,
    CFArrayRef resourcePropertiesToInclude,
    CFURLRef relativeToURL,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFURLCreateBookmarkData(
      allocator,
      url,
      options.value,
      resourcePropertiesToInclude,
      relativeToURL,
      error,
    );
  }

  late final _CFURLCreateBookmarkDataPtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(
              CFAllocatorRef,
              CFURLRef,
              CFOptionFlags,
              CFArrayRef,
              CFURLRef,
              ffi.Pointer<CFErrorRef>)>>('CFURLCreateBookmarkData');
  late final _CFURLCreateBookmarkData = _CFURLCreateBookmarkDataPtr.asFunction<
      CFDataRef Function(CFAllocatorRef, CFURLRef, int, CFArrayRef, CFURLRef,
          ffi.Pointer<CFErrorRef>)>();

  CFURLRef CFURLCreateByResolvingBookmarkData(
    CFAllocatorRef allocator,
    CFDataRef bookmark,
    CFURLBookmarkResolutionOptions options,
    CFURLRef relativeToURL,
    CFArrayRef resourcePropertiesToInclude,
    ffi.Pointer<Boolean> isStale,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFURLCreateByResolvingBookmarkData(
      allocator,
      bookmark,
      options.value,
      relativeToURL,
      resourcePropertiesToInclude,
      isStale,
      error,
    );
  }

  late final _CFURLCreateByResolvingBookmarkDataPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(
              CFAllocatorRef,
              CFDataRef,
              CFOptionFlags,
              CFURLRef,
              CFArrayRef,
              ffi.Pointer<Boolean>,
              ffi.Pointer<CFErrorRef>)>>('CFURLCreateByResolvingBookmarkData');
  late final _CFURLCreateByResolvingBookmarkData =
      _CFURLCreateByResolvingBookmarkDataPtr.asFunction<
          CFURLRef Function(CFAllocatorRef, CFDataRef, int, CFURLRef,
              CFArrayRef, ffi.Pointer<Boolean>, ffi.Pointer<CFErrorRef>)>();

  CFDictionaryRef CFURLCreateResourcePropertiesForKeysFromBookmarkData(
    CFAllocatorRef allocator,
    CFArrayRef resourcePropertiesToReturn,
    CFDataRef bookmark,
  ) {
    return _CFURLCreateResourcePropertiesForKeysFromBookmarkData(
      allocator,
      resourcePropertiesToReturn,
      bookmark,
    );
  }

  late final _CFURLCreateResourcePropertiesForKeysFromBookmarkDataPtr = _lookup<
          ffi.NativeFunction<
              CFDictionaryRef Function(CFAllocatorRef, CFArrayRef, CFDataRef)>>(
      'CFURLCreateResourcePropertiesForKeysFromBookmarkData');
  late final _CFURLCreateResourcePropertiesForKeysFromBookmarkData =
      _CFURLCreateResourcePropertiesForKeysFromBookmarkDataPtr.asFunction<
          CFDictionaryRef Function(CFAllocatorRef, CFArrayRef, CFDataRef)>();

  CFTypeRef CFURLCreateResourcePropertyForKeyFromBookmarkData(
    CFAllocatorRef allocator,
    CFStringRef resourcePropertyKey,
    CFDataRef bookmark,
  ) {
    return _CFURLCreateResourcePropertyForKeyFromBookmarkData(
      allocator,
      resourcePropertyKey,
      bookmark,
    );
  }

  late final _CFURLCreateResourcePropertyForKeyFromBookmarkDataPtr = _lookup<
      ffi.NativeFunction<
          CFTypeRef Function(CFAllocatorRef, CFStringRef,
              CFDataRef)>>('CFURLCreateResourcePropertyForKeyFromBookmarkData');
  late final _CFURLCreateResourcePropertyForKeyFromBookmarkData =
      _CFURLCreateResourcePropertyForKeyFromBookmarkDataPtr.asFunction<
          CFTypeRef Function(CFAllocatorRef, CFStringRef, CFDataRef)>();

  CFDataRef CFURLCreateBookmarkDataFromFile(
    CFAllocatorRef allocator,
    CFURLRef fileURL,
    ffi.Pointer<CFErrorRef> errorRef,
  ) {
    return _CFURLCreateBookmarkDataFromFile(
      allocator,
      fileURL,
      errorRef,
    );
  }

  late final _CFURLCreateBookmarkDataFromFilePtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(CFAllocatorRef, CFURLRef,
              ffi.Pointer<CFErrorRef>)>>('CFURLCreateBookmarkDataFromFile');
  late final _CFURLCreateBookmarkDataFromFile =
      _CFURLCreateBookmarkDataFromFilePtr.asFunction<
          CFDataRef Function(
              CFAllocatorRef, CFURLRef, ffi.Pointer<CFErrorRef>)>();

  int CFURLWriteBookmarkDataToFile(
    CFDataRef bookmarkRef,
    CFURLRef fileURL,
    int options,
    ffi.Pointer<CFErrorRef> errorRef,
  ) {
    return _CFURLWriteBookmarkDataToFile(
      bookmarkRef,
      fileURL,
      options,
      errorRef,
    );
  }

  late final _CFURLWriteBookmarkDataToFilePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(
              CFDataRef,
              CFURLRef,
              CFURLBookmarkFileCreationOptions,
              ffi.Pointer<CFErrorRef>)>>('CFURLWriteBookmarkDataToFile');
  late final _CFURLWriteBookmarkDataToFile =
      _CFURLWriteBookmarkDataToFilePtr.asFunction<
          int Function(CFDataRef, CFURLRef, int, ffi.Pointer<CFErrorRef>)>();

  CFDataRef CFURLCreateBookmarkDataFromAliasRecord(
    CFAllocatorRef allocatorRef,
    CFDataRef aliasRecordDataRef,
  ) {
    return _CFURLCreateBookmarkDataFromAliasRecord(
      allocatorRef,
      aliasRecordDataRef,
    );
  }

  late final _CFURLCreateBookmarkDataFromAliasRecordPtr = _lookup<
          ffi.NativeFunction<CFDataRef Function(CFAllocatorRef, CFDataRef)>>(
      'CFURLCreateBookmarkDataFromAliasRecord');
  late final _CFURLCreateBookmarkDataFromAliasRecord =
      _CFURLCreateBookmarkDataFromAliasRecordPtr.asFunction<
          CFDataRef Function(CFAllocatorRef, CFDataRef)>();

  int CFURLStartAccessingSecurityScopedResource(
    CFURLRef url,
  ) {
    return _CFURLStartAccessingSecurityScopedResource(
      url,
    );
  }

  late final _CFURLStartAccessingSecurityScopedResourcePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFURLRef)>>(
          'CFURLStartAccessingSecurityScopedResource');
  late final _CFURLStartAccessingSecurityScopedResource =
      _CFURLStartAccessingSecurityScopedResourcePtr.asFunction<
          int Function(CFURLRef)>();

  void CFURLStopAccessingSecurityScopedResource(
    CFURLRef url,
  ) {
    return _CFURLStopAccessingSecurityScopedResource(
      url,
    );
  }

  late final _CFURLStopAccessingSecurityScopedResourcePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFURLRef)>>(
          'CFURLStopAccessingSecurityScopedResource');
  late final _CFURLStopAccessingSecurityScopedResource =
      _CFURLStopAccessingSecurityScopedResourcePtr.asFunction<
          void Function(CFURLRef)>();

  late final ffi.Pointer<CFRunLoopMode> _kCFRunLoopDefaultMode =
      _lookup<CFRunLoopMode>('kCFRunLoopDefaultMode');

  CFRunLoopMode get kCFRunLoopDefaultMode => _kCFRunLoopDefaultMode.value;

  late final ffi.Pointer<CFRunLoopMode> _kCFRunLoopCommonModes =
      _lookup<CFRunLoopMode>('kCFRunLoopCommonModes');

  CFRunLoopMode get kCFRunLoopCommonModes => _kCFRunLoopCommonModes.value;

  int CFRunLoopGetTypeID() {
    return _CFRunLoopGetTypeID();
  }

  late final _CFRunLoopGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFRunLoopGetTypeID');
  late final _CFRunLoopGetTypeID =
      _CFRunLoopGetTypeIDPtr.asFunction<int Function()>();

  CFRunLoopRef CFRunLoopGetCurrent() {
    return _CFRunLoopGetCurrent();
  }

  late final _CFRunLoopGetCurrentPtr =
      _lookup<ffi.NativeFunction<CFRunLoopRef Function()>>(
          'CFRunLoopGetCurrent');
  late final _CFRunLoopGetCurrent =
      _CFRunLoopGetCurrentPtr.asFunction<CFRunLoopRef Function()>();

  CFRunLoopRef CFRunLoopGetMain() {
    return _CFRunLoopGetMain();
  }

  late final _CFRunLoopGetMainPtr =
      _lookup<ffi.NativeFunction<CFRunLoopRef Function()>>('CFRunLoopGetMain');
  late final _CFRunLoopGetMain =
      _CFRunLoopGetMainPtr.asFunction<CFRunLoopRef Function()>();

  CFRunLoopMode CFRunLoopCopyCurrentMode(
    CFRunLoopRef rl,
  ) {
    return _CFRunLoopCopyCurrentMode(
      rl,
    );
  }

  late final _CFRunLoopCopyCurrentModePtr =
      _lookup<ffi.NativeFunction<CFRunLoopMode Function(CFRunLoopRef)>>(
          'CFRunLoopCopyCurrentMode');
  late final _CFRunLoopCopyCurrentMode = _CFRunLoopCopyCurrentModePtr
      .asFunction<CFRunLoopMode Function(CFRunLoopRef)>();

  CFArrayRef CFRunLoopCopyAllModes(
    CFRunLoopRef rl,
  ) {
    return _CFRunLoopCopyAllModes(
      rl,
    );
  }

  late final _CFRunLoopCopyAllModesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(CFRunLoopRef)>>(
          'CFRunLoopCopyAllModes');
  late final _CFRunLoopCopyAllModes =
      _CFRunLoopCopyAllModesPtr.asFunction<CFArrayRef Function(CFRunLoopRef)>();

  void CFRunLoopAddCommonMode(
    CFRunLoopRef rl,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopAddCommonMode(
      rl,
      mode,
    );
  }

  late final _CFRunLoopAddCommonModePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFRunLoopRef, CFRunLoopMode)>>(
      'CFRunLoopAddCommonMode');
  late final _CFRunLoopAddCommonMode = _CFRunLoopAddCommonModePtr.asFunction<
      void Function(CFRunLoopRef, CFRunLoopMode)>();

  double CFRunLoopGetNextTimerFireDate(
    CFRunLoopRef rl,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopGetNextTimerFireDate(
      rl,
      mode,
    );
  }

  late final _CFRunLoopGetNextTimerFireDatePtr = _lookup<
      ffi.NativeFunction<
          CFAbsoluteTime Function(
              CFRunLoopRef, CFRunLoopMode)>>('CFRunLoopGetNextTimerFireDate');
  late final _CFRunLoopGetNextTimerFireDate = _CFRunLoopGetNextTimerFireDatePtr
      .asFunction<double Function(CFRunLoopRef, CFRunLoopMode)>();

  void CFRunLoopRun() {
    return _CFRunLoopRun();
  }

  late final _CFRunLoopRunPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('CFRunLoopRun');
  late final _CFRunLoopRun = _CFRunLoopRunPtr.asFunction<void Function()>();

  CFRunLoopRunResult CFRunLoopRunInMode(
    CFRunLoopMode mode,
    DartCFTimeInterval seconds,
    DartBoolean returnAfterSourceHandled,
  ) {
    return CFRunLoopRunResult.fromValue(_CFRunLoopRunInMode(
      mode,
      seconds,
      returnAfterSourceHandled,
    ));
  }

  late final _CFRunLoopRunInModePtr = _lookup<
      ffi.NativeFunction<
          SInt32 Function(
              CFRunLoopMode, CFTimeInterval, Boolean)>>('CFRunLoopRunInMode');
  late final _CFRunLoopRunInMode = _CFRunLoopRunInModePtr.asFunction<
      int Function(CFRunLoopMode, double, int)>();

  int CFRunLoopIsWaiting(
    CFRunLoopRef rl,
  ) {
    return _CFRunLoopIsWaiting(
      rl,
    );
  }

  late final _CFRunLoopIsWaitingPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFRunLoopRef)>>(
          'CFRunLoopIsWaiting');
  late final _CFRunLoopIsWaiting =
      _CFRunLoopIsWaitingPtr.asFunction<int Function(CFRunLoopRef)>();

  void CFRunLoopWakeUp(
    CFRunLoopRef rl,
  ) {
    return _CFRunLoopWakeUp(
      rl,
    );
  }

  late final _CFRunLoopWakeUpPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFRunLoopRef)>>(
          'CFRunLoopWakeUp');
  late final _CFRunLoopWakeUp =
      _CFRunLoopWakeUpPtr.asFunction<void Function(CFRunLoopRef)>();

  void CFRunLoopStop(
    CFRunLoopRef rl,
  ) {
    return _CFRunLoopStop(
      rl,
    );
  }

  late final _CFRunLoopStopPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFRunLoopRef)>>(
          'CFRunLoopStop');
  late final _CFRunLoopStop =
      _CFRunLoopStopPtr.asFunction<void Function(CFRunLoopRef)>();

  void CFRunLoopPerformBlock(
    CFRunLoopRef rl,
    CFTypeRef mode,
    objc.ObjCBlock<ffi.Void Function()> block,
  ) {
    return _CFRunLoopPerformBlock(
      rl,
      mode,
      block.ref.pointer,
    );
  }

  late final _CFRunLoopPerformBlockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFRunLoopRef, CFTypeRef,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('CFRunLoopPerformBlock');
  late final _CFRunLoopPerformBlock = _CFRunLoopPerformBlockPtr.asFunction<
      void Function(
          CFRunLoopRef, CFTypeRef, ffi.Pointer<objc.ObjCBlockImpl>)>();

  int CFRunLoopContainsSource(
    CFRunLoopRef rl,
    CFRunLoopSourceRef source,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopContainsSource(
      rl,
      source,
      mode,
    );
  }

  late final _CFRunLoopContainsSourcePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFRunLoopRef, CFRunLoopSourceRef,
              CFRunLoopMode)>>('CFRunLoopContainsSource');
  late final _CFRunLoopContainsSource = _CFRunLoopContainsSourcePtr.asFunction<
      int Function(CFRunLoopRef, CFRunLoopSourceRef, CFRunLoopMode)>();

  void CFRunLoopAddSource(
    CFRunLoopRef rl,
    CFRunLoopSourceRef source,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopAddSource(
      rl,
      source,
      mode,
    );
  }

  late final _CFRunLoopAddSourcePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFRunLoopRef, CFRunLoopSourceRef,
              CFRunLoopMode)>>('CFRunLoopAddSource');
  late final _CFRunLoopAddSource = _CFRunLoopAddSourcePtr.asFunction<
      void Function(CFRunLoopRef, CFRunLoopSourceRef, CFRunLoopMode)>();

  void CFRunLoopRemoveSource(
    CFRunLoopRef rl,
    CFRunLoopSourceRef source,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopRemoveSource(
      rl,
      source,
      mode,
    );
  }

  late final _CFRunLoopRemoveSourcePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFRunLoopRef, CFRunLoopSourceRef,
              CFRunLoopMode)>>('CFRunLoopRemoveSource');
  late final _CFRunLoopRemoveSource = _CFRunLoopRemoveSourcePtr.asFunction<
      void Function(CFRunLoopRef, CFRunLoopSourceRef, CFRunLoopMode)>();

  int CFRunLoopContainsObserver(
    CFRunLoopRef rl,
    CFRunLoopObserverRef observer,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopContainsObserver(
      rl,
      observer,
      mode,
    );
  }

  late final _CFRunLoopContainsObserverPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFRunLoopRef, CFRunLoopObserverRef,
              CFRunLoopMode)>>('CFRunLoopContainsObserver');
  late final _CFRunLoopContainsObserver =
      _CFRunLoopContainsObserverPtr.asFunction<
          int Function(CFRunLoopRef, CFRunLoopObserverRef, CFRunLoopMode)>();

  void CFRunLoopAddObserver(
    CFRunLoopRef rl,
    CFRunLoopObserverRef observer,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopAddObserver(
      rl,
      observer,
      mode,
    );
  }

  late final _CFRunLoopAddObserverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFRunLoopRef, CFRunLoopObserverRef,
              CFRunLoopMode)>>('CFRunLoopAddObserver');
  late final _CFRunLoopAddObserver = _CFRunLoopAddObserverPtr.asFunction<
      void Function(CFRunLoopRef, CFRunLoopObserverRef, CFRunLoopMode)>();

  void CFRunLoopRemoveObserver(
    CFRunLoopRef rl,
    CFRunLoopObserverRef observer,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopRemoveObserver(
      rl,
      observer,
      mode,
    );
  }

  late final _CFRunLoopRemoveObserverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFRunLoopRef, CFRunLoopObserverRef,
              CFRunLoopMode)>>('CFRunLoopRemoveObserver');
  late final _CFRunLoopRemoveObserver = _CFRunLoopRemoveObserverPtr.asFunction<
      void Function(CFRunLoopRef, CFRunLoopObserverRef, CFRunLoopMode)>();

  int CFRunLoopContainsTimer(
    CFRunLoopRef rl,
    CFRunLoopTimerRef timer,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopContainsTimer(
      rl,
      timer,
      mode,
    );
  }

  late final _CFRunLoopContainsTimerPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFRunLoopRef, CFRunLoopTimerRef,
              CFRunLoopMode)>>('CFRunLoopContainsTimer');
  late final _CFRunLoopContainsTimer = _CFRunLoopContainsTimerPtr.asFunction<
      int Function(CFRunLoopRef, CFRunLoopTimerRef, CFRunLoopMode)>();

  void CFRunLoopAddTimer(
    CFRunLoopRef rl,
    CFRunLoopTimerRef timer,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopAddTimer(
      rl,
      timer,
      mode,
    );
  }

  late final _CFRunLoopAddTimerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFRunLoopRef, CFRunLoopTimerRef,
              CFRunLoopMode)>>('CFRunLoopAddTimer');
  late final _CFRunLoopAddTimer = _CFRunLoopAddTimerPtr.asFunction<
      void Function(CFRunLoopRef, CFRunLoopTimerRef, CFRunLoopMode)>();

  void CFRunLoopRemoveTimer(
    CFRunLoopRef rl,
    CFRunLoopTimerRef timer,
    CFRunLoopMode mode,
  ) {
    return _CFRunLoopRemoveTimer(
      rl,
      timer,
      mode,
    );
  }

  late final _CFRunLoopRemoveTimerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFRunLoopRef, CFRunLoopTimerRef,
              CFRunLoopMode)>>('CFRunLoopRemoveTimer');
  late final _CFRunLoopRemoveTimer = _CFRunLoopRemoveTimerPtr.asFunction<
      void Function(CFRunLoopRef, CFRunLoopTimerRef, CFRunLoopMode)>();

  int CFRunLoopSourceGetTypeID() {
    return _CFRunLoopSourceGetTypeID();
  }

  late final _CFRunLoopSourceGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFRunLoopSourceGetTypeID');
  late final _CFRunLoopSourceGetTypeID =
      _CFRunLoopSourceGetTypeIDPtr.asFunction<int Function()>();

  CFRunLoopSourceRef CFRunLoopSourceCreate(
    CFAllocatorRef allocator,
    int order,
    ffi.Pointer<CFRunLoopSourceContext> context,
  ) {
    return _CFRunLoopSourceCreate(
      allocator,
      order,
      context,
    );
  }

  late final _CFRunLoopSourceCreatePtr = _lookup<
      ffi.NativeFunction<
          CFRunLoopSourceRef Function(CFAllocatorRef, CFIndex,
              ffi.Pointer<CFRunLoopSourceContext>)>>('CFRunLoopSourceCreate');
  late final _CFRunLoopSourceCreate = _CFRunLoopSourceCreatePtr.asFunction<
      CFRunLoopSourceRef Function(
          CFAllocatorRef, int, ffi.Pointer<CFRunLoopSourceContext>)>();

  int CFRunLoopSourceGetOrder(
    CFRunLoopSourceRef source,
  ) {
    return _CFRunLoopSourceGetOrder(
      source,
    );
  }

  late final _CFRunLoopSourceGetOrderPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFRunLoopSourceRef)>>(
          'CFRunLoopSourceGetOrder');
  late final _CFRunLoopSourceGetOrder = _CFRunLoopSourceGetOrderPtr.asFunction<
      int Function(CFRunLoopSourceRef)>();

  void CFRunLoopSourceInvalidate(
    CFRunLoopSourceRef source,
  ) {
    return _CFRunLoopSourceInvalidate(
      source,
    );
  }

  late final _CFRunLoopSourceInvalidatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFRunLoopSourceRef)>>(
          'CFRunLoopSourceInvalidate');
  late final _CFRunLoopSourceInvalidate = _CFRunLoopSourceInvalidatePtr
      .asFunction<void Function(CFRunLoopSourceRef)>();

  int CFRunLoopSourceIsValid(
    CFRunLoopSourceRef source,
  ) {
    return _CFRunLoopSourceIsValid(
      source,
    );
  }

  late final _CFRunLoopSourceIsValidPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFRunLoopSourceRef)>>(
          'CFRunLoopSourceIsValid');
  late final _CFRunLoopSourceIsValid =
      _CFRunLoopSourceIsValidPtr.asFunction<int Function(CFRunLoopSourceRef)>();

  void CFRunLoopSourceGetContext(
    CFRunLoopSourceRef source,
    ffi.Pointer<CFRunLoopSourceContext> context,
  ) {
    return _CFRunLoopSourceGetContext(
      source,
      context,
    );
  }

  late final _CFRunLoopSourceGetContextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  CFRunLoopSourceRef, ffi.Pointer<CFRunLoopSourceContext>)>>(
      'CFRunLoopSourceGetContext');
  late final _CFRunLoopSourceGetContext =
      _CFRunLoopSourceGetContextPtr.asFunction<
          void Function(
              CFRunLoopSourceRef, ffi.Pointer<CFRunLoopSourceContext>)>();

  void CFRunLoopSourceSignal(
    CFRunLoopSourceRef source,
  ) {
    return _CFRunLoopSourceSignal(
      source,
    );
  }

  late final _CFRunLoopSourceSignalPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFRunLoopSourceRef)>>(
          'CFRunLoopSourceSignal');
  late final _CFRunLoopSourceSignal =
      _CFRunLoopSourceSignalPtr.asFunction<void Function(CFRunLoopSourceRef)>();

  int CFRunLoopObserverGetTypeID() {
    return _CFRunLoopObserverGetTypeID();
  }

  late final _CFRunLoopObserverGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFRunLoopObserverGetTypeID');
  late final _CFRunLoopObserverGetTypeID =
      _CFRunLoopObserverGetTypeIDPtr.asFunction<int Function()>();

  CFRunLoopObserverRef CFRunLoopObserverCreate(
    CFAllocatorRef allocator,
    int activities,
    int repeats,
    int order,
    CFRunLoopObserverCallBack callout,
    ffi.Pointer<CFRunLoopObserverContext> context,
  ) {
    return _CFRunLoopObserverCreate(
      allocator,
      activities,
      repeats,
      order,
      callout,
      context,
    );
  }

  late final _CFRunLoopObserverCreatePtr = _lookup<
          ffi.NativeFunction<
              CFRunLoopObserverRef Function(
                  CFAllocatorRef,
                  CFOptionFlags,
                  Boolean,
                  CFIndex,
                  CFRunLoopObserverCallBack,
                  ffi.Pointer<CFRunLoopObserverContext>)>>(
      'CFRunLoopObserverCreate');
  late final _CFRunLoopObserverCreate = _CFRunLoopObserverCreatePtr.asFunction<
      CFRunLoopObserverRef Function(CFAllocatorRef, int, int, int,
          CFRunLoopObserverCallBack, ffi.Pointer<CFRunLoopObserverContext>)>();

  CFRunLoopObserverRef CFRunLoopObserverCreateWithHandler(
    CFAllocatorRef allocator,
    DartCFOptionFlags activities,
    DartBoolean repeats,
    DartCFIndex order,
    objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)>
        block,
  ) {
    return _CFRunLoopObserverCreateWithHandler(
      allocator,
      activities,
      repeats,
      order,
      block.ref.pointer,
    );
  }

  late final _CFRunLoopObserverCreateWithHandlerPtr = _lookup<
          ffi.NativeFunction<
              CFRunLoopObserverRef Function(CFAllocatorRef, CFOptionFlags,
                  Boolean, CFIndex, ffi.Pointer<objc.ObjCBlockImpl>)>>(
      'CFRunLoopObserverCreateWithHandler');
  late final _CFRunLoopObserverCreateWithHandler =
      _CFRunLoopObserverCreateWithHandlerPtr.asFunction<
          CFRunLoopObserverRef Function(CFAllocatorRef, int, int, int,
              ffi.Pointer<objc.ObjCBlockImpl>)>();

  int CFRunLoopObserverGetActivities(
    CFRunLoopObserverRef observer,
  ) {
    return _CFRunLoopObserverGetActivities(
      observer,
    );
  }

  late final _CFRunLoopObserverGetActivitiesPtr =
      _lookup<ffi.NativeFunction<CFOptionFlags Function(CFRunLoopObserverRef)>>(
          'CFRunLoopObserverGetActivities');
  late final _CFRunLoopObserverGetActivities =
      _CFRunLoopObserverGetActivitiesPtr.asFunction<
          int Function(CFRunLoopObserverRef)>();

  int CFRunLoopObserverDoesRepeat(
    CFRunLoopObserverRef observer,
  ) {
    return _CFRunLoopObserverDoesRepeat(
      observer,
    );
  }

  late final _CFRunLoopObserverDoesRepeatPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFRunLoopObserverRef)>>(
          'CFRunLoopObserverDoesRepeat');
  late final _CFRunLoopObserverDoesRepeat = _CFRunLoopObserverDoesRepeatPtr
      .asFunction<int Function(CFRunLoopObserverRef)>();

  int CFRunLoopObserverGetOrder(
    CFRunLoopObserverRef observer,
  ) {
    return _CFRunLoopObserverGetOrder(
      observer,
    );
  }

  late final _CFRunLoopObserverGetOrderPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFRunLoopObserverRef)>>(
          'CFRunLoopObserverGetOrder');
  late final _CFRunLoopObserverGetOrder = _CFRunLoopObserverGetOrderPtr
      .asFunction<int Function(CFRunLoopObserverRef)>();

  void CFRunLoopObserverInvalidate(
    CFRunLoopObserverRef observer,
  ) {
    return _CFRunLoopObserverInvalidate(
      observer,
    );
  }

  late final _CFRunLoopObserverInvalidatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFRunLoopObserverRef)>>(
          'CFRunLoopObserverInvalidate');
  late final _CFRunLoopObserverInvalidate = _CFRunLoopObserverInvalidatePtr
      .asFunction<void Function(CFRunLoopObserverRef)>();

  int CFRunLoopObserverIsValid(
    CFRunLoopObserverRef observer,
  ) {
    return _CFRunLoopObserverIsValid(
      observer,
    );
  }

  late final _CFRunLoopObserverIsValidPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFRunLoopObserverRef)>>(
          'CFRunLoopObserverIsValid');
  late final _CFRunLoopObserverIsValid = _CFRunLoopObserverIsValidPtr
      .asFunction<int Function(CFRunLoopObserverRef)>();

  void CFRunLoopObserverGetContext(
    CFRunLoopObserverRef observer,
    ffi.Pointer<CFRunLoopObserverContext> context,
  ) {
    return _CFRunLoopObserverGetContext(
      observer,
      context,
    );
  }

  late final _CFRunLoopObserverGetContextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(CFRunLoopObserverRef,
                  ffi.Pointer<CFRunLoopObserverContext>)>>(
      'CFRunLoopObserverGetContext');
  late final _CFRunLoopObserverGetContext =
      _CFRunLoopObserverGetContextPtr.asFunction<
          void Function(
              CFRunLoopObserverRef, ffi.Pointer<CFRunLoopObserverContext>)>();

  int CFRunLoopTimerGetTypeID() {
    return _CFRunLoopTimerGetTypeID();
  }

  late final _CFRunLoopTimerGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFRunLoopTimerGetTypeID');
  late final _CFRunLoopTimerGetTypeID =
      _CFRunLoopTimerGetTypeIDPtr.asFunction<int Function()>();

  CFRunLoopTimerRef CFRunLoopTimerCreate(
    CFAllocatorRef allocator,
    double fireDate,
    double interval,
    int flags,
    int order,
    CFRunLoopTimerCallBack callout,
    ffi.Pointer<CFRunLoopTimerContext> context,
  ) {
    return _CFRunLoopTimerCreate(
      allocator,
      fireDate,
      interval,
      flags,
      order,
      callout,
      context,
    );
  }

  late final _CFRunLoopTimerCreatePtr = _lookup<
      ffi.NativeFunction<
          CFRunLoopTimerRef Function(
              CFAllocatorRef,
              CFAbsoluteTime,
              CFTimeInterval,
              CFOptionFlags,
              CFIndex,
              CFRunLoopTimerCallBack,
              ffi.Pointer<CFRunLoopTimerContext>)>>('CFRunLoopTimerCreate');
  late final _CFRunLoopTimerCreate = _CFRunLoopTimerCreatePtr.asFunction<
      CFRunLoopTimerRef Function(CFAllocatorRef, double, double, int, int,
          CFRunLoopTimerCallBack, ffi.Pointer<CFRunLoopTimerContext>)>();

  CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler(
    CFAllocatorRef allocator,
    DartCFTimeInterval fireDate,
    DartCFTimeInterval interval,
    DartCFOptionFlags flags,
    DartCFIndex order,
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)> block,
  ) {
    return _CFRunLoopTimerCreateWithHandler(
      allocator,
      fireDate,
      interval,
      flags,
      order,
      block.ref.pointer,
    );
  }

  late final _CFRunLoopTimerCreateWithHandlerPtr = _lookup<
          ffi.NativeFunction<
              CFRunLoopTimerRef Function(
                  CFAllocatorRef,
                  CFAbsoluteTime,
                  CFTimeInterval,
                  CFOptionFlags,
                  CFIndex,
                  ffi.Pointer<objc.ObjCBlockImpl>)>>(
      'CFRunLoopTimerCreateWithHandler');
  late final _CFRunLoopTimerCreateWithHandler =
      _CFRunLoopTimerCreateWithHandlerPtr.asFunction<
          CFRunLoopTimerRef Function(CFAllocatorRef, double, double, int, int,
              ffi.Pointer<objc.ObjCBlockImpl>)>();

  double CFRunLoopTimerGetNextFireDate(
    CFRunLoopTimerRef timer,
  ) {
    return _CFRunLoopTimerGetNextFireDate(
      timer,
    );
  }

  late final _CFRunLoopTimerGetNextFireDatePtr =
      _lookup<ffi.NativeFunction<CFAbsoluteTime Function(CFRunLoopTimerRef)>>(
          'CFRunLoopTimerGetNextFireDate');
  late final _CFRunLoopTimerGetNextFireDate = _CFRunLoopTimerGetNextFireDatePtr
      .asFunction<double Function(CFRunLoopTimerRef)>();

  void CFRunLoopTimerSetNextFireDate(
    CFRunLoopTimerRef timer,
    double fireDate,
  ) {
    return _CFRunLoopTimerSetNextFireDate(
      timer,
      fireDate,
    );
  }

  late final _CFRunLoopTimerSetNextFireDatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFRunLoopTimerRef,
              CFAbsoluteTime)>>('CFRunLoopTimerSetNextFireDate');
  late final _CFRunLoopTimerSetNextFireDate = _CFRunLoopTimerSetNextFireDatePtr
      .asFunction<void Function(CFRunLoopTimerRef, double)>();

  double CFRunLoopTimerGetInterval(
    CFRunLoopTimerRef timer,
  ) {
    return _CFRunLoopTimerGetInterval(
      timer,
    );
  }

  late final _CFRunLoopTimerGetIntervalPtr =
      _lookup<ffi.NativeFunction<CFTimeInterval Function(CFRunLoopTimerRef)>>(
          'CFRunLoopTimerGetInterval');
  late final _CFRunLoopTimerGetInterval = _CFRunLoopTimerGetIntervalPtr
      .asFunction<double Function(CFRunLoopTimerRef)>();

  int CFRunLoopTimerDoesRepeat(
    CFRunLoopTimerRef timer,
  ) {
    return _CFRunLoopTimerDoesRepeat(
      timer,
    );
  }

  late final _CFRunLoopTimerDoesRepeatPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFRunLoopTimerRef)>>(
          'CFRunLoopTimerDoesRepeat');
  late final _CFRunLoopTimerDoesRepeat = _CFRunLoopTimerDoesRepeatPtr
      .asFunction<int Function(CFRunLoopTimerRef)>();

  int CFRunLoopTimerGetOrder(
    CFRunLoopTimerRef timer,
  ) {
    return _CFRunLoopTimerGetOrder(
      timer,
    );
  }

  late final _CFRunLoopTimerGetOrderPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFRunLoopTimerRef)>>(
          'CFRunLoopTimerGetOrder');
  late final _CFRunLoopTimerGetOrder =
      _CFRunLoopTimerGetOrderPtr.asFunction<int Function(CFRunLoopTimerRef)>();

  void CFRunLoopTimerInvalidate(
    CFRunLoopTimerRef timer,
  ) {
    return _CFRunLoopTimerInvalidate(
      timer,
    );
  }

  late final _CFRunLoopTimerInvalidatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFRunLoopTimerRef)>>(
          'CFRunLoopTimerInvalidate');
  late final _CFRunLoopTimerInvalidate = _CFRunLoopTimerInvalidatePtr
      .asFunction<void Function(CFRunLoopTimerRef)>();

  int CFRunLoopTimerIsValid(
    CFRunLoopTimerRef timer,
  ) {
    return _CFRunLoopTimerIsValid(
      timer,
    );
  }

  late final _CFRunLoopTimerIsValidPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFRunLoopTimerRef)>>(
          'CFRunLoopTimerIsValid');
  late final _CFRunLoopTimerIsValid =
      _CFRunLoopTimerIsValidPtr.asFunction<int Function(CFRunLoopTimerRef)>();

  void CFRunLoopTimerGetContext(
    CFRunLoopTimerRef timer,
    ffi.Pointer<CFRunLoopTimerContext> context,
  ) {
    return _CFRunLoopTimerGetContext(
      timer,
      context,
    );
  }

  late final _CFRunLoopTimerGetContextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFRunLoopTimerRef,
              ffi.Pointer<CFRunLoopTimerContext>)>>('CFRunLoopTimerGetContext');
  late final _CFRunLoopTimerGetContext =
      _CFRunLoopTimerGetContextPtr.asFunction<
          void Function(
              CFRunLoopTimerRef, ffi.Pointer<CFRunLoopTimerContext>)>();

  double CFRunLoopTimerGetTolerance(
    CFRunLoopTimerRef timer,
  ) {
    return _CFRunLoopTimerGetTolerance(
      timer,
    );
  }

  late final _CFRunLoopTimerGetTolerancePtr =
      _lookup<ffi.NativeFunction<CFTimeInterval Function(CFRunLoopTimerRef)>>(
          'CFRunLoopTimerGetTolerance');
  late final _CFRunLoopTimerGetTolerance = _CFRunLoopTimerGetTolerancePtr
      .asFunction<double Function(CFRunLoopTimerRef)>();

  void CFRunLoopTimerSetTolerance(
    CFRunLoopTimerRef timer,
    double tolerance,
  ) {
    return _CFRunLoopTimerSetTolerance(
      timer,
      tolerance,
    );
  }

  late final _CFRunLoopTimerSetTolerancePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFRunLoopTimerRef,
              CFTimeInterval)>>('CFRunLoopTimerSetTolerance');
  late final _CFRunLoopTimerSetTolerance = _CFRunLoopTimerSetTolerancePtr
      .asFunction<void Function(CFRunLoopTimerRef, double)>();

  int CFSocketGetTypeID() {
    return _CFSocketGetTypeID();
  }

  late final _CFSocketGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFSocketGetTypeID');
  late final _CFSocketGetTypeID =
      _CFSocketGetTypeIDPtr.asFunction<int Function()>();

  CFSocketRef CFSocketCreate(
    CFAllocatorRef allocator,
    int protocolFamily,
    int socketType,
    int protocol,
    int callBackTypes,
    CFSocketCallBack callout,
    ffi.Pointer<CFSocketContext> context,
  ) {
    return _CFSocketCreate(
      allocator,
      protocolFamily,
      socketType,
      protocol,
      callBackTypes,
      callout,
      context,
    );
  }

  late final _CFSocketCreatePtr = _lookup<
      ffi.NativeFunction<
          CFSocketRef Function(
              CFAllocatorRef,
              SInt32,
              SInt32,
              SInt32,
              CFOptionFlags,
              CFSocketCallBack,
              ffi.Pointer<CFSocketContext>)>>('CFSocketCreate');
  late final _CFSocketCreate = _CFSocketCreatePtr.asFunction<
      CFSocketRef Function(CFAllocatorRef, int, int, int, int, CFSocketCallBack,
          ffi.Pointer<CFSocketContext>)>();

  CFSocketRef CFSocketCreateWithNative(
    CFAllocatorRef allocator,
    int sock,
    int callBackTypes,
    CFSocketCallBack callout,
    ffi.Pointer<CFSocketContext> context,
  ) {
    return _CFSocketCreateWithNative(
      allocator,
      sock,
      callBackTypes,
      callout,
      context,
    );
  }

  late final _CFSocketCreateWithNativePtr = _lookup<
      ffi.NativeFunction<
          CFSocketRef Function(
              CFAllocatorRef,
              CFSocketNativeHandle,
              CFOptionFlags,
              CFSocketCallBack,
              ffi.Pointer<CFSocketContext>)>>('CFSocketCreateWithNative');
  late final _CFSocketCreateWithNative =
      _CFSocketCreateWithNativePtr.asFunction<
          CFSocketRef Function(CFAllocatorRef, int, int, CFSocketCallBack,
              ffi.Pointer<CFSocketContext>)>();

  CFSocketRef CFSocketCreateWithSocketSignature(
    CFAllocatorRef allocator,
    ffi.Pointer<CFSocketSignature> signature,
    int callBackTypes,
    CFSocketCallBack callout,
    ffi.Pointer<CFSocketContext> context,
  ) {
    return _CFSocketCreateWithSocketSignature(
      allocator,
      signature,
      callBackTypes,
      callout,
      context,
    );
  }

  late final _CFSocketCreateWithSocketSignaturePtr = _lookup<
          ffi.NativeFunction<
              CFSocketRef Function(
                  CFAllocatorRef,
                  ffi.Pointer<CFSocketSignature>,
                  CFOptionFlags,
                  CFSocketCallBack,
                  ffi.Pointer<CFSocketContext>)>>(
      'CFSocketCreateWithSocketSignature');
  late final _CFSocketCreateWithSocketSignature =
      _CFSocketCreateWithSocketSignaturePtr.asFunction<
          CFSocketRef Function(CFAllocatorRef, ffi.Pointer<CFSocketSignature>,
              int, CFSocketCallBack, ffi.Pointer<CFSocketContext>)>();

  CFSocketRef CFSocketCreateConnectedToSocketSignature(
    CFAllocatorRef allocator,
    ffi.Pointer<CFSocketSignature> signature,
    int callBackTypes,
    CFSocketCallBack callout,
    ffi.Pointer<CFSocketContext> context,
    double timeout,
  ) {
    return _CFSocketCreateConnectedToSocketSignature(
      allocator,
      signature,
      callBackTypes,
      callout,
      context,
      timeout,
    );
  }

  late final _CFSocketCreateConnectedToSocketSignaturePtr = _lookup<
      ffi.NativeFunction<
          CFSocketRef Function(
              CFAllocatorRef,
              ffi.Pointer<CFSocketSignature>,
              CFOptionFlags,
              CFSocketCallBack,
              ffi.Pointer<CFSocketContext>,
              CFTimeInterval)>>('CFSocketCreateConnectedToSocketSignature');
  late final _CFSocketCreateConnectedToSocketSignature =
      _CFSocketCreateConnectedToSocketSignaturePtr.asFunction<
          CFSocketRef Function(CFAllocatorRef, ffi.Pointer<CFSocketSignature>,
              int, CFSocketCallBack, ffi.Pointer<CFSocketContext>, double)>();

  CFSocketError CFSocketSetAddress(
    CFSocketRef s,
    CFDataRef address,
  ) {
    return CFSocketError.fromValue(_CFSocketSetAddress(
      s,
      address,
    ));
  }

  late final _CFSocketSetAddressPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFSocketRef, CFDataRef)>>(
          'CFSocketSetAddress');
  late final _CFSocketSetAddress =
      _CFSocketSetAddressPtr.asFunction<int Function(CFSocketRef, CFDataRef)>();

  CFSocketError CFSocketConnectToAddress(
    CFSocketRef s,
    CFDataRef address,
    DartCFTimeInterval timeout,
  ) {
    return CFSocketError.fromValue(_CFSocketConnectToAddress(
      s,
      address,
      timeout,
    ));
  }

  late final _CFSocketConnectToAddressPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFSocketRef, CFDataRef,
              CFTimeInterval)>>('CFSocketConnectToAddress');
  late final _CFSocketConnectToAddress = _CFSocketConnectToAddressPtr
      .asFunction<int Function(CFSocketRef, CFDataRef, double)>();

  void CFSocketInvalidate(
    CFSocketRef s,
  ) {
    return _CFSocketInvalidate(
      s,
    );
  }

  late final _CFSocketInvalidatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFSocketRef)>>(
          'CFSocketInvalidate');
  late final _CFSocketInvalidate =
      _CFSocketInvalidatePtr.asFunction<void Function(CFSocketRef)>();

  int CFSocketIsValid(
    CFSocketRef s,
  ) {
    return _CFSocketIsValid(
      s,
    );
  }

  late final _CFSocketIsValidPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFSocketRef)>>(
          'CFSocketIsValid');
  late final _CFSocketIsValid =
      _CFSocketIsValidPtr.asFunction<int Function(CFSocketRef)>();

  CFDataRef CFSocketCopyAddress(
    CFSocketRef s,
  ) {
    return _CFSocketCopyAddress(
      s,
    );
  }

  late final _CFSocketCopyAddressPtr =
      _lookup<ffi.NativeFunction<CFDataRef Function(CFSocketRef)>>(
          'CFSocketCopyAddress');
  late final _CFSocketCopyAddress =
      _CFSocketCopyAddressPtr.asFunction<CFDataRef Function(CFSocketRef)>();

  CFDataRef CFSocketCopyPeerAddress(
    CFSocketRef s,
  ) {
    return _CFSocketCopyPeerAddress(
      s,
    );
  }

  late final _CFSocketCopyPeerAddressPtr =
      _lookup<ffi.NativeFunction<CFDataRef Function(CFSocketRef)>>(
          'CFSocketCopyPeerAddress');
  late final _CFSocketCopyPeerAddress =
      _CFSocketCopyPeerAddressPtr.asFunction<CFDataRef Function(CFSocketRef)>();

  void CFSocketGetContext(
    CFSocketRef s,
    ffi.Pointer<CFSocketContext> context,
  ) {
    return _CFSocketGetContext(
      s,
      context,
    );
  }

  late final _CFSocketGetContextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFSocketRef,
              ffi.Pointer<CFSocketContext>)>>('CFSocketGetContext');
  late final _CFSocketGetContext = _CFSocketGetContextPtr.asFunction<
      void Function(CFSocketRef, ffi.Pointer<CFSocketContext>)>();

  int CFSocketGetNative(
    CFSocketRef s,
  ) {
    return _CFSocketGetNative(
      s,
    );
  }

  late final _CFSocketGetNativePtr =
      _lookup<ffi.NativeFunction<CFSocketNativeHandle Function(CFSocketRef)>>(
          'CFSocketGetNative');
  late final _CFSocketGetNative =
      _CFSocketGetNativePtr.asFunction<int Function(CFSocketRef)>();

  CFRunLoopSourceRef CFSocketCreateRunLoopSource(
    CFAllocatorRef allocator,
    CFSocketRef s,
    int order,
  ) {
    return _CFSocketCreateRunLoopSource(
      allocator,
      s,
      order,
    );
  }

  late final _CFSocketCreateRunLoopSourcePtr = _lookup<
      ffi.NativeFunction<
          CFRunLoopSourceRef Function(CFAllocatorRef, CFSocketRef,
              CFIndex)>>('CFSocketCreateRunLoopSource');
  late final _CFSocketCreateRunLoopSource =
      _CFSocketCreateRunLoopSourcePtr.asFunction<
          CFRunLoopSourceRef Function(CFAllocatorRef, CFSocketRef, int)>();

  int CFSocketGetSocketFlags(
    CFSocketRef s,
  ) {
    return _CFSocketGetSocketFlags(
      s,
    );
  }

  late final _CFSocketGetSocketFlagsPtr =
      _lookup<ffi.NativeFunction<CFOptionFlags Function(CFSocketRef)>>(
          'CFSocketGetSocketFlags');
  late final _CFSocketGetSocketFlags =
      _CFSocketGetSocketFlagsPtr.asFunction<int Function(CFSocketRef)>();

  void CFSocketSetSocketFlags(
    CFSocketRef s,
    int flags,
  ) {
    return _CFSocketSetSocketFlags(
      s,
      flags,
    );
  }

  late final _CFSocketSetSocketFlagsPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFSocketRef, CFOptionFlags)>>(
      'CFSocketSetSocketFlags');
  late final _CFSocketSetSocketFlags =
      _CFSocketSetSocketFlagsPtr.asFunction<void Function(CFSocketRef, int)>();

  void CFSocketDisableCallBacks(
    CFSocketRef s,
    int callBackTypes,
  ) {
    return _CFSocketDisableCallBacks(
      s,
      callBackTypes,
    );
  }

  late final _CFSocketDisableCallBacksPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFSocketRef, CFOptionFlags)>>(
      'CFSocketDisableCallBacks');
  late final _CFSocketDisableCallBacks = _CFSocketDisableCallBacksPtr
      .asFunction<void Function(CFSocketRef, int)>();

  void CFSocketEnableCallBacks(
    CFSocketRef s,
    int callBackTypes,
  ) {
    return _CFSocketEnableCallBacks(
      s,
      callBackTypes,
    );
  }

  late final _CFSocketEnableCallBacksPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFSocketRef, CFOptionFlags)>>(
      'CFSocketEnableCallBacks');
  late final _CFSocketEnableCallBacks =
      _CFSocketEnableCallBacksPtr.asFunction<void Function(CFSocketRef, int)>();

  CFSocketError CFSocketSendData(
    CFSocketRef s,
    CFDataRef address,
    CFDataRef data,
    DartCFTimeInterval timeout,
  ) {
    return CFSocketError.fromValue(_CFSocketSendData(
      s,
      address,
      data,
      timeout,
    ));
  }

  late final _CFSocketSendDataPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFSocketRef, CFDataRef, CFDataRef,
              CFTimeInterval)>>('CFSocketSendData');
  late final _CFSocketSendData = _CFSocketSendDataPtr.asFunction<
      int Function(CFSocketRef, CFDataRef, CFDataRef, double)>();

  CFSocketError CFSocketRegisterValue(
    ffi.Pointer<CFSocketSignature> nameServerSignature,
    DartCFTimeInterval timeout,
    CFStringRef name,
    CFPropertyListRef value,
  ) {
    return CFSocketError.fromValue(_CFSocketRegisterValue(
      nameServerSignature,
      timeout,
      name,
      value,
    ));
  }

  late final _CFSocketRegisterValuePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(ffi.Pointer<CFSocketSignature>, CFTimeInterval,
              CFStringRef, CFPropertyListRef)>>('CFSocketRegisterValue');
  late final _CFSocketRegisterValue = _CFSocketRegisterValuePtr.asFunction<
      int Function(ffi.Pointer<CFSocketSignature>, double, CFStringRef,
          CFPropertyListRef)>();

  CFSocketError CFSocketCopyRegisteredValue(
    ffi.Pointer<CFSocketSignature> nameServerSignature,
    DartCFTimeInterval timeout,
    CFStringRef name,
    ffi.Pointer<CFPropertyListRef> value,
    ffi.Pointer<CFDataRef> nameServerAddress,
  ) {
    return CFSocketError.fromValue(_CFSocketCopyRegisteredValue(
      nameServerSignature,
      timeout,
      name,
      value,
      nameServerAddress,
    ));
  }

  late final _CFSocketCopyRegisteredValuePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(
              ffi.Pointer<CFSocketSignature>,
              CFTimeInterval,
              CFStringRef,
              ffi.Pointer<CFPropertyListRef>,
              ffi.Pointer<CFDataRef>)>>('CFSocketCopyRegisteredValue');
  late final _CFSocketCopyRegisteredValue =
      _CFSocketCopyRegisteredValuePtr.asFunction<
          int Function(ffi.Pointer<CFSocketSignature>, double, CFStringRef,
              ffi.Pointer<CFPropertyListRef>, ffi.Pointer<CFDataRef>)>();

  CFSocketError CFSocketRegisterSocketSignature(
    ffi.Pointer<CFSocketSignature> nameServerSignature,
    DartCFTimeInterval timeout,
    CFStringRef name,
    ffi.Pointer<CFSocketSignature> signature,
  ) {
    return CFSocketError.fromValue(_CFSocketRegisterSocketSignature(
      nameServerSignature,
      timeout,
      name,
      signature,
    ));
  }

  late final _CFSocketRegisterSocketSignaturePtr = _lookup<
          ffi.NativeFunction<
              CFIndex Function(ffi.Pointer<CFSocketSignature>, CFTimeInterval,
                  CFStringRef, ffi.Pointer<CFSocketSignature>)>>(
      'CFSocketRegisterSocketSignature');
  late final _CFSocketRegisterSocketSignature =
      _CFSocketRegisterSocketSignaturePtr.asFunction<
          int Function(ffi.Pointer<CFSocketSignature>, double, CFStringRef,
              ffi.Pointer<CFSocketSignature>)>();

  CFSocketError CFSocketCopyRegisteredSocketSignature(
    ffi.Pointer<CFSocketSignature> nameServerSignature,
    DartCFTimeInterval timeout,
    CFStringRef name,
    ffi.Pointer<CFSocketSignature> signature,
    ffi.Pointer<CFDataRef> nameServerAddress,
  ) {
    return CFSocketError.fromValue(_CFSocketCopyRegisteredSocketSignature(
      nameServerSignature,
      timeout,
      name,
      signature,
      nameServerAddress,
    ));
  }

  late final _CFSocketCopyRegisteredSocketSignaturePtr = _lookup<
          ffi.NativeFunction<
              CFIndex Function(
                  ffi.Pointer<CFSocketSignature>,
                  CFTimeInterval,
                  CFStringRef,
                  ffi.Pointer<CFSocketSignature>,
                  ffi.Pointer<CFDataRef>)>>(
      'CFSocketCopyRegisteredSocketSignature');
  late final _CFSocketCopyRegisteredSocketSignature =
      _CFSocketCopyRegisteredSocketSignaturePtr.asFunction<
          int Function(ffi.Pointer<CFSocketSignature>, double, CFStringRef,
              ffi.Pointer<CFSocketSignature>, ffi.Pointer<CFDataRef>)>();

  CFSocketError CFSocketUnregister(
    ffi.Pointer<CFSocketSignature> nameServerSignature,
    DartCFTimeInterval timeout,
    CFStringRef name,
  ) {
    return CFSocketError.fromValue(_CFSocketUnregister(
      nameServerSignature,
      timeout,
      name,
    ));
  }

  late final _CFSocketUnregisterPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(ffi.Pointer<CFSocketSignature>, CFTimeInterval,
              CFStringRef)>>('CFSocketUnregister');
  late final _CFSocketUnregister = _CFSocketUnregisterPtr.asFunction<
      int Function(ffi.Pointer<CFSocketSignature>, double, CFStringRef)>();

  void CFSocketSetDefaultNameRegistryPortNumber(
    int port,
  ) {
    return _CFSocketSetDefaultNameRegistryPortNumber(
      port,
    );
  }

  late final _CFSocketSetDefaultNameRegistryPortNumberPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(UInt16)>>(
          'CFSocketSetDefaultNameRegistryPortNumber');
  late final _CFSocketSetDefaultNameRegistryPortNumber =
      _CFSocketSetDefaultNameRegistryPortNumberPtr.asFunction<
          void Function(int)>();

  int CFSocketGetDefaultNameRegistryPortNumber() {
    return _CFSocketGetDefaultNameRegistryPortNumber();
  }

  late final _CFSocketGetDefaultNameRegistryPortNumberPtr =
      _lookup<ffi.NativeFunction<UInt16 Function()>>(
          'CFSocketGetDefaultNameRegistryPortNumber');
  late final _CFSocketGetDefaultNameRegistryPortNumber =
      _CFSocketGetDefaultNameRegistryPortNumberPtr.asFunction<int Function()>();

  late final ffi.Pointer<CFStringRef> _kCFSocketCommandKey =
      _lookup<CFStringRef>('kCFSocketCommandKey');

  CFStringRef get kCFSocketCommandKey => _kCFSocketCommandKey.value;

  late final ffi.Pointer<CFStringRef> _kCFSocketNameKey =
      _lookup<CFStringRef>('kCFSocketNameKey');

  CFStringRef get kCFSocketNameKey => _kCFSocketNameKey.value;

  late final ffi.Pointer<CFStringRef> _kCFSocketValueKey =
      _lookup<CFStringRef>('kCFSocketValueKey');

  CFStringRef get kCFSocketValueKey => _kCFSocketValueKey.value;

  late final ffi.Pointer<CFStringRef> _kCFSocketResultKey =
      _lookup<CFStringRef>('kCFSocketResultKey');

  CFStringRef get kCFSocketResultKey => _kCFSocketResultKey.value;

  late final ffi.Pointer<CFStringRef> _kCFSocketErrorKey =
      _lookup<CFStringRef>('kCFSocketErrorKey');

  CFStringRef get kCFSocketErrorKey => _kCFSocketErrorKey.value;

  late final ffi.Pointer<CFStringRef> _kCFSocketRegisterCommand =
      _lookup<CFStringRef>('kCFSocketRegisterCommand');

  CFStringRef get kCFSocketRegisterCommand => _kCFSocketRegisterCommand.value;

  late final ffi.Pointer<CFStringRef> _kCFSocketRetrieveCommand =
      _lookup<CFStringRef>('kCFSocketRetrieveCommand');

  CFStringRef get kCFSocketRetrieveCommand => _kCFSocketRetrieveCommand.value;

  int getattrlistbulk(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    int arg4,
  ) {
    return _getattrlistbulk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _getattrlistbulkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Uint64)>>('getattrlistbulk');
  late final _getattrlistbulk = _getattrlistbulkPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  int getattrlistat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Void> arg2,
    ffi.Pointer<ffi.Void> arg3,
    int arg4,
    int arg5,
  ) {
    return _getattrlistat(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final _getattrlistatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.UnsignedLong)>>('getattrlistat');
  late final _getattrlistat = _getattrlistatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int)>();

  int setattrlistat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Void> arg2,
    ffi.Pointer<ffi.Void> arg3,
    int arg4,
    int arg5,
  ) {
    return _setattrlistat(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final _setattrlistatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Uint32)>>('setattrlistat');
  late final _setattrlistat = _setattrlistatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int)>();

  int freadlink(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _freadlink(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _freadlinkPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('freadlink');
  late final _freadlink =
      _freadlinkPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int faccessat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
  ) {
    return _faccessat(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _faccessatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int)>>('faccessat');
  late final _faccessat = _faccessatPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  int fchownat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
    int arg4,
  ) {
    return _fchownat(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _fchownatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, uid_t, gid_t,
              ffi.Int)>>('fchownat');
  late final _fchownat = _fchownatPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int, int)>();

  int linkat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    int arg4,
  ) {
    return _linkat(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _linkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('linkat');
  late final _linkat = _linkatPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  int readlinkat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Char> arg2,
    int arg3,
  ) {
    return _readlinkat(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _readlinkatPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('readlinkat');
  late final _readlinkat = _readlinkatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int symlinkat(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _symlinkat(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _symlinkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('symlinkat');
  late final _symlinkat = _symlinkatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int unlinkat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _unlinkat(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _unlinkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('unlinkat');
  late final _unlinkat =
      _unlinkatPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  void _exit(
    int arg0,
  ) {
    return __exit(
      arg0,
    );
  }

  late final __exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_exit');
  late final __exit = __exitPtr.asFunction<void Function(int)>();

  int access(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _access(
      arg0,
      arg1,
    );
  }

  late final _accessPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'access');
  late final _access =
      _accessPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int alarm(
    int arg0,
  ) {
    return _alarm(
      arg0,
    );
  }

  late final _alarmPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'alarm');
  late final _alarm = _alarmPtr.asFunction<int Function(int)>();

  int chdir(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _chdir(
      arg0,
    );
  }

  late final _chdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'chdir');
  late final _chdir =
      _chdirPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int chown(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
  ) {
    return _chown(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _chownPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, uid_t, gid_t)>>('chown');
  late final _chown =
      _chownPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int close(
    int arg0,
  ) {
    return _close(
      arg0,
    );
  }

  late final _closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('close');
  late final _close = _closePtr.asFunction<int Function(int)>();

  int dup(
    int arg0,
  ) {
    return _dup(
      arg0,
    );
  }

  late final _dupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('dup');
  late final _dup = _dupPtr.asFunction<int Function(int)>();

  int dup2(
    int arg0,
    int arg1,
  ) {
    return _dup2(
      arg0,
      arg1,
    );
  }

  late final _dup2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('dup2');
  late final _dup2 = _dup2Ptr.asFunction<int Function(int, int)>();

  int execl(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __arg0,
  ) {
    return _execl(
      __path,
      __arg0,
    );
  }

  late final _execlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execl');
  late final _execl = _execlPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int execle(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __arg0,
  ) {
    return _execle(
      __path,
      __arg0,
    );
  }

  late final _execlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execle');
  late final _execle = _execlePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int execlp(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Char> __arg0,
  ) {
    return _execlp(
      __file,
      __arg0,
    );
  }

  late final _execlpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execlp');
  late final _execlp = _execlpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int execv(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
  ) {
    return _execv(
      __path,
      __argv,
    );
  }

  late final _execvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execv');
  late final _execv = _execvPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int execve(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __envp,
  ) {
    return _execve(
      __file,
      __argv,
      __envp,
    );
  }

  late final _execvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execve');
  late final _execve = _execvePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int execvp(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
  ) {
    return _execvp(
      __file,
      __argv,
    );
  }

  late final _execvpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execvp');
  late final _execvp = _execvpPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int fork() {
    return _fork();
  }

  late final _forkPtr = _lookup<ffi.NativeFunction<pid_t Function()>>('fork');
  late final _fork = _forkPtr.asFunction<int Function()>();

  int fpathconf(
    int arg0,
    int arg1,
  ) {
    return _fpathconf(
      arg0,
      arg1,
    );
  }

  late final _fpathconfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Int, ffi.Int)>>(
          'fpathconf');
  late final _fpathconf = _fpathconfPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> getcwd(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _getcwd(
      arg0,
      arg1,
    );
  }

  late final _getcwdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('getcwd');
  late final _getcwd = _getcwdPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int getegid() {
    return _getegid();
  }

  late final _getegidPtr =
      _lookup<ffi.NativeFunction<gid_t Function()>>('getegid');
  late final _getegid = _getegidPtr.asFunction<int Function()>();

  int geteuid() {
    return _geteuid();
  }

  late final _geteuidPtr =
      _lookup<ffi.NativeFunction<uid_t Function()>>('geteuid');
  late final _geteuid = _geteuidPtr.asFunction<int Function()>();

  int getgid() {
    return _getgid();
  }

  late final _getgidPtr =
      _lookup<ffi.NativeFunction<gid_t Function()>>('getgid');
  late final _getgid = _getgidPtr.asFunction<int Function()>();

  int getgroups(
    int arg0,
    ffi.Pointer<gid_t> arg1,
  ) {
    return _getgroups(
      arg0,
      arg1,
    );
  }

  late final _getgroupsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<gid_t>)>>(
      'getgroups');
  late final _getgroups =
      _getgroupsPtr.asFunction<int Function(int, ffi.Pointer<gid_t>)>();

  ffi.Pointer<ffi.Char> getlogin() {
    return _getlogin();
  }

  late final _getloginPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>('getlogin');
  late final _getlogin =
      _getloginPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  int getpgrp() {
    return _getpgrp();
  }

  late final _getpgrpPtr =
      _lookup<ffi.NativeFunction<pid_t Function()>>('getpgrp');
  late final _getpgrp = _getpgrpPtr.asFunction<int Function()>();

  int getpid() {
    return _getpid();
  }

  late final _getpidPtr =
      _lookup<ffi.NativeFunction<pid_t Function()>>('getpid');
  late final _getpid = _getpidPtr.asFunction<int Function()>();

  int getppid() {
    return _getppid();
  }

  late final _getppidPtr =
      _lookup<ffi.NativeFunction<pid_t Function()>>('getppid');
  late final _getppid = _getppidPtr.asFunction<int Function()>();

  int getuid() {
    return _getuid();
  }

  late final _getuidPtr =
      _lookup<ffi.NativeFunction<uid_t Function()>>('getuid');
  late final _getuid = _getuidPtr.asFunction<int Function()>();

  int isatty(
    int arg0,
  ) {
    return _isatty(
      arg0,
    );
  }

  late final _isattyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('isatty');
  late final _isatty = _isattyPtr.asFunction<int Function(int)>();

  int link(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _link(
      arg0,
      arg1,
    );
  }

  late final _linkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('link');
  late final _link = _linkPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int lseek(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _lseek(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _lseekPtr =
      _lookup<ffi.NativeFunction<off_t Function(ffi.Int, off_t, ffi.Int)>>(
          'lseek');
  late final _lseek = _lseekPtr.asFunction<int Function(int, int, int)>();

  int pathconf(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _pathconf(
      arg0,
      arg1,
    );
  }

  late final _pathconfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>, ffi.Int)>>('pathconf');
  late final _pathconf =
      _pathconfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int pause() {
    return _pause();
  }

  late final _pausePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('pause');
  late final _pause = _pausePtr.asFunction<int Function()>();

  int pipe(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _pipe(
      arg0,
    );
  }

  late final _pipePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>)>>(
          'pipe');
  late final _pipe = _pipePtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int read(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _read(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _readPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('read');
  late final _read =
      _readPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  int rmdir(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _rmdir(
      arg0,
    );
  }

  late final _rmdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rmdir');
  late final _rmdir =
      _rmdirPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int setgid(
    int arg0,
  ) {
    return _setgid(
      arg0,
    );
  }

  late final _setgidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(gid_t)>>('setgid');
  late final _setgid = _setgidPtr.asFunction<int Function(int)>();

  int setpgid(
    int arg0,
    int arg1,
  ) {
    return _setpgid(
      arg0,
      arg1,
    );
  }

  late final _setpgidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(pid_t, pid_t)>>('setpgid');
  late final _setpgid = _setpgidPtr.asFunction<int Function(int, int)>();

  int setsid() {
    return _setsid();
  }

  late final _setsidPtr =
      _lookup<ffi.NativeFunction<pid_t Function()>>('setsid');
  late final _setsid = _setsidPtr.asFunction<int Function()>();

  int setuid(
    int arg0,
  ) {
    return _setuid(
      arg0,
    );
  }

  late final _setuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(uid_t)>>('setuid');
  late final _setuid = _setuidPtr.asFunction<int Function(int)>();

  int sleep(
    int arg0,
  ) {
    return _sleep(
      arg0,
    );
  }

  late final _sleepPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'sleep');
  late final _sleep = _sleepPtr.asFunction<int Function(int)>();

  int sysconf(
    int arg0,
  ) {
    return _sysconf(
      arg0,
    );
  }

  late final _sysconfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Int)>>('sysconf');
  late final _sysconf = _sysconfPtr.asFunction<int Function(int)>();

  int tcgetpgrp(
    int arg0,
  ) {
    return _tcgetpgrp(
      arg0,
    );
  }

  late final _tcgetpgrpPtr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Int)>>('tcgetpgrp');
  late final _tcgetpgrp = _tcgetpgrpPtr.asFunction<int Function(int)>();

  int tcsetpgrp(
    int arg0,
    int arg1,
  ) {
    return _tcsetpgrp(
      arg0,
      arg1,
    );
  }

  late final _tcsetpgrpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, pid_t)>>(
          'tcsetpgrp');
  late final _tcsetpgrp = _tcsetpgrpPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> ttyname(
    int arg0,
  ) {
    return _ttyname(
      arg0,
    );
  }

  late final _ttynamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ttyname');
  late final _ttyname =
      _ttynamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int ttyname_r(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _ttyname_r(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _ttyname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ttyname_r');
  late final _ttyname_r =
      _ttyname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int unlink(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unlink(
      arg0,
    );
  }

  late final _unlinkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unlink');
  late final _unlink =
      _unlinkPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int write(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbyte,
  ) {
    return _write(
      __fd,
      __buf,
      __nbyte,
    );
  }

  late final _writePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('write');
  late final _write =
      _writePtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  int confstr(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _confstr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _confstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('confstr');
  late final _confstr =
      _confstrPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int getopt(
    int arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _getopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getoptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('getopt');
  late final _getopt = _getoptPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _optarg =
      _lookup<ffi.Pointer<ffi.Char>>('optarg');

  ffi.Pointer<ffi.Char> get optarg => _optarg.value;

  set optarg(ffi.Pointer<ffi.Char> value) => _optarg.value = value;

  late final ffi.Pointer<ffi.Int> _optind = _lookup<ffi.Int>('optind');

  int get optind => _optind.value;

  set optind(int value) => _optind.value = value;

  late final ffi.Pointer<ffi.Int> _opterr = _lookup<ffi.Int>('opterr');

  int get opterr => _opterr.value;

  set opterr(int value) => _opterr.value = value;

  late final ffi.Pointer<ffi.Int> _optopt = _lookup<ffi.Int>('optopt');

  int get optopt => _optopt.value;

  set optopt(int value) => _optopt.value = value;

  ffi.Pointer<ffi.Void> brk(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _brk(
      arg0,
    );
  }

  late final _brkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>>('brk');
  late final _brk = _brkPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  int chroot(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _chroot(
      arg0,
    );
  }

  late final _chrootPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'chroot');
  late final _chroot =
      _chrootPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> crypt(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _crypt(
      arg0,
      arg1,
    );
  }

  late final _cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('crypt');
  late final _crypt = _cryptPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  void encrypt(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _encrypt(
      arg0,
      arg1,
    );
  }

  late final _encryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Int)>>('encrypt');
  late final _encrypt =
      _encryptPtr.asFunction<void Function(ffi.Pointer<ffi.Char>, int)>();

  int fchdir(
    int arg0,
  ) {
    return _fchdir(
      arg0,
    );
  }

  late final _fchdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fchdir');
  late final _fchdir = _fchdirPtr.asFunction<int Function(int)>();

  int gethostid() {
    return _gethostid();
  }

  late final _gethostidPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('gethostid');
  late final _gethostid = _gethostidPtr.asFunction<int Function()>();

  int getpgid(
    int arg0,
  ) {
    return _getpgid(
      arg0,
    );
  }

  late final _getpgidPtr =
      _lookup<ffi.NativeFunction<pid_t Function(pid_t)>>('getpgid');
  late final _getpgid = _getpgidPtr.asFunction<int Function(int)>();

  int getsid(
    int arg0,
  ) {
    return _getsid(
      arg0,
    );
  }

  late final _getsidPtr =
      _lookup<ffi.NativeFunction<pid_t Function(pid_t)>>('getsid');
  late final _getsid = _getsidPtr.asFunction<int Function(int)>();

  int getdtablesize() {
    return _getdtablesize();
  }

  late final _getdtablesizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getdtablesize');
  late final _getdtablesize = _getdtablesizePtr.asFunction<int Function()>();

  int getpagesize() {
    return _getpagesize();
  }

  late final _getpagesizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getpagesize');
  late final _getpagesize = _getpagesizePtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> getpass(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getpass(
      arg0,
    );
  }

  late final _getpassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getpass');
  late final _getpass = _getpassPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> getwd(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getwd(
      arg0,
    );
  }

  late final _getwdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getwd');
  late final _getwd = _getwdPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int lchown(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
  ) {
    return _lchown(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _lchownPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, uid_t, gid_t)>>('lchown');
  late final _lchown =
      _lchownPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int lockf(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _lockf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _lockfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, off_t)>>(
          'lockf');
  late final _lockf = _lockfPtr.asFunction<int Function(int, int, int)>();

  int nice(
    int arg0,
  ) {
    return _nice(
      arg0,
    );
  }

  late final _nicePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('nice');
  late final _nice = _nicePtr.asFunction<int Function(int)>();

  int pread(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbyte,
    int __offset,
  ) {
    return _pread(
      __fd,
      __buf,
      __nbyte,
      __offset,
    );
  }

  late final _preadPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, off_t)>>('pread');
  late final _pread = _preadPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  int pwrite(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbyte,
    int __offset,
  ) {
    return _pwrite(
      __fd,
      __buf,
      __nbyte,
      __offset,
    );
  }

  late final _pwritePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, off_t)>>('pwrite');
  late final _pwrite = _pwritePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> sbrk(
    int arg0,
  ) {
    return _sbrk(
      arg0,
    );
  }

  late final _sbrkPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Int)>>(
          'sbrk');
  late final _sbrk = _sbrkPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  int setpgrp() {
    return _setpgrp();
  }

  late final _setpgrpPtr =
      _lookup<ffi.NativeFunction<pid_t Function()>>('setpgrp');
  late final _setpgrp = _setpgrpPtr.asFunction<int Function()>();

  int setregid(
    int arg0,
    int arg1,
  ) {
    return _setregid(
      arg0,
      arg1,
    );
  }

  late final _setregidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(gid_t, gid_t)>>('setregid');
  late final _setregid = _setregidPtr.asFunction<int Function(int, int)>();

  int setreuid(
    int arg0,
    int arg1,
  ) {
    return _setreuid(
      arg0,
      arg1,
    );
  }

  late final _setreuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(uid_t, uid_t)>>('setreuid');
  late final _setreuid = _setreuidPtr.asFunction<int Function(int, int)>();

  void sync1() {
    return _sync1();
  }

  late final _sync1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sync');
  late final _sync1 = _sync1Ptr.asFunction<void Function()>();

  int truncate(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _truncate(
      arg0,
      arg1,
    );
  }

  late final _truncatePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, off_t)>>(
      'truncate');
  late final _truncate =
      _truncatePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int ualarm(
    int arg0,
    int arg1,
  ) {
    return _ualarm(
      arg0,
      arg1,
    );
  }

  late final _ualarmPtr =
      _lookup<ffi.NativeFunction<useconds_t Function(useconds_t, useconds_t)>>(
          'ualarm');
  late final _ualarm = _ualarmPtr.asFunction<int Function(int, int)>();

  int usleep(
    int arg0,
  ) {
    return _usleep(
      arg0,
    );
  }

  late final _usleepPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(useconds_t)>>('usleep');
  late final _usleep = _usleepPtr.asFunction<int Function(int)>();

  int vfork() {
    return _vfork();
  }

  late final _vforkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('vfork');
  late final _vfork = _vforkPtr.asFunction<int Function()>();

  int fsync(
    int arg0,
  ) {
    return _fsync(
      arg0,
    );
  }

  late final _fsyncPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fsync');
  late final _fsync = _fsyncPtr.asFunction<int Function(int)>();

  int ftruncate(
    int arg0,
    int arg1,
  ) {
    return _ftruncate(
      arg0,
      arg1,
    );
  }

  late final _ftruncatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, off_t)>>(
          'ftruncate');
  late final _ftruncate = _ftruncatePtr.asFunction<int Function(int, int)>();

  int getlogin_r(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _getlogin_r(
      arg0,
      arg1,
    );
  }

  late final _getlogin_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('getlogin_r');
  late final _getlogin_r =
      _getlogin_rPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int fchown(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _fchown(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fchownPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, uid_t, gid_t)>>(
          'fchown');
  late final _fchown = _fchownPtr.asFunction<int Function(int, int, int)>();

  int gethostname(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _gethostname(
      arg0,
      arg1,
    );
  }

  late final _gethostnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('gethostname');
  late final _gethostname =
      _gethostnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int readlink(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _readlink(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _readlinkPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('readlink');
  late final _readlink = _readlinkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int setegid(
    int arg0,
  ) {
    return _setegid(
      arg0,
    );
  }

  late final _setegidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(gid_t)>>('setegid');
  late final _setegid = _setegidPtr.asFunction<int Function(int)>();

  int seteuid(
    int arg0,
  ) {
    return _seteuid(
      arg0,
    );
  }

  late final _seteuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(uid_t)>>('seteuid');
  late final _seteuid = _seteuidPtr.asFunction<int Function(int)>();

  int symlink(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _symlink(
      arg0,
      arg1,
    );
  }

  late final _symlinkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('symlink');
  late final _symlink = _symlinkPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int pselect(
    int arg0,
    ffi.Pointer<fd_set> arg1,
    ffi.Pointer<fd_set> arg2,
    ffi.Pointer<fd_set> arg3,
    ffi.Pointer<timespec> arg4,
    ffi.Pointer<sigset_t> arg5,
  ) {
    return _pselect(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final _pselectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<timespec>,
              ffi.Pointer<sigset_t>)>>('pselect');
  late final _pselect = _pselectPtr.asFunction<
      int Function(int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>, ffi.Pointer<timespec>, ffi.Pointer<sigset_t>)>();

  int select(
    int arg0,
    ffi.Pointer<fd_set> arg1,
    ffi.Pointer<fd_set> arg2,
    ffi.Pointer<fd_set> arg3,
    ffi.Pointer<timeval> arg4,
  ) {
    return _select(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>>('select');
  late final _select = _selectPtr.asFunction<
      int Function(int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>();

  int accessx_np(
    ffi.Pointer<accessx_descriptor> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    int arg3,
  ) {
    return _accessx_np(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _accessx_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<accessx_descriptor>, ffi.Size,
              ffi.Pointer<ffi.Int>, uid_t)>>('accessx_np');
  late final _accessx_np = _accessx_npPtr.asFunction<
      int Function(
          ffi.Pointer<accessx_descriptor>, int, ffi.Pointer<ffi.Int>, int)>();

  int acct(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _acct(
      arg0,
    );
  }

  late final _acctPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'acct');
  late final _acct = _acctPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int add_profil(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
  ) {
    return _add_profil(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _add_profilPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.UnsignedLong,
              ffi.UnsignedInt)>>('add_profil');
  late final _add_profil = _add_profilPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  void endusershell() {
    return _endusershell();
  }

  late final _endusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('endusershell');
  late final _endusershell = _endusershellPtr.asFunction<void Function()>();

  int execvP(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Char> __searchpath,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
  ) {
    return _execvP(
      __file,
      __searchpath,
      __argv,
    );
  }

  late final _execvPPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execvP');
  late final _execvP = _execvPPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Char> fflagstostr(
    int arg0,
  ) {
    return _fflagstostr(
      arg0,
    );
  }

  late final _fflagstostrPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedLong)>>(
      'fflagstostr');
  late final _fflagstostr =
      _fflagstostrPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int getdomainname(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _getdomainname(
      arg0,
      arg1,
    );
  }

  late final _getdomainnamePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'getdomainname');
  late final _getdomainname =
      _getdomainnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int getgrouplist(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _getgrouplist(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _getgrouplistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('getgrouplist');
  late final _getgrouplist = _getgrouplistPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  int gethostuuid(
    ffi.Pointer<ffi.UnsignedChar> arg0,
    ffi.Pointer<timespec> arg1,
  ) {
    return _gethostuuid(
      arg0,
      arg1,
    );
  }

  late final _gethostuuidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<timespec>)>>('gethostuuid');
  late final _gethostuuid = _gethostuuidPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<timespec>)>();

  int getmode(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    return _getmode(
      arg0,
      arg1,
    );
  }

  late final _getmodePtr = _lookup<
          ffi.NativeFunction<mode_t Function(ffi.Pointer<ffi.Void>, mode_t)>>(
      'getmode');
  late final _getmode =
      _getmodePtr.asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  int getpeereid(
    int arg0,
    ffi.Pointer<uid_t> arg1,
    ffi.Pointer<gid_t> arg2,
  ) {
    return _getpeereid(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getpeereidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<uid_t>, ffi.Pointer<gid_t>)>>('getpeereid');
  late final _getpeereid = _getpeereidPtr
      .asFunction<int Function(int, ffi.Pointer<uid_t>, ffi.Pointer<gid_t>)>();

  int getsgroups_np(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.UnsignedChar> arg1,
  ) {
    return _getsgroups_np(
      arg0,
      arg1,
    );
  }

  late final _getsgroups_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.UnsignedChar>)>>('getsgroups_np');
  late final _getsgroups_np = _getsgroups_npPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.UnsignedChar>)>();

  ffi.Pointer<ffi.Char> getusershell() {
    return _getusershell();
  }

  late final _getusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getusershell');
  late final _getusershell =
      _getusershellPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  int getwgroups_np(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.UnsignedChar> arg1,
  ) {
    return _getwgroups_np(
      arg0,
      arg1,
    );
  }

  late final _getwgroups_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.UnsignedChar>)>>('getwgroups_np');
  late final _getwgroups_np = _getwgroups_npPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.UnsignedChar>)>();

  int initgroups(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _initgroups(
      arg0,
      arg1,
    );
  }

  late final _initgroupsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'initgroups');
  late final _initgroups =
      _initgroupsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int issetugid() {
    return _issetugid();
  }

  late final _issetugidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('issetugid');
  late final _issetugid = _issetugidPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mkdtemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkdtemp(
      arg0,
    );
  }

  late final _mkdtempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mkdtemp');
  late final _mkdtemp = _mkdtempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mknod(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
  ) {
    return _mknod(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mknodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, mode_t, dev_t)>>('mknod');
  late final _mknod =
      _mknodPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int mkpath_np(
    ffi.Pointer<ffi.Char> path,
    int omode,
  ) {
    return _mkpath_np(
      path,
      omode,
    );
  }

  late final _mkpath_npPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, mode_t)>>(
      'mkpath_np');
  late final _mkpath_np =
      _mkpath_npPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mkpathat_np(
    int dfd,
    ffi.Pointer<ffi.Char> path,
    int omode,
  ) {
    return _mkpathat_np(
      dfd,
      path,
      omode,
    );
  }

  late final _mkpathat_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, mode_t)>>('mkpathat_np');
  late final _mkpathat_np = _mkpathat_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int mkstemps(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _mkstemps(
      arg0,
      arg1,
    );
  }

  late final _mkstempsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'mkstemps');
  late final _mkstemps =
      _mkstempsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mkostemp(
    ffi.Pointer<ffi.Char> path,
    int oflags,
  ) {
    return _mkostemp(
      path,
      oflags,
    );
  }

  late final _mkostempPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'mkostemp');
  late final _mkostemp =
      _mkostempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mkostemps(
    ffi.Pointer<ffi.Char> path,
    int slen,
    int oflags,
  ) {
    return _mkostemps(
      path,
      slen,
      oflags,
    );
  }

  late final _mkostempsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int)>>('mkostemps');
  late final _mkostemps =
      _mkostempsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int mkstemp_dprotected_np(
    ffi.Pointer<ffi.Char> path,
    int dpclass,
    int dpflags,
  ) {
    return _mkstemp_dprotected_np(
      path,
      dpclass,
      dpflags,
    );
  }

  late final _mkstemp_dprotected_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int)>>('mkstemp_dprotected_np');
  late final _mkstemp_dprotected_np = _mkstemp_dprotected_npPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  ffi.Pointer<ffi.Char> mkdtempat_np(
    int dfd,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _mkdtempat_np(
      dfd,
      path,
    );
  }

  late final _mkdtempat_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('mkdtempat_np');
  late final _mkdtempat_np = _mkdtempat_npPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>)>();

  int mkstempsat_np(
    int dfd,
    ffi.Pointer<ffi.Char> path,
    int slen,
  ) {
    return _mkstempsat_np(
      dfd,
      path,
      slen,
    );
  }

  late final _mkstempsat_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('mkstempsat_np');
  late final _mkstempsat_np = _mkstempsat_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int mkostempsat_np(
    int dfd,
    ffi.Pointer<ffi.Char> path,
    int slen,
    int oflags,
  ) {
    return _mkostempsat_np(
      dfd,
      path,
      slen,
      oflags,
    );
  }

  late final _mkostempsat_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int)>>('mkostempsat_np');
  late final _mkostempsat_np = _mkostempsat_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  int nfssvc(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
  ) {
    return _nfssvc(
      arg0,
      arg1,
    );
  }

  late final _nfssvcPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Void>)>>(
      'nfssvc');
  late final _nfssvc =
      _nfssvcPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>)>();

  int profil(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
  ) {
    return _profil(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _profilPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.UnsignedLong,
              ffi.UnsignedInt)>>('profil');
  late final _profil = _profilPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  int pthread_setugid_np(
    int arg0,
    int arg1,
  ) {
    return _pthread_setugid_np(
      arg0,
      arg1,
    );
  }

  late final _pthread_setugid_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(uid_t, gid_t)>>(
          'pthread_setugid_np');
  late final _pthread_setugid_np =
      _pthread_setugid_npPtr.asFunction<int Function(int, int)>();

  int pthread_getugid_np(
    ffi.Pointer<uid_t> arg0,
    ffi.Pointer<gid_t> arg1,
  ) {
    return _pthread_getugid_np(
      arg0,
      arg1,
    );
  }

  late final _pthread_getugid_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<uid_t>, ffi.Pointer<gid_t>)>>('pthread_getugid_np');
  late final _pthread_getugid_np = _pthread_getugid_npPtr
      .asFunction<int Function(ffi.Pointer<uid_t>, ffi.Pointer<gid_t>)>();

  int reboot(
    int arg0,
  ) {
    return _reboot(
      arg0,
    );
  }

  late final _rebootPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('reboot');
  late final _reboot = _rebootPtr.asFunction<int Function(int)>();

  int revoke(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _revoke(
      arg0,
    );
  }

  late final _revokePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'revoke');
  late final _revoke =
      _revokePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int rcmd(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<ffi.Char> arg3,
    ffi.Pointer<ffi.Char> arg4,
    ffi.Pointer<ffi.Int> arg5,
  ) {
    return _rcmd(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final _rcmdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>>('rcmd');
  late final _rcmd = _rcmdPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>)>();

  int rcmd_af(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<ffi.Char> arg3,
    ffi.Pointer<ffi.Char> arg4,
    ffi.Pointer<ffi.Int> arg5,
    int arg6,
  ) {
    return _rcmd_af(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
      arg6,
    );
  }

  late final _rcmd_afPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('rcmd_af');
  late final _rcmd_af = _rcmd_afPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          int)>();

  int rresvport(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _rresvport(
      arg0,
    );
  }

  late final _rresvportPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>)>>(
          'rresvport');
  late final _rresvport =
      _rresvportPtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int rresvport_af(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
  ) {
    return _rresvport_af(
      arg0,
      arg1,
    );
  }

  late final _rresvport_afPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Int)>>(
      'rresvport_af');
  late final _rresvport_af =
      _rresvport_afPtr.asFunction<int Function(ffi.Pointer<ffi.Int>, int)>();

  int iruserok(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return _iruserok(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _iruserokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedLong, ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('iruserok');
  late final _iruserok = _iruserokPtr.asFunction<
      int Function(int, int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int iruserok_sa(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    ffi.Pointer<ffi.Char> arg4,
  ) {
    return _iruserok_sa(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _iruserok_saPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('iruserok_sa');
  late final _iruserok_sa = _iruserok_saPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  int ruserok(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return _ruserok(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ruserokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('ruserok');
  late final _ruserok = _ruserokPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  int setdomainname(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _setdomainname(
      arg0,
      arg1,
    );
  }

  late final _setdomainnamePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'setdomainname');
  late final _setdomainname =
      _setdomainnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int setgroups(
    int arg0,
    ffi.Pointer<gid_t> arg1,
  ) {
    return _setgroups(
      arg0,
      arg1,
    );
  }

  late final _setgroupsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<gid_t>)>>(
      'setgroups');
  late final _setgroups =
      _setgroupsPtr.asFunction<int Function(int, ffi.Pointer<gid_t>)>();

  void sethostid(
    int arg0,
  ) {
    return _sethostid(
      arg0,
    );
  }

  late final _sethostidPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('sethostid');
  late final _sethostid = _sethostidPtr.asFunction<void Function(int)>();

  int sethostname(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _sethostname(
      arg0,
      arg1,
    );
  }

  late final _sethostnamePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'sethostname');
  late final _sethostname =
      _sethostnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int setlogin(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setlogin(
      arg0,
    );
  }

  late final _setloginPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'setlogin');
  late final _setlogin =
      _setloginPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> setmode(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setmode(
      arg0,
    );
  }

  late final _setmodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>>('setmode');
  late final _setmode = _setmodePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  int setrgid(
    int arg0,
  ) {
    return _setrgid(
      arg0,
    );
  }

  late final _setrgidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(gid_t)>>('setrgid');
  late final _setrgid = _setrgidPtr.asFunction<int Function(int)>();

  int setruid(
    int arg0,
  ) {
    return _setruid(
      arg0,
    );
  }

  late final _setruidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(uid_t)>>('setruid');
  late final _setruid = _setruidPtr.asFunction<int Function(int)>();

  int setsgroups_np(
    int arg0,
    ffi.Pointer<ffi.UnsignedChar> arg1,
  ) {
    return _setsgroups_np(
      arg0,
      arg1,
    );
  }

  late final _setsgroups_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.UnsignedChar>)>>('setsgroups_np');
  late final _setsgroups_np = _setsgroups_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.UnsignedChar>)>();

  void setusershell() {
    return _setusershell();
  }

  late final _setusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('setusershell');
  late final _setusershell = _setusershellPtr.asFunction<void Function()>();

  int setwgroups_np(
    int arg0,
    ffi.Pointer<ffi.UnsignedChar> arg1,
  ) {
    return _setwgroups_np(
      arg0,
      arg1,
    );
  }

  late final _setwgroups_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.UnsignedChar>)>>('setwgroups_np');
  late final _setwgroups_np = _setwgroups_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.UnsignedChar>)>();

  int strtofflags(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.UnsignedLong> arg1,
    ffi.Pointer<ffi.UnsignedLong> arg2,
  ) {
    return _strtofflags(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _strtofflagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Pointer<ffi.UnsignedLong>)>>('strtofflags');
  late final _strtofflags = _strtofflagsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.UnsignedLong>, ffi.Pointer<ffi.UnsignedLong>)>();

  int swapon(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _swapon(
      arg0,
    );
  }

  late final _swaponPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'swapon');
  late final _swapon =
      _swaponPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int ttyslot() {
    return _ttyslot();
  }

  late final _ttyslotPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('ttyslot');
  late final _ttyslot = _ttyslotPtr.asFunction<int Function()>();

  int undelete(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _undelete(
      arg0,
    );
  }

  late final _undeletePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'undelete');
  late final _undelete =
      _undeletePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int unwhiteout(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unwhiteout(
      arg0,
    );
  }

  late final _unwhiteoutPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unwhiteout');
  late final _unwhiteout =
      _unwhiteoutPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int syscall(
    int arg0,
  ) {
    return _syscall(
      arg0,
    );
  }

  late final _syscallPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('syscall');
  late final _syscall = _syscallPtr.asFunction<int Function(int)>();

  int fgetattrlist(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    int arg4,
  ) {
    return _fgetattrlist(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _fgetattrlistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.UnsignedInt)>>('fgetattrlist');
  late final _fgetattrlist = _fgetattrlistPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  int fsetattrlist(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    int arg4,
  ) {
    return _fsetattrlist(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _fsetattrlistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.UnsignedInt)>>('fsetattrlist');
  late final _fsetattrlist = _fsetattrlistPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  int getattrlist(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    int arg4,
  ) {
    return _getattrlist(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _getattrlistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.UnsignedInt)>>('getattrlist');
  late final _getattrlist = _getattrlistPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int)>();

  int setattrlist(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    int arg4,
  ) {
    return _setattrlist(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _setattrlistPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.UnsignedInt)>>('setattrlist');
  late final _setattrlist = _setattrlistPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int)>();

  int exchangedata(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _exchangedata(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _exchangedataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('exchangedata');
  late final _exchangedata = _exchangedataPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int getdirentriesattr(
    int arg0,
    ffi.Pointer<ffi.Void> arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
    ffi.Pointer<ffi.UnsignedInt> arg4,
    ffi.Pointer<ffi.UnsignedInt> arg5,
    ffi.Pointer<ffi.UnsignedInt> arg6,
    int arg7,
  ) {
    return _getdirentriesattr(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
      arg6,
      arg7,
    );
  }

  late final _getdirentriesattrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.UnsignedInt)>>('getdirentriesattr');
  late final _getdirentriesattr = _getdirentriesattrPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>,
          int)>();

  int searchfs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<fssearchblock> arg1,
    ffi.Pointer<ffi.UnsignedLong> arg2,
    int arg3,
    int arg4,
    ffi.Pointer<searchstate> arg5,
  ) {
    return _searchfs(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final _searchfsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<fssearchblock>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<searchstate>)>>('searchfs');
  late final _searchfs = _searchfsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<fssearchblock>,
          ffi.Pointer<ffi.UnsignedLong>, int, int, ffi.Pointer<searchstate>)>();

  int fsctl(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
  ) {
    return _fsctl(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _fsctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedLong,
              ffi.Pointer<ffi.Void>, ffi.UnsignedInt)>>('fsctl');
  late final _fsctl = _fsctlPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Void>, int)>();

  int ffsctl(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Void> arg2,
    int arg3,
  ) {
    return _ffsctl(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ffsctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.UnsignedLong, ffi.Pointer<ffi.Void>,
              ffi.UnsignedInt)>>('ffsctl');
  late final _ffsctl = _ffsctlPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Void>, int)>();

  int fsync_volume_np(
    int arg0,
    int arg1,
  ) {
    return _fsync_volume_np(
      arg0,
      arg1,
    );
  }

  late final _fsync_volume_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'fsync_volume_np');
  late final _fsync_volume_np =
      _fsync_volume_npPtr.asFunction<int Function(int, int)>();

  int sync_volume_np(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _sync_volume_np(
      arg0,
      arg1,
    );
  }

  late final _sync_volume_npPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'sync_volume_np');
  late final _sync_volume_np =
      _sync_volume_npPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  late final ffi.Pointer<ffi.Int> _optreset = _lookup<ffi.Int>('optreset');

  int get optreset => _optreset.value;

  set optreset(int value) => _optreset.value = value;

  int open(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _open(
      arg0,
      arg1,
    );
  }

  late final _openPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'open');
  late final _open =
      _openPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int openat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _openat(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _openatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('openat');
  late final _openat =
      _openatPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int creat(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _creat(
      arg0,
      arg1,
    );
  }

  late final _creatPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, mode_t)>>(
      'creat');
  late final _creat =
      _creatPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int fcntl(
    int arg0,
    int arg1,
  ) {
    return _fcntl(
      arg0,
      arg1,
    );
  }

  late final _fcntlPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('fcntl');
  late final _fcntl = _fcntlPtr.asFunction<int Function(int, int)>();

  int openx_np(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    filesec_t arg2,
  ) {
    return _openx_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _openx_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Int, filesec_t)>>('openx_np');
  late final _openx_np = _openx_npPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, filesec_t)>();

  int open_dprotected_np(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
  ) {
    return _open_dprotected_np(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _open_dprotected_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int,
              ffi.Int)>>('open_dprotected_np');
  late final _open_dprotected_np = _open_dprotected_npPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  int openat_dprotected_np(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
    int arg4,
  ) {
    return _openat_dprotected_np(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _openat_dprotected_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int,
              ffi.Int)>>('openat_dprotected_np');
  late final _openat_dprotected_np = _openat_dprotected_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int, int)>();

  int openat_authenticated_np(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
  ) {
    return _openat_authenticated_np(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _openat_authenticated_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int)>>('openat_authenticated_np');
  late final _openat_authenticated_np = _openat_authenticated_npPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  int flock1(
    int arg0,
    int arg1,
  ) {
    return _flock1(
      arg0,
      arg1,
    );
  }

  late final _flock1Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('flock');
  late final _flock1 = _flock1Ptr.asFunction<int Function(int, int)>();

  filesec_t filesec_init() {
    return _filesec_init();
  }

  late final _filesec_initPtr =
      _lookup<ffi.NativeFunction<filesec_t Function()>>('filesec_init');
  late final _filesec_init =
      _filesec_initPtr.asFunction<filesec_t Function()>();

  filesec_t filesec_dup(
    filesec_t arg0,
  ) {
    return _filesec_dup(
      arg0,
    );
  }

  late final _filesec_dupPtr =
      _lookup<ffi.NativeFunction<filesec_t Function(filesec_t)>>('filesec_dup');
  late final _filesec_dup =
      _filesec_dupPtr.asFunction<filesec_t Function(filesec_t)>();

  void filesec_free(
    filesec_t arg0,
  ) {
    return _filesec_free(
      arg0,
    );
  }

  late final _filesec_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(filesec_t)>>('filesec_free');
  late final _filesec_free =
      _filesec_freePtr.asFunction<void Function(filesec_t)>();

  int filesec_get_property(
    filesec_t arg0,
    filesec_property_t arg1,
    ffi.Pointer<ffi.Void> arg2,
  ) {
    return _filesec_get_property(
      arg0,
      arg1.value,
      arg2,
    );
  }

  late final _filesec_get_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(filesec_t, ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>)>>('filesec_get_property');
  late final _filesec_get_property = _filesec_get_propertyPtr
      .asFunction<int Function(filesec_t, int, ffi.Pointer<ffi.Void>)>();

  int filesec_query_property(
    filesec_t arg0,
    filesec_property_t arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return _filesec_query_property(
      arg0,
      arg1.value,
      arg2,
    );
  }

  late final _filesec_query_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(filesec_t, ffi.UnsignedInt,
              ffi.Pointer<ffi.Int>)>>('filesec_query_property');
  late final _filesec_query_property = _filesec_query_propertyPtr
      .asFunction<int Function(filesec_t, int, ffi.Pointer<ffi.Int>)>();

  int filesec_set_property(
    filesec_t arg0,
    filesec_property_t arg1,
    ffi.Pointer<ffi.Void> arg2,
  ) {
    return _filesec_set_property(
      arg0,
      arg1.value,
      arg2,
    );
  }

  late final _filesec_set_propertyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(filesec_t, ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>)>>('filesec_set_property');
  late final _filesec_set_property = _filesec_set_propertyPtr
      .asFunction<int Function(filesec_t, int, ffi.Pointer<ffi.Void>)>();

  int filesec_unset_property(
    filesec_t arg0,
    filesec_property_t arg1,
  ) {
    return _filesec_unset_property(
      arg0,
      arg1.value,
    );
  }

  late final _filesec_unset_propertyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(filesec_t, ffi.UnsignedInt)>>(
          'filesec_unset_property');
  late final _filesec_unset_property =
      _filesec_unset_propertyPtr.asFunction<int Function(filesec_t, int)>();

  int os_workgroup_copy_port(
    Dartos_workgroup_t wg,
    ffi.Pointer<mach_port_t> mach_port_out,
  ) {
    return _os_workgroup_copy_port(
      wg.ref.pointer,
      mach_port_out,
    );
  }

  late final _os_workgroup_copy_portPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(os_workgroup_t,
              ffi.Pointer<mach_port_t>)>>('os_workgroup_copy_port');
  late final _os_workgroup_copy_port = _os_workgroup_copy_portPtr
      .asFunction<int Function(os_workgroup_t, ffi.Pointer<mach_port_t>)>();

  Dartos_workgroup_t? os_workgroup_create_with_port(
    ffi.Pointer<ffi.Char> name,
    Dart__darwin_natural_t mach_port,
  ) {
    return _os_workgroup_create_with_port(
              name,
              mach_port,
            ).address ==
            0
        ? null
        : OS_os_workgroup.castFromPointer(
            _os_workgroup_create_with_port(
              name,
              mach_port,
            ),
            retain: false,
            release: true);
  }

  late final _os_workgroup_create_with_portPtr = _lookup<
      ffi.NativeFunction<
          os_workgroup_t Function(ffi.Pointer<ffi.Char>,
              mach_port_t)>>('os_workgroup_create_with_port');
  late final _os_workgroup_create_with_port = _os_workgroup_create_with_portPtr
      .asFunction<os_workgroup_t Function(ffi.Pointer<ffi.Char>, int)>();

  Dartos_workgroup_t? os_workgroup_create_with_workgroup(
    ffi.Pointer<ffi.Char> name,
    Dartos_workgroup_t wg,
  ) {
    return _os_workgroup_create_with_workgroup(
              name,
              wg.ref.pointer,
            ).address ==
            0
        ? null
        : OS_os_workgroup.castFromPointer(
            _os_workgroup_create_with_workgroup(
              name,
              wg.ref.pointer,
            ),
            retain: false,
            release: true);
  }

  late final _os_workgroup_create_with_workgroupPtr = _lookup<
      ffi.NativeFunction<
          os_workgroup_t Function(ffi.Pointer<ffi.Char>,
              os_workgroup_t)>>('os_workgroup_create_with_workgroup');
  late final _os_workgroup_create_with_workgroup =
      _os_workgroup_create_with_workgroupPtr.asFunction<
          os_workgroup_t Function(ffi.Pointer<ffi.Char>, os_workgroup_t)>();

  int os_workgroup_join(
    Dartos_workgroup_t wg,
    os_workgroup_join_token_t token_out,
  ) {
    return _os_workgroup_join(
      wg.ref.pointer,
      token_out,
    );
  }

  late final _os_workgroup_joinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              os_workgroup_t, os_workgroup_join_token_t)>>('os_workgroup_join');
  late final _os_workgroup_join = _os_workgroup_joinPtr
      .asFunction<int Function(os_workgroup_t, os_workgroup_join_token_t)>();

  void os_workgroup_leave(
    Dartos_workgroup_t wg,
    os_workgroup_join_token_t token,
  ) {
    return _os_workgroup_leave(
      wg.ref.pointer,
      token,
    );
  }

  late final _os_workgroup_leavePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(os_workgroup_t,
              os_workgroup_join_token_t)>>('os_workgroup_leave');
  late final _os_workgroup_leave = _os_workgroup_leavePtr
      .asFunction<void Function(os_workgroup_t, os_workgroup_join_token_t)>();

  int os_workgroup_set_working_arena(
    Dartos_workgroup_t wg,
    ffi.Pointer<ffi.Void> arena,
    int max_workers,
    os_workgroup_working_arena_destructor_t destructor,
  ) {
    return _os_workgroup_set_working_arena(
      wg.ref.pointer,
      arena,
      max_workers,
      destructor,
    );
  }

  late final _os_workgroup_set_working_arenaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(os_workgroup_t, ffi.Pointer<ffi.Void>,
                  ffi.Uint32, os_workgroup_working_arena_destructor_t)>>(
      'os_workgroup_set_working_arena');
  late final _os_workgroup_set_working_arena =
      _os_workgroup_set_working_arenaPtr.asFunction<
          int Function(os_workgroup_t, ffi.Pointer<ffi.Void>, int,
              os_workgroup_working_arena_destructor_t)>();

  ffi.Pointer<ffi.Void> os_workgroup_get_working_arena(
    Dartos_workgroup_t wg,
    ffi.Pointer<os_workgroup_index> index_out,
  ) {
    return _os_workgroup_get_working_arena(
      wg.ref.pointer,
      index_out,
    );
  }

  late final _os_workgroup_get_working_arenaPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  os_workgroup_t, ffi.Pointer<os_workgroup_index>)>>(
      'os_workgroup_get_working_arena');
  late final _os_workgroup_get_working_arena =
      _os_workgroup_get_working_arenaPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              os_workgroup_t, ffi.Pointer<os_workgroup_index>)>();

  void os_workgroup_cancel(
    Dartos_workgroup_t wg,
  ) {
    return _os_workgroup_cancel(
      wg.ref.pointer,
    );
  }

  late final _os_workgroup_cancelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(os_workgroup_t)>>(
          'os_workgroup_cancel');
  late final _os_workgroup_cancel =
      _os_workgroup_cancelPtr.asFunction<void Function(os_workgroup_t)>();

  bool os_workgroup_testcancel(
    Dartos_workgroup_t wg,
  ) {
    return _os_workgroup_testcancel(
      wg.ref.pointer,
    );
  }

  late final _os_workgroup_testcancelPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(os_workgroup_t)>>(
          'os_workgroup_testcancel');
  late final _os_workgroup_testcancel =
      _os_workgroup_testcancelPtr.asFunction<bool Function(os_workgroup_t)>();

  int os_workgroup_max_parallel_threads(
    Dartos_workgroup_t wg,
    os_workgroup_mpt_attr_t attr,
  ) {
    return _os_workgroup_max_parallel_threads(
      wg.ref.pointer,
      attr,
    );
  }

  late final _os_workgroup_max_parallel_threadsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(os_workgroup_t,
              os_workgroup_mpt_attr_t)>>('os_workgroup_max_parallel_threads');
  late final _os_workgroup_max_parallel_threads =
      _os_workgroup_max_parallel_threadsPtr
          .asFunction<int Function(os_workgroup_t, os_workgroup_mpt_attr_t)>();

  int os_workgroup_interval_start(
    Dartos_workgroup_interval_t wg,
    int start,
    int deadline,
    os_workgroup_interval_data_t data,
  ) {
    return _os_workgroup_interval_start(
      wg.ref.pointer,
      start,
      deadline,
      data,
    );
  }

  late final _os_workgroup_interval_startPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(os_workgroup_interval_t, ffi.Uint64, ffi.Uint64,
              os_workgroup_interval_data_t)>>('os_workgroup_interval_start');
  late final _os_workgroup_interval_start =
      _os_workgroup_interval_startPtr.asFunction<
          int Function(os_workgroup_interval_t, int, int,
              os_workgroup_interval_data_t)>();

  int os_workgroup_interval_update(
    Dartos_workgroup_interval_t wg,
    int deadline,
    os_workgroup_interval_data_t data,
  ) {
    return _os_workgroup_interval_update(
      wg.ref.pointer,
      deadline,
      data,
    );
  }

  late final _os_workgroup_interval_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(os_workgroup_interval_t, ffi.Uint64,
              os_workgroup_interval_data_t)>>('os_workgroup_interval_update');
  late final _os_workgroup_interval_update =
      _os_workgroup_interval_updatePtr.asFunction<
          int Function(
              os_workgroup_interval_t, int, os_workgroup_interval_data_t)>();

  int os_workgroup_interval_finish(
    Dartos_workgroup_interval_t wg,
    os_workgroup_interval_data_t data,
  ) {
    return _os_workgroup_interval_finish(
      wg.ref.pointer,
      data,
    );
  }

  late final _os_workgroup_interval_finishPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(os_workgroup_interval_t,
              os_workgroup_interval_data_t)>>('os_workgroup_interval_finish');
  late final _os_workgroup_interval_finish =
      _os_workgroup_interval_finishPtr.asFunction<
          int Function(
              os_workgroup_interval_t, os_workgroup_interval_data_t)>();

  Dartos_workgroup_parallel_t? os_workgroup_parallel_create(
    ffi.Pointer<ffi.Char> name,
    os_workgroup_attr_t attr,
  ) {
    return _os_workgroup_parallel_create(
              name,
              attr,
            ).address ==
            0
        ? null
        : OS_os_workgroup.castFromPointer(
            _os_workgroup_parallel_create(
              name,
              attr,
            ),
            retain: false,
            release: true);
  }

  late final _os_workgroup_parallel_createPtr = _lookup<
      ffi.NativeFunction<
          os_workgroup_parallel_t Function(ffi.Pointer<ffi.Char>,
              os_workgroup_attr_t)>>('os_workgroup_parallel_create');
  late final _os_workgroup_parallel_create =
      _os_workgroup_parallel_createPtr.asFunction<
          os_workgroup_parallel_t Function(
              ffi.Pointer<ffi.Char>, os_workgroup_attr_t)>();

  int dispatch_time(
    int when,
    int delta,
  ) {
    return _dispatch_time(
      when,
      delta,
    );
  }

  late final _dispatch_timePtr = _lookup<
      ffi.NativeFunction<
          dispatch_time_t Function(
              dispatch_time_t, ffi.Int64)>>('dispatch_time');
  late final _dispatch_time =
      _dispatch_timePtr.asFunction<int Function(int, int)>();

  int dispatch_walltime(
    ffi.Pointer<timespec> when,
    int delta,
  ) {
    return _dispatch_walltime(
      when,
      delta,
    );
  }

  late final _dispatch_walltimePtr = _lookup<
      ffi.NativeFunction<
          dispatch_time_t Function(
              ffi.Pointer<timespec>, ffi.Int64)>>('dispatch_walltime');
  late final _dispatch_walltime = _dispatch_walltimePtr
      .asFunction<int Function(ffi.Pointer<timespec>, int)>();

  qos_class_t qos_class_self() {
    return qos_class_t.fromValue(_qos_class_self());
  }

  late final _qos_class_selfPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>('qos_class_self');
  late final _qos_class_self = _qos_class_selfPtr.asFunction<int Function()>();

  qos_class_t qos_class_main() {
    return qos_class_t.fromValue(_qos_class_main());
  }

  late final _qos_class_mainPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>('qos_class_main');
  late final _qos_class_main = _qos_class_mainPtr.asFunction<int Function()>();

  void dispatch_retain(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_retain(
      object.ref.pointer,
    );
  }

  late final _dispatch_retainPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_object_t)>>(
          'dispatch_retain');
  late final _dispatch_retain =
      _dispatch_retainPtr.asFunction<void Function(dispatch_object_t)>();

  void dispatch_release(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_release(
      object.ref.pointer,
    );
  }

  late final _dispatch_releasePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_object_t)>>(
          'dispatch_release');
  late final _dispatch_release =
      _dispatch_releasePtr.asFunction<void Function(dispatch_object_t)>();

  ffi.Pointer<ffi.Void> dispatch_get_context(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_get_context(
      object.ref.pointer,
    );
  }

  late final _dispatch_get_contextPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ffi.Void> Function(dispatch_object_t)>>(
      'dispatch_get_context');
  late final _dispatch_get_context = _dispatch_get_contextPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(dispatch_object_t)>();

  void dispatch_set_context(
    Dartdispatch_object_t object,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _dispatch_set_context(
      object.ref.pointer,
      context,
    );
  }

  late final _dispatch_set_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_object_t,
              ffi.Pointer<ffi.Void>)>>('dispatch_set_context');
  late final _dispatch_set_context = _dispatch_set_contextPtr
      .asFunction<void Function(dispatch_object_t, ffi.Pointer<ffi.Void>)>();

  void dispatch_set_finalizer_f(
    Dartdispatch_object_t object,
    dispatch_function_t finalizer,
  ) {
    return _dispatch_set_finalizer_f(
      object.ref.pointer,
      finalizer,
    );
  }

  late final _dispatch_set_finalizer_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_object_t,
              dispatch_function_t)>>('dispatch_set_finalizer_f');
  late final _dispatch_set_finalizer_f = _dispatch_set_finalizer_fPtr
      .asFunction<void Function(dispatch_object_t, dispatch_function_t)>();

  void dispatch_activate(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_activate(
      object.ref.pointer,
    );
  }

  late final _dispatch_activatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_object_t)>>(
          'dispatch_activate');
  late final _dispatch_activate =
      _dispatch_activatePtr.asFunction<void Function(dispatch_object_t)>();

  void dispatch_suspend(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_suspend(
      object.ref.pointer,
    );
  }

  late final _dispatch_suspendPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_object_t)>>(
          'dispatch_suspend');
  late final _dispatch_suspend =
      _dispatch_suspendPtr.asFunction<void Function(dispatch_object_t)>();

  void dispatch_resume(
    Dartdispatch_object_t object,
  ) {
    return _dispatch_resume(
      object.ref.pointer,
    );
  }

  late final _dispatch_resumePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_object_t)>>(
          'dispatch_resume');
  late final _dispatch_resume =
      _dispatch_resumePtr.asFunction<void Function(dispatch_object_t)>();

  void dispatch_set_qos_class_floor(
    Dartdispatch_object_t object,
    qos_class_t qos_class,
    int relative_priority,
  ) {
    return _dispatch_set_qos_class_floor(
      object.ref.pointer,
      qos_class.value,
      relative_priority,
    );
  }

  late final _dispatch_set_qos_class_floorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_object_t, ffi.UnsignedInt,
              ffi.Int)>>('dispatch_set_qos_class_floor');
  late final _dispatch_set_qos_class_floor = _dispatch_set_qos_class_floorPtr
      .asFunction<void Function(dispatch_object_t, int, int)>();

  int dispatch_wait(
    ffi.Pointer<ffi.Void> object,
    int timeout,
  ) {
    return _dispatch_wait(
      object,
      timeout,
    );
  }

  late final _dispatch_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<ffi.Void>, dispatch_time_t)>>('dispatch_wait');
  late final _dispatch_wait =
      _dispatch_waitPtr.asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  void dispatch_notify(
    ffi.Pointer<ffi.Void> object,
    Dartdispatch_object_t queue,
    Dartdispatch_block_t notification_block,
  ) {
    return _dispatch_notify(
      object,
      queue.ref.pointer,
      notification_block.ref.pointer,
    );
  }

  late final _dispatch_notifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, dispatch_object_t,
              dispatch_block_t)>>('dispatch_notify');
  late final _dispatch_notify = _dispatch_notifyPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>, dispatch_object_t, dispatch_block_t)>();

  void dispatch_cancel(
    ffi.Pointer<ffi.Void> object,
  ) {
    return _dispatch_cancel(
      object,
    );
  }

  late final _dispatch_cancelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'dispatch_cancel');
  late final _dispatch_cancel =
      _dispatch_cancelPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  int dispatch_testcancel(
    ffi.Pointer<ffi.Void> object,
  ) {
    return _dispatch_testcancel(
      object,
    );
  }

  late final _dispatch_testcancelPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(ffi.Pointer<ffi.Void>)>>(
          'dispatch_testcancel');
  late final _dispatch_testcancel =
      _dispatch_testcancelPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  void dispatch_debug(
    Dartdispatch_object_t object,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _dispatch_debug(
      object.ref.pointer,
      message,
    );
  }

  late final _dispatch_debugPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_object_t, ffi.Pointer<ffi.Char>)>>('dispatch_debug');
  late final _dispatch_debug = _dispatch_debugPtr
      .asFunction<void Function(dispatch_object_t, ffi.Pointer<ffi.Char>)>();

  void dispatch_debugv(
    Dartdispatch_object_t object,
    ffi.Pointer<ffi.Char> message,
    va_list ap,
  ) {
    return _dispatch_debugv(
      object.ref.pointer,
      message,
      ap,
    );
  }

  late final _dispatch_debugvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_object_t, ffi.Pointer<ffi.Char>,
              va_list)>>('dispatch_debugv');
  late final _dispatch_debugv = _dispatch_debugvPtr.asFunction<
      void Function(dispatch_object_t, ffi.Pointer<ffi.Char>, va_list)>();

  void dispatch_async(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_async(
      queue.ref.pointer,
      block.ref.pointer,
    );
  }

  late final _dispatch_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t, dispatch_block_t)>>('dispatch_async');
  late final _dispatch_async = _dispatch_asyncPtr
      .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_async_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_async_f(
      queue.ref.pointer,
      context,
      work,
    );
  }

  late final _dispatch_async_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_async_f');
  late final _dispatch_async_f = _dispatch_async_fPtr.asFunction<
      void Function(
          dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_sync(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_sync(
      queue.ref.pointer,
      block.ref.pointer,
    );
  }

  late final _dispatch_syncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t, dispatch_block_t)>>('dispatch_sync');
  late final _dispatch_sync = _dispatch_syncPtr
      .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_sync_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_sync_f(
      queue.ref.pointer,
      context,
      work,
    );
  }

  late final _dispatch_sync_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_sync_f');
  late final _dispatch_sync_f = _dispatch_sync_fPtr.asFunction<
      void Function(
          dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_async_and_wait(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_async_and_wait(
      queue.ref.pointer,
      block.ref.pointer,
    );
  }

  late final _dispatch_async_and_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t, dispatch_block_t)>>('dispatch_async_and_wait');
  late final _dispatch_async_and_wait = _dispatch_async_and_waitPtr
      .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_async_and_wait_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_async_and_wait_f(
      queue.ref.pointer,
      context,
      work,
    );
  }

  late final _dispatch_async_and_wait_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_async_and_wait_f');
  late final _dispatch_async_and_wait_f =
      _dispatch_async_and_wait_fPtr.asFunction<
          void Function(
              dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_apply(
    int iterations,
    Dartdispatch_queue_t? queue,
    objc.ObjCBlock<ffi.Void Function(ffi.Size)> block,
  ) {
    return _dispatch_apply(
      iterations,
      queue?.ref.pointer ?? ffi.nullptr,
      block.ref.pointer,
    );
  }

  late final _dispatch_applyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Size, dispatch_queue_t,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('dispatch_apply');
  late final _dispatch_apply = _dispatch_applyPtr.asFunction<
      void Function(int, dispatch_queue_t, ffi.Pointer<objc.ObjCBlockImpl>)>();

  void dispatch_apply_f(
    int iterations,
    Dartdispatch_queue_t? queue,
    ffi.Pointer<ffi.Void> context,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> context, ffi.Size iteration)>>
        work,
  ) {
    return _dispatch_apply_f(
      iterations,
      queue?.ref.pointer ?? ffi.nullptr,
      context,
      work,
    );
  }

  late final _dispatch_apply_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Size,
              dispatch_queue_t,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> context,
                          ffi.Size iteration)>>)>>('dispatch_apply_f');
  late final _dispatch_apply_f = _dispatch_apply_fPtr.asFunction<
      void Function(
          int,
          dispatch_queue_t,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void> context, ffi.Size iteration)>>)>();

  Dartdispatch_queue_t dispatch_get_current_queue() {
    return objc.NSObject.castFromPointer(_dispatch_get_current_queue(),
        retain: true, release: true);
  }

  late final _dispatch_get_current_queuePtr =
      _lookup<ffi.NativeFunction<dispatch_queue_t Function()>>(
          'dispatch_get_current_queue');
  late final _dispatch_get_current_queue =
      _dispatch_get_current_queuePtr.asFunction<dispatch_queue_t Function()>();

  late final ffi.Pointer<dispatch_queue_s> __dispatch_main_q =
      _lookup<dispatch_queue_s>('_dispatch_main_q');

  ffi.Pointer<dispatch_queue_s> get _dispatch_main_q => __dispatch_main_q;

  Dartdispatch_queue_global_t dispatch_get_global_queue(
    int identifier,
    int flags,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_get_global_queue(
          identifier,
          flags,
        ),
        retain: true,
        release: true);
  }

  late final _dispatch_get_global_queuePtr = _lookup<
      ffi.NativeFunction<
          dispatch_queue_global_t Function(
              ffi.IntPtr, ffi.UintPtr)>>('dispatch_get_global_queue');
  late final _dispatch_get_global_queue = _dispatch_get_global_queuePtr
      .asFunction<dispatch_queue_global_t Function(int, int)>();

  late final ffi.Pointer<dispatch_queue_attr_s>
      __dispatch_queue_attr_concurrent =
      _lookup<dispatch_queue_attr_s>('_dispatch_queue_attr_concurrent');

  ffi.Pointer<dispatch_queue_attr_s> get _dispatch_queue_attr_concurrent =>
      __dispatch_queue_attr_concurrent;

  Dartdispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(
    Dartdispatch_queue_attr_t? attr,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_queue_attr_make_initially_inactive(
          attr?.ref.pointer ?? ffi.nullptr,
        ),
        retain: true,
        release: true);
  }

  late final _dispatch_queue_attr_make_initially_inactivePtr = _lookup<
          ffi.NativeFunction<
              dispatch_queue_attr_t Function(dispatch_queue_attr_t)>>(
      'dispatch_queue_attr_make_initially_inactive');
  late final _dispatch_queue_attr_make_initially_inactive =
      _dispatch_queue_attr_make_initially_inactivePtr
          .asFunction<dispatch_queue_attr_t Function(dispatch_queue_attr_t)>();

  Dartdispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(
    Dartdispatch_queue_attr_t? attr,
    dispatch_autorelease_frequency_t frequency,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_queue_attr_make_with_autorelease_frequency(
          attr?.ref.pointer ?? ffi.nullptr,
          frequency.value,
        ),
        retain: true,
        release: true);
  }

  late final _dispatch_queue_attr_make_with_autorelease_frequencyPtr = _lookup<
          ffi.NativeFunction<
              dispatch_queue_attr_t Function(
                  dispatch_queue_attr_t, ffi.UnsignedLong)>>(
      'dispatch_queue_attr_make_with_autorelease_frequency');
  late final _dispatch_queue_attr_make_with_autorelease_frequency =
      _dispatch_queue_attr_make_with_autorelease_frequencyPtr.asFunction<
          dispatch_queue_attr_t Function(dispatch_queue_attr_t, int)>();

  Dartdispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(
    Dartdispatch_queue_attr_t? attr,
    qos_class_t qos_class,
    int relative_priority,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_queue_attr_make_with_qos_class(
          attr?.ref.pointer ?? ffi.nullptr,
          qos_class.value,
          relative_priority,
        ),
        retain: true,
        release: true);
  }

  late final _dispatch_queue_attr_make_with_qos_classPtr = _lookup<
      ffi.NativeFunction<
          dispatch_queue_attr_t Function(dispatch_queue_attr_t, ffi.UnsignedInt,
              ffi.Int)>>('dispatch_queue_attr_make_with_qos_class');
  late final _dispatch_queue_attr_make_with_qos_class =
      _dispatch_queue_attr_make_with_qos_classPtr.asFunction<
          dispatch_queue_attr_t Function(dispatch_queue_attr_t, int, int)>();

  Dartdispatch_queue_t dispatch_queue_create_with_target(
    ffi.Pointer<ffi.Char> label,
    Dartdispatch_queue_attr_t? attr,
    Dartdispatch_queue_t? target,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_queue_create_with_target(
          label,
          attr?.ref.pointer ?? ffi.nullptr,
          target?.ref.pointer ?? ffi.nullptr,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_queue_create_with_targetPtr = _lookup<
      ffi.NativeFunction<
          dispatch_queue_t Function(
              ffi.Pointer<ffi.Char>,
              dispatch_queue_attr_t,
              dispatch_queue_t)>>('dispatch_queue_create_with_target');
  late final _dispatch_queue_create_with_target =
      _dispatch_queue_create_with_targetPtr.asFunction<
          dispatch_queue_t Function(ffi.Pointer<ffi.Char>,
              dispatch_queue_attr_t, dispatch_queue_t)>();

  Dartdispatch_queue_t dispatch_queue_create(
    ffi.Pointer<ffi.Char> label,
    Dartdispatch_queue_attr_t? attr,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_queue_create(
          label,
          attr?.ref.pointer ?? ffi.nullptr,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_queue_createPtr = _lookup<
      ffi.NativeFunction<
          dispatch_queue_t Function(ffi.Pointer<ffi.Char>,
              dispatch_queue_attr_t)>>('dispatch_queue_create');
  late final _dispatch_queue_create = _dispatch_queue_createPtr.asFunction<
      dispatch_queue_t Function(
          ffi.Pointer<ffi.Char>, dispatch_queue_attr_t)>();

  ffi.Pointer<ffi.Char> dispatch_queue_get_label(
    Dartdispatch_queue_t? queue,
  ) {
    return _dispatch_queue_get_label(
      queue?.ref.pointer ?? ffi.nullptr,
    );
  }

  late final _dispatch_queue_get_labelPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(dispatch_queue_t)>>(
      'dispatch_queue_get_label');
  late final _dispatch_queue_get_label = _dispatch_queue_get_labelPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(dispatch_queue_t)>();

  qos_class_t dispatch_queue_get_qos_class(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Int> relative_priority_ptr,
  ) {
    return qos_class_t.fromValue(_dispatch_queue_get_qos_class(
      queue.ref.pointer,
      relative_priority_ptr,
    ));
  }

  late final _dispatch_queue_get_qos_classPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(dispatch_queue_t,
              ffi.Pointer<ffi.Int>)>>('dispatch_queue_get_qos_class');
  late final _dispatch_queue_get_qos_class = _dispatch_queue_get_qos_classPtr
      .asFunction<int Function(dispatch_queue_t, ffi.Pointer<ffi.Int>)>();

  void dispatch_set_target_queue(
    Dartdispatch_object_t object,
    Dartdispatch_queue_t? queue,
  ) {
    return _dispatch_set_target_queue(
      object.ref.pointer,
      queue?.ref.pointer ?? ffi.nullptr,
    );
  }

  late final _dispatch_set_target_queuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_object_t,
              dispatch_queue_t)>>('dispatch_set_target_queue');
  late final _dispatch_set_target_queue = _dispatch_set_target_queuePtr
      .asFunction<void Function(dispatch_object_t, dispatch_queue_t)>();

  void dispatch_main() {
    return _dispatch_main();
  }

  late final _dispatch_mainPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('dispatch_main');
  late final _dispatch_main = _dispatch_mainPtr.asFunction<void Function()>();

  void dispatch_after(
    Dartdispatch_time_t when,
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_after(
      when,
      queue.ref.pointer,
      block.ref.pointer,
    );
  }

  late final _dispatch_afterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_time_t, dispatch_queue_t,
              dispatch_block_t)>>('dispatch_after');
  late final _dispatch_after = _dispatch_afterPtr
      .asFunction<void Function(int, dispatch_queue_t, dispatch_block_t)>();

  void dispatch_after_f(
    Dartdispatch_time_t when,
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_after_f(
      when,
      queue.ref.pointer,
      context,
      work,
    );
  }

  late final _dispatch_after_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_time_t, dispatch_queue_t,
              ffi.Pointer<ffi.Void>, dispatch_function_t)>>('dispatch_after_f');
  late final _dispatch_after_f = _dispatch_after_fPtr.asFunction<
      void Function(
          int, dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_barrier_async(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_barrier_async(
      queue.ref.pointer,
      block.ref.pointer,
    );
  }

  late final _dispatch_barrier_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t, dispatch_block_t)>>('dispatch_barrier_async');
  late final _dispatch_barrier_async = _dispatch_barrier_asyncPtr
      .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_barrier_async_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_barrier_async_f(
      queue.ref.pointer,
      context,
      work,
    );
  }

  late final _dispatch_barrier_async_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_barrier_async_f');
  late final _dispatch_barrier_async_f =
      _dispatch_barrier_async_fPtr.asFunction<
          void Function(
              dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_barrier_sync(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_barrier_sync(
      queue.ref.pointer,
      block.ref.pointer,
    );
  }

  late final _dispatch_barrier_syncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t, dispatch_block_t)>>('dispatch_barrier_sync');
  late final _dispatch_barrier_sync = _dispatch_barrier_syncPtr
      .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_barrier_sync_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_barrier_sync_f(
      queue.ref.pointer,
      context,
      work,
    );
  }

  late final _dispatch_barrier_sync_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_barrier_sync_f');
  late final _dispatch_barrier_sync_f = _dispatch_barrier_sync_fPtr.asFunction<
      void Function(
          dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_barrier_async_and_wait(
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_barrier_async_and_wait(
      queue.ref.pointer,
      block.ref.pointer,
    );
  }

  late final _dispatch_barrier_async_and_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t,
              dispatch_block_t)>>('dispatch_barrier_async_and_wait');
  late final _dispatch_barrier_async_and_wait =
      _dispatch_barrier_async_and_waitPtr
          .asFunction<void Function(dispatch_queue_t, dispatch_block_t)>();

  void dispatch_barrier_async_and_wait_f(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_barrier_async_and_wait_f(
      queue.ref.pointer,
      context,
      work,
    );
  }

  late final _dispatch_barrier_async_and_wait_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_barrier_async_and_wait_f');
  late final _dispatch_barrier_async_and_wait_f =
      _dispatch_barrier_async_and_wait_fPtr.asFunction<
          void Function(
              dispatch_queue_t, ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  void dispatch_queue_set_specific(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t destructor,
  ) {
    return _dispatch_queue_set_specific(
      queue.ref.pointer,
      key,
      context,
      destructor,
    );
  }

  late final _dispatch_queue_set_specificPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_queue_t,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_queue_set_specific');
  late final _dispatch_queue_set_specific =
      _dispatch_queue_set_specificPtr.asFunction<
          void Function(dispatch_queue_t, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, dispatch_function_t)>();

  ffi.Pointer<ffi.Void> dispatch_queue_get_specific(
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> key,
  ) {
    return _dispatch_queue_get_specific(
      queue.ref.pointer,
      key,
    );
  }

  late final _dispatch_queue_get_specificPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(dispatch_queue_t,
              ffi.Pointer<ffi.Void>)>>('dispatch_queue_get_specific');
  late final _dispatch_queue_get_specific =
      _dispatch_queue_get_specificPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              dispatch_queue_t, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> dispatch_get_specific(
    ffi.Pointer<ffi.Void> key,
  ) {
    return _dispatch_get_specific(
      key,
    );
  }

  late final _dispatch_get_specificPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>)>>('dispatch_get_specific');
  late final _dispatch_get_specific = _dispatch_get_specificPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  void dispatch_assert_queue(
    Dartdispatch_queue_t queue,
  ) {
    return _dispatch_assert_queue(
      queue.ref.pointer,
    );
  }

  late final _dispatch_assert_queuePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_queue_t)>>(
          'dispatch_assert_queue');
  late final _dispatch_assert_queue =
      _dispatch_assert_queuePtr.asFunction<void Function(dispatch_queue_t)>();

  void dispatch_assert_queue_barrier(
    Dartdispatch_queue_t queue,
  ) {
    return _dispatch_assert_queue_barrier(
      queue.ref.pointer,
    );
  }

  late final _dispatch_assert_queue_barrierPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_queue_t)>>(
          'dispatch_assert_queue_barrier');
  late final _dispatch_assert_queue_barrier = _dispatch_assert_queue_barrierPtr
      .asFunction<void Function(dispatch_queue_t)>();

  void dispatch_assert_queue_not(
    Dartdispatch_queue_t queue,
  ) {
    return _dispatch_assert_queue_not(
      queue.ref.pointer,
    );
  }

  late final _dispatch_assert_queue_notPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_queue_t)>>(
          'dispatch_assert_queue_not');
  late final _dispatch_assert_queue_not = _dispatch_assert_queue_notPtr
      .asFunction<void Function(dispatch_queue_t)>();

  int dispatch_allow_send_signals(
    int preserve_signum,
  ) {
    return _dispatch_allow_send_signals(
      preserve_signum,
    );
  }

  late final _dispatch_allow_send_signalsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'dispatch_allow_send_signals');
  late final _dispatch_allow_send_signals =
      _dispatch_allow_send_signalsPtr.asFunction<int Function(int)>();

  Dartdispatch_block_t dispatch_block_create(
    dispatch_block_flags_t flags,
    Dartdispatch_block_t block,
  ) {
    return ObjCBlock_ffiVoid.castFromPointer(
        _dispatch_block_create(
          flags.value,
          block.ref.pointer,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_block_createPtr = _lookup<
      ffi.NativeFunction<
          dispatch_block_t Function(
              ffi.UnsignedLong, dispatch_block_t)>>('dispatch_block_create');
  late final _dispatch_block_create = _dispatch_block_createPtr
      .asFunction<dispatch_block_t Function(int, dispatch_block_t)>();

  Dartdispatch_block_t dispatch_block_create_with_qos_class(
    dispatch_block_flags_t flags,
    qos_class_t qos_class,
    int relative_priority,
    Dartdispatch_block_t block,
  ) {
    return ObjCBlock_ffiVoid.castFromPointer(
        _dispatch_block_create_with_qos_class(
          flags.value,
          qos_class.value,
          relative_priority,
          block.ref.pointer,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_block_create_with_qos_classPtr = _lookup<
      ffi.NativeFunction<
          dispatch_block_t Function(ffi.UnsignedLong, ffi.UnsignedInt, ffi.Int,
              dispatch_block_t)>>('dispatch_block_create_with_qos_class');
  late final _dispatch_block_create_with_qos_class =
      _dispatch_block_create_with_qos_classPtr.asFunction<
          dispatch_block_t Function(int, int, int, dispatch_block_t)>();

  void dispatch_block_perform(
    dispatch_block_flags_t flags,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_block_perform(
      flags.value,
      block.ref.pointer,
    );
  }

  late final _dispatch_block_performPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.UnsignedLong, dispatch_block_t)>>('dispatch_block_perform');
  late final _dispatch_block_perform = _dispatch_block_performPtr
      .asFunction<void Function(int, dispatch_block_t)>();

  int dispatch_block_wait(
    Dartdispatch_block_t block,
    Dartdispatch_time_t timeout,
  ) {
    return _dispatch_block_wait(
      block.ref.pointer,
      timeout,
    );
  }

  late final _dispatch_block_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              dispatch_block_t, dispatch_time_t)>>('dispatch_block_wait');
  late final _dispatch_block_wait =
      _dispatch_block_waitPtr.asFunction<int Function(dispatch_block_t, int)>();

  void dispatch_block_notify(
    Dartdispatch_block_t block,
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t notification_block,
  ) {
    return _dispatch_block_notify(
      block.ref.pointer,
      queue.ref.pointer,
      notification_block.ref.pointer,
    );
  }

  late final _dispatch_block_notifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_block_t, dispatch_queue_t,
              dispatch_block_t)>>('dispatch_block_notify');
  late final _dispatch_block_notify = _dispatch_block_notifyPtr.asFunction<
      void Function(dispatch_block_t, dispatch_queue_t, dispatch_block_t)>();

  void dispatch_block_cancel(
    Dartdispatch_block_t block,
  ) {
    return _dispatch_block_cancel(
      block.ref.pointer,
    );
  }

  late final _dispatch_block_cancelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_block_t)>>(
          'dispatch_block_cancel');
  late final _dispatch_block_cancel =
      _dispatch_block_cancelPtr.asFunction<void Function(dispatch_block_t)>();

  int dispatch_block_testcancel(
    Dartdispatch_block_t block,
  ) {
    return _dispatch_block_testcancel(
      block.ref.pointer,
    );
  }

  late final _dispatch_block_testcancelPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(dispatch_block_t)>>(
          'dispatch_block_testcancel');
  late final _dispatch_block_testcancel = _dispatch_block_testcancelPtr
      .asFunction<int Function(dispatch_block_t)>();

  late final ffi.Pointer<security_token_t> _KERNEL_SECURITY_TOKEN =
      _lookup<security_token_t>('KERNEL_SECURITY_TOKEN');

  security_token_t get KERNEL_SECURITY_TOKEN => _KERNEL_SECURITY_TOKEN.ref;

  late final ffi.Pointer<audit_token_t> _KERNEL_AUDIT_TOKEN =
      _lookup<audit_token_t>('KERNEL_AUDIT_TOKEN');

  audit_token_t get KERNEL_AUDIT_TOKEN => _KERNEL_AUDIT_TOKEN.ref;

  int mach_msg_overwrite(
    ffi.Pointer<mach_msg_header_t> msg,
    int option,
    int send_size,
    int rcv_size,
    int rcv_name,
    int timeout,
    int notify,
    ffi.Pointer<mach_msg_header_t> rcv_msg,
    int rcv_limit,
  ) {
    return _mach_msg_overwrite(
      msg,
      option,
      send_size,
      rcv_size,
      rcv_name,
      timeout,
      notify,
      rcv_msg,
      rcv_limit,
    );
  }

  late final _mach_msg_overwritePtr = _lookup<
      ffi.NativeFunction<
          mach_msg_return_t Function(
              ffi.Pointer<mach_msg_header_t>,
              mach_msg_option_t,
              mach_msg_size_t,
              mach_msg_size_t,
              mach_port_name_t,
              mach_msg_timeout_t,
              mach_port_name_t,
              ffi.Pointer<mach_msg_header_t>,
              mach_msg_size_t)>>('mach_msg_overwrite');
  late final _mach_msg_overwrite = _mach_msg_overwritePtr.asFunction<
      int Function(ffi.Pointer<mach_msg_header_t>, int, int, int, int, int, int,
          ffi.Pointer<mach_msg_header_t>, int)>();

  int mach_msg(
    ffi.Pointer<mach_msg_header_t> msg,
    int option,
    int send_size,
    int rcv_size,
    int rcv_name,
    int timeout,
    int notify,
  ) {
    return _mach_msg(
      msg,
      option,
      send_size,
      rcv_size,
      rcv_name,
      timeout,
      notify,
    );
  }

  late final _mach_msgPtr = _lookup<
      ffi.NativeFunction<
          mach_msg_return_t Function(
              ffi.Pointer<mach_msg_header_t>,
              mach_msg_option_t,
              mach_msg_size_t,
              mach_msg_size_t,
              mach_port_name_t,
              mach_msg_timeout_t,
              mach_port_name_t)>>('mach_msg');
  late final _mach_msg = _mach_msgPtr.asFunction<
      int Function(
          ffi.Pointer<mach_msg_header_t>, int, int, int, int, int, int)>();

  int mach_voucher_deallocate(
    int voucher,
  ) {
    return _mach_voucher_deallocate(
      voucher,
    );
  }

  late final _mach_voucher_deallocatePtr =
      _lookup<ffi.NativeFunction<kern_return_t Function(mach_port_name_t)>>(
          'mach_voucher_deallocate');
  late final _mach_voucher_deallocate =
      _mach_voucher_deallocatePtr.asFunction<int Function(int)>();

  late final ffi.Pointer<dispatch_source_type_s>
      __dispatch_source_type_data_add =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_data_add');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_data_add =>
      __dispatch_source_type_data_add;

  late final ffi.Pointer<dispatch_source_type_s>
      __dispatch_source_type_data_or =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_data_or');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_data_or =>
      __dispatch_source_type_data_or;

  late final ffi.Pointer<dispatch_source_type_s>
      __dispatch_source_type_data_replace =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_data_replace');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_data_replace =>
      __dispatch_source_type_data_replace;

  late final ffi.Pointer<dispatch_source_type_s>
      __dispatch_source_type_mach_send =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_mach_send');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_mach_send =>
      __dispatch_source_type_mach_send;

  late final ffi.Pointer<dispatch_source_type_s>
      __dispatch_source_type_mach_recv =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_mach_recv');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_mach_recv =>
      __dispatch_source_type_mach_recv;

  late final ffi.Pointer<dispatch_source_type_s>
      __dispatch_source_type_memorypressure =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_memorypressure');

  ffi.Pointer<dispatch_source_type_s>
      get _dispatch_source_type_memorypressure =>
          __dispatch_source_type_memorypressure;

  late final ffi.Pointer<dispatch_source_type_s> __dispatch_source_type_proc =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_proc');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_proc =>
      __dispatch_source_type_proc;

  late final ffi.Pointer<dispatch_source_type_s> __dispatch_source_type_read =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_read');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_read =>
      __dispatch_source_type_read;

  late final ffi.Pointer<dispatch_source_type_s> __dispatch_source_type_signal =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_signal');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_signal =>
      __dispatch_source_type_signal;

  late final ffi.Pointer<dispatch_source_type_s> __dispatch_source_type_timer =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_timer');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_timer =>
      __dispatch_source_type_timer;

  late final ffi.Pointer<dispatch_source_type_s> __dispatch_source_type_vnode =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_vnode');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_vnode =>
      __dispatch_source_type_vnode;

  late final ffi.Pointer<dispatch_source_type_s> __dispatch_source_type_write =
      _lookup<dispatch_source_type_s>('_dispatch_source_type_write');

  ffi.Pointer<dispatch_source_type_s> get _dispatch_source_type_write =>
      __dispatch_source_type_write;

  Dartdispatch_source_t dispatch_source_create(
    dispatch_source_type_t type,
    int handle,
    int mask,
    Dartdispatch_queue_t? queue,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_source_create(
          type,
          handle,
          mask,
          queue?.ref.pointer ?? ffi.nullptr,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_source_createPtr = _lookup<
      ffi.NativeFunction<
          dispatch_source_t Function(dispatch_source_type_t, ffi.UintPtr,
              ffi.UintPtr, dispatch_queue_t)>>('dispatch_source_create');
  late final _dispatch_source_create = _dispatch_source_createPtr.asFunction<
      dispatch_source_t Function(
          dispatch_source_type_t, int, int, dispatch_queue_t)>();

  void dispatch_source_set_event_handler(
    Dartdispatch_source_t source,
    Dartdispatch_block_t? handler,
  ) {
    return _dispatch_source_set_event_handler(
      source.ref.pointer,
      handler?.ref.pointer ?? ffi.nullptr,
    );
  }

  late final _dispatch_source_set_event_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t,
              dispatch_block_t)>>('dispatch_source_set_event_handler');
  late final _dispatch_source_set_event_handler =
      _dispatch_source_set_event_handlerPtr
          .asFunction<void Function(dispatch_source_t, dispatch_block_t)>();

  void dispatch_source_set_event_handler_f(
    Dartdispatch_source_t source,
    dispatch_function_t handler,
  ) {
    return _dispatch_source_set_event_handler_f(
      source.ref.pointer,
      handler,
    );
  }

  late final _dispatch_source_set_event_handler_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t,
              dispatch_function_t)>>('dispatch_source_set_event_handler_f');
  late final _dispatch_source_set_event_handler_f =
      _dispatch_source_set_event_handler_fPtr
          .asFunction<void Function(dispatch_source_t, dispatch_function_t)>();

  void dispatch_source_set_cancel_handler(
    Dartdispatch_source_t source,
    Dartdispatch_block_t? handler,
  ) {
    return _dispatch_source_set_cancel_handler(
      source.ref.pointer,
      handler?.ref.pointer ?? ffi.nullptr,
    );
  }

  late final _dispatch_source_set_cancel_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t,
              dispatch_block_t)>>('dispatch_source_set_cancel_handler');
  late final _dispatch_source_set_cancel_handler =
      _dispatch_source_set_cancel_handlerPtr
          .asFunction<void Function(dispatch_source_t, dispatch_block_t)>();

  void dispatch_source_set_cancel_handler_f(
    Dartdispatch_source_t source,
    dispatch_function_t handler,
  ) {
    return _dispatch_source_set_cancel_handler_f(
      source.ref.pointer,
      handler,
    );
  }

  late final _dispatch_source_set_cancel_handler_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t,
              dispatch_function_t)>>('dispatch_source_set_cancel_handler_f');
  late final _dispatch_source_set_cancel_handler_f =
      _dispatch_source_set_cancel_handler_fPtr
          .asFunction<void Function(dispatch_source_t, dispatch_function_t)>();

  void dispatch_source_cancel(
    Dartdispatch_source_t source,
  ) {
    return _dispatch_source_cancel(
      source.ref.pointer,
    );
  }

  late final _dispatch_source_cancelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_source_t)>>(
          'dispatch_source_cancel');
  late final _dispatch_source_cancel =
      _dispatch_source_cancelPtr.asFunction<void Function(dispatch_source_t)>();

  int dispatch_source_testcancel(
    Dartdispatch_source_t source,
  ) {
    return _dispatch_source_testcancel(
      source.ref.pointer,
    );
  }

  late final _dispatch_source_testcancelPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(dispatch_source_t)>>(
          'dispatch_source_testcancel');
  late final _dispatch_source_testcancel = _dispatch_source_testcancelPtr
      .asFunction<int Function(dispatch_source_t)>();

  int dispatch_source_get_handle(
    Dartdispatch_source_t source,
  ) {
    return _dispatch_source_get_handle(
      source.ref.pointer,
    );
  }

  late final _dispatch_source_get_handlePtr =
      _lookup<ffi.NativeFunction<ffi.UintPtr Function(dispatch_source_t)>>(
          'dispatch_source_get_handle');
  late final _dispatch_source_get_handle = _dispatch_source_get_handlePtr
      .asFunction<int Function(dispatch_source_t)>();

  int dispatch_source_get_mask(
    Dartdispatch_source_t source,
  ) {
    return _dispatch_source_get_mask(
      source.ref.pointer,
    );
  }

  late final _dispatch_source_get_maskPtr =
      _lookup<ffi.NativeFunction<ffi.UintPtr Function(dispatch_source_t)>>(
          'dispatch_source_get_mask');
  late final _dispatch_source_get_mask = _dispatch_source_get_maskPtr
      .asFunction<int Function(dispatch_source_t)>();

  int dispatch_source_get_data(
    Dartdispatch_source_t source,
  ) {
    return _dispatch_source_get_data(
      source.ref.pointer,
    );
  }

  late final _dispatch_source_get_dataPtr =
      _lookup<ffi.NativeFunction<ffi.UintPtr Function(dispatch_source_t)>>(
          'dispatch_source_get_data');
  late final _dispatch_source_get_data = _dispatch_source_get_dataPtr
      .asFunction<int Function(dispatch_source_t)>();

  void dispatch_source_merge_data(
    Dartdispatch_source_t source,
    int value,
  ) {
    return _dispatch_source_merge_data(
      source.ref.pointer,
      value,
    );
  }

  late final _dispatch_source_merge_dataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(dispatch_source_t, ffi.UintPtr)>>(
      'dispatch_source_merge_data');
  late final _dispatch_source_merge_data = _dispatch_source_merge_dataPtr
      .asFunction<void Function(dispatch_source_t, int)>();

  void dispatch_source_set_timer(
    Dartdispatch_source_t source,
    Dartdispatch_time_t start,
    int interval,
    int leeway,
  ) {
    return _dispatch_source_set_timer(
      source.ref.pointer,
      start,
      interval,
      leeway,
    );
  }

  late final _dispatch_source_set_timerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t, dispatch_time_t, ffi.Uint64,
              ffi.Uint64)>>('dispatch_source_set_timer');
  late final _dispatch_source_set_timer = _dispatch_source_set_timerPtr
      .asFunction<void Function(dispatch_source_t, int, int, int)>();

  void dispatch_source_set_registration_handler(
    Dartdispatch_source_t source,
    Dartdispatch_block_t? handler,
  ) {
    return _dispatch_source_set_registration_handler(
      source.ref.pointer,
      handler?.ref.pointer ?? ffi.nullptr,
    );
  }

  late final _dispatch_source_set_registration_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_source_t,
              dispatch_block_t)>>('dispatch_source_set_registration_handler');
  late final _dispatch_source_set_registration_handler =
      _dispatch_source_set_registration_handlerPtr
          .asFunction<void Function(dispatch_source_t, dispatch_block_t)>();

  void dispatch_source_set_registration_handler_f(
    Dartdispatch_source_t source,
    dispatch_function_t handler,
  ) {
    return _dispatch_source_set_registration_handler_f(
      source.ref.pointer,
      handler,
    );
  }

  late final _dispatch_source_set_registration_handler_fPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(dispatch_source_t, dispatch_function_t)>>(
      'dispatch_source_set_registration_handler_f');
  late final _dispatch_source_set_registration_handler_f =
      _dispatch_source_set_registration_handler_fPtr
          .asFunction<void Function(dispatch_source_t, dispatch_function_t)>();

  Dartdispatch_group_t dispatch_group_create() {
    return objc.NSObject.castFromPointer(_dispatch_group_create(),
        retain: false, release: true);
  }

  late final _dispatch_group_createPtr =
      _lookup<ffi.NativeFunction<dispatch_group_t Function()>>(
          'dispatch_group_create');
  late final _dispatch_group_create =
      _dispatch_group_createPtr.asFunction<dispatch_group_t Function()>();

  void dispatch_group_async(
    Dartdispatch_group_t group,
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_group_async(
      group.ref.pointer,
      queue.ref.pointer,
      block.ref.pointer,
    );
  }

  late final _dispatch_group_asyncPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_group_t, dispatch_queue_t,
              dispatch_block_t)>>('dispatch_group_async');
  late final _dispatch_group_async = _dispatch_group_asyncPtr.asFunction<
      void Function(dispatch_group_t, dispatch_queue_t, dispatch_block_t)>();

  void dispatch_group_async_f(
    Dartdispatch_group_t group,
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_group_async_f(
      group.ref.pointer,
      queue.ref.pointer,
      context,
      work,
    );
  }

  late final _dispatch_group_async_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_group_t,
              dispatch_queue_t,
              ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_group_async_f');
  late final _dispatch_group_async_f = _dispatch_group_async_fPtr.asFunction<
      void Function(dispatch_group_t, dispatch_queue_t, ffi.Pointer<ffi.Void>,
          dispatch_function_t)>();

  int dispatch_group_wait(
    Dartdispatch_group_t group,
    Dartdispatch_time_t timeout,
  ) {
    return _dispatch_group_wait(
      group.ref.pointer,
      timeout,
    );
  }

  late final _dispatch_group_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              dispatch_group_t, dispatch_time_t)>>('dispatch_group_wait');
  late final _dispatch_group_wait =
      _dispatch_group_waitPtr.asFunction<int Function(dispatch_group_t, int)>();

  void dispatch_group_notify(
    Dartdispatch_group_t group,
    Dartdispatch_queue_t queue,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_group_notify(
      group.ref.pointer,
      queue.ref.pointer,
      block.ref.pointer,
    );
  }

  late final _dispatch_group_notifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_group_t, dispatch_queue_t,
              dispatch_block_t)>>('dispatch_group_notify');
  late final _dispatch_group_notify = _dispatch_group_notifyPtr.asFunction<
      void Function(dispatch_group_t, dispatch_queue_t, dispatch_block_t)>();

  void dispatch_group_notify_f(
    Dartdispatch_group_t group,
    Dartdispatch_queue_t queue,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t work,
  ) {
    return _dispatch_group_notify_f(
      group.ref.pointer,
      queue.ref.pointer,
      context,
      work,
    );
  }

  late final _dispatch_group_notify_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_group_t,
              dispatch_queue_t,
              ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_group_notify_f');
  late final _dispatch_group_notify_f = _dispatch_group_notify_fPtr.asFunction<
      void Function(dispatch_group_t, dispatch_queue_t, ffi.Pointer<ffi.Void>,
          dispatch_function_t)>();

  void dispatch_group_enter(
    Dartdispatch_group_t group,
  ) {
    return _dispatch_group_enter(
      group.ref.pointer,
    );
  }

  late final _dispatch_group_enterPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_group_t)>>(
          'dispatch_group_enter');
  late final _dispatch_group_enter =
      _dispatch_group_enterPtr.asFunction<void Function(dispatch_group_t)>();

  void dispatch_group_leave(
    Dartdispatch_group_t group,
  ) {
    return _dispatch_group_leave(
      group.ref.pointer,
    );
  }

  late final _dispatch_group_leavePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_group_t)>>(
          'dispatch_group_leave');
  late final _dispatch_group_leave =
      _dispatch_group_leavePtr.asFunction<void Function(dispatch_group_t)>();

  Dartdispatch_semaphore_t dispatch_semaphore_create(
    int value,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_semaphore_create(
          value,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_semaphore_createPtr =
      _lookup<ffi.NativeFunction<dispatch_semaphore_t Function(ffi.IntPtr)>>(
          'dispatch_semaphore_create');
  late final _dispatch_semaphore_create = _dispatch_semaphore_createPtr
      .asFunction<dispatch_semaphore_t Function(int)>();

  int dispatch_semaphore_wait(
    Dartdispatch_semaphore_t dsema,
    Dartdispatch_time_t timeout,
  ) {
    return _dispatch_semaphore_wait(
      dsema.ref.pointer,
      timeout,
    );
  }

  late final _dispatch_semaphore_waitPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(dispatch_semaphore_t,
              dispatch_time_t)>>('dispatch_semaphore_wait');
  late final _dispatch_semaphore_wait = _dispatch_semaphore_waitPtr
      .asFunction<int Function(dispatch_semaphore_t, int)>();

  int dispatch_semaphore_signal(
    Dartdispatch_semaphore_t dsema,
  ) {
    return _dispatch_semaphore_signal(
      dsema.ref.pointer,
    );
  }

  late final _dispatch_semaphore_signalPtr =
      _lookup<ffi.NativeFunction<ffi.IntPtr Function(dispatch_semaphore_t)>>(
          'dispatch_semaphore_signal');
  late final _dispatch_semaphore_signal = _dispatch_semaphore_signalPtr
      .asFunction<int Function(dispatch_semaphore_t)>();

  void dispatch_once(
    ffi.Pointer<dispatch_once_t> predicate,
    Dartdispatch_block_t block,
  ) {
    return _dispatch_once(
      predicate,
      block.ref.pointer,
    );
  }

  late final _dispatch_oncePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<dispatch_once_t>,
              dispatch_block_t)>>('dispatch_once');
  late final _dispatch_once = _dispatch_oncePtr.asFunction<
      void Function(ffi.Pointer<dispatch_once_t>, dispatch_block_t)>();

  void dispatch_once_f(
    ffi.Pointer<dispatch_once_t> predicate,
    ffi.Pointer<ffi.Void> context,
    dispatch_function_t function,
  ) {
    return _dispatch_once_f(
      predicate,
      context,
      function,
    );
  }

  late final _dispatch_once_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<dispatch_once_t>, ffi.Pointer<ffi.Void>,
              dispatch_function_t)>>('dispatch_once_f');
  late final _dispatch_once_f = _dispatch_once_fPtr.asFunction<
      void Function(ffi.Pointer<dispatch_once_t>, ffi.Pointer<ffi.Void>,
          dispatch_function_t)>();

  late final ffi.Pointer<dispatch_data_s> __dispatch_data_empty =
      _lookup<dispatch_data_s>('_dispatch_data_empty');

  ffi.Pointer<dispatch_data_s> get _dispatch_data_empty =>
      __dispatch_data_empty;

  late final ffi.Pointer<dispatch_block_t> __dispatch_data_destructor_free =
      _lookup<dispatch_block_t>('_dispatch_data_destructor_free');

  Dartdispatch_block_t get _dispatch_data_destructor_free =>
      ObjCBlock_ffiVoid.castFromPointer(__dispatch_data_destructor_free.value,
          retain: true, release: true);

  set _dispatch_data_destructor_free(Dartdispatch_block_t value) {
    ObjCBlock_ffiVoid.castFromPointer(__dispatch_data_destructor_free.value,
            retain: false, release: true)
        .ref
        .release();
    __dispatch_data_destructor_free.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<dispatch_block_t> __dispatch_data_destructor_munmap =
      _lookup<dispatch_block_t>('_dispatch_data_destructor_munmap');

  Dartdispatch_block_t get _dispatch_data_destructor_munmap =>
      ObjCBlock_ffiVoid.castFromPointer(__dispatch_data_destructor_munmap.value,
          retain: true, release: true);

  set _dispatch_data_destructor_munmap(Dartdispatch_block_t value) {
    ObjCBlock_ffiVoid.castFromPointer(__dispatch_data_destructor_munmap.value,
            retain: false, release: true)
        .ref
        .release();
    __dispatch_data_destructor_munmap.value =
        value.ref.retainAndReturnPointer();
  }

  Dartdispatch_data_t dispatch_data_create(
    ffi.Pointer<ffi.Void> buffer,
    int size,
    Dartdispatch_queue_t? queue,
    Dartdispatch_block_t? destructor,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_data_create(
          buffer,
          size,
          queue?.ref.pointer ?? ffi.nullptr,
          destructor?.ref.pointer ?? ffi.nullptr,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_data_createPtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(ffi.Pointer<ffi.Void>, ffi.Size,
              dispatch_queue_t, dispatch_block_t)>>('dispatch_data_create');
  late final _dispatch_data_create = _dispatch_data_createPtr.asFunction<
      dispatch_data_t Function(
          ffi.Pointer<ffi.Void>, int, dispatch_queue_t, dispatch_block_t)>();

  int dispatch_data_get_size(
    Dartdispatch_data_t data,
  ) {
    return _dispatch_data_get_size(
      data.ref.pointer,
    );
  }

  late final _dispatch_data_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(dispatch_data_t)>>(
          'dispatch_data_get_size');
  late final _dispatch_data_get_size =
      _dispatch_data_get_sizePtr.asFunction<int Function(dispatch_data_t)>();

  Dartdispatch_data_t dispatch_data_create_map(
    Dartdispatch_data_t data,
    ffi.Pointer<ffi.Pointer<ffi.Void>> buffer_ptr,
    ffi.Pointer<ffi.Size> size_ptr,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_data_create_map(
          data.ref.pointer,
          buffer_ptr,
          size_ptr,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_data_create_mapPtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(
              dispatch_data_t,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>)>>('dispatch_data_create_map');
  late final _dispatch_data_create_map =
      _dispatch_data_create_mapPtr.asFunction<
          dispatch_data_t Function(dispatch_data_t,
              ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Size>)>();

  Dartdispatch_data_t dispatch_data_create_concat(
    Dartdispatch_data_t data1,
    Dartdispatch_data_t data2,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_data_create_concat(
          data1.ref.pointer,
          data2.ref.pointer,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_data_create_concatPtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(dispatch_data_t,
              dispatch_data_t)>>('dispatch_data_create_concat');
  late final _dispatch_data_create_concat = _dispatch_data_create_concatPtr
      .asFunction<dispatch_data_t Function(dispatch_data_t, dispatch_data_t)>();

  Dartdispatch_data_t dispatch_data_create_subrange(
    Dartdispatch_data_t data,
    int offset,
    int length,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_data_create_subrange(
          data.ref.pointer,
          offset,
          length,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_data_create_subrangePtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(dispatch_data_t, ffi.Size,
              ffi.Size)>>('dispatch_data_create_subrange');
  late final _dispatch_data_create_subrange = _dispatch_data_create_subrangePtr
      .asFunction<dispatch_data_t Function(dispatch_data_t, int, int)>();

  bool dispatch_data_apply(
    Dartdispatch_data_t data,
    Dartdispatch_data_applier_t applier,
  ) {
    return _dispatch_data_apply(
      data.ref.pointer,
      applier.ref.pointer,
    );
  }

  late final _dispatch_data_applyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(dispatch_data_t,
              dispatch_data_applier_t)>>('dispatch_data_apply');
  late final _dispatch_data_apply = _dispatch_data_applyPtr
      .asFunction<bool Function(dispatch_data_t, dispatch_data_applier_t)>();

  Dartdispatch_data_t dispatch_data_copy_region(
    Dartdispatch_data_t data,
    int location,
    ffi.Pointer<ffi.Size> offset_ptr,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_data_copy_region(
          data.ref.pointer,
          location,
          offset_ptr,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_data_copy_regionPtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(dispatch_data_t, ffi.Size,
              ffi.Pointer<ffi.Size>)>>('dispatch_data_copy_region');
  late final _dispatch_data_copy_region =
      _dispatch_data_copy_regionPtr.asFunction<
          dispatch_data_t Function(
              dispatch_data_t, int, ffi.Pointer<ffi.Size>)>();

  void dispatch_read(
    Dartdispatch_fd_t fd,
    int length,
    Dartdispatch_queue_t queue,
    objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)> handler,
  ) {
    return _dispatch_read(
      fd,
      length,
      queue.ref.pointer,
      handler.ref.pointer,
    );
  }

  late final _dispatch_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_fd_t, ffi.Size, dispatch_queue_t,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('dispatch_read');
  late final _dispatch_read = _dispatch_readPtr.asFunction<
      void Function(
          int, int, dispatch_queue_t, ffi.Pointer<objc.ObjCBlockImpl>)>();

  void dispatch_write(
    Dartdispatch_fd_t fd,
    Dartdispatch_data_t data,
    Dartdispatch_queue_t queue,
    objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)> handler,
  ) {
    return _dispatch_write(
      fd,
      data.ref.pointer,
      queue.ref.pointer,
      handler.ref.pointer,
    );
  }

  late final _dispatch_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_fd_t, dispatch_data_t, dispatch_queue_t,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('dispatch_write');
  late final _dispatch_write = _dispatch_writePtr.asFunction<
      void Function(int, dispatch_data_t, dispatch_queue_t,
          ffi.Pointer<objc.ObjCBlockImpl>)>();

  Dartdispatch_io_t dispatch_io_create(
    Dartdispatch_io_type_t type,
    Dartdispatch_fd_t fd,
    Dartdispatch_queue_t queue,
    objc.ObjCBlock<ffi.Void Function(ffi.Int)> cleanup_handler,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_io_create(
          type,
          fd,
          queue.ref.pointer,
          cleanup_handler.ref.pointer,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_io_createPtr = _lookup<
      ffi.NativeFunction<
          dispatch_io_t Function(
              dispatch_io_type_t,
              dispatch_fd_t,
              dispatch_queue_t,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('dispatch_io_create');
  late final _dispatch_io_create = _dispatch_io_createPtr.asFunction<
      dispatch_io_t Function(
          int, int, dispatch_queue_t, ffi.Pointer<objc.ObjCBlockImpl>)>();

  Dartdispatch_io_t dispatch_io_create_with_path(
    Dartdispatch_io_type_t type,
    ffi.Pointer<ffi.Char> path,
    int oflag,
    Dart__uint16_t mode,
    Dartdispatch_queue_t queue,
    objc.ObjCBlock<ffi.Void Function(ffi.Int)> cleanup_handler,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_io_create_with_path(
          type,
          path,
          oflag,
          mode,
          queue.ref.pointer,
          cleanup_handler.ref.pointer,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_io_create_with_pathPtr = _lookup<
          ffi.NativeFunction<
              dispatch_io_t Function(
                  dispatch_io_type_t,
                  ffi.Pointer<ffi.Char>,
                  ffi.Int,
                  mode_t,
                  dispatch_queue_t,
                  ffi.Pointer<objc.ObjCBlockImpl>)>>(
      'dispatch_io_create_with_path');
  late final _dispatch_io_create_with_path =
      _dispatch_io_create_with_pathPtr.asFunction<
          dispatch_io_t Function(int, ffi.Pointer<ffi.Char>, int, int,
              dispatch_queue_t, ffi.Pointer<objc.ObjCBlockImpl>)>();

  Dartdispatch_io_t dispatch_io_create_with_io(
    Dartdispatch_io_type_t type,
    Dartdispatch_io_t io,
    Dartdispatch_queue_t queue,
    objc.ObjCBlock<ffi.Void Function(ffi.Int)> cleanup_handler,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_io_create_with_io(
          type,
          io.ref.pointer,
          queue.ref.pointer,
          cleanup_handler.ref.pointer,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_io_create_with_ioPtr = _lookup<
      ffi.NativeFunction<
          dispatch_io_t Function(
              dispatch_io_type_t,
              dispatch_io_t,
              dispatch_queue_t,
              ffi.Pointer<objc.ObjCBlockImpl>)>>('dispatch_io_create_with_io');
  late final _dispatch_io_create_with_io =
      _dispatch_io_create_with_ioPtr.asFunction<
          dispatch_io_t Function(int, dispatch_io_t, dispatch_queue_t,
              ffi.Pointer<objc.ObjCBlockImpl>)>();

  void dispatch_io_read(
    Dartdispatch_io_t channel,
    Dart__int64_t offset,
    int length,
    Dartdispatch_queue_t queue,
    Dartdispatch_io_handler_t io_handler,
  ) {
    return _dispatch_io_read(
      channel.ref.pointer,
      offset,
      length,
      queue.ref.pointer,
      io_handler.ref.pointer,
    );
  }

  late final _dispatch_io_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_io_t, off_t, ffi.Size, dispatch_queue_t,
              dispatch_io_handler_t)>>('dispatch_io_read');
  late final _dispatch_io_read = _dispatch_io_readPtr.asFunction<
      void Function(
          dispatch_io_t, int, int, dispatch_queue_t, dispatch_io_handler_t)>();

  void dispatch_io_write(
    Dartdispatch_io_t channel,
    Dart__int64_t offset,
    Dartdispatch_data_t data,
    Dartdispatch_queue_t queue,
    Dartdispatch_io_handler_t io_handler,
  ) {
    return _dispatch_io_write(
      channel.ref.pointer,
      offset,
      data.ref.pointer,
      queue.ref.pointer,
      io_handler.ref.pointer,
    );
  }

  late final _dispatch_io_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_io_t, off_t, dispatch_data_t,
              dispatch_queue_t, dispatch_io_handler_t)>>('dispatch_io_write');
  late final _dispatch_io_write = _dispatch_io_writePtr.asFunction<
      void Function(dispatch_io_t, int, dispatch_data_t, dispatch_queue_t,
          dispatch_io_handler_t)>();

  void dispatch_io_close(
    Dartdispatch_io_t channel,
    Dartdispatch_io_close_flags_t flags,
  ) {
    return _dispatch_io_close(
      channel.ref.pointer,
      flags,
    );
  }

  late final _dispatch_io_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              dispatch_io_t, dispatch_io_close_flags_t)>>('dispatch_io_close');
  late final _dispatch_io_close =
      _dispatch_io_closePtr.asFunction<void Function(dispatch_io_t, int)>();

  void dispatch_io_barrier(
    Dartdispatch_io_t channel,
    Dartdispatch_block_t barrier,
  ) {
    return _dispatch_io_barrier(
      channel.ref.pointer,
      barrier.ref.pointer,
    );
  }

  late final _dispatch_io_barrierPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(dispatch_io_t, dispatch_block_t)>>(
      'dispatch_io_barrier');
  late final _dispatch_io_barrier = _dispatch_io_barrierPtr
      .asFunction<void Function(dispatch_io_t, dispatch_block_t)>();

  Dartdispatch_fd_t dispatch_io_get_descriptor(
    Dartdispatch_io_t channel,
  ) {
    return _dispatch_io_get_descriptor(
      channel.ref.pointer,
    );
  }

  late final _dispatch_io_get_descriptorPtr =
      _lookup<ffi.NativeFunction<dispatch_fd_t Function(dispatch_io_t)>>(
          'dispatch_io_get_descriptor');
  late final _dispatch_io_get_descriptor =
      _dispatch_io_get_descriptorPtr.asFunction<int Function(dispatch_io_t)>();

  void dispatch_io_set_high_water(
    Dartdispatch_io_t channel,
    int high_water,
  ) {
    return _dispatch_io_set_high_water(
      channel.ref.pointer,
      high_water,
    );
  }

  late final _dispatch_io_set_high_waterPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_io_t, ffi.Size)>>(
          'dispatch_io_set_high_water');
  late final _dispatch_io_set_high_water = _dispatch_io_set_high_waterPtr
      .asFunction<void Function(dispatch_io_t, int)>();

  void dispatch_io_set_low_water(
    Dartdispatch_io_t channel,
    int low_water,
  ) {
    return _dispatch_io_set_low_water(
      channel.ref.pointer,
      low_water,
    );
  }

  late final _dispatch_io_set_low_waterPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(dispatch_io_t, ffi.Size)>>(
          'dispatch_io_set_low_water');
  late final _dispatch_io_set_low_water = _dispatch_io_set_low_waterPtr
      .asFunction<void Function(dispatch_io_t, int)>();

  void dispatch_io_set_interval(
    Dartdispatch_io_t channel,
    int interval,
    Dartdispatch_io_interval_flags_t flags,
  ) {
    return _dispatch_io_set_interval(
      channel.ref.pointer,
      interval,
      flags,
    );
  }

  late final _dispatch_io_set_intervalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_io_t, ffi.Uint64,
              dispatch_io_interval_flags_t)>>('dispatch_io_set_interval');
  late final _dispatch_io_set_interval = _dispatch_io_set_intervalPtr
      .asFunction<void Function(dispatch_io_t, int, int)>();

  Dartdispatch_workloop_t dispatch_workloop_create(
    ffi.Pointer<ffi.Char> label,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_workloop_create(
          label,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_workloop_createPtr = _lookup<
          ffi
          .NativeFunction<dispatch_workloop_t Function(ffi.Pointer<ffi.Char>)>>(
      'dispatch_workloop_create');
  late final _dispatch_workloop_create = _dispatch_workloop_createPtr
      .asFunction<dispatch_workloop_t Function(ffi.Pointer<ffi.Char>)>();

  Dartdispatch_workloop_t dispatch_workloop_create_inactive(
    ffi.Pointer<ffi.Char> label,
  ) {
    return objc.NSObject.castFromPointer(
        _dispatch_workloop_create_inactive(
          label,
        ),
        retain: false,
        release: true);
  }

  late final _dispatch_workloop_create_inactivePtr = _lookup<
          ffi
          .NativeFunction<dispatch_workloop_t Function(ffi.Pointer<ffi.Char>)>>(
      'dispatch_workloop_create_inactive');
  late final _dispatch_workloop_create_inactive =
      _dispatch_workloop_create_inactivePtr
          .asFunction<dispatch_workloop_t Function(ffi.Pointer<ffi.Char>)>();

  void dispatch_workloop_set_autorelease_frequency(
    Dartdispatch_workloop_t workloop,
    dispatch_autorelease_frequency_t frequency,
  ) {
    return _dispatch_workloop_set_autorelease_frequency(
      workloop.ref.pointer,
      frequency.value,
    );
  }

  late final _dispatch_workloop_set_autorelease_frequencyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(dispatch_workloop_t, ffi.UnsignedLong)>>(
      'dispatch_workloop_set_autorelease_frequency');
  late final _dispatch_workloop_set_autorelease_frequency =
      _dispatch_workloop_set_autorelease_frequencyPtr
          .asFunction<void Function(dispatch_workloop_t, int)>();

  void dispatch_workloop_set_os_workgroup(
    Dartdispatch_workloop_t workloop,
    Dartos_workgroup_t workgroup,
  ) {
    return _dispatch_workloop_set_os_workgroup(
      workloop.ref.pointer,
      workgroup.ref.pointer,
    );
  }

  late final _dispatch_workloop_set_os_workgroupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(dispatch_workloop_t,
              os_workgroup_t)>>('dispatch_workloop_set_os_workgroup');
  late final _dispatch_workloop_set_os_workgroup =
      _dispatch_workloop_set_os_workgroupPtr
          .asFunction<void Function(dispatch_workloop_t, os_workgroup_t)>();

  int CFReadStreamGetTypeID() {
    return _CFReadStreamGetTypeID();
  }

  late final _CFReadStreamGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFReadStreamGetTypeID');
  late final _CFReadStreamGetTypeID =
      _CFReadStreamGetTypeIDPtr.asFunction<int Function()>();

  int CFWriteStreamGetTypeID() {
    return _CFWriteStreamGetTypeID();
  }

  late final _CFWriteStreamGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFWriteStreamGetTypeID');
  late final _CFWriteStreamGetTypeID =
      _CFWriteStreamGetTypeIDPtr.asFunction<int Function()>();

  late final ffi.Pointer<CFStreamPropertyKey> _kCFStreamPropertyDataWritten =
      _lookup<CFStreamPropertyKey>('kCFStreamPropertyDataWritten');

  CFStreamPropertyKey get kCFStreamPropertyDataWritten =>
      _kCFStreamPropertyDataWritten.value;

  CFReadStreamRef CFReadStreamCreateWithBytesNoCopy(
    CFAllocatorRef alloc,
    ffi.Pointer<UInt8> bytes,
    int length,
    CFAllocatorRef bytesDeallocator,
  ) {
    return _CFReadStreamCreateWithBytesNoCopy(
      alloc,
      bytes,
      length,
      bytesDeallocator,
    );
  }

  late final _CFReadStreamCreateWithBytesNoCopyPtr = _lookup<
      ffi.NativeFunction<
          CFReadStreamRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, CFIndex,
              CFAllocatorRef)>>('CFReadStreamCreateWithBytesNoCopy');
  late final _CFReadStreamCreateWithBytesNoCopy =
      _CFReadStreamCreateWithBytesNoCopyPtr.asFunction<
          CFReadStreamRef Function(
              CFAllocatorRef, ffi.Pointer<UInt8>, int, CFAllocatorRef)>();

  CFWriteStreamRef CFWriteStreamCreateWithBuffer(
    CFAllocatorRef alloc,
    ffi.Pointer<UInt8> buffer,
    int bufferCapacity,
  ) {
    return _CFWriteStreamCreateWithBuffer(
      alloc,
      buffer,
      bufferCapacity,
    );
  }

  late final _CFWriteStreamCreateWithBufferPtr = _lookup<
      ffi.NativeFunction<
          CFWriteStreamRef Function(CFAllocatorRef, ffi.Pointer<UInt8>,
              CFIndex)>>('CFWriteStreamCreateWithBuffer');
  late final _CFWriteStreamCreateWithBuffer =
      _CFWriteStreamCreateWithBufferPtr.asFunction<
          CFWriteStreamRef Function(CFAllocatorRef, ffi.Pointer<UInt8>, int)>();

  CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(
    CFAllocatorRef alloc,
    CFAllocatorRef bufferAllocator,
  ) {
    return _CFWriteStreamCreateWithAllocatedBuffers(
      alloc,
      bufferAllocator,
    );
  }

  late final _CFWriteStreamCreateWithAllocatedBuffersPtr = _lookup<
      ffi.NativeFunction<
          CFWriteStreamRef Function(CFAllocatorRef,
              CFAllocatorRef)>>('CFWriteStreamCreateWithAllocatedBuffers');
  late final _CFWriteStreamCreateWithAllocatedBuffers =
      _CFWriteStreamCreateWithAllocatedBuffersPtr.asFunction<
          CFWriteStreamRef Function(CFAllocatorRef, CFAllocatorRef)>();

  CFReadStreamRef CFReadStreamCreateWithFile(
    CFAllocatorRef alloc,
    CFURLRef fileURL,
  ) {
    return _CFReadStreamCreateWithFile(
      alloc,
      fileURL,
    );
  }

  late final _CFReadStreamCreateWithFilePtr = _lookup<
          ffi
          .NativeFunction<CFReadStreamRef Function(CFAllocatorRef, CFURLRef)>>(
      'CFReadStreamCreateWithFile');
  late final _CFReadStreamCreateWithFile = _CFReadStreamCreateWithFilePtr
      .asFunction<CFReadStreamRef Function(CFAllocatorRef, CFURLRef)>();

  CFWriteStreamRef CFWriteStreamCreateWithFile(
    CFAllocatorRef alloc,
    CFURLRef fileURL,
  ) {
    return _CFWriteStreamCreateWithFile(
      alloc,
      fileURL,
    );
  }

  late final _CFWriteStreamCreateWithFilePtr = _lookup<
          ffi
          .NativeFunction<CFWriteStreamRef Function(CFAllocatorRef, CFURLRef)>>(
      'CFWriteStreamCreateWithFile');
  late final _CFWriteStreamCreateWithFile = _CFWriteStreamCreateWithFilePtr
      .asFunction<CFWriteStreamRef Function(CFAllocatorRef, CFURLRef)>();

  void CFStreamCreateBoundPair(
    CFAllocatorRef alloc,
    ffi.Pointer<CFReadStreamRef> readStream,
    ffi.Pointer<CFWriteStreamRef> writeStream,
    int transferBufferSize,
  ) {
    return _CFStreamCreateBoundPair(
      alloc,
      readStream,
      writeStream,
      transferBufferSize,
    );
  }

  late final _CFStreamCreateBoundPairPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFAllocatorRef,
              ffi.Pointer<CFReadStreamRef>,
              ffi.Pointer<CFWriteStreamRef>,
              CFIndex)>>('CFStreamCreateBoundPair');
  late final _CFStreamCreateBoundPair = _CFStreamCreateBoundPairPtr.asFunction<
      void Function(CFAllocatorRef, ffi.Pointer<CFReadStreamRef>,
          ffi.Pointer<CFWriteStreamRef>, int)>();

  late final ffi.Pointer<CFStreamPropertyKey> _kCFStreamPropertyAppendToFile =
      _lookup<CFStreamPropertyKey>('kCFStreamPropertyAppendToFile');

  CFStreamPropertyKey get kCFStreamPropertyAppendToFile =>
      _kCFStreamPropertyAppendToFile.value;

  late final ffi.Pointer<CFStreamPropertyKey>
      _kCFStreamPropertyFileCurrentOffset =
      _lookup<CFStreamPropertyKey>('kCFStreamPropertyFileCurrentOffset');

  CFStreamPropertyKey get kCFStreamPropertyFileCurrentOffset =>
      _kCFStreamPropertyFileCurrentOffset.value;

  late final ffi.Pointer<CFStreamPropertyKey>
      _kCFStreamPropertySocketNativeHandle =
      _lookup<CFStreamPropertyKey>('kCFStreamPropertySocketNativeHandle');

  CFStreamPropertyKey get kCFStreamPropertySocketNativeHandle =>
      _kCFStreamPropertySocketNativeHandle.value;

  late final ffi.Pointer<CFStreamPropertyKey>
      _kCFStreamPropertySocketRemoteHostName =
      _lookup<CFStreamPropertyKey>('kCFStreamPropertySocketRemoteHostName');

  CFStreamPropertyKey get kCFStreamPropertySocketRemoteHostName =>
      _kCFStreamPropertySocketRemoteHostName.value;

  late final ffi.Pointer<CFStreamPropertyKey>
      _kCFStreamPropertySocketRemotePortNumber =
      _lookup<CFStreamPropertyKey>('kCFStreamPropertySocketRemotePortNumber');

  CFStreamPropertyKey get kCFStreamPropertySocketRemotePortNumber =>
      _kCFStreamPropertySocketRemotePortNumber.value;

  late final ffi.Pointer<ffi.Int> _kCFStreamErrorDomainSOCKS =
      _lookup<ffi.Int>('kCFStreamErrorDomainSOCKS');

  int get kCFStreamErrorDomainSOCKS => _kCFStreamErrorDomainSOCKS.value;

  late final ffi.Pointer<CFStringRef> _kCFStreamPropertySOCKSProxy =
      _lookup<CFStringRef>('kCFStreamPropertySOCKSProxy');

  CFStringRef get kCFStreamPropertySOCKSProxy =>
      _kCFStreamPropertySOCKSProxy.value;

  set kCFStreamPropertySOCKSProxy(CFStringRef value) =>
      _kCFStreamPropertySOCKSProxy.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamPropertySOCKSProxyHost =
      _lookup<CFStringRef>('kCFStreamPropertySOCKSProxyHost');

  CFStringRef get kCFStreamPropertySOCKSProxyHost =>
      _kCFStreamPropertySOCKSProxyHost.value;

  set kCFStreamPropertySOCKSProxyHost(CFStringRef value) =>
      _kCFStreamPropertySOCKSProxyHost.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamPropertySOCKSProxyPort =
      _lookup<CFStringRef>('kCFStreamPropertySOCKSProxyPort');

  CFStringRef get kCFStreamPropertySOCKSProxyPort =>
      _kCFStreamPropertySOCKSProxyPort.value;

  set kCFStreamPropertySOCKSProxyPort(CFStringRef value) =>
      _kCFStreamPropertySOCKSProxyPort.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamPropertySOCKSVersion =
      _lookup<CFStringRef>('kCFStreamPropertySOCKSVersion');

  CFStringRef get kCFStreamPropertySOCKSVersion =>
      _kCFStreamPropertySOCKSVersion.value;

  set kCFStreamPropertySOCKSVersion(CFStringRef value) =>
      _kCFStreamPropertySOCKSVersion.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamSocketSOCKSVersion4 =
      _lookup<CFStringRef>('kCFStreamSocketSOCKSVersion4');

  CFStringRef get kCFStreamSocketSOCKSVersion4 =>
      _kCFStreamSocketSOCKSVersion4.value;

  set kCFStreamSocketSOCKSVersion4(CFStringRef value) =>
      _kCFStreamSocketSOCKSVersion4.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamSocketSOCKSVersion5 =
      _lookup<CFStringRef>('kCFStreamSocketSOCKSVersion5');

  CFStringRef get kCFStreamSocketSOCKSVersion5 =>
      _kCFStreamSocketSOCKSVersion5.value;

  set kCFStreamSocketSOCKSVersion5(CFStringRef value) =>
      _kCFStreamSocketSOCKSVersion5.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamPropertySOCKSUser =
      _lookup<CFStringRef>('kCFStreamPropertySOCKSUser');

  CFStringRef get kCFStreamPropertySOCKSUser =>
      _kCFStreamPropertySOCKSUser.value;

  set kCFStreamPropertySOCKSUser(CFStringRef value) =>
      _kCFStreamPropertySOCKSUser.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamPropertySOCKSPassword =
      _lookup<CFStringRef>('kCFStreamPropertySOCKSPassword');

  CFStringRef get kCFStreamPropertySOCKSPassword =>
      _kCFStreamPropertySOCKSPassword.value;

  set kCFStreamPropertySOCKSPassword(CFStringRef value) =>
      _kCFStreamPropertySOCKSPassword.value = value;

  late final ffi.Pointer<ffi.Int> _kCFStreamErrorDomainSSL =
      _lookup<ffi.Int>('kCFStreamErrorDomainSSL');

  int get kCFStreamErrorDomainSSL => _kCFStreamErrorDomainSSL.value;

  late final ffi.Pointer<CFStringRef> _kCFStreamPropertySocketSecurityLevel =
      _lookup<CFStringRef>('kCFStreamPropertySocketSecurityLevel');

  CFStringRef get kCFStreamPropertySocketSecurityLevel =>
      _kCFStreamPropertySocketSecurityLevel.value;

  set kCFStreamPropertySocketSecurityLevel(CFStringRef value) =>
      _kCFStreamPropertySocketSecurityLevel.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamSocketSecurityLevelNone =
      _lookup<CFStringRef>('kCFStreamSocketSecurityLevelNone');

  CFStringRef get kCFStreamSocketSecurityLevelNone =>
      _kCFStreamSocketSecurityLevelNone.value;

  set kCFStreamSocketSecurityLevelNone(CFStringRef value) =>
      _kCFStreamSocketSecurityLevelNone.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamSocketSecurityLevelSSLv2 =
      _lookup<CFStringRef>('kCFStreamSocketSecurityLevelSSLv2');

  CFStringRef get kCFStreamSocketSecurityLevelSSLv2 =>
      _kCFStreamSocketSecurityLevelSSLv2.value;

  set kCFStreamSocketSecurityLevelSSLv2(CFStringRef value) =>
      _kCFStreamSocketSecurityLevelSSLv2.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamSocketSecurityLevelSSLv3 =
      _lookup<CFStringRef>('kCFStreamSocketSecurityLevelSSLv3');

  CFStringRef get kCFStreamSocketSecurityLevelSSLv3 =>
      _kCFStreamSocketSecurityLevelSSLv3.value;

  set kCFStreamSocketSecurityLevelSSLv3(CFStringRef value) =>
      _kCFStreamSocketSecurityLevelSSLv3.value = value;

  late final ffi.Pointer<CFStringRef> _kCFStreamSocketSecurityLevelTLSv1 =
      _lookup<CFStringRef>('kCFStreamSocketSecurityLevelTLSv1');

  CFStringRef get kCFStreamSocketSecurityLevelTLSv1 =>
      _kCFStreamSocketSecurityLevelTLSv1.value;

  set kCFStreamSocketSecurityLevelTLSv1(CFStringRef value) =>
      _kCFStreamSocketSecurityLevelTLSv1.value = value;

  late final ffi.Pointer<CFStringRef>
      _kCFStreamSocketSecurityLevelNegotiatedSSL =
      _lookup<CFStringRef>('kCFStreamSocketSecurityLevelNegotiatedSSL');

  CFStringRef get kCFStreamSocketSecurityLevelNegotiatedSSL =>
      _kCFStreamSocketSecurityLevelNegotiatedSSL.value;

  set kCFStreamSocketSecurityLevelNegotiatedSSL(CFStringRef value) =>
      _kCFStreamSocketSecurityLevelNegotiatedSSL.value = value;

  late final ffi.Pointer<CFStringRef>
      _kCFStreamPropertyShouldCloseNativeSocket =
      _lookup<CFStringRef>('kCFStreamPropertyShouldCloseNativeSocket');

  CFStringRef get kCFStreamPropertyShouldCloseNativeSocket =>
      _kCFStreamPropertyShouldCloseNativeSocket.value;

  set kCFStreamPropertyShouldCloseNativeSocket(CFStringRef value) =>
      _kCFStreamPropertyShouldCloseNativeSocket.value = value;

  void CFStreamCreatePairWithSocket(
    CFAllocatorRef alloc,
    int sock,
    ffi.Pointer<CFReadStreamRef> readStream,
    ffi.Pointer<CFWriteStreamRef> writeStream,
  ) {
    return _CFStreamCreatePairWithSocket(
      alloc,
      sock,
      readStream,
      writeStream,
    );
  }

  late final _CFStreamCreatePairWithSocketPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFAllocatorRef,
              CFSocketNativeHandle,
              ffi.Pointer<CFReadStreamRef>,
              ffi.Pointer<CFWriteStreamRef>)>>('CFStreamCreatePairWithSocket');
  late final _CFStreamCreatePairWithSocket =
      _CFStreamCreatePairWithSocketPtr.asFunction<
          void Function(CFAllocatorRef, int, ffi.Pointer<CFReadStreamRef>,
              ffi.Pointer<CFWriteStreamRef>)>();

  void CFStreamCreatePairWithSocketToHost(
    CFAllocatorRef alloc,
    CFStringRef host,
    int port,
    ffi.Pointer<CFReadStreamRef> readStream,
    ffi.Pointer<CFWriteStreamRef> writeStream,
  ) {
    return _CFStreamCreatePairWithSocketToHost(
      alloc,
      host,
      port,
      readStream,
      writeStream,
    );
  }

  late final _CFStreamCreatePairWithSocketToHostPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  CFAllocatorRef,
                  CFStringRef,
                  UInt32,
                  ffi.Pointer<CFReadStreamRef>,
                  ffi.Pointer<CFWriteStreamRef>)>>(
      'CFStreamCreatePairWithSocketToHost');
  late final _CFStreamCreatePairWithSocketToHost =
      _CFStreamCreatePairWithSocketToHostPtr.asFunction<
          void Function(CFAllocatorRef, CFStringRef, int,
              ffi.Pointer<CFReadStreamRef>, ffi.Pointer<CFWriteStreamRef>)>();

  void CFStreamCreatePairWithPeerSocketSignature(
    CFAllocatorRef alloc,
    ffi.Pointer<CFSocketSignature> signature,
    ffi.Pointer<CFReadStreamRef> readStream,
    ffi.Pointer<CFWriteStreamRef> writeStream,
  ) {
    return _CFStreamCreatePairWithPeerSocketSignature(
      alloc,
      signature,
      readStream,
      writeStream,
    );
  }

  late final _CFStreamCreatePairWithPeerSocketSignaturePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  CFAllocatorRef,
                  ffi.Pointer<CFSocketSignature>,
                  ffi.Pointer<CFReadStreamRef>,
                  ffi.Pointer<CFWriteStreamRef>)>>(
      'CFStreamCreatePairWithPeerSocketSignature');
  late final _CFStreamCreatePairWithPeerSocketSignature =
      _CFStreamCreatePairWithPeerSocketSignaturePtr.asFunction<
          void Function(CFAllocatorRef, ffi.Pointer<CFSocketSignature>,
              ffi.Pointer<CFReadStreamRef>, ffi.Pointer<CFWriteStreamRef>)>();

  CFStreamStatus CFReadStreamGetStatus(
    CFReadStreamRef stream,
  ) {
    return CFStreamStatus.fromValue(_CFReadStreamGetStatus(
      stream,
    ));
  }

  late final _CFReadStreamGetStatusPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFReadStreamRef)>>(
          'CFReadStreamGetStatus');
  late final _CFReadStreamGetStatus =
      _CFReadStreamGetStatusPtr.asFunction<int Function(CFReadStreamRef)>();

  CFStreamStatus CFWriteStreamGetStatus(
    CFWriteStreamRef stream,
  ) {
    return CFStreamStatus.fromValue(_CFWriteStreamGetStatus(
      stream,
    ));
  }

  late final _CFWriteStreamGetStatusPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFWriteStreamRef)>>(
          'CFWriteStreamGetStatus');
  late final _CFWriteStreamGetStatus =
      _CFWriteStreamGetStatusPtr.asFunction<int Function(CFWriteStreamRef)>();

  CFErrorRef CFReadStreamCopyError(
    CFReadStreamRef stream,
  ) {
    return _CFReadStreamCopyError(
      stream,
    );
  }

  late final _CFReadStreamCopyErrorPtr =
      _lookup<ffi.NativeFunction<CFErrorRef Function(CFReadStreamRef)>>(
          'CFReadStreamCopyError');
  late final _CFReadStreamCopyError = _CFReadStreamCopyErrorPtr.asFunction<
      CFErrorRef Function(CFReadStreamRef)>();

  CFErrorRef CFWriteStreamCopyError(
    CFWriteStreamRef stream,
  ) {
    return _CFWriteStreamCopyError(
      stream,
    );
  }

  late final _CFWriteStreamCopyErrorPtr =
      _lookup<ffi.NativeFunction<CFErrorRef Function(CFWriteStreamRef)>>(
          'CFWriteStreamCopyError');
  late final _CFWriteStreamCopyError = _CFWriteStreamCopyErrorPtr.asFunction<
      CFErrorRef Function(CFWriteStreamRef)>();

  int CFReadStreamOpen(
    CFReadStreamRef stream,
  ) {
    return _CFReadStreamOpen(
      stream,
    );
  }

  late final _CFReadStreamOpenPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFReadStreamRef)>>(
          'CFReadStreamOpen');
  late final _CFReadStreamOpen =
      _CFReadStreamOpenPtr.asFunction<int Function(CFReadStreamRef)>();

  int CFWriteStreamOpen(
    CFWriteStreamRef stream,
  ) {
    return _CFWriteStreamOpen(
      stream,
    );
  }

  late final _CFWriteStreamOpenPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFWriteStreamRef)>>(
          'CFWriteStreamOpen');
  late final _CFWriteStreamOpen =
      _CFWriteStreamOpenPtr.asFunction<int Function(CFWriteStreamRef)>();

  void CFReadStreamClose(
    CFReadStreamRef stream,
  ) {
    return _CFReadStreamClose(
      stream,
    );
  }

  late final _CFReadStreamClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFReadStreamRef)>>(
          'CFReadStreamClose');
  late final _CFReadStreamClose =
      _CFReadStreamClosePtr.asFunction<void Function(CFReadStreamRef)>();

  void CFWriteStreamClose(
    CFWriteStreamRef stream,
  ) {
    return _CFWriteStreamClose(
      stream,
    );
  }

  late final _CFWriteStreamClosePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFWriteStreamRef)>>(
          'CFWriteStreamClose');
  late final _CFWriteStreamClose =
      _CFWriteStreamClosePtr.asFunction<void Function(CFWriteStreamRef)>();

  int CFReadStreamHasBytesAvailable(
    CFReadStreamRef stream,
  ) {
    return _CFReadStreamHasBytesAvailable(
      stream,
    );
  }

  late final _CFReadStreamHasBytesAvailablePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFReadStreamRef)>>(
          'CFReadStreamHasBytesAvailable');
  late final _CFReadStreamHasBytesAvailable = _CFReadStreamHasBytesAvailablePtr
      .asFunction<int Function(CFReadStreamRef)>();

  int CFReadStreamRead(
    CFReadStreamRef stream,
    ffi.Pointer<UInt8> buffer,
    int bufferLength,
  ) {
    return _CFReadStreamRead(
      stream,
      buffer,
      bufferLength,
    );
  }

  late final _CFReadStreamReadPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFReadStreamRef, ffi.Pointer<UInt8>,
              CFIndex)>>('CFReadStreamRead');
  late final _CFReadStreamRead = _CFReadStreamReadPtr.asFunction<
      int Function(CFReadStreamRef, ffi.Pointer<UInt8>, int)>();

  ffi.Pointer<UInt8> CFReadStreamGetBuffer(
    CFReadStreamRef stream,
    int maxBytesToRead,
    ffi.Pointer<CFIndex> numBytesRead,
  ) {
    return _CFReadStreamGetBuffer(
      stream,
      maxBytesToRead,
      numBytesRead,
    );
  }

  late final _CFReadStreamGetBufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<UInt8> Function(CFReadStreamRef, CFIndex,
              ffi.Pointer<CFIndex>)>>('CFReadStreamGetBuffer');
  late final _CFReadStreamGetBuffer = _CFReadStreamGetBufferPtr.asFunction<
      ffi.Pointer<UInt8> Function(
          CFReadStreamRef, int, ffi.Pointer<CFIndex>)>();

  int CFWriteStreamCanAcceptBytes(
    CFWriteStreamRef stream,
  ) {
    return _CFWriteStreamCanAcceptBytes(
      stream,
    );
  }

  late final _CFWriteStreamCanAcceptBytesPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFWriteStreamRef)>>(
          'CFWriteStreamCanAcceptBytes');
  late final _CFWriteStreamCanAcceptBytes = _CFWriteStreamCanAcceptBytesPtr
      .asFunction<int Function(CFWriteStreamRef)>();

  int CFWriteStreamWrite(
    CFWriteStreamRef stream,
    ffi.Pointer<UInt8> buffer,
    int bufferLength,
  ) {
    return _CFWriteStreamWrite(
      stream,
      buffer,
      bufferLength,
    );
  }

  late final _CFWriteStreamWritePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFWriteStreamRef, ffi.Pointer<UInt8>,
              CFIndex)>>('CFWriteStreamWrite');
  late final _CFWriteStreamWrite = _CFWriteStreamWritePtr.asFunction<
      int Function(CFWriteStreamRef, ffi.Pointer<UInt8>, int)>();

  CFTypeRef CFReadStreamCopyProperty(
    CFReadStreamRef stream,
    CFStreamPropertyKey propertyName,
  ) {
    return _CFReadStreamCopyProperty(
      stream,
      propertyName,
    );
  }

  late final _CFReadStreamCopyPropertyPtr = _lookup<
      ffi.NativeFunction<
          CFTypeRef Function(CFReadStreamRef,
              CFStreamPropertyKey)>>('CFReadStreamCopyProperty');
  late final _CFReadStreamCopyProperty = _CFReadStreamCopyPropertyPtr
      .asFunction<CFTypeRef Function(CFReadStreamRef, CFStreamPropertyKey)>();

  CFTypeRef CFWriteStreamCopyProperty(
    CFWriteStreamRef stream,
    CFStreamPropertyKey propertyName,
  ) {
    return _CFWriteStreamCopyProperty(
      stream,
      propertyName,
    );
  }

  late final _CFWriteStreamCopyPropertyPtr = _lookup<
      ffi.NativeFunction<
          CFTypeRef Function(CFWriteStreamRef,
              CFStreamPropertyKey)>>('CFWriteStreamCopyProperty');
  late final _CFWriteStreamCopyProperty = _CFWriteStreamCopyPropertyPtr
      .asFunction<CFTypeRef Function(CFWriteStreamRef, CFStreamPropertyKey)>();

  int CFReadStreamSetProperty(
    CFReadStreamRef stream,
    CFStreamPropertyKey propertyName,
    CFTypeRef propertyValue,
  ) {
    return _CFReadStreamSetProperty(
      stream,
      propertyName,
      propertyValue,
    );
  }

  late final _CFReadStreamSetPropertyPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFReadStreamRef, CFStreamPropertyKey,
              CFTypeRef)>>('CFReadStreamSetProperty');
  late final _CFReadStreamSetProperty = _CFReadStreamSetPropertyPtr.asFunction<
      int Function(CFReadStreamRef, CFStreamPropertyKey, CFTypeRef)>();

  int CFWriteStreamSetProperty(
    CFWriteStreamRef stream,
    CFStreamPropertyKey propertyName,
    CFTypeRef propertyValue,
  ) {
    return _CFWriteStreamSetProperty(
      stream,
      propertyName,
      propertyValue,
    );
  }

  late final _CFWriteStreamSetPropertyPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFWriteStreamRef, CFStreamPropertyKey,
              CFTypeRef)>>('CFWriteStreamSetProperty');
  late final _CFWriteStreamSetProperty =
      _CFWriteStreamSetPropertyPtr.asFunction<
          int Function(CFWriteStreamRef, CFStreamPropertyKey, CFTypeRef)>();

  int CFReadStreamSetClient(
    CFReadStreamRef stream,
    int streamEvents,
    CFReadStreamClientCallBack clientCB,
    ffi.Pointer<CFStreamClientContext> clientContext,
  ) {
    return _CFReadStreamSetClient(
      stream,
      streamEvents,
      clientCB,
      clientContext,
    );
  }

  late final _CFReadStreamSetClientPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(
              CFReadStreamRef,
              CFOptionFlags,
              CFReadStreamClientCallBack,
              ffi.Pointer<CFStreamClientContext>)>>('CFReadStreamSetClient');
  late final _CFReadStreamSetClient = _CFReadStreamSetClientPtr.asFunction<
      int Function(CFReadStreamRef, int, CFReadStreamClientCallBack,
          ffi.Pointer<CFStreamClientContext>)>();

  int CFWriteStreamSetClient(
    CFWriteStreamRef stream,
    int streamEvents,
    CFWriteStreamClientCallBack clientCB,
    ffi.Pointer<CFStreamClientContext> clientContext,
  ) {
    return _CFWriteStreamSetClient(
      stream,
      streamEvents,
      clientCB,
      clientContext,
    );
  }

  late final _CFWriteStreamSetClientPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(
              CFWriteStreamRef,
              CFOptionFlags,
              CFWriteStreamClientCallBack,
              ffi.Pointer<CFStreamClientContext>)>>('CFWriteStreamSetClient');
  late final _CFWriteStreamSetClient = _CFWriteStreamSetClientPtr.asFunction<
      int Function(CFWriteStreamRef, int, CFWriteStreamClientCallBack,
          ffi.Pointer<CFStreamClientContext>)>();

  void CFReadStreamScheduleWithRunLoop(
    CFReadStreamRef stream,
    CFRunLoopRef runLoop,
    CFRunLoopMode runLoopMode,
  ) {
    return _CFReadStreamScheduleWithRunLoop(
      stream,
      runLoop,
      runLoopMode,
    );
  }

  late final _CFReadStreamScheduleWithRunLoopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFReadStreamRef, CFRunLoopRef,
              CFRunLoopMode)>>('CFReadStreamScheduleWithRunLoop');
  late final _CFReadStreamScheduleWithRunLoop =
      _CFReadStreamScheduleWithRunLoopPtr.asFunction<
          void Function(CFReadStreamRef, CFRunLoopRef, CFRunLoopMode)>();

  void CFWriteStreamScheduleWithRunLoop(
    CFWriteStreamRef stream,
    CFRunLoopRef runLoop,
    CFRunLoopMode runLoopMode,
  ) {
    return _CFWriteStreamScheduleWithRunLoop(
      stream,
      runLoop,
      runLoopMode,
    );
  }

  late final _CFWriteStreamScheduleWithRunLoopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFWriteStreamRef, CFRunLoopRef,
              CFRunLoopMode)>>('CFWriteStreamScheduleWithRunLoop');
  late final _CFWriteStreamScheduleWithRunLoop =
      _CFWriteStreamScheduleWithRunLoopPtr.asFunction<
          void Function(CFWriteStreamRef, CFRunLoopRef, CFRunLoopMode)>();

  void CFReadStreamUnscheduleFromRunLoop(
    CFReadStreamRef stream,
    CFRunLoopRef runLoop,
    CFRunLoopMode runLoopMode,
  ) {
    return _CFReadStreamUnscheduleFromRunLoop(
      stream,
      runLoop,
      runLoopMode,
    );
  }

  late final _CFReadStreamUnscheduleFromRunLoopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFReadStreamRef, CFRunLoopRef,
              CFRunLoopMode)>>('CFReadStreamUnscheduleFromRunLoop');
  late final _CFReadStreamUnscheduleFromRunLoop =
      _CFReadStreamUnscheduleFromRunLoopPtr.asFunction<
          void Function(CFReadStreamRef, CFRunLoopRef, CFRunLoopMode)>();

  void CFWriteStreamUnscheduleFromRunLoop(
    CFWriteStreamRef stream,
    CFRunLoopRef runLoop,
    CFRunLoopMode runLoopMode,
  ) {
    return _CFWriteStreamUnscheduleFromRunLoop(
      stream,
      runLoop,
      runLoopMode,
    );
  }

  late final _CFWriteStreamUnscheduleFromRunLoopPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFWriteStreamRef, CFRunLoopRef,
              CFRunLoopMode)>>('CFWriteStreamUnscheduleFromRunLoop');
  late final _CFWriteStreamUnscheduleFromRunLoop =
      _CFWriteStreamUnscheduleFromRunLoopPtr.asFunction<
          void Function(CFWriteStreamRef, CFRunLoopRef, CFRunLoopMode)>();

  void CFReadStreamSetDispatchQueue(
    CFReadStreamRef stream,
    Dartdispatch_queue_t q,
  ) {
    return _CFReadStreamSetDispatchQueue(
      stream,
      q.ref.pointer,
    );
  }

  late final _CFReadStreamSetDispatchQueuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFReadStreamRef,
              dispatch_queue_t)>>('CFReadStreamSetDispatchQueue');
  late final _CFReadStreamSetDispatchQueue = _CFReadStreamSetDispatchQueuePtr
      .asFunction<void Function(CFReadStreamRef, dispatch_queue_t)>();

  void CFWriteStreamSetDispatchQueue(
    CFWriteStreamRef stream,
    Dartdispatch_queue_t q,
  ) {
    return _CFWriteStreamSetDispatchQueue(
      stream,
      q.ref.pointer,
    );
  }

  late final _CFWriteStreamSetDispatchQueuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFWriteStreamRef,
              dispatch_queue_t)>>('CFWriteStreamSetDispatchQueue');
  late final _CFWriteStreamSetDispatchQueue = _CFWriteStreamSetDispatchQueuePtr
      .asFunction<void Function(CFWriteStreamRef, dispatch_queue_t)>();

  Dartdispatch_queue_t CFReadStreamCopyDispatchQueue(
    CFReadStreamRef stream,
  ) {
    return objc.NSObject.castFromPointer(
        _CFReadStreamCopyDispatchQueue(
          stream,
        ),
        retain: true,
        release: true);
  }

  late final _CFReadStreamCopyDispatchQueuePtr =
      _lookup<ffi.NativeFunction<dispatch_queue_t Function(CFReadStreamRef)>>(
          'CFReadStreamCopyDispatchQueue');
  late final _CFReadStreamCopyDispatchQueue = _CFReadStreamCopyDispatchQueuePtr
      .asFunction<dispatch_queue_t Function(CFReadStreamRef)>();

  Dartdispatch_queue_t CFWriteStreamCopyDispatchQueue(
    CFWriteStreamRef stream,
  ) {
    return objc.NSObject.castFromPointer(
        _CFWriteStreamCopyDispatchQueue(
          stream,
        ),
        retain: true,
        release: true);
  }

  late final _CFWriteStreamCopyDispatchQueuePtr =
      _lookup<ffi.NativeFunction<dispatch_queue_t Function(CFWriteStreamRef)>>(
          'CFWriteStreamCopyDispatchQueue');
  late final _CFWriteStreamCopyDispatchQueue =
      _CFWriteStreamCopyDispatchQueuePtr.asFunction<
          dispatch_queue_t Function(CFWriteStreamRef)>();

  CFStreamError CFReadStreamGetError(
    CFReadStreamRef stream,
  ) {
    return _CFReadStreamGetError(
      stream,
    );
  }

  late final _CFReadStreamGetErrorPtr =
      _lookup<ffi.NativeFunction<CFStreamError Function(CFReadStreamRef)>>(
          'CFReadStreamGetError');
  late final _CFReadStreamGetError = _CFReadStreamGetErrorPtr.asFunction<
      CFStreamError Function(CFReadStreamRef)>();

  CFStreamError CFWriteStreamGetError(
    CFWriteStreamRef stream,
  ) {
    return _CFWriteStreamGetError(
      stream,
    );
  }

  late final _CFWriteStreamGetErrorPtr =
      _lookup<ffi.NativeFunction<CFStreamError Function(CFWriteStreamRef)>>(
          'CFWriteStreamGetError');
  late final _CFWriteStreamGetError = _CFWriteStreamGetErrorPtr.asFunction<
      CFStreamError Function(CFWriteStreamRef)>();

  CFPropertyListRef CFPropertyListCreateFromXMLData(
    CFAllocatorRef allocator,
    CFDataRef xmlData,
    int mutabilityOption,
    ffi.Pointer<CFStringRef> errorString,
  ) {
    return _CFPropertyListCreateFromXMLData(
      allocator,
      xmlData,
      mutabilityOption,
      errorString,
    );
  }

  late final _CFPropertyListCreateFromXMLDataPtr = _lookup<
      ffi.NativeFunction<
          CFPropertyListRef Function(CFAllocatorRef, CFDataRef, CFOptionFlags,
              ffi.Pointer<CFStringRef>)>>('CFPropertyListCreateFromXMLData');
  late final _CFPropertyListCreateFromXMLData =
      _CFPropertyListCreateFromXMLDataPtr.asFunction<
          CFPropertyListRef Function(
              CFAllocatorRef, CFDataRef, int, ffi.Pointer<CFStringRef>)>();

  CFDataRef CFPropertyListCreateXMLData(
    CFAllocatorRef allocator,
    CFPropertyListRef propertyList,
  ) {
    return _CFPropertyListCreateXMLData(
      allocator,
      propertyList,
    );
  }

  late final _CFPropertyListCreateXMLDataPtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(CFAllocatorRef,
              CFPropertyListRef)>>('CFPropertyListCreateXMLData');
  late final _CFPropertyListCreateXMLData = _CFPropertyListCreateXMLDataPtr
      .asFunction<CFDataRef Function(CFAllocatorRef, CFPropertyListRef)>();

  CFPropertyListRef CFPropertyListCreateDeepCopy(
    CFAllocatorRef allocator,
    CFPropertyListRef propertyList,
    int mutabilityOption,
  ) {
    return _CFPropertyListCreateDeepCopy(
      allocator,
      propertyList,
      mutabilityOption,
    );
  }

  late final _CFPropertyListCreateDeepCopyPtr = _lookup<
      ffi.NativeFunction<
          CFPropertyListRef Function(CFAllocatorRef, CFPropertyListRef,
              CFOptionFlags)>>('CFPropertyListCreateDeepCopy');
  late final _CFPropertyListCreateDeepCopy =
      _CFPropertyListCreateDeepCopyPtr.asFunction<
          CFPropertyListRef Function(CFAllocatorRef, CFPropertyListRef, int)>();

  DartBoolean CFPropertyListIsValid(
    CFPropertyListRef plist,
    CFPropertyListFormat format,
  ) {
    return _CFPropertyListIsValid(
      plist,
      format.value,
    );
  }

  late final _CFPropertyListIsValidPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFPropertyListRef, CFIndex)>>(
          'CFPropertyListIsValid');
  late final _CFPropertyListIsValid = _CFPropertyListIsValidPtr.asFunction<
      int Function(CFPropertyListRef, int)>();

  DartCFIndex CFPropertyListWriteToStream(
    CFPropertyListRef propertyList,
    CFWriteStreamRef stream,
    CFPropertyListFormat format,
    ffi.Pointer<CFStringRef> errorString,
  ) {
    return _CFPropertyListWriteToStream(
      propertyList,
      stream,
      format.value,
      errorString,
    );
  }

  late final _CFPropertyListWriteToStreamPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFPropertyListRef, CFWriteStreamRef, CFIndex,
              ffi.Pointer<CFStringRef>)>>('CFPropertyListWriteToStream');
  late final _CFPropertyListWriteToStream =
      _CFPropertyListWriteToStreamPtr.asFunction<
          int Function(CFPropertyListRef, CFWriteStreamRef, int,
              ffi.Pointer<CFStringRef>)>();

  CFPropertyListRef CFPropertyListCreateFromStream(
    CFAllocatorRef allocator,
    CFReadStreamRef stream,
    int streamLength,
    int mutabilityOption,
    ffi.Pointer<CFIndex> format,
    ffi.Pointer<CFStringRef> errorString,
  ) {
    return _CFPropertyListCreateFromStream(
      allocator,
      stream,
      streamLength,
      mutabilityOption,
      format,
      errorString,
    );
  }

  late final _CFPropertyListCreateFromStreamPtr = _lookup<
      ffi.NativeFunction<
          CFPropertyListRef Function(
              CFAllocatorRef,
              CFReadStreamRef,
              CFIndex,
              CFOptionFlags,
              ffi.Pointer<CFIndex>,
              ffi.Pointer<CFStringRef>)>>('CFPropertyListCreateFromStream');
  late final _CFPropertyListCreateFromStream =
      _CFPropertyListCreateFromStreamPtr.asFunction<
          CFPropertyListRef Function(CFAllocatorRef, CFReadStreamRef, int, int,
              ffi.Pointer<CFIndex>, ffi.Pointer<CFStringRef>)>();

  CFPropertyListRef CFPropertyListCreateWithData(
    CFAllocatorRef allocator,
    CFDataRef data,
    int options,
    ffi.Pointer<CFIndex> format,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFPropertyListCreateWithData(
      allocator,
      data,
      options,
      format,
      error,
    );
  }

  late final _CFPropertyListCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          CFPropertyListRef Function(
              CFAllocatorRef,
              CFDataRef,
              CFOptionFlags,
              ffi.Pointer<CFIndex>,
              ffi.Pointer<CFErrorRef>)>>('CFPropertyListCreateWithData');
  late final _CFPropertyListCreateWithData =
      _CFPropertyListCreateWithDataPtr.asFunction<
          CFPropertyListRef Function(CFAllocatorRef, CFDataRef, int,
              ffi.Pointer<CFIndex>, ffi.Pointer<CFErrorRef>)>();

  CFPropertyListRef CFPropertyListCreateWithStream(
    CFAllocatorRef allocator,
    CFReadStreamRef stream,
    int streamLength,
    int options,
    ffi.Pointer<CFIndex> format,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFPropertyListCreateWithStream(
      allocator,
      stream,
      streamLength,
      options,
      format,
      error,
    );
  }

  late final _CFPropertyListCreateWithStreamPtr = _lookup<
      ffi.NativeFunction<
          CFPropertyListRef Function(
              CFAllocatorRef,
              CFReadStreamRef,
              CFIndex,
              CFOptionFlags,
              ffi.Pointer<CFIndex>,
              ffi.Pointer<CFErrorRef>)>>('CFPropertyListCreateWithStream');
  late final _CFPropertyListCreateWithStream =
      _CFPropertyListCreateWithStreamPtr.asFunction<
          CFPropertyListRef Function(CFAllocatorRef, CFReadStreamRef, int, int,
              ffi.Pointer<CFIndex>, ffi.Pointer<CFErrorRef>)>();

  DartCFIndex CFPropertyListWrite(
    CFPropertyListRef propertyList,
    CFWriteStreamRef stream,
    CFPropertyListFormat format,
    DartCFOptionFlags options,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFPropertyListWrite(
      propertyList,
      stream,
      format.value,
      options,
      error,
    );
  }

  late final _CFPropertyListWritePtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFPropertyListRef, CFWriteStreamRef, CFIndex,
              CFOptionFlags, ffi.Pointer<CFErrorRef>)>>('CFPropertyListWrite');
  late final _CFPropertyListWrite = _CFPropertyListWritePtr.asFunction<
      int Function(CFPropertyListRef, CFWriteStreamRef, int, int,
          ffi.Pointer<CFErrorRef>)>();

  CFDataRef CFPropertyListCreateData(
    CFAllocatorRef allocator,
    CFPropertyListRef propertyList,
    CFPropertyListFormat format,
    DartCFOptionFlags options,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFPropertyListCreateData(
      allocator,
      propertyList,
      format.value,
      options,
      error,
    );
  }

  late final _CFPropertyListCreateDataPtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(
              CFAllocatorRef,
              CFPropertyListRef,
              CFIndex,
              CFOptionFlags,
              ffi.Pointer<CFErrorRef>)>>('CFPropertyListCreateData');
  late final _CFPropertyListCreateData =
      _CFPropertyListCreateDataPtr.asFunction<
          CFDataRef Function(CFAllocatorRef, CFPropertyListRef, int, int,
              ffi.Pointer<CFErrorRef>)>();

  late final ffi.Pointer<CFSetCallBacks> _kCFTypeSetCallBacks =
      _lookup<CFSetCallBacks>('kCFTypeSetCallBacks');

  CFSetCallBacks get kCFTypeSetCallBacks => _kCFTypeSetCallBacks.ref;

  late final ffi.Pointer<CFSetCallBacks> _kCFCopyStringSetCallBacks =
      _lookup<CFSetCallBacks>('kCFCopyStringSetCallBacks');

  CFSetCallBacks get kCFCopyStringSetCallBacks =>
      _kCFCopyStringSetCallBacks.ref;

  int CFSetGetTypeID() {
    return _CFSetGetTypeID();
  }

  late final _CFSetGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFSetGetTypeID');
  late final _CFSetGetTypeID = _CFSetGetTypeIDPtr.asFunction<int Function()>();

  CFSetRef CFSetCreate(
    CFAllocatorRef allocator,
    ffi.Pointer<ffi.Pointer<ffi.Void>> values,
    int numValues,
    ffi.Pointer<CFSetCallBacks> callBacks,
  ) {
    return _CFSetCreate(
      allocator,
      values,
      numValues,
      callBacks,
    );
  }

  late final _CFSetCreatePtr = _lookup<
      ffi.NativeFunction<
          CFSetRef Function(CFAllocatorRef, ffi.Pointer<ffi.Pointer<ffi.Void>>,
              CFIndex, ffi.Pointer<CFSetCallBacks>)>>('CFSetCreate');
  late final _CFSetCreate = _CFSetCreatePtr.asFunction<
      CFSetRef Function(CFAllocatorRef, ffi.Pointer<ffi.Pointer<ffi.Void>>, int,
          ffi.Pointer<CFSetCallBacks>)>();

  CFSetRef CFSetCreateCopy(
    CFAllocatorRef allocator,
    CFSetRef theSet,
  ) {
    return _CFSetCreateCopy(
      allocator,
      theSet,
    );
  }

  late final _CFSetCreateCopyPtr =
      _lookup<ffi.NativeFunction<CFSetRef Function(CFAllocatorRef, CFSetRef)>>(
          'CFSetCreateCopy');
  late final _CFSetCreateCopy = _CFSetCreateCopyPtr.asFunction<
      CFSetRef Function(CFAllocatorRef, CFSetRef)>();

  CFMutableSetRef CFSetCreateMutable(
    CFAllocatorRef allocator,
    int capacity,
    ffi.Pointer<CFSetCallBacks> callBacks,
  ) {
    return _CFSetCreateMutable(
      allocator,
      capacity,
      callBacks,
    );
  }

  late final _CFSetCreateMutablePtr = _lookup<
      ffi.NativeFunction<
          CFMutableSetRef Function(CFAllocatorRef, CFIndex,
              ffi.Pointer<CFSetCallBacks>)>>('CFSetCreateMutable');
  late final _CFSetCreateMutable = _CFSetCreateMutablePtr.asFunction<
      CFMutableSetRef Function(
          CFAllocatorRef, int, ffi.Pointer<CFSetCallBacks>)>();

  CFMutableSetRef CFSetCreateMutableCopy(
    CFAllocatorRef allocator,
    int capacity,
    CFSetRef theSet,
  ) {
    return _CFSetCreateMutableCopy(
      allocator,
      capacity,
      theSet,
    );
  }

  late final _CFSetCreateMutableCopyPtr = _lookup<
      ffi.NativeFunction<
          CFMutableSetRef Function(
              CFAllocatorRef, CFIndex, CFSetRef)>>('CFSetCreateMutableCopy');
  late final _CFSetCreateMutableCopy = _CFSetCreateMutableCopyPtr.asFunction<
      CFMutableSetRef Function(CFAllocatorRef, int, CFSetRef)>();

  int CFSetGetCount(
    CFSetRef theSet,
  ) {
    return _CFSetGetCount(
      theSet,
    );
  }

  late final _CFSetGetCountPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFSetRef)>>('CFSetGetCount');
  late final _CFSetGetCount =
      _CFSetGetCountPtr.asFunction<int Function(CFSetRef)>();

  int CFSetGetCountOfValue(
    CFSetRef theSet,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFSetGetCountOfValue(
      theSet,
      value,
    );
  }

  late final _CFSetGetCountOfValuePtr = _lookup<
          ffi
          .NativeFunction<CFIndex Function(CFSetRef, ffi.Pointer<ffi.Void>)>>(
      'CFSetGetCountOfValue');
  late final _CFSetGetCountOfValue = _CFSetGetCountOfValuePtr.asFunction<
      int Function(CFSetRef, ffi.Pointer<ffi.Void>)>();

  int CFSetContainsValue(
    CFSetRef theSet,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFSetContainsValue(
      theSet,
      value,
    );
  }

  late final _CFSetContainsValuePtr = _lookup<
          ffi
          .NativeFunction<Boolean Function(CFSetRef, ffi.Pointer<ffi.Void>)>>(
      'CFSetContainsValue');
  late final _CFSetContainsValue = _CFSetContainsValuePtr.asFunction<
      int Function(CFSetRef, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> CFSetGetValue(
    CFSetRef theSet,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFSetGetValue(
      theSet,
      value,
    );
  }

  late final _CFSetGetValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              CFSetRef, ffi.Pointer<ffi.Void>)>>('CFSetGetValue');
  late final _CFSetGetValue = _CFSetGetValuePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(CFSetRef, ffi.Pointer<ffi.Void>)>();

  int CFSetGetValueIfPresent(
    CFSetRef theSet,
    ffi.Pointer<ffi.Void> candidate,
    ffi.Pointer<ffi.Pointer<ffi.Void>> value,
  ) {
    return _CFSetGetValueIfPresent(
      theSet,
      candidate,
      value,
    );
  }

  late final _CFSetGetValueIfPresentPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFSetRef, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('CFSetGetValueIfPresent');
  late final _CFSetGetValueIfPresent = _CFSetGetValueIfPresentPtr.asFunction<
      int Function(CFSetRef, ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  void CFSetGetValues(
    CFSetRef theSet,
    ffi.Pointer<ffi.Pointer<ffi.Void>> values,
  ) {
    return _CFSetGetValues(
      theSet,
      values,
    );
  }

  late final _CFSetGetValuesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFSetRef, ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('CFSetGetValues');
  late final _CFSetGetValues = _CFSetGetValuesPtr.asFunction<
      void Function(CFSetRef, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  void CFSetApplyFunction(
    CFSetRef theSet,
    CFSetApplierFunction applier,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CFSetApplyFunction(
      theSet,
      applier,
      context,
    );
  }

  late final _CFSetApplyFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFSetRef, CFSetApplierFunction,
              ffi.Pointer<ffi.Void>)>>('CFSetApplyFunction');
  late final _CFSetApplyFunction = _CFSetApplyFunctionPtr.asFunction<
      void Function(CFSetRef, CFSetApplierFunction, ffi.Pointer<ffi.Void>)>();

  void CFSetAddValue(
    CFMutableSetRef theSet,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFSetAddValue(
      theSet,
      value,
    );
  }

  late final _CFSetAddValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableSetRef, ffi.Pointer<ffi.Void>)>>('CFSetAddValue');
  late final _CFSetAddValue = _CFSetAddValuePtr.asFunction<
      void Function(CFMutableSetRef, ffi.Pointer<ffi.Void>)>();

  void CFSetReplaceValue(
    CFMutableSetRef theSet,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFSetReplaceValue(
      theSet,
      value,
    );
  }

  late final _CFSetReplaceValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableSetRef, ffi.Pointer<ffi.Void>)>>('CFSetReplaceValue');
  late final _CFSetReplaceValue = _CFSetReplaceValuePtr.asFunction<
      void Function(CFMutableSetRef, ffi.Pointer<ffi.Void>)>();

  void CFSetSetValue(
    CFMutableSetRef theSet,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFSetSetValue(
      theSet,
      value,
    );
  }

  late final _CFSetSetValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableSetRef, ffi.Pointer<ffi.Void>)>>('CFSetSetValue');
  late final _CFSetSetValue = _CFSetSetValuePtr.asFunction<
      void Function(CFMutableSetRef, ffi.Pointer<ffi.Void>)>();

  void CFSetRemoveValue(
    CFMutableSetRef theSet,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _CFSetRemoveValue(
      theSet,
      value,
    );
  }

  late final _CFSetRemoveValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFMutableSetRef, ffi.Pointer<ffi.Void>)>>('CFSetRemoveValue');
  late final _CFSetRemoveValue = _CFSetRemoveValuePtr.asFunction<
      void Function(CFMutableSetRef, ffi.Pointer<ffi.Void>)>();

  void CFSetRemoveAllValues(
    CFMutableSetRef theSet,
  ) {
    return _CFSetRemoveAllValues(
      theSet,
    );
  }

  late final _CFSetRemoveAllValuesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMutableSetRef)>>(
          'CFSetRemoveAllValues');
  late final _CFSetRemoveAllValues =
      _CFSetRemoveAllValuesPtr.asFunction<void Function(CFMutableSetRef)>();

  int CFTreeGetTypeID() {
    return _CFTreeGetTypeID();
  }

  late final _CFTreeGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFTreeGetTypeID');
  late final _CFTreeGetTypeID =
      _CFTreeGetTypeIDPtr.asFunction<int Function()>();

  CFTreeRef CFTreeCreate(
    CFAllocatorRef allocator,
    ffi.Pointer<CFTreeContext> context,
  ) {
    return _CFTreeCreate(
      allocator,
      context,
    );
  }

  late final _CFTreeCreatePtr = _lookup<
      ffi.NativeFunction<
          CFTreeRef Function(
              CFAllocatorRef, ffi.Pointer<CFTreeContext>)>>('CFTreeCreate');
  late final _CFTreeCreate = _CFTreeCreatePtr.asFunction<
      CFTreeRef Function(CFAllocatorRef, ffi.Pointer<CFTreeContext>)>();

  CFTreeRef CFTreeGetParent(
    CFTreeRef tree,
  ) {
    return _CFTreeGetParent(
      tree,
    );
  }

  late final _CFTreeGetParentPtr =
      _lookup<ffi.NativeFunction<CFTreeRef Function(CFTreeRef)>>(
          'CFTreeGetParent');
  late final _CFTreeGetParent =
      _CFTreeGetParentPtr.asFunction<CFTreeRef Function(CFTreeRef)>();

  CFTreeRef CFTreeGetNextSibling(
    CFTreeRef tree,
  ) {
    return _CFTreeGetNextSibling(
      tree,
    );
  }

  late final _CFTreeGetNextSiblingPtr =
      _lookup<ffi.NativeFunction<CFTreeRef Function(CFTreeRef)>>(
          'CFTreeGetNextSibling');
  late final _CFTreeGetNextSibling =
      _CFTreeGetNextSiblingPtr.asFunction<CFTreeRef Function(CFTreeRef)>();

  CFTreeRef CFTreeGetFirstChild(
    CFTreeRef tree,
  ) {
    return _CFTreeGetFirstChild(
      tree,
    );
  }

  late final _CFTreeGetFirstChildPtr =
      _lookup<ffi.NativeFunction<CFTreeRef Function(CFTreeRef)>>(
          'CFTreeGetFirstChild');
  late final _CFTreeGetFirstChild =
      _CFTreeGetFirstChildPtr.asFunction<CFTreeRef Function(CFTreeRef)>();

  void CFTreeGetContext(
    CFTreeRef tree,
    ffi.Pointer<CFTreeContext> context,
  ) {
    return _CFTreeGetContext(
      tree,
      context,
    );
  }

  late final _CFTreeGetContextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFTreeRef, ffi.Pointer<CFTreeContext>)>>('CFTreeGetContext');
  late final _CFTreeGetContext = _CFTreeGetContextPtr.asFunction<
      void Function(CFTreeRef, ffi.Pointer<CFTreeContext>)>();

  int CFTreeGetChildCount(
    CFTreeRef tree,
  ) {
    return _CFTreeGetChildCount(
      tree,
    );
  }

  late final _CFTreeGetChildCountPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFTreeRef)>>(
          'CFTreeGetChildCount');
  late final _CFTreeGetChildCount =
      _CFTreeGetChildCountPtr.asFunction<int Function(CFTreeRef)>();

  CFTreeRef CFTreeGetChildAtIndex(
    CFTreeRef tree,
    int idx,
  ) {
    return _CFTreeGetChildAtIndex(
      tree,
      idx,
    );
  }

  late final _CFTreeGetChildAtIndexPtr =
      _lookup<ffi.NativeFunction<CFTreeRef Function(CFTreeRef, CFIndex)>>(
          'CFTreeGetChildAtIndex');
  late final _CFTreeGetChildAtIndex = _CFTreeGetChildAtIndexPtr.asFunction<
      CFTreeRef Function(CFTreeRef, int)>();

  void CFTreeGetChildren(
    CFTreeRef tree,
    ffi.Pointer<CFTreeRef> children,
  ) {
    return _CFTreeGetChildren(
      tree,
      children,
    );
  }

  late final _CFTreeGetChildrenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFTreeRef, ffi.Pointer<CFTreeRef>)>>('CFTreeGetChildren');
  late final _CFTreeGetChildren = _CFTreeGetChildrenPtr.asFunction<
      void Function(CFTreeRef, ffi.Pointer<CFTreeRef>)>();

  void CFTreeApplyFunctionToChildren(
    CFTreeRef tree,
    CFTreeApplierFunction applier,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CFTreeApplyFunctionToChildren(
      tree,
      applier,
      context,
    );
  }

  late final _CFTreeApplyFunctionToChildrenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFTreeRef, CFTreeApplierFunction,
              ffi.Pointer<ffi.Void>)>>('CFTreeApplyFunctionToChildren');
  late final _CFTreeApplyFunctionToChildren =
      _CFTreeApplyFunctionToChildrenPtr.asFunction<
          void Function(
              CFTreeRef, CFTreeApplierFunction, ffi.Pointer<ffi.Void>)>();

  CFTreeRef CFTreeFindRoot(
    CFTreeRef tree,
  ) {
    return _CFTreeFindRoot(
      tree,
    );
  }

  late final _CFTreeFindRootPtr =
      _lookup<ffi.NativeFunction<CFTreeRef Function(CFTreeRef)>>(
          'CFTreeFindRoot');
  late final _CFTreeFindRoot =
      _CFTreeFindRootPtr.asFunction<CFTreeRef Function(CFTreeRef)>();

  void CFTreeSetContext(
    CFTreeRef tree,
    ffi.Pointer<CFTreeContext> context,
  ) {
    return _CFTreeSetContext(
      tree,
      context,
    );
  }

  late final _CFTreeSetContextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFTreeRef, ffi.Pointer<CFTreeContext>)>>('CFTreeSetContext');
  late final _CFTreeSetContext = _CFTreeSetContextPtr.asFunction<
      void Function(CFTreeRef, ffi.Pointer<CFTreeContext>)>();

  void CFTreePrependChild(
    CFTreeRef tree,
    CFTreeRef newChild,
  ) {
    return _CFTreePrependChild(
      tree,
      newChild,
    );
  }

  late final _CFTreePrependChildPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFTreeRef, CFTreeRef)>>(
          'CFTreePrependChild');
  late final _CFTreePrependChild =
      _CFTreePrependChildPtr.asFunction<void Function(CFTreeRef, CFTreeRef)>();

  void CFTreeAppendChild(
    CFTreeRef tree,
    CFTreeRef newChild,
  ) {
    return _CFTreeAppendChild(
      tree,
      newChild,
    );
  }

  late final _CFTreeAppendChildPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFTreeRef, CFTreeRef)>>(
          'CFTreeAppendChild');
  late final _CFTreeAppendChild =
      _CFTreeAppendChildPtr.asFunction<void Function(CFTreeRef, CFTreeRef)>();

  void CFTreeInsertSibling(
    CFTreeRef tree,
    CFTreeRef newSibling,
  ) {
    return _CFTreeInsertSibling(
      tree,
      newSibling,
    );
  }

  late final _CFTreeInsertSiblingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFTreeRef, CFTreeRef)>>(
          'CFTreeInsertSibling');
  late final _CFTreeInsertSibling =
      _CFTreeInsertSiblingPtr.asFunction<void Function(CFTreeRef, CFTreeRef)>();

  void CFTreeRemove(
    CFTreeRef tree,
  ) {
    return _CFTreeRemove(
      tree,
    );
  }

  late final _CFTreeRemovePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFTreeRef)>>('CFTreeRemove');
  late final _CFTreeRemove =
      _CFTreeRemovePtr.asFunction<void Function(CFTreeRef)>();

  void CFTreeRemoveAllChildren(
    CFTreeRef tree,
  ) {
    return _CFTreeRemoveAllChildren(
      tree,
    );
  }

  late final _CFTreeRemoveAllChildrenPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFTreeRef)>>(
          'CFTreeRemoveAllChildren');
  late final _CFTreeRemoveAllChildren =
      _CFTreeRemoveAllChildrenPtr.asFunction<void Function(CFTreeRef)>();

  void CFTreeSortChildren(
    CFTreeRef tree,
    CFComparatorFunction comparator,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _CFTreeSortChildren(
      tree,
      comparator,
      context,
    );
  }

  late final _CFTreeSortChildrenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFTreeRef, CFComparatorFunction,
              ffi.Pointer<ffi.Void>)>>('CFTreeSortChildren');
  late final _CFTreeSortChildren = _CFTreeSortChildrenPtr.asFunction<
      void Function(CFTreeRef, CFComparatorFunction, ffi.Pointer<ffi.Void>)>();

  int CFURLCreateDataAndPropertiesFromResource(
    CFAllocatorRef alloc,
    CFURLRef url,
    ffi.Pointer<CFDataRef> resourceData,
    ffi.Pointer<CFDictionaryRef> properties,
    CFArrayRef desiredProperties,
    ffi.Pointer<SInt32> errorCode,
  ) {
    return _CFURLCreateDataAndPropertiesFromResource(
      alloc,
      url,
      resourceData,
      properties,
      desiredProperties,
      errorCode,
    );
  }

  late final _CFURLCreateDataAndPropertiesFromResourcePtr = _lookup<
          ffi.NativeFunction<
              Boolean Function(
                  CFAllocatorRef,
                  CFURLRef,
                  ffi.Pointer<CFDataRef>,
                  ffi.Pointer<CFDictionaryRef>,
                  CFArrayRef,
                  ffi.Pointer<SInt32>)>>(
      'CFURLCreateDataAndPropertiesFromResource');
  late final _CFURLCreateDataAndPropertiesFromResource =
      _CFURLCreateDataAndPropertiesFromResourcePtr.asFunction<
          int Function(CFAllocatorRef, CFURLRef, ffi.Pointer<CFDataRef>,
              ffi.Pointer<CFDictionaryRef>, CFArrayRef, ffi.Pointer<SInt32>)>();

  int CFURLWriteDataAndPropertiesToResource(
    CFURLRef url,
    CFDataRef dataToWrite,
    CFDictionaryRef propertiesToWrite,
    ffi.Pointer<SInt32> errorCode,
  ) {
    return _CFURLWriteDataAndPropertiesToResource(
      url,
      dataToWrite,
      propertiesToWrite,
      errorCode,
    );
  }

  late final _CFURLWriteDataAndPropertiesToResourcePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFURLRef, CFDataRef, CFDictionaryRef,
              ffi.Pointer<SInt32>)>>('CFURLWriteDataAndPropertiesToResource');
  late final _CFURLWriteDataAndPropertiesToResource =
      _CFURLWriteDataAndPropertiesToResourcePtr.asFunction<
          int Function(
              CFURLRef, CFDataRef, CFDictionaryRef, ffi.Pointer<SInt32>)>();

  int CFURLDestroyResource(
    CFURLRef url,
    ffi.Pointer<SInt32> errorCode,
  ) {
    return _CFURLDestroyResource(
      url,
      errorCode,
    );
  }

  late final _CFURLDestroyResourcePtr = _lookup<
          ffi.NativeFunction<Boolean Function(CFURLRef, ffi.Pointer<SInt32>)>>(
      'CFURLDestroyResource');
  late final _CFURLDestroyResource = _CFURLDestroyResourcePtr.asFunction<
      int Function(CFURLRef, ffi.Pointer<SInt32>)>();

  CFTypeRef CFURLCreatePropertyFromResource(
    CFAllocatorRef alloc,
    CFURLRef url,
    CFStringRef property,
    ffi.Pointer<SInt32> errorCode,
  ) {
    return _CFURLCreatePropertyFromResource(
      alloc,
      url,
      property,
      errorCode,
    );
  }

  late final _CFURLCreatePropertyFromResourcePtr = _lookup<
      ffi.NativeFunction<
          CFTypeRef Function(CFAllocatorRef, CFURLRef, CFStringRef,
              ffi.Pointer<SInt32>)>>('CFURLCreatePropertyFromResource');
  late final _CFURLCreatePropertyFromResource =
      _CFURLCreatePropertyFromResourcePtr.asFunction<
          CFTypeRef Function(
              CFAllocatorRef, CFURLRef, CFStringRef, ffi.Pointer<SInt32>)>();

  late final ffi.Pointer<CFStringRef> _kCFURLFileExists =
      _lookup<CFStringRef>('kCFURLFileExists');

  CFStringRef get kCFURLFileExists => _kCFURLFileExists.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileDirectoryContents =
      _lookup<CFStringRef>('kCFURLFileDirectoryContents');

  CFStringRef get kCFURLFileDirectoryContents =>
      _kCFURLFileDirectoryContents.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileLength =
      _lookup<CFStringRef>('kCFURLFileLength');

  CFStringRef get kCFURLFileLength => _kCFURLFileLength.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileLastModificationTime =
      _lookup<CFStringRef>('kCFURLFileLastModificationTime');

  CFStringRef get kCFURLFileLastModificationTime =>
      _kCFURLFileLastModificationTime.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFilePOSIXMode =
      _lookup<CFStringRef>('kCFURLFilePOSIXMode');

  CFStringRef get kCFURLFilePOSIXMode => _kCFURLFilePOSIXMode.value;

  late final ffi.Pointer<CFStringRef> _kCFURLFileOwnerID =
      _lookup<CFStringRef>('kCFURLFileOwnerID');

  CFStringRef get kCFURLFileOwnerID => _kCFURLFileOwnerID.value;

  late final ffi.Pointer<CFStringRef> _kCFURLHTTPStatusCode =
      _lookup<CFStringRef>('kCFURLHTTPStatusCode');

  CFStringRef get kCFURLHTTPStatusCode => _kCFURLHTTPStatusCode.value;

  late final ffi.Pointer<CFStringRef> _kCFURLHTTPStatusLine =
      _lookup<CFStringRef>('kCFURLHTTPStatusLine');

  CFStringRef get kCFURLHTTPStatusLine => _kCFURLHTTPStatusLine.value;

  int CFUUIDGetTypeID() {
    return _CFUUIDGetTypeID();
  }

  late final _CFUUIDGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFUUIDGetTypeID');
  late final _CFUUIDGetTypeID =
      _CFUUIDGetTypeIDPtr.asFunction<int Function()>();

  CFUUIDRef CFUUIDCreate(
    CFAllocatorRef alloc,
  ) {
    return _CFUUIDCreate(
      alloc,
    );
  }

  late final _CFUUIDCreatePtr =
      _lookup<ffi.NativeFunction<CFUUIDRef Function(CFAllocatorRef)>>(
          'CFUUIDCreate');
  late final _CFUUIDCreate =
      _CFUUIDCreatePtr.asFunction<CFUUIDRef Function(CFAllocatorRef)>();

  CFUUIDRef CFUUIDCreateWithBytes(
    CFAllocatorRef alloc,
    int byte0,
    int byte1,
    int byte2,
    int byte3,
    int byte4,
    int byte5,
    int byte6,
    int byte7,
    int byte8,
    int byte9,
    int byte10,
    int byte11,
    int byte12,
    int byte13,
    int byte14,
    int byte15,
  ) {
    return _CFUUIDCreateWithBytes(
      alloc,
      byte0,
      byte1,
      byte2,
      byte3,
      byte4,
      byte5,
      byte6,
      byte7,
      byte8,
      byte9,
      byte10,
      byte11,
      byte12,
      byte13,
      byte14,
      byte15,
    );
  }

  late final _CFUUIDCreateWithBytesPtr = _lookup<
      ffi.NativeFunction<
          CFUUIDRef Function(
              CFAllocatorRef,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8)>>('CFUUIDCreateWithBytes');
  late final _CFUUIDCreateWithBytes = _CFUUIDCreateWithBytesPtr.asFunction<
      CFUUIDRef Function(CFAllocatorRef, int, int, int, int, int, int, int, int,
          int, int, int, int, int, int, int, int)>();

  CFUUIDRef CFUUIDCreateFromString(
    CFAllocatorRef alloc,
    CFStringRef uuidStr,
  ) {
    return _CFUUIDCreateFromString(
      alloc,
      uuidStr,
    );
  }

  late final _CFUUIDCreateFromStringPtr = _lookup<
          ffi.NativeFunction<CFUUIDRef Function(CFAllocatorRef, CFStringRef)>>(
      'CFUUIDCreateFromString');
  late final _CFUUIDCreateFromString = _CFUUIDCreateFromStringPtr.asFunction<
      CFUUIDRef Function(CFAllocatorRef, CFStringRef)>();

  CFStringRef CFUUIDCreateString(
    CFAllocatorRef alloc,
    CFUUIDRef uuid,
  ) {
    return _CFUUIDCreateString(
      alloc,
      uuid,
    );
  }

  late final _CFUUIDCreateStringPtr = _lookup<
          ffi.NativeFunction<CFStringRef Function(CFAllocatorRef, CFUUIDRef)>>(
      'CFUUIDCreateString');
  late final _CFUUIDCreateString = _CFUUIDCreateStringPtr.asFunction<
      CFStringRef Function(CFAllocatorRef, CFUUIDRef)>();

  CFUUIDRef CFUUIDGetConstantUUIDWithBytes(
    CFAllocatorRef alloc,
    int byte0,
    int byte1,
    int byte2,
    int byte3,
    int byte4,
    int byte5,
    int byte6,
    int byte7,
    int byte8,
    int byte9,
    int byte10,
    int byte11,
    int byte12,
    int byte13,
    int byte14,
    int byte15,
  ) {
    return _CFUUIDGetConstantUUIDWithBytes(
      alloc,
      byte0,
      byte1,
      byte2,
      byte3,
      byte4,
      byte5,
      byte6,
      byte7,
      byte8,
      byte9,
      byte10,
      byte11,
      byte12,
      byte13,
      byte14,
      byte15,
    );
  }

  late final _CFUUIDGetConstantUUIDWithBytesPtr = _lookup<
      ffi.NativeFunction<
          CFUUIDRef Function(
              CFAllocatorRef,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8,
              UInt8)>>('CFUUIDGetConstantUUIDWithBytes');
  late final _CFUUIDGetConstantUUIDWithBytes =
      _CFUUIDGetConstantUUIDWithBytesPtr.asFunction<
          CFUUIDRef Function(CFAllocatorRef, int, int, int, int, int, int, int,
              int, int, int, int, int, int, int, int, int)>();

  CFUUIDBytes CFUUIDGetUUIDBytes(
    CFUUIDRef uuid,
  ) {
    return _CFUUIDGetUUIDBytes(
      uuid,
    );
  }

  late final _CFUUIDGetUUIDBytesPtr =
      _lookup<ffi.NativeFunction<CFUUIDBytes Function(CFUUIDRef)>>(
          'CFUUIDGetUUIDBytes');
  late final _CFUUIDGetUUIDBytes =
      _CFUUIDGetUUIDBytesPtr.asFunction<CFUUIDBytes Function(CFUUIDRef)>();

  CFUUIDRef CFUUIDCreateFromUUIDBytes(
    CFAllocatorRef alloc,
    CFUUIDBytes bytes,
  ) {
    return _CFUUIDCreateFromUUIDBytes(
      alloc,
      bytes,
    );
  }

  late final _CFUUIDCreateFromUUIDBytesPtr = _lookup<
          ffi.NativeFunction<CFUUIDRef Function(CFAllocatorRef, CFUUIDBytes)>>(
      'CFUUIDCreateFromUUIDBytes');
  late final _CFUUIDCreateFromUUIDBytes = _CFUUIDCreateFromUUIDBytesPtr
      .asFunction<CFUUIDRef Function(CFAllocatorRef, CFUUIDBytes)>();

  CFURLRef CFCopyHomeDirectoryURL() {
    return _CFCopyHomeDirectoryURL();
  }

  late final _CFCopyHomeDirectoryURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function()>>(
          'CFCopyHomeDirectoryURL');
  late final _CFCopyHomeDirectoryURL =
      _CFCopyHomeDirectoryURLPtr.asFunction<CFURLRef Function()>();

  late final ffi.Pointer<CFStringRef> _kCFBundleInfoDictionaryVersionKey =
      _lookup<CFStringRef>('kCFBundleInfoDictionaryVersionKey');

  CFStringRef get kCFBundleInfoDictionaryVersionKey =>
      _kCFBundleInfoDictionaryVersionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFBundleExecutableKey =
      _lookup<CFStringRef>('kCFBundleExecutableKey');

  CFStringRef get kCFBundleExecutableKey => _kCFBundleExecutableKey.value;

  late final ffi.Pointer<CFStringRef> _kCFBundleIdentifierKey =
      _lookup<CFStringRef>('kCFBundleIdentifierKey');

  CFStringRef get kCFBundleIdentifierKey => _kCFBundleIdentifierKey.value;

  late final ffi.Pointer<CFStringRef> _kCFBundleVersionKey =
      _lookup<CFStringRef>('kCFBundleVersionKey');

  CFStringRef get kCFBundleVersionKey => _kCFBundleVersionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFBundleDevelopmentRegionKey =
      _lookup<CFStringRef>('kCFBundleDevelopmentRegionKey');

  CFStringRef get kCFBundleDevelopmentRegionKey =>
      _kCFBundleDevelopmentRegionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFBundleNameKey =
      _lookup<CFStringRef>('kCFBundleNameKey');

  CFStringRef get kCFBundleNameKey => _kCFBundleNameKey.value;

  late final ffi.Pointer<CFStringRef> _kCFBundleLocalizationsKey =
      _lookup<CFStringRef>('kCFBundleLocalizationsKey');

  CFStringRef get kCFBundleLocalizationsKey => _kCFBundleLocalizationsKey.value;

  CFBundleRef CFBundleGetMainBundle() {
    return _CFBundleGetMainBundle();
  }

  late final _CFBundleGetMainBundlePtr =
      _lookup<ffi.NativeFunction<CFBundleRef Function()>>(
          'CFBundleGetMainBundle');
  late final _CFBundleGetMainBundle =
      _CFBundleGetMainBundlePtr.asFunction<CFBundleRef Function()>();

  CFBundleRef CFBundleGetBundleWithIdentifier(
    CFStringRef bundleID,
  ) {
    return _CFBundleGetBundleWithIdentifier(
      bundleID,
    );
  }

  late final _CFBundleGetBundleWithIdentifierPtr =
      _lookup<ffi.NativeFunction<CFBundleRef Function(CFStringRef)>>(
          'CFBundleGetBundleWithIdentifier');
  late final _CFBundleGetBundleWithIdentifier =
      _CFBundleGetBundleWithIdentifierPtr.asFunction<
          CFBundleRef Function(CFStringRef)>();

  CFArrayRef CFBundleGetAllBundles() {
    return _CFBundleGetAllBundles();
  }

  late final _CFBundleGetAllBundlesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function()>>(
          'CFBundleGetAllBundles');
  late final _CFBundleGetAllBundles =
      _CFBundleGetAllBundlesPtr.asFunction<CFArrayRef Function()>();

  int CFBundleGetTypeID() {
    return _CFBundleGetTypeID();
  }

  late final _CFBundleGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFBundleGetTypeID');
  late final _CFBundleGetTypeID =
      _CFBundleGetTypeIDPtr.asFunction<int Function()>();

  CFBundleRef CFBundleCreate(
    CFAllocatorRef allocator,
    CFURLRef bundleURL,
  ) {
    return _CFBundleCreate(
      allocator,
      bundleURL,
    );
  }

  late final _CFBundleCreatePtr = _lookup<
          ffi.NativeFunction<CFBundleRef Function(CFAllocatorRef, CFURLRef)>>(
      'CFBundleCreate');
  late final _CFBundleCreate = _CFBundleCreatePtr.asFunction<
      CFBundleRef Function(CFAllocatorRef, CFURLRef)>();

  CFArrayRef CFBundleCreateBundlesFromDirectory(
    CFAllocatorRef allocator,
    CFURLRef directoryURL,
    CFStringRef bundleType,
  ) {
    return _CFBundleCreateBundlesFromDirectory(
      allocator,
      directoryURL,
      bundleType,
    );
  }

  late final _CFBundleCreateBundlesFromDirectoryPtr = _lookup<
      ffi.NativeFunction<
          CFArrayRef Function(CFAllocatorRef, CFURLRef,
              CFStringRef)>>('CFBundleCreateBundlesFromDirectory');
  late final _CFBundleCreateBundlesFromDirectory =
      _CFBundleCreateBundlesFromDirectoryPtr.asFunction<
          CFArrayRef Function(CFAllocatorRef, CFURLRef, CFStringRef)>();

  CFURLRef CFBundleCopyBundleURL(
    CFBundleRef bundle,
  ) {
    return _CFBundleCopyBundleURL(
      bundle,
    );
  }

  late final _CFBundleCopyBundleURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFBundleRef)>>(
          'CFBundleCopyBundleURL');
  late final _CFBundleCopyBundleURL =
      _CFBundleCopyBundleURLPtr.asFunction<CFURLRef Function(CFBundleRef)>();

  CFTypeRef CFBundleGetValueForInfoDictionaryKey(
    CFBundleRef bundle,
    CFStringRef key,
  ) {
    return _CFBundleGetValueForInfoDictionaryKey(
      bundle,
      key,
    );
  }

  late final _CFBundleGetValueForInfoDictionaryKeyPtr =
      _lookup<ffi.NativeFunction<CFTypeRef Function(CFBundleRef, CFStringRef)>>(
          'CFBundleGetValueForInfoDictionaryKey');
  late final _CFBundleGetValueForInfoDictionaryKey =
      _CFBundleGetValueForInfoDictionaryKeyPtr.asFunction<
          CFTypeRef Function(CFBundleRef, CFStringRef)>();

  CFDictionaryRef CFBundleGetInfoDictionary(
    CFBundleRef bundle,
  ) {
    return _CFBundleGetInfoDictionary(
      bundle,
    );
  }

  late final _CFBundleGetInfoDictionaryPtr =
      _lookup<ffi.NativeFunction<CFDictionaryRef Function(CFBundleRef)>>(
          'CFBundleGetInfoDictionary');
  late final _CFBundleGetInfoDictionary = _CFBundleGetInfoDictionaryPtr
      .asFunction<CFDictionaryRef Function(CFBundleRef)>();

  CFDictionaryRef CFBundleGetLocalInfoDictionary(
    CFBundleRef bundle,
  ) {
    return _CFBundleGetLocalInfoDictionary(
      bundle,
    );
  }

  late final _CFBundleGetLocalInfoDictionaryPtr =
      _lookup<ffi.NativeFunction<CFDictionaryRef Function(CFBundleRef)>>(
          'CFBundleGetLocalInfoDictionary');
  late final _CFBundleGetLocalInfoDictionary =
      _CFBundleGetLocalInfoDictionaryPtr.asFunction<
          CFDictionaryRef Function(CFBundleRef)>();

  void CFBundleGetPackageInfo(
    CFBundleRef bundle,
    ffi.Pointer<UInt32> packageType,
    ffi.Pointer<UInt32> packageCreator,
  ) {
    return _CFBundleGetPackageInfo(
      bundle,
      packageType,
      packageCreator,
    );
  }

  late final _CFBundleGetPackageInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFBundleRef, ffi.Pointer<UInt32>,
              ffi.Pointer<UInt32>)>>('CFBundleGetPackageInfo');
  late final _CFBundleGetPackageInfo = _CFBundleGetPackageInfoPtr.asFunction<
      void Function(CFBundleRef, ffi.Pointer<UInt32>, ffi.Pointer<UInt32>)>();

  CFStringRef CFBundleGetIdentifier(
    CFBundleRef bundle,
  ) {
    return _CFBundleGetIdentifier(
      bundle,
    );
  }

  late final _CFBundleGetIdentifierPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFBundleRef)>>(
          'CFBundleGetIdentifier');
  late final _CFBundleGetIdentifier =
      _CFBundleGetIdentifierPtr.asFunction<CFStringRef Function(CFBundleRef)>();

  int CFBundleGetVersionNumber(
    CFBundleRef bundle,
  ) {
    return _CFBundleGetVersionNumber(
      bundle,
    );
  }

  late final _CFBundleGetVersionNumberPtr =
      _lookup<ffi.NativeFunction<UInt32 Function(CFBundleRef)>>(
          'CFBundleGetVersionNumber');
  late final _CFBundleGetVersionNumber =
      _CFBundleGetVersionNumberPtr.asFunction<int Function(CFBundleRef)>();

  CFStringRef CFBundleGetDevelopmentRegion(
    CFBundleRef bundle,
  ) {
    return _CFBundleGetDevelopmentRegion(
      bundle,
    );
  }

  late final _CFBundleGetDevelopmentRegionPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFBundleRef)>>(
          'CFBundleGetDevelopmentRegion');
  late final _CFBundleGetDevelopmentRegion = _CFBundleGetDevelopmentRegionPtr
      .asFunction<CFStringRef Function(CFBundleRef)>();

  CFURLRef CFBundleCopySupportFilesDirectoryURL(
    CFBundleRef bundle,
  ) {
    return _CFBundleCopySupportFilesDirectoryURL(
      bundle,
    );
  }

  late final _CFBundleCopySupportFilesDirectoryURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFBundleRef)>>(
          'CFBundleCopySupportFilesDirectoryURL');
  late final _CFBundleCopySupportFilesDirectoryURL =
      _CFBundleCopySupportFilesDirectoryURLPtr.asFunction<
          CFURLRef Function(CFBundleRef)>();

  CFURLRef CFBundleCopyResourcesDirectoryURL(
    CFBundleRef bundle,
  ) {
    return _CFBundleCopyResourcesDirectoryURL(
      bundle,
    );
  }

  late final _CFBundleCopyResourcesDirectoryURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFBundleRef)>>(
          'CFBundleCopyResourcesDirectoryURL');
  late final _CFBundleCopyResourcesDirectoryURL =
      _CFBundleCopyResourcesDirectoryURLPtr.asFunction<
          CFURLRef Function(CFBundleRef)>();

  CFURLRef CFBundleCopyPrivateFrameworksURL(
    CFBundleRef bundle,
  ) {
    return _CFBundleCopyPrivateFrameworksURL(
      bundle,
    );
  }

  late final _CFBundleCopyPrivateFrameworksURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFBundleRef)>>(
          'CFBundleCopyPrivateFrameworksURL');
  late final _CFBundleCopyPrivateFrameworksURL =
      _CFBundleCopyPrivateFrameworksURLPtr.asFunction<
          CFURLRef Function(CFBundleRef)>();

  CFURLRef CFBundleCopySharedFrameworksURL(
    CFBundleRef bundle,
  ) {
    return _CFBundleCopySharedFrameworksURL(
      bundle,
    );
  }

  late final _CFBundleCopySharedFrameworksURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFBundleRef)>>(
          'CFBundleCopySharedFrameworksURL');
  late final _CFBundleCopySharedFrameworksURL =
      _CFBundleCopySharedFrameworksURLPtr.asFunction<
          CFURLRef Function(CFBundleRef)>();

  CFURLRef CFBundleCopySharedSupportURL(
    CFBundleRef bundle,
  ) {
    return _CFBundleCopySharedSupportURL(
      bundle,
    );
  }

  late final _CFBundleCopySharedSupportURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFBundleRef)>>(
          'CFBundleCopySharedSupportURL');
  late final _CFBundleCopySharedSupportURL = _CFBundleCopySharedSupportURLPtr
      .asFunction<CFURLRef Function(CFBundleRef)>();

  CFURLRef CFBundleCopyBuiltInPlugInsURL(
    CFBundleRef bundle,
  ) {
    return _CFBundleCopyBuiltInPlugInsURL(
      bundle,
    );
  }

  late final _CFBundleCopyBuiltInPlugInsURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFBundleRef)>>(
          'CFBundleCopyBuiltInPlugInsURL');
  late final _CFBundleCopyBuiltInPlugInsURL = _CFBundleCopyBuiltInPlugInsURLPtr
      .asFunction<CFURLRef Function(CFBundleRef)>();

  CFDictionaryRef CFBundleCopyInfoDictionaryInDirectory(
    CFURLRef bundleURL,
  ) {
    return _CFBundleCopyInfoDictionaryInDirectory(
      bundleURL,
    );
  }

  late final _CFBundleCopyInfoDictionaryInDirectoryPtr =
      _lookup<ffi.NativeFunction<CFDictionaryRef Function(CFURLRef)>>(
          'CFBundleCopyInfoDictionaryInDirectory');
  late final _CFBundleCopyInfoDictionaryInDirectory =
      _CFBundleCopyInfoDictionaryInDirectoryPtr.asFunction<
          CFDictionaryRef Function(CFURLRef)>();

  int CFBundleGetPackageInfoInDirectory(
    CFURLRef url,
    ffi.Pointer<UInt32> packageType,
    ffi.Pointer<UInt32> packageCreator,
  ) {
    return _CFBundleGetPackageInfoInDirectory(
      url,
      packageType,
      packageCreator,
    );
  }

  late final _CFBundleGetPackageInfoInDirectoryPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFURLRef, ffi.Pointer<UInt32>,
              ffi.Pointer<UInt32>)>>('CFBundleGetPackageInfoInDirectory');
  late final _CFBundleGetPackageInfoInDirectory =
      _CFBundleGetPackageInfoInDirectoryPtr.asFunction<
          int Function(CFURLRef, ffi.Pointer<UInt32>, ffi.Pointer<UInt32>)>();

  CFURLRef CFBundleCopyResourceURL(
    CFBundleRef bundle,
    CFStringRef resourceName,
    CFStringRef resourceType,
    CFStringRef subDirName,
  ) {
    return _CFBundleCopyResourceURL(
      bundle,
      resourceName,
      resourceType,
      subDirName,
    );
  }

  late final _CFBundleCopyResourceURLPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFBundleRef, CFStringRef, CFStringRef,
              CFStringRef)>>('CFBundleCopyResourceURL');
  late final _CFBundleCopyResourceURL = _CFBundleCopyResourceURLPtr.asFunction<
      CFURLRef Function(CFBundleRef, CFStringRef, CFStringRef, CFStringRef)>();

  CFArrayRef CFBundleCopyResourceURLsOfType(
    CFBundleRef bundle,
    CFStringRef resourceType,
    CFStringRef subDirName,
  ) {
    return _CFBundleCopyResourceURLsOfType(
      bundle,
      resourceType,
      subDirName,
    );
  }

  late final _CFBundleCopyResourceURLsOfTypePtr = _lookup<
      ffi.NativeFunction<
          CFArrayRef Function(CFBundleRef, CFStringRef,
              CFStringRef)>>('CFBundleCopyResourceURLsOfType');
  late final _CFBundleCopyResourceURLsOfType =
      _CFBundleCopyResourceURLsOfTypePtr.asFunction<
          CFArrayRef Function(CFBundleRef, CFStringRef, CFStringRef)>();

  CFStringRef CFBundleCopyLocalizedString(
    CFBundleRef bundle,
    CFStringRef key,
    CFStringRef value,
    CFStringRef tableName,
  ) {
    return _CFBundleCopyLocalizedString(
      bundle,
      key,
      value,
      tableName,
    );
  }

  late final _CFBundleCopyLocalizedStringPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFBundleRef, CFStringRef, CFStringRef,
              CFStringRef)>>('CFBundleCopyLocalizedString');
  late final _CFBundleCopyLocalizedString =
      _CFBundleCopyLocalizedStringPtr.asFunction<
          CFStringRef Function(
              CFBundleRef, CFStringRef, CFStringRef, CFStringRef)>();

  CFURLRef CFBundleCopyResourceURLInDirectory(
    CFURLRef bundleURL,
    CFStringRef resourceName,
    CFStringRef resourceType,
    CFStringRef subDirName,
  ) {
    return _CFBundleCopyResourceURLInDirectory(
      bundleURL,
      resourceName,
      resourceType,
      subDirName,
    );
  }

  late final _CFBundleCopyResourceURLInDirectoryPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFURLRef, CFStringRef, CFStringRef,
              CFStringRef)>>('CFBundleCopyResourceURLInDirectory');
  late final _CFBundleCopyResourceURLInDirectory =
      _CFBundleCopyResourceURLInDirectoryPtr.asFunction<
          CFURLRef Function(CFURLRef, CFStringRef, CFStringRef, CFStringRef)>();

  CFArrayRef CFBundleCopyResourceURLsOfTypeInDirectory(
    CFURLRef bundleURL,
    CFStringRef resourceType,
    CFStringRef subDirName,
  ) {
    return _CFBundleCopyResourceURLsOfTypeInDirectory(
      bundleURL,
      resourceType,
      subDirName,
    );
  }

  late final _CFBundleCopyResourceURLsOfTypeInDirectoryPtr = _lookup<
      ffi.NativeFunction<
          CFArrayRef Function(CFURLRef, CFStringRef,
              CFStringRef)>>('CFBundleCopyResourceURLsOfTypeInDirectory');
  late final _CFBundleCopyResourceURLsOfTypeInDirectory =
      _CFBundleCopyResourceURLsOfTypeInDirectoryPtr.asFunction<
          CFArrayRef Function(CFURLRef, CFStringRef, CFStringRef)>();

  CFArrayRef CFBundleCopyBundleLocalizations(
    CFBundleRef bundle,
  ) {
    return _CFBundleCopyBundleLocalizations(
      bundle,
    );
  }

  late final _CFBundleCopyBundleLocalizationsPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(CFBundleRef)>>(
          'CFBundleCopyBundleLocalizations');
  late final _CFBundleCopyBundleLocalizations =
      _CFBundleCopyBundleLocalizationsPtr.asFunction<
          CFArrayRef Function(CFBundleRef)>();

  CFArrayRef CFBundleCopyPreferredLocalizationsFromArray(
    CFArrayRef locArray,
  ) {
    return _CFBundleCopyPreferredLocalizationsFromArray(
      locArray,
    );
  }

  late final _CFBundleCopyPreferredLocalizationsFromArrayPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(CFArrayRef)>>(
          'CFBundleCopyPreferredLocalizationsFromArray');
  late final _CFBundleCopyPreferredLocalizationsFromArray =
      _CFBundleCopyPreferredLocalizationsFromArrayPtr.asFunction<
          CFArrayRef Function(CFArrayRef)>();

  CFArrayRef CFBundleCopyLocalizationsForPreferences(
    CFArrayRef locArray,
    CFArrayRef prefArray,
  ) {
    return _CFBundleCopyLocalizationsForPreferences(
      locArray,
      prefArray,
    );
  }

  late final _CFBundleCopyLocalizationsForPreferencesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(CFArrayRef, CFArrayRef)>>(
          'CFBundleCopyLocalizationsForPreferences');
  late final _CFBundleCopyLocalizationsForPreferences =
      _CFBundleCopyLocalizationsForPreferencesPtr.asFunction<
          CFArrayRef Function(CFArrayRef, CFArrayRef)>();

  CFURLRef CFBundleCopyResourceURLForLocalization(
    CFBundleRef bundle,
    CFStringRef resourceName,
    CFStringRef resourceType,
    CFStringRef subDirName,
    CFStringRef localizationName,
  ) {
    return _CFBundleCopyResourceURLForLocalization(
      bundle,
      resourceName,
      resourceType,
      subDirName,
      localizationName,
    );
  }

  late final _CFBundleCopyResourceURLForLocalizationPtr = _lookup<
      ffi.NativeFunction<
          CFURLRef Function(CFBundleRef, CFStringRef, CFStringRef, CFStringRef,
              CFStringRef)>>('CFBundleCopyResourceURLForLocalization');
  late final _CFBundleCopyResourceURLForLocalization =
      _CFBundleCopyResourceURLForLocalizationPtr.asFunction<
          CFURLRef Function(CFBundleRef, CFStringRef, CFStringRef, CFStringRef,
              CFStringRef)>();

  CFArrayRef CFBundleCopyResourceURLsOfTypeForLocalization(
    CFBundleRef bundle,
    CFStringRef resourceType,
    CFStringRef subDirName,
    CFStringRef localizationName,
  ) {
    return _CFBundleCopyResourceURLsOfTypeForLocalization(
      bundle,
      resourceType,
      subDirName,
      localizationName,
    );
  }

  late final _CFBundleCopyResourceURLsOfTypeForLocalizationPtr = _lookup<
      ffi.NativeFunction<
          CFArrayRef Function(CFBundleRef, CFStringRef, CFStringRef,
              CFStringRef)>>('CFBundleCopyResourceURLsOfTypeForLocalization');
  late final _CFBundleCopyResourceURLsOfTypeForLocalization =
      _CFBundleCopyResourceURLsOfTypeForLocalizationPtr.asFunction<
          CFArrayRef Function(
              CFBundleRef, CFStringRef, CFStringRef, CFStringRef)>();

  CFDictionaryRef CFBundleCopyInfoDictionaryForURL(
    CFURLRef url,
  ) {
    return _CFBundleCopyInfoDictionaryForURL(
      url,
    );
  }

  late final _CFBundleCopyInfoDictionaryForURLPtr =
      _lookup<ffi.NativeFunction<CFDictionaryRef Function(CFURLRef)>>(
          'CFBundleCopyInfoDictionaryForURL');
  late final _CFBundleCopyInfoDictionaryForURL =
      _CFBundleCopyInfoDictionaryForURLPtr.asFunction<
          CFDictionaryRef Function(CFURLRef)>();

  CFArrayRef CFBundleCopyLocalizationsForURL(
    CFURLRef url,
  ) {
    return _CFBundleCopyLocalizationsForURL(
      url,
    );
  }

  late final _CFBundleCopyLocalizationsForURLPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(CFURLRef)>>(
          'CFBundleCopyLocalizationsForURL');
  late final _CFBundleCopyLocalizationsForURL =
      _CFBundleCopyLocalizationsForURLPtr.asFunction<
          CFArrayRef Function(CFURLRef)>();

  CFArrayRef CFBundleCopyExecutableArchitecturesForURL(
    CFURLRef url,
  ) {
    return _CFBundleCopyExecutableArchitecturesForURL(
      url,
    );
  }

  late final _CFBundleCopyExecutableArchitecturesForURLPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(CFURLRef)>>(
          'CFBundleCopyExecutableArchitecturesForURL');
  late final _CFBundleCopyExecutableArchitecturesForURL =
      _CFBundleCopyExecutableArchitecturesForURLPtr.asFunction<
          CFArrayRef Function(CFURLRef)>();

  CFURLRef CFBundleCopyExecutableURL(
    CFBundleRef bundle,
  ) {
    return _CFBundleCopyExecutableURL(
      bundle,
    );
  }

  late final _CFBundleCopyExecutableURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFBundleRef)>>(
          'CFBundleCopyExecutableURL');
  late final _CFBundleCopyExecutableURL = _CFBundleCopyExecutableURLPtr
      .asFunction<CFURLRef Function(CFBundleRef)>();

  CFArrayRef CFBundleCopyExecutableArchitectures(
    CFBundleRef bundle,
  ) {
    return _CFBundleCopyExecutableArchitectures(
      bundle,
    );
  }

  late final _CFBundleCopyExecutableArchitecturesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(CFBundleRef)>>(
          'CFBundleCopyExecutableArchitectures');
  late final _CFBundleCopyExecutableArchitectures =
      _CFBundleCopyExecutableArchitecturesPtr.asFunction<
          CFArrayRef Function(CFBundleRef)>();

  int CFBundlePreflightExecutable(
    CFBundleRef bundle,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFBundlePreflightExecutable(
      bundle,
      error,
    );
  }

  late final _CFBundlePreflightExecutablePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFBundleRef,
              ffi.Pointer<CFErrorRef>)>>('CFBundlePreflightExecutable');
  late final _CFBundlePreflightExecutable = _CFBundlePreflightExecutablePtr
      .asFunction<int Function(CFBundleRef, ffi.Pointer<CFErrorRef>)>();

  int CFBundleLoadExecutableAndReturnError(
    CFBundleRef bundle,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _CFBundleLoadExecutableAndReturnError(
      bundle,
      error,
    );
  }

  late final _CFBundleLoadExecutableAndReturnErrorPtr = _lookup<
          ffi.NativeFunction<
              Boolean Function(CFBundleRef, ffi.Pointer<CFErrorRef>)>>(
      'CFBundleLoadExecutableAndReturnError');
  late final _CFBundleLoadExecutableAndReturnError =
      _CFBundleLoadExecutableAndReturnErrorPtr.asFunction<
          int Function(CFBundleRef, ffi.Pointer<CFErrorRef>)>();

  int CFBundleLoadExecutable(
    CFBundleRef bundle,
  ) {
    return _CFBundleLoadExecutable(
      bundle,
    );
  }

  late final _CFBundleLoadExecutablePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFBundleRef)>>(
          'CFBundleLoadExecutable');
  late final _CFBundleLoadExecutable =
      _CFBundleLoadExecutablePtr.asFunction<int Function(CFBundleRef)>();

  int CFBundleIsExecutableLoaded(
    CFBundleRef bundle,
  ) {
    return _CFBundleIsExecutableLoaded(
      bundle,
    );
  }

  late final _CFBundleIsExecutableLoadedPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFBundleRef)>>(
          'CFBundleIsExecutableLoaded');
  late final _CFBundleIsExecutableLoaded =
      _CFBundleIsExecutableLoadedPtr.asFunction<int Function(CFBundleRef)>();

  void CFBundleUnloadExecutable(
    CFBundleRef bundle,
  ) {
    return _CFBundleUnloadExecutable(
      bundle,
    );
  }

  late final _CFBundleUnloadExecutablePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFBundleRef)>>(
          'CFBundleUnloadExecutable');
  late final _CFBundleUnloadExecutable =
      _CFBundleUnloadExecutablePtr.asFunction<void Function(CFBundleRef)>();

  ffi.Pointer<ffi.Void> CFBundleGetFunctionPointerForName(
    CFBundleRef bundle,
    CFStringRef functionName,
  ) {
    return _CFBundleGetFunctionPointerForName(
      bundle,
      functionName,
    );
  }

  late final _CFBundleGetFunctionPointerForNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              CFBundleRef, CFStringRef)>>('CFBundleGetFunctionPointerForName');
  late final _CFBundleGetFunctionPointerForName =
      _CFBundleGetFunctionPointerForNamePtr.asFunction<
          ffi.Pointer<ffi.Void> Function(CFBundleRef, CFStringRef)>();

  void CFBundleGetFunctionPointersForNames(
    CFBundleRef bundle,
    CFArrayRef functionNames,
    ffi.Pointer<ffi.Pointer<ffi.Void>> ftbl,
  ) {
    return _CFBundleGetFunctionPointersForNames(
      bundle,
      functionNames,
      ftbl,
    );
  }

  late final _CFBundleGetFunctionPointersForNamesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(CFBundleRef, CFArrayRef,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'CFBundleGetFunctionPointersForNames');
  late final _CFBundleGetFunctionPointersForNames =
      _CFBundleGetFunctionPointersForNamesPtr.asFunction<
          void Function(
              CFBundleRef, CFArrayRef, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  ffi.Pointer<ffi.Void> CFBundleGetDataPointerForName(
    CFBundleRef bundle,
    CFStringRef symbolName,
  ) {
    return _CFBundleGetDataPointerForName(
      bundle,
      symbolName,
    );
  }

  late final _CFBundleGetDataPointerForNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              CFBundleRef, CFStringRef)>>('CFBundleGetDataPointerForName');
  late final _CFBundleGetDataPointerForName = _CFBundleGetDataPointerForNamePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(CFBundleRef, CFStringRef)>();

  void CFBundleGetDataPointersForNames(
    CFBundleRef bundle,
    CFArrayRef symbolNames,
    ffi.Pointer<ffi.Pointer<ffi.Void>> stbl,
  ) {
    return _CFBundleGetDataPointersForNames(
      bundle,
      symbolNames,
      stbl,
    );
  }

  late final _CFBundleGetDataPointersForNamesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(CFBundleRef, CFArrayRef,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'CFBundleGetDataPointersForNames');
  late final _CFBundleGetDataPointersForNames =
      _CFBundleGetDataPointersForNamesPtr.asFunction<
          void Function(
              CFBundleRef, CFArrayRef, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  CFURLRef CFBundleCopyAuxiliaryExecutableURL(
    CFBundleRef bundle,
    CFStringRef executableName,
  ) {
    return _CFBundleCopyAuxiliaryExecutableURL(
      bundle,
      executableName,
    );
  }

  late final _CFBundleCopyAuxiliaryExecutableURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFBundleRef, CFStringRef)>>(
          'CFBundleCopyAuxiliaryExecutableURL');
  late final _CFBundleCopyAuxiliaryExecutableURL =
      _CFBundleCopyAuxiliaryExecutableURLPtr.asFunction<
          CFURLRef Function(CFBundleRef, CFStringRef)>();

  int CFBundleIsExecutableLoadable(
    CFBundleRef bundle,
  ) {
    return _CFBundleIsExecutableLoadable(
      bundle,
    );
  }

  late final _CFBundleIsExecutableLoadablePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFBundleRef)>>(
          'CFBundleIsExecutableLoadable');
  late final _CFBundleIsExecutableLoadable =
      _CFBundleIsExecutableLoadablePtr.asFunction<int Function(CFBundleRef)>();

  int CFBundleIsExecutableLoadableForURL(
    CFURLRef url,
  ) {
    return _CFBundleIsExecutableLoadableForURL(
      url,
    );
  }

  late final _CFBundleIsExecutableLoadableForURLPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFURLRef)>>(
          'CFBundleIsExecutableLoadableForURL');
  late final _CFBundleIsExecutableLoadableForURL =
      _CFBundleIsExecutableLoadableForURLPtr.asFunction<
          int Function(CFURLRef)>();

  int CFBundleIsArchitectureLoadable(
    int arch,
  ) {
    return _CFBundleIsArchitectureLoadable(
      arch,
    );
  }

  late final _CFBundleIsArchitectureLoadablePtr =
      _lookup<ffi.NativeFunction<Boolean Function(cpu_type_t)>>(
          'CFBundleIsArchitectureLoadable');
  late final _CFBundleIsArchitectureLoadable =
      _CFBundleIsArchitectureLoadablePtr.asFunction<int Function(int)>();

  CFPlugInRef CFBundleGetPlugIn(
    CFBundleRef bundle,
  ) {
    return _CFBundleGetPlugIn(
      bundle,
    );
  }

  late final _CFBundleGetPlugInPtr =
      _lookup<ffi.NativeFunction<CFPlugInRef Function(CFBundleRef)>>(
          'CFBundleGetPlugIn');
  late final _CFBundleGetPlugIn =
      _CFBundleGetPlugInPtr.asFunction<CFPlugInRef Function(CFBundleRef)>();

  int CFBundleOpenBundleResourceMap(
    CFBundleRef bundle,
  ) {
    return _CFBundleOpenBundleResourceMap(
      bundle,
    );
  }

  late final _CFBundleOpenBundleResourceMapPtr =
      _lookup<ffi.NativeFunction<CFBundleRefNum Function(CFBundleRef)>>(
          'CFBundleOpenBundleResourceMap');
  late final _CFBundleOpenBundleResourceMap =
      _CFBundleOpenBundleResourceMapPtr.asFunction<int Function(CFBundleRef)>();

  int CFBundleOpenBundleResourceFiles(
    CFBundleRef bundle,
    ffi.Pointer<CFBundleRefNum> refNum,
    ffi.Pointer<CFBundleRefNum> localizedRefNum,
  ) {
    return _CFBundleOpenBundleResourceFiles(
      bundle,
      refNum,
      localizedRefNum,
    );
  }

  late final _CFBundleOpenBundleResourceFilesPtr = _lookup<
      ffi.NativeFunction<
          SInt32 Function(CFBundleRef, ffi.Pointer<CFBundleRefNum>,
              ffi.Pointer<CFBundleRefNum>)>>('CFBundleOpenBundleResourceFiles');
  late final _CFBundleOpenBundleResourceFiles =
      _CFBundleOpenBundleResourceFilesPtr.asFunction<
          int Function(CFBundleRef, ffi.Pointer<CFBundleRefNum>,
              ffi.Pointer<CFBundleRefNum>)>();

  void CFBundleCloseBundleResourceMap(
    CFBundleRef bundle,
    int refNum,
  ) {
    return _CFBundleCloseBundleResourceMap(
      bundle,
      refNum,
    );
  }

  late final _CFBundleCloseBundleResourceMapPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFBundleRef, CFBundleRefNum)>>(
      'CFBundleCloseBundleResourceMap');
  late final _CFBundleCloseBundleResourceMap =
      _CFBundleCloseBundleResourceMapPtr.asFunction<
          void Function(CFBundleRef, int)>();

  int CFMessagePortGetTypeID() {
    return _CFMessagePortGetTypeID();
  }

  late final _CFMessagePortGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFMessagePortGetTypeID');
  late final _CFMessagePortGetTypeID =
      _CFMessagePortGetTypeIDPtr.asFunction<int Function()>();

  CFMessagePortRef CFMessagePortCreateLocal(
    CFAllocatorRef allocator,
    CFStringRef name,
    CFMessagePortCallBack callout,
    ffi.Pointer<CFMessagePortContext> context,
    ffi.Pointer<Boolean> shouldFreeInfo,
  ) {
    return _CFMessagePortCreateLocal(
      allocator,
      name,
      callout,
      context,
      shouldFreeInfo,
    );
  }

  late final _CFMessagePortCreateLocalPtr = _lookup<
      ffi.NativeFunction<
          CFMessagePortRef Function(
              CFAllocatorRef,
              CFStringRef,
              CFMessagePortCallBack,
              ffi.Pointer<CFMessagePortContext>,
              ffi.Pointer<Boolean>)>>('CFMessagePortCreateLocal');
  late final _CFMessagePortCreateLocal =
      _CFMessagePortCreateLocalPtr.asFunction<
          CFMessagePortRef Function(
              CFAllocatorRef,
              CFStringRef,
              CFMessagePortCallBack,
              ffi.Pointer<CFMessagePortContext>,
              ffi.Pointer<Boolean>)>();

  CFMessagePortRef CFMessagePortCreateRemote(
    CFAllocatorRef allocator,
    CFStringRef name,
  ) {
    return _CFMessagePortCreateRemote(
      allocator,
      name,
    );
  }

  late final _CFMessagePortCreateRemotePtr = _lookup<
      ffi.NativeFunction<
          CFMessagePortRef Function(
              CFAllocatorRef, CFStringRef)>>('CFMessagePortCreateRemote');
  late final _CFMessagePortCreateRemote = _CFMessagePortCreateRemotePtr
      .asFunction<CFMessagePortRef Function(CFAllocatorRef, CFStringRef)>();

  int CFMessagePortIsRemote(
    CFMessagePortRef ms,
  ) {
    return _CFMessagePortIsRemote(
      ms,
    );
  }

  late final _CFMessagePortIsRemotePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFMessagePortRef)>>(
          'CFMessagePortIsRemote');
  late final _CFMessagePortIsRemote =
      _CFMessagePortIsRemotePtr.asFunction<int Function(CFMessagePortRef)>();

  CFStringRef CFMessagePortGetName(
    CFMessagePortRef ms,
  ) {
    return _CFMessagePortGetName(
      ms,
    );
  }

  late final _CFMessagePortGetNamePtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFMessagePortRef)>>(
          'CFMessagePortGetName');
  late final _CFMessagePortGetName = _CFMessagePortGetNamePtr.asFunction<
      CFStringRef Function(CFMessagePortRef)>();

  int CFMessagePortSetName(
    CFMessagePortRef ms,
    CFStringRef newName,
  ) {
    return _CFMessagePortSetName(
      ms,
      newName,
    );
  }

  late final _CFMessagePortSetNamePtr = _lookup<
          ffi.NativeFunction<Boolean Function(CFMessagePortRef, CFStringRef)>>(
      'CFMessagePortSetName');
  late final _CFMessagePortSetName = _CFMessagePortSetNamePtr.asFunction<
      int Function(CFMessagePortRef, CFStringRef)>();

  void CFMessagePortGetContext(
    CFMessagePortRef ms,
    ffi.Pointer<CFMessagePortContext> context,
  ) {
    return _CFMessagePortGetContext(
      ms,
      context,
    );
  }

  late final _CFMessagePortGetContextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMessagePortRef,
              ffi.Pointer<CFMessagePortContext>)>>('CFMessagePortGetContext');
  late final _CFMessagePortGetContext = _CFMessagePortGetContextPtr.asFunction<
      void Function(CFMessagePortRef, ffi.Pointer<CFMessagePortContext>)>();

  void CFMessagePortInvalidate(
    CFMessagePortRef ms,
  ) {
    return _CFMessagePortInvalidate(
      ms,
    );
  }

  late final _CFMessagePortInvalidatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMessagePortRef)>>(
          'CFMessagePortInvalidate');
  late final _CFMessagePortInvalidate =
      _CFMessagePortInvalidatePtr.asFunction<void Function(CFMessagePortRef)>();

  int CFMessagePortIsValid(
    CFMessagePortRef ms,
  ) {
    return _CFMessagePortIsValid(
      ms,
    );
  }

  late final _CFMessagePortIsValidPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFMessagePortRef)>>(
          'CFMessagePortIsValid');
  late final _CFMessagePortIsValid =
      _CFMessagePortIsValidPtr.asFunction<int Function(CFMessagePortRef)>();

  CFMessagePortInvalidationCallBack CFMessagePortGetInvalidationCallBack(
    CFMessagePortRef ms,
  ) {
    return _CFMessagePortGetInvalidationCallBack(
      ms,
    );
  }

  late final _CFMessagePortGetInvalidationCallBackPtr = _lookup<
      ffi.NativeFunction<
          CFMessagePortInvalidationCallBack Function(
              CFMessagePortRef)>>('CFMessagePortGetInvalidationCallBack');
  late final _CFMessagePortGetInvalidationCallBack =
      _CFMessagePortGetInvalidationCallBackPtr.asFunction<
          CFMessagePortInvalidationCallBack Function(CFMessagePortRef)>();

  void CFMessagePortSetInvalidationCallBack(
    CFMessagePortRef ms,
    CFMessagePortInvalidationCallBack callout,
  ) {
    return _CFMessagePortSetInvalidationCallBack(
      ms,
      callout,
    );
  }

  late final _CFMessagePortSetInvalidationCallBackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  CFMessagePortRef, CFMessagePortInvalidationCallBack)>>(
      'CFMessagePortSetInvalidationCallBack');
  late final _CFMessagePortSetInvalidationCallBack =
      _CFMessagePortSetInvalidationCallBackPtr.asFunction<
          void Function(CFMessagePortRef, CFMessagePortInvalidationCallBack)>();

  int CFMessagePortSendRequest(
    CFMessagePortRef remote,
    int msgid,
    CFDataRef data,
    double sendTimeout,
    double rcvTimeout,
    CFStringRef replyMode,
    ffi.Pointer<CFDataRef> returnData,
  ) {
    return _CFMessagePortSendRequest(
      remote,
      msgid,
      data,
      sendTimeout,
      rcvTimeout,
      replyMode,
      returnData,
    );
  }

  late final _CFMessagePortSendRequestPtr = _lookup<
      ffi.NativeFunction<
          SInt32 Function(
              CFMessagePortRef,
              SInt32,
              CFDataRef,
              CFTimeInterval,
              CFTimeInterval,
              CFStringRef,
              ffi.Pointer<CFDataRef>)>>('CFMessagePortSendRequest');
  late final _CFMessagePortSendRequest =
      _CFMessagePortSendRequestPtr.asFunction<
          int Function(CFMessagePortRef, int, CFDataRef, double, double,
              CFStringRef, ffi.Pointer<CFDataRef>)>();

  CFRunLoopSourceRef CFMessagePortCreateRunLoopSource(
    CFAllocatorRef allocator,
    CFMessagePortRef local,
    int order,
  ) {
    return _CFMessagePortCreateRunLoopSource(
      allocator,
      local,
      order,
    );
  }

  late final _CFMessagePortCreateRunLoopSourcePtr = _lookup<
      ffi.NativeFunction<
          CFRunLoopSourceRef Function(CFAllocatorRef, CFMessagePortRef,
              CFIndex)>>('CFMessagePortCreateRunLoopSource');
  late final _CFMessagePortCreateRunLoopSource =
      _CFMessagePortCreateRunLoopSourcePtr.asFunction<
          CFRunLoopSourceRef Function(CFAllocatorRef, CFMessagePortRef, int)>();

  void CFMessagePortSetDispatchQueue(
    CFMessagePortRef ms,
    Dartdispatch_queue_t queue,
  ) {
    return _CFMessagePortSetDispatchQueue(
      ms,
      queue.ref.pointer,
    );
  }

  late final _CFMessagePortSetDispatchQueuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMessagePortRef,
              dispatch_queue_t)>>('CFMessagePortSetDispatchQueue');
  late final _CFMessagePortSetDispatchQueue = _CFMessagePortSetDispatchQueuePtr
      .asFunction<void Function(CFMessagePortRef, dispatch_queue_t)>();

  late final ffi.Pointer<CFStringRef> _kCFPlugInDynamicRegistrationKey =
      _lookup<CFStringRef>('kCFPlugInDynamicRegistrationKey');

  CFStringRef get kCFPlugInDynamicRegistrationKey =>
      _kCFPlugInDynamicRegistrationKey.value;

  late final ffi.Pointer<CFStringRef> _kCFPlugInDynamicRegisterFunctionKey =
      _lookup<CFStringRef>('kCFPlugInDynamicRegisterFunctionKey');

  CFStringRef get kCFPlugInDynamicRegisterFunctionKey =>
      _kCFPlugInDynamicRegisterFunctionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFPlugInUnloadFunctionKey =
      _lookup<CFStringRef>('kCFPlugInUnloadFunctionKey');

  CFStringRef get kCFPlugInUnloadFunctionKey =>
      _kCFPlugInUnloadFunctionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFPlugInFactoriesKey =
      _lookup<CFStringRef>('kCFPlugInFactoriesKey');

  CFStringRef get kCFPlugInFactoriesKey => _kCFPlugInFactoriesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFPlugInTypesKey =
      _lookup<CFStringRef>('kCFPlugInTypesKey');

  CFStringRef get kCFPlugInTypesKey => _kCFPlugInTypesKey.value;

  int CFPlugInGetTypeID() {
    return _CFPlugInGetTypeID();
  }

  late final _CFPlugInGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFPlugInGetTypeID');
  late final _CFPlugInGetTypeID =
      _CFPlugInGetTypeIDPtr.asFunction<int Function()>();

  CFPlugInRef CFPlugInCreate(
    CFAllocatorRef allocator,
    CFURLRef plugInURL,
  ) {
    return _CFPlugInCreate(
      allocator,
      plugInURL,
    );
  }

  late final _CFPlugInCreatePtr = _lookup<
          ffi.NativeFunction<CFPlugInRef Function(CFAllocatorRef, CFURLRef)>>(
      'CFPlugInCreate');
  late final _CFPlugInCreate = _CFPlugInCreatePtr.asFunction<
      CFPlugInRef Function(CFAllocatorRef, CFURLRef)>();

  CFBundleRef CFPlugInGetBundle(
    CFPlugInRef plugIn,
  ) {
    return _CFPlugInGetBundle(
      plugIn,
    );
  }

  late final _CFPlugInGetBundlePtr =
      _lookup<ffi.NativeFunction<CFBundleRef Function(CFPlugInRef)>>(
          'CFPlugInGetBundle');
  late final _CFPlugInGetBundle =
      _CFPlugInGetBundlePtr.asFunction<CFBundleRef Function(CFPlugInRef)>();

  void CFPlugInSetLoadOnDemand(
    CFPlugInRef plugIn,
    int flag,
  ) {
    return _CFPlugInSetLoadOnDemand(
      plugIn,
      flag,
    );
  }

  late final _CFPlugInSetLoadOnDemandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFPlugInRef, Boolean)>>(
          'CFPlugInSetLoadOnDemand');
  late final _CFPlugInSetLoadOnDemand =
      _CFPlugInSetLoadOnDemandPtr.asFunction<void Function(CFPlugInRef, int)>();

  int CFPlugInIsLoadOnDemand(
    CFPlugInRef plugIn,
  ) {
    return _CFPlugInIsLoadOnDemand(
      plugIn,
    );
  }

  late final _CFPlugInIsLoadOnDemandPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFPlugInRef)>>(
          'CFPlugInIsLoadOnDemand');
  late final _CFPlugInIsLoadOnDemand =
      _CFPlugInIsLoadOnDemandPtr.asFunction<int Function(CFPlugInRef)>();

  CFArrayRef CFPlugInFindFactoriesForPlugInType(
    CFUUIDRef typeUUID,
  ) {
    return _CFPlugInFindFactoriesForPlugInType(
      typeUUID,
    );
  }

  late final _CFPlugInFindFactoriesForPlugInTypePtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(CFUUIDRef)>>(
          'CFPlugInFindFactoriesForPlugInType');
  late final _CFPlugInFindFactoriesForPlugInType =
      _CFPlugInFindFactoriesForPlugInTypePtr.asFunction<
          CFArrayRef Function(CFUUIDRef)>();

  CFArrayRef CFPlugInFindFactoriesForPlugInTypeInPlugIn(
    CFUUIDRef typeUUID,
    CFPlugInRef plugIn,
  ) {
    return _CFPlugInFindFactoriesForPlugInTypeInPlugIn(
      typeUUID,
      plugIn,
    );
  }

  late final _CFPlugInFindFactoriesForPlugInTypeInPlugInPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(CFUUIDRef, CFPlugInRef)>>(
          'CFPlugInFindFactoriesForPlugInTypeInPlugIn');
  late final _CFPlugInFindFactoriesForPlugInTypeInPlugIn =
      _CFPlugInFindFactoriesForPlugInTypeInPlugInPtr.asFunction<
          CFArrayRef Function(CFUUIDRef, CFPlugInRef)>();

  ffi.Pointer<ffi.Void> CFPlugInInstanceCreate(
    CFAllocatorRef allocator,
    CFUUIDRef factoryUUID,
    CFUUIDRef typeUUID,
  ) {
    return _CFPlugInInstanceCreate(
      allocator,
      factoryUUID,
      typeUUID,
    );
  }

  late final _CFPlugInInstanceCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              CFAllocatorRef, CFUUIDRef, CFUUIDRef)>>('CFPlugInInstanceCreate');
  late final _CFPlugInInstanceCreate = _CFPlugInInstanceCreatePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(CFAllocatorRef, CFUUIDRef, CFUUIDRef)>();

  int CFPlugInRegisterFactoryFunction(
    CFUUIDRef factoryUUID,
    CFPlugInFactoryFunction func,
  ) {
    return _CFPlugInRegisterFactoryFunction(
      factoryUUID,
      func,
    );
  }

  late final _CFPlugInRegisterFactoryFunctionPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFUUIDRef,
              CFPlugInFactoryFunction)>>('CFPlugInRegisterFactoryFunction');
  late final _CFPlugInRegisterFactoryFunction =
      _CFPlugInRegisterFactoryFunctionPtr.asFunction<
          int Function(CFUUIDRef, CFPlugInFactoryFunction)>();

  int CFPlugInRegisterFactoryFunctionByName(
    CFUUIDRef factoryUUID,
    CFPlugInRef plugIn,
    CFStringRef functionName,
  ) {
    return _CFPlugInRegisterFactoryFunctionByName(
      factoryUUID,
      plugIn,
      functionName,
    );
  }

  late final _CFPlugInRegisterFactoryFunctionByNamePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFUUIDRef, CFPlugInRef,
              CFStringRef)>>('CFPlugInRegisterFactoryFunctionByName');
  late final _CFPlugInRegisterFactoryFunctionByName =
      _CFPlugInRegisterFactoryFunctionByNamePtr.asFunction<
          int Function(CFUUIDRef, CFPlugInRef, CFStringRef)>();

  int CFPlugInUnregisterFactory(
    CFUUIDRef factoryUUID,
  ) {
    return _CFPlugInUnregisterFactory(
      factoryUUID,
    );
  }

  late final _CFPlugInUnregisterFactoryPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFUUIDRef)>>(
          'CFPlugInUnregisterFactory');
  late final _CFPlugInUnregisterFactory =
      _CFPlugInUnregisterFactoryPtr.asFunction<int Function(CFUUIDRef)>();

  int CFPlugInRegisterPlugInType(
    CFUUIDRef factoryUUID,
    CFUUIDRef typeUUID,
  ) {
    return _CFPlugInRegisterPlugInType(
      factoryUUID,
      typeUUID,
    );
  }

  late final _CFPlugInRegisterPlugInTypePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFUUIDRef, CFUUIDRef)>>(
          'CFPlugInRegisterPlugInType');
  late final _CFPlugInRegisterPlugInType = _CFPlugInRegisterPlugInTypePtr
      .asFunction<int Function(CFUUIDRef, CFUUIDRef)>();

  int CFPlugInUnregisterPlugInType(
    CFUUIDRef factoryUUID,
    CFUUIDRef typeUUID,
  ) {
    return _CFPlugInUnregisterPlugInType(
      factoryUUID,
      typeUUID,
    );
  }

  late final _CFPlugInUnregisterPlugInTypePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFUUIDRef, CFUUIDRef)>>(
          'CFPlugInUnregisterPlugInType');
  late final _CFPlugInUnregisterPlugInType = _CFPlugInUnregisterPlugInTypePtr
      .asFunction<int Function(CFUUIDRef, CFUUIDRef)>();

  void CFPlugInAddInstanceForFactory(
    CFUUIDRef factoryID,
  ) {
    return _CFPlugInAddInstanceForFactory(
      factoryID,
    );
  }

  late final _CFPlugInAddInstanceForFactoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFUUIDRef)>>(
          'CFPlugInAddInstanceForFactory');
  late final _CFPlugInAddInstanceForFactory =
      _CFPlugInAddInstanceForFactoryPtr.asFunction<void Function(CFUUIDRef)>();

  void CFPlugInRemoveInstanceForFactory(
    CFUUIDRef factoryID,
  ) {
    return _CFPlugInRemoveInstanceForFactory(
      factoryID,
    );
  }

  late final _CFPlugInRemoveInstanceForFactoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFUUIDRef)>>(
          'CFPlugInRemoveInstanceForFactory');
  late final _CFPlugInRemoveInstanceForFactory =
      _CFPlugInRemoveInstanceForFactoryPtr.asFunction<
          void Function(CFUUIDRef)>();

  int CFPlugInInstanceGetInterfaceFunctionTable(
    CFPlugInInstanceRef instance,
    CFStringRef interfaceName,
    ffi.Pointer<ffi.Pointer<ffi.Void>> ftbl,
  ) {
    return _CFPlugInInstanceGetInterfaceFunctionTable(
      instance,
      interfaceName,
      ftbl,
    );
  }

  late final _CFPlugInInstanceGetInterfaceFunctionTablePtr = _lookup<
          ffi.NativeFunction<
              Boolean Function(CFPlugInInstanceRef, CFStringRef,
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'CFPlugInInstanceGetInterfaceFunctionTable');
  late final _CFPlugInInstanceGetInterfaceFunctionTable =
      _CFPlugInInstanceGetInterfaceFunctionTablePtr.asFunction<
          int Function(CFPlugInInstanceRef, CFStringRef,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  CFStringRef CFPlugInInstanceGetFactoryName(
    CFPlugInInstanceRef instance,
  ) {
    return _CFPlugInInstanceGetFactoryName(
      instance,
    );
  }

  late final _CFPlugInInstanceGetFactoryNamePtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFPlugInInstanceRef)>>(
          'CFPlugInInstanceGetFactoryName');
  late final _CFPlugInInstanceGetFactoryName =
      _CFPlugInInstanceGetFactoryNamePtr.asFunction<
          CFStringRef Function(CFPlugInInstanceRef)>();

  ffi.Pointer<ffi.Void> CFPlugInInstanceGetInstanceData(
    CFPlugInInstanceRef instance,
  ) {
    return _CFPlugInInstanceGetInstanceData(
      instance,
    );
  }

  late final _CFPlugInInstanceGetInstanceDataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ffi.Void> Function(CFPlugInInstanceRef)>>(
      'CFPlugInInstanceGetInstanceData');
  late final _CFPlugInInstanceGetInstanceData =
      _CFPlugInInstanceGetInstanceDataPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(CFPlugInInstanceRef)>();

  int CFPlugInInstanceGetTypeID() {
    return _CFPlugInInstanceGetTypeID();
  }

  late final _CFPlugInInstanceGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFPlugInInstanceGetTypeID');
  late final _CFPlugInInstanceGetTypeID =
      _CFPlugInInstanceGetTypeIDPtr.asFunction<int Function()>();

  CFPlugInInstanceRef CFPlugInInstanceCreateWithInstanceDataSize(
    CFAllocatorRef allocator,
    int instanceDataSize,
    CFPlugInInstanceDeallocateInstanceDataFunction deallocateInstanceFunction,
    CFStringRef factoryName,
    CFPlugInInstanceGetInterfaceFunction getInterfaceFunction,
  ) {
    return _CFPlugInInstanceCreateWithInstanceDataSize(
      allocator,
      instanceDataSize,
      deallocateInstanceFunction,
      factoryName,
      getInterfaceFunction,
    );
  }

  late final _CFPlugInInstanceCreateWithInstanceDataSizePtr = _lookup<
          ffi.NativeFunction<
              CFPlugInInstanceRef Function(
                  CFAllocatorRef,
                  CFIndex,
                  CFPlugInInstanceDeallocateInstanceDataFunction,
                  CFStringRef,
                  CFPlugInInstanceGetInterfaceFunction)>>(
      'CFPlugInInstanceCreateWithInstanceDataSize');
  late final _CFPlugInInstanceCreateWithInstanceDataSize =
      _CFPlugInInstanceCreateWithInstanceDataSizePtr.asFunction<
          CFPlugInInstanceRef Function(
              CFAllocatorRef,
              int,
              CFPlugInInstanceDeallocateInstanceDataFunction,
              CFStringRef,
              CFPlugInInstanceGetInterfaceFunction)>();

  int CFMachPortGetTypeID() {
    return _CFMachPortGetTypeID();
  }

  late final _CFMachPortGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFMachPortGetTypeID');
  late final _CFMachPortGetTypeID =
      _CFMachPortGetTypeIDPtr.asFunction<int Function()>();

  CFMachPortRef CFMachPortCreate(
    CFAllocatorRef allocator,
    CFMachPortCallBack callout,
    ffi.Pointer<CFMachPortContext> context,
    ffi.Pointer<Boolean> shouldFreeInfo,
  ) {
    return _CFMachPortCreate(
      allocator,
      callout,
      context,
      shouldFreeInfo,
    );
  }

  late final _CFMachPortCreatePtr = _lookup<
      ffi.NativeFunction<
          CFMachPortRef Function(
              CFAllocatorRef,
              CFMachPortCallBack,
              ffi.Pointer<CFMachPortContext>,
              ffi.Pointer<Boolean>)>>('CFMachPortCreate');
  late final _CFMachPortCreate = _CFMachPortCreatePtr.asFunction<
      CFMachPortRef Function(CFAllocatorRef, CFMachPortCallBack,
          ffi.Pointer<CFMachPortContext>, ffi.Pointer<Boolean>)>();

  CFMachPortRef CFMachPortCreateWithPort(
    CFAllocatorRef allocator,
    int portNum,
    CFMachPortCallBack callout,
    ffi.Pointer<CFMachPortContext> context,
    ffi.Pointer<Boolean> shouldFreeInfo,
  ) {
    return _CFMachPortCreateWithPort(
      allocator,
      portNum,
      callout,
      context,
      shouldFreeInfo,
    );
  }

  late final _CFMachPortCreateWithPortPtr = _lookup<
      ffi.NativeFunction<
          CFMachPortRef Function(
              CFAllocatorRef,
              mach_port_t,
              CFMachPortCallBack,
              ffi.Pointer<CFMachPortContext>,
              ffi.Pointer<Boolean>)>>('CFMachPortCreateWithPort');
  late final _CFMachPortCreateWithPort =
      _CFMachPortCreateWithPortPtr.asFunction<
          CFMachPortRef Function(CFAllocatorRef, int, CFMachPortCallBack,
              ffi.Pointer<CFMachPortContext>, ffi.Pointer<Boolean>)>();

  int CFMachPortGetPort(
    CFMachPortRef port,
  ) {
    return _CFMachPortGetPort(
      port,
    );
  }

  late final _CFMachPortGetPortPtr =
      _lookup<ffi.NativeFunction<mach_port_t Function(CFMachPortRef)>>(
          'CFMachPortGetPort');
  late final _CFMachPortGetPort =
      _CFMachPortGetPortPtr.asFunction<int Function(CFMachPortRef)>();

  void CFMachPortGetContext(
    CFMachPortRef port,
    ffi.Pointer<CFMachPortContext> context,
  ) {
    return _CFMachPortGetContext(
      port,
      context,
    );
  }

  late final _CFMachPortGetContextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMachPortRef,
              ffi.Pointer<CFMachPortContext>)>>('CFMachPortGetContext');
  late final _CFMachPortGetContext = _CFMachPortGetContextPtr.asFunction<
      void Function(CFMachPortRef, ffi.Pointer<CFMachPortContext>)>();

  void CFMachPortInvalidate(
    CFMachPortRef port,
  ) {
    return _CFMachPortInvalidate(
      port,
    );
  }

  late final _CFMachPortInvalidatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFMachPortRef)>>(
          'CFMachPortInvalidate');
  late final _CFMachPortInvalidate =
      _CFMachPortInvalidatePtr.asFunction<void Function(CFMachPortRef)>();

  int CFMachPortIsValid(
    CFMachPortRef port,
  ) {
    return _CFMachPortIsValid(
      port,
    );
  }

  late final _CFMachPortIsValidPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFMachPortRef)>>(
          'CFMachPortIsValid');
  late final _CFMachPortIsValid =
      _CFMachPortIsValidPtr.asFunction<int Function(CFMachPortRef)>();

  CFMachPortInvalidationCallBack CFMachPortGetInvalidationCallBack(
    CFMachPortRef port,
  ) {
    return _CFMachPortGetInvalidationCallBack(
      port,
    );
  }

  late final _CFMachPortGetInvalidationCallBackPtr = _lookup<
      ffi.NativeFunction<
          CFMachPortInvalidationCallBack Function(
              CFMachPortRef)>>('CFMachPortGetInvalidationCallBack');
  late final _CFMachPortGetInvalidationCallBack =
      _CFMachPortGetInvalidationCallBackPtr.asFunction<
          CFMachPortInvalidationCallBack Function(CFMachPortRef)>();

  void CFMachPortSetInvalidationCallBack(
    CFMachPortRef port,
    CFMachPortInvalidationCallBack callout,
  ) {
    return _CFMachPortSetInvalidationCallBack(
      port,
      callout,
    );
  }

  late final _CFMachPortSetInvalidationCallBackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  CFMachPortRef, CFMachPortInvalidationCallBack)>>(
      'CFMachPortSetInvalidationCallBack');
  late final _CFMachPortSetInvalidationCallBack =
      _CFMachPortSetInvalidationCallBackPtr.asFunction<
          void Function(CFMachPortRef, CFMachPortInvalidationCallBack)>();

  CFRunLoopSourceRef CFMachPortCreateRunLoopSource(
    CFAllocatorRef allocator,
    CFMachPortRef port,
    int order,
  ) {
    return _CFMachPortCreateRunLoopSource(
      allocator,
      port,
      order,
    );
  }

  late final _CFMachPortCreateRunLoopSourcePtr = _lookup<
      ffi.NativeFunction<
          CFRunLoopSourceRef Function(CFAllocatorRef, CFMachPortRef,
              CFIndex)>>('CFMachPortCreateRunLoopSource');
  late final _CFMachPortCreateRunLoopSource =
      _CFMachPortCreateRunLoopSourcePtr.asFunction<
          CFRunLoopSourceRef Function(CFAllocatorRef, CFMachPortRef, int)>();

  int CFAttributedStringGetTypeID() {
    return _CFAttributedStringGetTypeID();
  }

  late final _CFAttributedStringGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFAttributedStringGetTypeID');
  late final _CFAttributedStringGetTypeID =
      _CFAttributedStringGetTypeIDPtr.asFunction<int Function()>();

  CFAttributedStringRef CFAttributedStringCreate(
    CFAllocatorRef alloc,
    CFStringRef str,
    CFDictionaryRef attributes,
  ) {
    return _CFAttributedStringCreate(
      alloc,
      str,
      attributes,
    );
  }

  late final _CFAttributedStringCreatePtr = _lookup<
      ffi.NativeFunction<
          CFAttributedStringRef Function(CFAllocatorRef, CFStringRef,
              CFDictionaryRef)>>('CFAttributedStringCreate');
  late final _CFAttributedStringCreate =
      _CFAttributedStringCreatePtr.asFunction<
          CFAttributedStringRef Function(
              CFAllocatorRef, CFStringRef, CFDictionaryRef)>();

  CFAttributedStringRef CFAttributedStringCreateWithSubstring(
    CFAllocatorRef alloc,
    CFAttributedStringRef aStr,
    CFRange range,
  ) {
    return _CFAttributedStringCreateWithSubstring(
      alloc,
      aStr,
      range,
    );
  }

  late final _CFAttributedStringCreateWithSubstringPtr = _lookup<
      ffi.NativeFunction<
          CFAttributedStringRef Function(CFAllocatorRef, CFAttributedStringRef,
              CFRange)>>('CFAttributedStringCreateWithSubstring');
  late final _CFAttributedStringCreateWithSubstring =
      _CFAttributedStringCreateWithSubstringPtr.asFunction<
          CFAttributedStringRef Function(
              CFAllocatorRef, CFAttributedStringRef, CFRange)>();

  CFAttributedStringRef CFAttributedStringCreateCopy(
    CFAllocatorRef alloc,
    CFAttributedStringRef aStr,
  ) {
    return _CFAttributedStringCreateCopy(
      alloc,
      aStr,
    );
  }

  late final _CFAttributedStringCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          CFAttributedStringRef Function(CFAllocatorRef,
              CFAttributedStringRef)>>('CFAttributedStringCreateCopy');
  late final _CFAttributedStringCreateCopy =
      _CFAttributedStringCreateCopyPtr.asFunction<
          CFAttributedStringRef Function(
              CFAllocatorRef, CFAttributedStringRef)>();

  CFStringRef CFAttributedStringGetString(
    CFAttributedStringRef aStr,
  ) {
    return _CFAttributedStringGetString(
      aStr,
    );
  }

  late final _CFAttributedStringGetStringPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFAttributedStringRef)>>(
          'CFAttributedStringGetString');
  late final _CFAttributedStringGetString = _CFAttributedStringGetStringPtr
      .asFunction<CFStringRef Function(CFAttributedStringRef)>();

  int CFAttributedStringGetLength(
    CFAttributedStringRef aStr,
  ) {
    return _CFAttributedStringGetLength(
      aStr,
    );
  }

  late final _CFAttributedStringGetLengthPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFAttributedStringRef)>>(
          'CFAttributedStringGetLength');
  late final _CFAttributedStringGetLength = _CFAttributedStringGetLengthPtr
      .asFunction<int Function(CFAttributedStringRef)>();

  CFDictionaryRef CFAttributedStringGetAttributes(
    CFAttributedStringRef aStr,
    int loc,
    ffi.Pointer<CFRange> effectiveRange,
  ) {
    return _CFAttributedStringGetAttributes(
      aStr,
      loc,
      effectiveRange,
    );
  }

  late final _CFAttributedStringGetAttributesPtr = _lookup<
      ffi.NativeFunction<
          CFDictionaryRef Function(CFAttributedStringRef, CFIndex,
              ffi.Pointer<CFRange>)>>('CFAttributedStringGetAttributes');
  late final _CFAttributedStringGetAttributes =
      _CFAttributedStringGetAttributesPtr.asFunction<
          CFDictionaryRef Function(
              CFAttributedStringRef, int, ffi.Pointer<CFRange>)>();

  CFTypeRef CFAttributedStringGetAttribute(
    CFAttributedStringRef aStr,
    int loc,
    CFStringRef attrName,
    ffi.Pointer<CFRange> effectiveRange,
  ) {
    return _CFAttributedStringGetAttribute(
      aStr,
      loc,
      attrName,
      effectiveRange,
    );
  }

  late final _CFAttributedStringGetAttributePtr = _lookup<
      ffi.NativeFunction<
          CFTypeRef Function(CFAttributedStringRef, CFIndex, CFStringRef,
              ffi.Pointer<CFRange>)>>('CFAttributedStringGetAttribute');
  late final _CFAttributedStringGetAttribute =
      _CFAttributedStringGetAttributePtr.asFunction<
          CFTypeRef Function(
              CFAttributedStringRef, int, CFStringRef, ffi.Pointer<CFRange>)>();

  CFDictionaryRef CFAttributedStringGetAttributesAndLongestEffectiveRange(
    CFAttributedStringRef aStr,
    int loc,
    CFRange inRange,
    ffi.Pointer<CFRange> longestEffectiveRange,
  ) {
    return _CFAttributedStringGetAttributesAndLongestEffectiveRange(
      aStr,
      loc,
      inRange,
      longestEffectiveRange,
    );
  }

  late final _CFAttributedStringGetAttributesAndLongestEffectiveRangePtr =
      _lookup<
              ffi.NativeFunction<
                  CFDictionaryRef Function(CFAttributedStringRef, CFIndex,
                      CFRange, ffi.Pointer<CFRange>)>>(
          'CFAttributedStringGetAttributesAndLongestEffectiveRange');
  late final _CFAttributedStringGetAttributesAndLongestEffectiveRange =
      _CFAttributedStringGetAttributesAndLongestEffectiveRangePtr.asFunction<
          CFDictionaryRef Function(
              CFAttributedStringRef, int, CFRange, ffi.Pointer<CFRange>)>();

  CFTypeRef CFAttributedStringGetAttributeAndLongestEffectiveRange(
    CFAttributedStringRef aStr,
    int loc,
    CFStringRef attrName,
    CFRange inRange,
    ffi.Pointer<CFRange> longestEffectiveRange,
  ) {
    return _CFAttributedStringGetAttributeAndLongestEffectiveRange(
      aStr,
      loc,
      attrName,
      inRange,
      longestEffectiveRange,
    );
  }

  late final _CFAttributedStringGetAttributeAndLongestEffectiveRangePtr =
      _lookup<
              ffi.NativeFunction<
                  CFTypeRef Function(CFAttributedStringRef, CFIndex,
                      CFStringRef, CFRange, ffi.Pointer<CFRange>)>>(
          'CFAttributedStringGetAttributeAndLongestEffectiveRange');
  late final _CFAttributedStringGetAttributeAndLongestEffectiveRange =
      _CFAttributedStringGetAttributeAndLongestEffectiveRangePtr.asFunction<
          CFTypeRef Function(CFAttributedStringRef, int, CFStringRef, CFRange,
              ffi.Pointer<CFRange>)>();

  CFMutableAttributedStringRef CFAttributedStringCreateMutableCopy(
    CFAllocatorRef alloc,
    int maxLength,
    CFAttributedStringRef aStr,
  ) {
    return _CFAttributedStringCreateMutableCopy(
      alloc,
      maxLength,
      aStr,
    );
  }

  late final _CFAttributedStringCreateMutableCopyPtr = _lookup<
      ffi.NativeFunction<
          CFMutableAttributedStringRef Function(CFAllocatorRef, CFIndex,
              CFAttributedStringRef)>>('CFAttributedStringCreateMutableCopy');
  late final _CFAttributedStringCreateMutableCopy =
      _CFAttributedStringCreateMutableCopyPtr.asFunction<
          CFMutableAttributedStringRef Function(
              CFAllocatorRef, int, CFAttributedStringRef)>();

  CFMutableAttributedStringRef CFAttributedStringCreateMutable(
    CFAllocatorRef alloc,
    int maxLength,
  ) {
    return _CFAttributedStringCreateMutable(
      alloc,
      maxLength,
    );
  }

  late final _CFAttributedStringCreateMutablePtr = _lookup<
      ffi.NativeFunction<
          CFMutableAttributedStringRef Function(
              CFAllocatorRef, CFIndex)>>('CFAttributedStringCreateMutable');
  late final _CFAttributedStringCreateMutable =
      _CFAttributedStringCreateMutablePtr.asFunction<
          CFMutableAttributedStringRef Function(CFAllocatorRef, int)>();

  void CFAttributedStringReplaceString(
    CFMutableAttributedStringRef aStr,
    CFRange range,
    CFStringRef replacement,
  ) {
    return _CFAttributedStringReplaceString(
      aStr,
      range,
      replacement,
    );
  }

  late final _CFAttributedStringReplaceStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableAttributedStringRef, CFRange,
              CFStringRef)>>('CFAttributedStringReplaceString');
  late final _CFAttributedStringReplaceString =
      _CFAttributedStringReplaceStringPtr.asFunction<
          void Function(CFMutableAttributedStringRef, CFRange, CFStringRef)>();

  CFMutableStringRef CFAttributedStringGetMutableString(
    CFMutableAttributedStringRef aStr,
  ) {
    return _CFAttributedStringGetMutableString(
      aStr,
    );
  }

  late final _CFAttributedStringGetMutableStringPtr = _lookup<
          ffi.NativeFunction<
              CFMutableStringRef Function(CFMutableAttributedStringRef)>>(
      'CFAttributedStringGetMutableString');
  late final _CFAttributedStringGetMutableString =
      _CFAttributedStringGetMutableStringPtr.asFunction<
          CFMutableStringRef Function(CFMutableAttributedStringRef)>();

  void CFAttributedStringSetAttributes(
    CFMutableAttributedStringRef aStr,
    CFRange range,
    CFDictionaryRef replacement,
    int clearOtherAttributes,
  ) {
    return _CFAttributedStringSetAttributes(
      aStr,
      range,
      replacement,
      clearOtherAttributes,
    );
  }

  late final _CFAttributedStringSetAttributesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableAttributedStringRef, CFRange,
              CFDictionaryRef, Boolean)>>('CFAttributedStringSetAttributes');
  late final _CFAttributedStringSetAttributes =
      _CFAttributedStringSetAttributesPtr.asFunction<
          void Function(
              CFMutableAttributedStringRef, CFRange, CFDictionaryRef, int)>();

  void CFAttributedStringSetAttribute(
    CFMutableAttributedStringRef aStr,
    CFRange range,
    CFStringRef attrName,
    CFTypeRef value,
  ) {
    return _CFAttributedStringSetAttribute(
      aStr,
      range,
      attrName,
      value,
    );
  }

  late final _CFAttributedStringSetAttributePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableAttributedStringRef, CFRange, CFStringRef,
              CFTypeRef)>>('CFAttributedStringSetAttribute');
  late final _CFAttributedStringSetAttribute =
      _CFAttributedStringSetAttributePtr.asFunction<
          void Function(
              CFMutableAttributedStringRef, CFRange, CFStringRef, CFTypeRef)>();

  void CFAttributedStringRemoveAttribute(
    CFMutableAttributedStringRef aStr,
    CFRange range,
    CFStringRef attrName,
  ) {
    return _CFAttributedStringRemoveAttribute(
      aStr,
      range,
      attrName,
    );
  }

  late final _CFAttributedStringRemoveAttributePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFMutableAttributedStringRef, CFRange,
              CFStringRef)>>('CFAttributedStringRemoveAttribute');
  late final _CFAttributedStringRemoveAttribute =
      _CFAttributedStringRemoveAttributePtr.asFunction<
          void Function(CFMutableAttributedStringRef, CFRange, CFStringRef)>();

  void CFAttributedStringReplaceAttributedString(
    CFMutableAttributedStringRef aStr,
    CFRange range,
    CFAttributedStringRef replacement,
  ) {
    return _CFAttributedStringReplaceAttributedString(
      aStr,
      range,
      replacement,
    );
  }

  late final _CFAttributedStringReplaceAttributedStringPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(CFMutableAttributedStringRef, CFRange,
                  CFAttributedStringRef)>>(
      'CFAttributedStringReplaceAttributedString');
  late final _CFAttributedStringReplaceAttributedString =
      _CFAttributedStringReplaceAttributedStringPtr.asFunction<
          void Function(
              CFMutableAttributedStringRef, CFRange, CFAttributedStringRef)>();

  void CFAttributedStringBeginEditing(
    CFMutableAttributedStringRef aStr,
  ) {
    return _CFAttributedStringBeginEditing(
      aStr,
    );
  }

  late final _CFAttributedStringBeginEditingPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFMutableAttributedStringRef)>>(
      'CFAttributedStringBeginEditing');
  late final _CFAttributedStringBeginEditing =
      _CFAttributedStringBeginEditingPtr.asFunction<
          void Function(CFMutableAttributedStringRef)>();

  void CFAttributedStringEndEditing(
    CFMutableAttributedStringRef aStr,
  ) {
    return _CFAttributedStringEndEditing(
      aStr,
    );
  }

  late final _CFAttributedStringEndEditingPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(CFMutableAttributedStringRef)>>(
      'CFAttributedStringEndEditing');
  late final _CFAttributedStringEndEditing = _CFAttributedStringEndEditingPtr
      .asFunction<void Function(CFMutableAttributedStringRef)>();

  bool CFAttributedStringGetBidiLevelsAndResolvedDirections(
    CFAttributedStringRef attributedString,
    CFRange range,
    int baseDirection,
    ffi.Pointer<ffi.Uint8> bidiLevels,
    ffi.Pointer<ffi.Uint8> baseDirections,
  ) {
    return _CFAttributedStringGetBidiLevelsAndResolvedDirections(
      attributedString,
      range,
      baseDirection,
      bidiLevels,
      baseDirections,
    );
  }

  late final _CFAttributedStringGetBidiLevelsAndResolvedDirectionsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(CFAttributedStringRef, CFRange, ffi.Int8,
                  ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>)>>(
      'CFAttributedStringGetBidiLevelsAndResolvedDirections');
  late final _CFAttributedStringGetBidiLevelsAndResolvedDirections =
      _CFAttributedStringGetBidiLevelsAndResolvedDirectionsPtr.asFunction<
          bool Function(CFAttributedStringRef, CFRange, int,
              ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>)>();

  int CFURLEnumeratorGetTypeID() {
    return _CFURLEnumeratorGetTypeID();
  }

  late final _CFURLEnumeratorGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFURLEnumeratorGetTypeID');
  late final _CFURLEnumeratorGetTypeID =
      _CFURLEnumeratorGetTypeIDPtr.asFunction<int Function()>();

  CFURLEnumeratorRef CFURLEnumeratorCreateForDirectoryURL(
    CFAllocatorRef alloc,
    CFURLRef directoryURL,
    CFURLEnumeratorOptions option,
    CFArrayRef propertyKeys,
  ) {
    return _CFURLEnumeratorCreateForDirectoryURL(
      alloc,
      directoryURL,
      option.value,
      propertyKeys,
    );
  }

  late final _CFURLEnumeratorCreateForDirectoryURLPtr = _lookup<
      ffi.NativeFunction<
          CFURLEnumeratorRef Function(CFAllocatorRef, CFURLRef, CFOptionFlags,
              CFArrayRef)>>('CFURLEnumeratorCreateForDirectoryURL');
  late final _CFURLEnumeratorCreateForDirectoryURL =
      _CFURLEnumeratorCreateForDirectoryURLPtr.asFunction<
          CFURLEnumeratorRef Function(
              CFAllocatorRef, CFURLRef, int, CFArrayRef)>();

  CFURLEnumeratorRef CFURLEnumeratorCreateForMountedVolumes(
    CFAllocatorRef alloc,
    CFURLEnumeratorOptions option,
    CFArrayRef propertyKeys,
  ) {
    return _CFURLEnumeratorCreateForMountedVolumes(
      alloc,
      option.value,
      propertyKeys,
    );
  }

  late final _CFURLEnumeratorCreateForMountedVolumesPtr = _lookup<
      ffi.NativeFunction<
          CFURLEnumeratorRef Function(CFAllocatorRef, CFOptionFlags,
              CFArrayRef)>>('CFURLEnumeratorCreateForMountedVolumes');
  late final _CFURLEnumeratorCreateForMountedVolumes =
      _CFURLEnumeratorCreateForMountedVolumesPtr.asFunction<
          CFURLEnumeratorRef Function(CFAllocatorRef, int, CFArrayRef)>();

  CFURLEnumeratorResult CFURLEnumeratorGetNextURL(
    CFURLEnumeratorRef enumerator,
    ffi.Pointer<CFURLRef> url,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return CFURLEnumeratorResult.fromValue(_CFURLEnumeratorGetNextURL(
      enumerator,
      url,
      error,
    ));
  }

  late final _CFURLEnumeratorGetNextURLPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFURLEnumeratorRef, ffi.Pointer<CFURLRef>,
              ffi.Pointer<CFErrorRef>)>>('CFURLEnumeratorGetNextURL');
  late final _CFURLEnumeratorGetNextURL =
      _CFURLEnumeratorGetNextURLPtr.asFunction<
          int Function(CFURLEnumeratorRef, ffi.Pointer<CFURLRef>,
              ffi.Pointer<CFErrorRef>)>();

  void CFURLEnumeratorSkipDescendents(
    CFURLEnumeratorRef enumerator,
  ) {
    return _CFURLEnumeratorSkipDescendents(
      enumerator,
    );
  }

  late final _CFURLEnumeratorSkipDescendentsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFURLEnumeratorRef)>>(
          'CFURLEnumeratorSkipDescendents');
  late final _CFURLEnumeratorSkipDescendents =
      _CFURLEnumeratorSkipDescendentsPtr.asFunction<
          void Function(CFURLEnumeratorRef)>();

  int CFURLEnumeratorGetDescendentLevel(
    CFURLEnumeratorRef enumerator,
  ) {
    return _CFURLEnumeratorGetDescendentLevel(
      enumerator,
    );
  }

  late final _CFURLEnumeratorGetDescendentLevelPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFURLEnumeratorRef)>>(
          'CFURLEnumeratorGetDescendentLevel');
  late final _CFURLEnumeratorGetDescendentLevel =
      _CFURLEnumeratorGetDescendentLevelPtr.asFunction<
          int Function(CFURLEnumeratorRef)>();

  int CFURLEnumeratorGetSourceDidChange(
    CFURLEnumeratorRef enumerator,
  ) {
    return _CFURLEnumeratorGetSourceDidChange(
      enumerator,
    );
  }

  late final _CFURLEnumeratorGetSourceDidChangePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFURLEnumeratorRef)>>(
          'CFURLEnumeratorGetSourceDidChange');
  late final _CFURLEnumeratorGetSourceDidChange =
      _CFURLEnumeratorGetSourceDidChangePtr.asFunction<
          int Function(CFURLEnumeratorRef)>();

  acl_t acl_dup(
    acl_t acl,
  ) {
    return _acl_dup(
      acl,
    );
  }

  late final _acl_dupPtr =
      _lookup<ffi.NativeFunction<acl_t Function(acl_t)>>('acl_dup');
  late final _acl_dup = _acl_dupPtr.asFunction<acl_t Function(acl_t)>();

  int acl_free(
    ffi.Pointer<ffi.Void> obj_p,
  ) {
    return _acl_free(
      obj_p,
    );
  }

  late final _acl_freePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>(
          'acl_free');
  late final _acl_free =
      _acl_freePtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  acl_t acl_init(
    int count,
  ) {
    return _acl_init(
      count,
    );
  }

  late final _acl_initPtr =
      _lookup<ffi.NativeFunction<acl_t Function(ffi.Int)>>('acl_init');
  late final _acl_init = _acl_initPtr.asFunction<acl_t Function(int)>();

  int acl_copy_entry(
    acl_entry_t dest_d,
    acl_entry_t src_d,
  ) {
    return _acl_copy_entry(
      dest_d,
      src_d,
    );
  }

  late final _acl_copy_entryPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(acl_entry_t, acl_entry_t)>>(
          'acl_copy_entry');
  late final _acl_copy_entry =
      _acl_copy_entryPtr.asFunction<int Function(acl_entry_t, acl_entry_t)>();

  int acl_create_entry(
    ffi.Pointer<acl_t> acl_p,
    ffi.Pointer<acl_entry_t> entry_p,
  ) {
    return _acl_create_entry(
      acl_p,
      entry_p,
    );
  }

  late final _acl_create_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<acl_t>,
              ffi.Pointer<acl_entry_t>)>>('acl_create_entry');
  late final _acl_create_entry = _acl_create_entryPtr
      .asFunction<int Function(ffi.Pointer<acl_t>, ffi.Pointer<acl_entry_t>)>();

  int acl_create_entry_np(
    ffi.Pointer<acl_t> acl_p,
    ffi.Pointer<acl_entry_t> entry_p,
    int entry_index,
  ) {
    return _acl_create_entry_np(
      acl_p,
      entry_p,
      entry_index,
    );
  }

  late final _acl_create_entry_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<acl_t>, ffi.Pointer<acl_entry_t>,
              ffi.Int)>>('acl_create_entry_np');
  late final _acl_create_entry_np = _acl_create_entry_npPtr.asFunction<
      int Function(ffi.Pointer<acl_t>, ffi.Pointer<acl_entry_t>, int)>();

  int acl_delete_entry(
    acl_t acl,
    acl_entry_t entry_d,
  ) {
    return _acl_delete_entry(
      acl,
      entry_d,
    );
  }

  late final _acl_delete_entryPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(acl_t, acl_entry_t)>>(
          'acl_delete_entry');
  late final _acl_delete_entry =
      _acl_delete_entryPtr.asFunction<int Function(acl_t, acl_entry_t)>();

  int acl_get_entry(
    acl_t acl,
    int entry_id,
    ffi.Pointer<acl_entry_t> entry_p,
  ) {
    return _acl_get_entry(
      acl,
      entry_id,
      entry_p,
    );
  }

  late final _acl_get_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              acl_t, ffi.Int, ffi.Pointer<acl_entry_t>)>>('acl_get_entry');
  late final _acl_get_entry = _acl_get_entryPtr
      .asFunction<int Function(acl_t, int, ffi.Pointer<acl_entry_t>)>();

  int acl_valid(
    acl_t acl,
  ) {
    return _acl_valid(
      acl,
    );
  }

  late final _acl_validPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(acl_t)>>('acl_valid');
  late final _acl_valid = _acl_validPtr.asFunction<int Function(acl_t)>();

  int acl_valid_fd_np(
    int fd,
    acl_type_t type,
    acl_t acl,
  ) {
    return _acl_valid_fd_np(
      fd,
      type.value,
      acl,
    );
  }

  late final _acl_valid_fd_npPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Int, ffi.UnsignedInt, acl_t)>>(
      'acl_valid_fd_np');
  late final _acl_valid_fd_np =
      _acl_valid_fd_npPtr.asFunction<int Function(int, int, acl_t)>();

  int acl_valid_file_np(
    ffi.Pointer<ffi.Char> path,
    acl_type_t type,
    acl_t acl,
  ) {
    return _acl_valid_file_np(
      path,
      type.value,
      acl,
    );
  }

  late final _acl_valid_file_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedInt,
              acl_t)>>('acl_valid_file_np');
  late final _acl_valid_file_np = _acl_valid_file_npPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, acl_t)>();

  int acl_valid_link_np(
    ffi.Pointer<ffi.Char> path,
    acl_type_t type,
    acl_t acl,
  ) {
    return _acl_valid_link_np(
      path,
      type.value,
      acl,
    );
  }

  late final _acl_valid_link_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedInt,
              acl_t)>>('acl_valid_link_np');
  late final _acl_valid_link_np = _acl_valid_link_npPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, acl_t)>();

  int acl_add_perm(
    acl_permset_t permset_d,
    acl_perm_t perm,
  ) {
    return _acl_add_perm(
      permset_d,
      perm.value,
    );
  }

  late final _acl_add_permPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(acl_permset_t, ffi.UnsignedInt)>>(
      'acl_add_perm');
  late final _acl_add_perm =
      _acl_add_permPtr.asFunction<int Function(acl_permset_t, int)>();

  int acl_calc_mask(
    ffi.Pointer<acl_t> acl_p,
  ) {
    return _acl_calc_mask(
      acl_p,
    );
  }

  late final _acl_calc_maskPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<acl_t>)>>(
          'acl_calc_mask');
  late final _acl_calc_mask =
      _acl_calc_maskPtr.asFunction<int Function(ffi.Pointer<acl_t>)>();

  int acl_clear_perms(
    acl_permset_t permset_d,
  ) {
    return _acl_clear_perms(
      permset_d,
    );
  }

  late final _acl_clear_permsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(acl_permset_t)>>(
          'acl_clear_perms');
  late final _acl_clear_perms =
      _acl_clear_permsPtr.asFunction<int Function(acl_permset_t)>();

  int acl_delete_perm(
    acl_permset_t permset_d,
    acl_perm_t perm,
  ) {
    return _acl_delete_perm(
      permset_d,
      perm.value,
    );
  }

  late final _acl_delete_permPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(acl_permset_t, ffi.UnsignedInt)>>(
      'acl_delete_perm');
  late final _acl_delete_perm =
      _acl_delete_permPtr.asFunction<int Function(acl_permset_t, int)>();

  int acl_get_perm_np(
    acl_permset_t permset_d,
    acl_perm_t perm,
  ) {
    return _acl_get_perm_np(
      permset_d,
      perm.value,
    );
  }

  late final _acl_get_perm_npPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(acl_permset_t, ffi.UnsignedInt)>>(
      'acl_get_perm_np');
  late final _acl_get_perm_np =
      _acl_get_perm_npPtr.asFunction<int Function(acl_permset_t, int)>();

  int acl_get_permset(
    acl_entry_t entry_d,
    ffi.Pointer<acl_permset_t> permset_p,
  ) {
    return _acl_get_permset(
      entry_d,
      permset_p,
    );
  }

  late final _acl_get_permsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              acl_entry_t, ffi.Pointer<acl_permset_t>)>>('acl_get_permset');
  late final _acl_get_permset = _acl_get_permsetPtr
      .asFunction<int Function(acl_entry_t, ffi.Pointer<acl_permset_t>)>();

  int acl_set_permset(
    acl_entry_t entry_d,
    acl_permset_t permset_d,
  ) {
    return _acl_set_permset(
      entry_d,
      permset_d,
    );
  }

  late final _acl_set_permsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(acl_entry_t, acl_permset_t)>>(
          'acl_set_permset');
  late final _acl_set_permset = _acl_set_permsetPtr
      .asFunction<int Function(acl_entry_t, acl_permset_t)>();

  int acl_maximal_permset_mask_np(
    ffi.Pointer<acl_permset_mask_t> mask_p,
  ) {
    return _acl_maximal_permset_mask_np(
      mask_p,
    );
  }

  late final _acl_maximal_permset_mask_npPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<acl_permset_mask_t>)>>(
      'acl_maximal_permset_mask_np');
  late final _acl_maximal_permset_mask_np = _acl_maximal_permset_mask_npPtr
      .asFunction<int Function(ffi.Pointer<acl_permset_mask_t>)>();

  int acl_get_permset_mask_np(
    acl_entry_t entry_d,
    ffi.Pointer<acl_permset_mask_t> mask_p,
  ) {
    return _acl_get_permset_mask_np(
      entry_d,
      mask_p,
    );
  }

  late final _acl_get_permset_mask_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(acl_entry_t,
              ffi.Pointer<acl_permset_mask_t>)>>('acl_get_permset_mask_np');
  late final _acl_get_permset_mask_np = _acl_get_permset_mask_npPtr
      .asFunction<int Function(acl_entry_t, ffi.Pointer<acl_permset_mask_t>)>();

  int acl_set_permset_mask_np(
    acl_entry_t entry_d,
    int mask,
  ) {
    return _acl_set_permset_mask_np(
      entry_d,
      mask,
    );
  }

  late final _acl_set_permset_mask_npPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(acl_entry_t, acl_permset_mask_t)>>(
      'acl_set_permset_mask_np');
  late final _acl_set_permset_mask_np =
      _acl_set_permset_mask_npPtr.asFunction<int Function(acl_entry_t, int)>();

  int acl_add_flag_np(
    acl_flagset_t flagset_d,
    acl_flag_t flag,
  ) {
    return _acl_add_flag_np(
      flagset_d,
      flag.value,
    );
  }

  late final _acl_add_flag_npPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(acl_flagset_t, ffi.UnsignedInt)>>(
      'acl_add_flag_np');
  late final _acl_add_flag_np =
      _acl_add_flag_npPtr.asFunction<int Function(acl_flagset_t, int)>();

  int acl_clear_flags_np(
    acl_flagset_t flagset_d,
  ) {
    return _acl_clear_flags_np(
      flagset_d,
    );
  }

  late final _acl_clear_flags_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(acl_flagset_t)>>(
          'acl_clear_flags_np');
  late final _acl_clear_flags_np =
      _acl_clear_flags_npPtr.asFunction<int Function(acl_flagset_t)>();

  int acl_delete_flag_np(
    acl_flagset_t flagset_d,
    acl_flag_t flag,
  ) {
    return _acl_delete_flag_np(
      flagset_d,
      flag.value,
    );
  }

  late final _acl_delete_flag_npPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(acl_flagset_t, ffi.UnsignedInt)>>(
      'acl_delete_flag_np');
  late final _acl_delete_flag_np =
      _acl_delete_flag_npPtr.asFunction<int Function(acl_flagset_t, int)>();

  int acl_get_flag_np(
    acl_flagset_t flagset_d,
    acl_flag_t flag,
  ) {
    return _acl_get_flag_np(
      flagset_d,
      flag.value,
    );
  }

  late final _acl_get_flag_npPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(acl_flagset_t, ffi.UnsignedInt)>>(
      'acl_get_flag_np');
  late final _acl_get_flag_np =
      _acl_get_flag_npPtr.asFunction<int Function(acl_flagset_t, int)>();

  int acl_get_flagset_np(
    ffi.Pointer<ffi.Void> obj_p,
    ffi.Pointer<acl_flagset_t> flagset_p,
  ) {
    return _acl_get_flagset_np(
      obj_p,
      flagset_p,
    );
  }

  late final _acl_get_flagset_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<acl_flagset_t>)>>('acl_get_flagset_np');
  late final _acl_get_flagset_np = _acl_get_flagset_npPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<acl_flagset_t>)>();

  int acl_set_flagset_np(
    ffi.Pointer<ffi.Void> obj_p,
    acl_flagset_t flagset_d,
  ) {
    return _acl_set_flagset_np(
      obj_p,
      flagset_d,
    );
  }

  late final _acl_set_flagset_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, acl_flagset_t)>>('acl_set_flagset_np');
  late final _acl_set_flagset_np = _acl_set_flagset_npPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, acl_flagset_t)>();

  ffi.Pointer<ffi.Void> acl_get_qualifier(
    acl_entry_t entry_d,
  ) {
    return _acl_get_qualifier(
      entry_d,
    );
  }

  late final _acl_get_qualifierPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(acl_entry_t)>>(
          'acl_get_qualifier');
  late final _acl_get_qualifier = _acl_get_qualifierPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(acl_entry_t)>();

  int acl_get_tag_type(
    acl_entry_t entry_d,
    ffi.Pointer<ffi.UnsignedInt> tag_type_p,
  ) {
    return _acl_get_tag_type(
      entry_d,
      tag_type_p,
    );
  }

  late final _acl_get_tag_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              acl_entry_t, ffi.Pointer<ffi.UnsignedInt>)>>('acl_get_tag_type');
  late final _acl_get_tag_type = _acl_get_tag_typePtr
      .asFunction<int Function(acl_entry_t, ffi.Pointer<ffi.UnsignedInt>)>();

  int acl_set_qualifier(
    acl_entry_t entry_d,
    ffi.Pointer<ffi.Void> tag_qualifier_p,
  ) {
    return _acl_set_qualifier(
      entry_d,
      tag_qualifier_p,
    );
  }

  late final _acl_set_qualifierPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              acl_entry_t, ffi.Pointer<ffi.Void>)>>('acl_set_qualifier');
  late final _acl_set_qualifier = _acl_set_qualifierPtr
      .asFunction<int Function(acl_entry_t, ffi.Pointer<ffi.Void>)>();

  int acl_set_tag_type(
    acl_entry_t entry_d,
    acl_tag_t tag_type,
  ) {
    return _acl_set_tag_type(
      entry_d,
      tag_type.value,
    );
  }

  late final _acl_set_tag_typePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(acl_entry_t, ffi.UnsignedInt)>>(
      'acl_set_tag_type');
  late final _acl_set_tag_type =
      _acl_set_tag_typePtr.asFunction<int Function(acl_entry_t, int)>();

  int acl_delete_def_file(
    ffi.Pointer<ffi.Char> path_p,
  ) {
    return _acl_delete_def_file(
      path_p,
    );
  }

  late final _acl_delete_def_filePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'acl_delete_def_file');
  late final _acl_delete_def_file =
      _acl_delete_def_filePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  acl_t acl_get_fd(
    int fd,
  ) {
    return _acl_get_fd(
      fd,
    );
  }

  late final _acl_get_fdPtr =
      _lookup<ffi.NativeFunction<acl_t Function(ffi.Int)>>('acl_get_fd');
  late final _acl_get_fd = _acl_get_fdPtr.asFunction<acl_t Function(int)>();

  acl_t acl_get_fd_np(
    int fd,
    acl_type_t type,
  ) {
    return _acl_get_fd_np(
      fd,
      type.value,
    );
  }

  late final _acl_get_fd_npPtr =
      _lookup<ffi.NativeFunction<acl_t Function(ffi.Int, ffi.UnsignedInt)>>(
          'acl_get_fd_np');
  late final _acl_get_fd_np =
      _acl_get_fd_npPtr.asFunction<acl_t Function(int, int)>();

  acl_t acl_get_file(
    ffi.Pointer<ffi.Char> path_p,
    acl_type_t type,
  ) {
    return _acl_get_file(
      path_p,
      type.value,
    );
  }

  late final _acl_get_filePtr = _lookup<
      ffi.NativeFunction<
          acl_t Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('acl_get_file');
  late final _acl_get_file =
      _acl_get_filePtr.asFunction<acl_t Function(ffi.Pointer<ffi.Char>, int)>();

  acl_t acl_get_link_np(
    ffi.Pointer<ffi.Char> path_p,
    acl_type_t type,
  ) {
    return _acl_get_link_np(
      path_p,
      type.value,
    );
  }

  late final _acl_get_link_npPtr = _lookup<
      ffi.NativeFunction<
          acl_t Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('acl_get_link_np');
  late final _acl_get_link_np = _acl_get_link_npPtr
      .asFunction<acl_t Function(ffi.Pointer<ffi.Char>, int)>();

  int acl_set_fd(
    int fd,
    acl_t acl,
  ) {
    return _acl_set_fd(
      fd,
      acl,
    );
  }

  late final _acl_set_fdPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, acl_t)>>(
          'acl_set_fd');
  late final _acl_set_fd =
      _acl_set_fdPtr.asFunction<int Function(int, acl_t)>();

  int acl_set_fd_np(
    int fd,
    acl_t acl,
    acl_type_t acl_type,
  ) {
    return _acl_set_fd_np(
      fd,
      acl,
      acl_type.value,
    );
  }

  late final _acl_set_fd_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, acl_t, ffi.UnsignedInt)>>('acl_set_fd_np');
  late final _acl_set_fd_np =
      _acl_set_fd_npPtr.asFunction<int Function(int, acl_t, int)>();

  int acl_set_file(
    ffi.Pointer<ffi.Char> path_p,
    acl_type_t type,
    acl_t acl,
  ) {
    return _acl_set_file(
      path_p,
      type.value,
      acl,
    );
  }

  late final _acl_set_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt, acl_t)>>('acl_set_file');
  late final _acl_set_file = _acl_set_filePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, acl_t)>();

  int acl_set_link_np(
    ffi.Pointer<ffi.Char> path_p,
    acl_type_t type,
    acl_t acl,
  ) {
    return _acl_set_link_np(
      path_p,
      type.value,
      acl,
    );
  }

  late final _acl_set_link_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.UnsignedInt,
              acl_t)>>('acl_set_link_np');
  late final _acl_set_link_np = _acl_set_link_npPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, acl_t)>();

  int acl_copy_ext(
    ffi.Pointer<ffi.Void> buf_p,
    acl_t acl,
    int size,
  ) {
    return _acl_copy_ext(
      buf_p,
      acl,
      size,
    );
  }

  late final _acl_copy_extPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Pointer<ffi.Void>, acl_t, ssize_t)>>('acl_copy_ext');
  late final _acl_copy_ext = _acl_copy_extPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, acl_t, int)>();

  int acl_copy_ext_native(
    ffi.Pointer<ffi.Void> buf_p,
    acl_t acl,
    int size,
  ) {
    return _acl_copy_ext_native(
      buf_p,
      acl,
      size,
    );
  }

  late final _acl_copy_ext_nativePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Pointer<ffi.Void>, acl_t, ssize_t)>>('acl_copy_ext_native');
  late final _acl_copy_ext_native = _acl_copy_ext_nativePtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, acl_t, int)>();

  acl_t acl_copy_int(
    ffi.Pointer<ffi.Void> buf_p,
  ) {
    return _acl_copy_int(
      buf_p,
    );
  }

  late final _acl_copy_intPtr =
      _lookup<ffi.NativeFunction<acl_t Function(ffi.Pointer<ffi.Void>)>>(
          'acl_copy_int');
  late final _acl_copy_int =
      _acl_copy_intPtr.asFunction<acl_t Function(ffi.Pointer<ffi.Void>)>();

  acl_t acl_copy_int_native(
    ffi.Pointer<ffi.Void> buf_p,
  ) {
    return _acl_copy_int_native(
      buf_p,
    );
  }

  late final _acl_copy_int_nativePtr =
      _lookup<ffi.NativeFunction<acl_t Function(ffi.Pointer<ffi.Void>)>>(
          'acl_copy_int_native');
  late final _acl_copy_int_native = _acl_copy_int_nativePtr
      .asFunction<acl_t Function(ffi.Pointer<ffi.Void>)>();

  acl_t acl_from_text(
    ffi.Pointer<ffi.Char> buf_p,
  ) {
    return _acl_from_text(
      buf_p,
    );
  }

  late final _acl_from_textPtr =
      _lookup<ffi.NativeFunction<acl_t Function(ffi.Pointer<ffi.Char>)>>(
          'acl_from_text');
  late final _acl_from_text =
      _acl_from_textPtr.asFunction<acl_t Function(ffi.Pointer<ffi.Char>)>();

  int acl_size(
    acl_t acl,
  ) {
    return _acl_size(
      acl,
    );
  }

  late final _acl_sizePtr =
      _lookup<ffi.NativeFunction<ssize_t Function(acl_t)>>('acl_size');
  late final _acl_size = _acl_sizePtr.asFunction<int Function(acl_t)>();

  ffi.Pointer<ffi.Char> acl_to_text(
    acl_t acl,
    ffi.Pointer<ssize_t> len_p,
  ) {
    return _acl_to_text(
      acl,
      len_p,
    );
  }

  late final _acl_to_textPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              acl_t, ffi.Pointer<ssize_t>)>>('acl_to_text');
  late final _acl_to_text = _acl_to_textPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(acl_t, ffi.Pointer<ssize_t>)>();

  int CFFileSecurityGetTypeID() {
    return _CFFileSecurityGetTypeID();
  }

  late final _CFFileSecurityGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFFileSecurityGetTypeID');
  late final _CFFileSecurityGetTypeID =
      _CFFileSecurityGetTypeIDPtr.asFunction<int Function()>();

  CFFileSecurityRef CFFileSecurityCreate(
    CFAllocatorRef allocator,
  ) {
    return _CFFileSecurityCreate(
      allocator,
    );
  }

  late final _CFFileSecurityCreatePtr =
      _lookup<ffi.NativeFunction<CFFileSecurityRef Function(CFAllocatorRef)>>(
          'CFFileSecurityCreate');
  late final _CFFileSecurityCreate = _CFFileSecurityCreatePtr.asFunction<
      CFFileSecurityRef Function(CFAllocatorRef)>();

  CFFileSecurityRef CFFileSecurityCreateCopy(
    CFAllocatorRef allocator,
    CFFileSecurityRef fileSec,
  ) {
    return _CFFileSecurityCreateCopy(
      allocator,
      fileSec,
    );
  }

  late final _CFFileSecurityCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          CFFileSecurityRef Function(
              CFAllocatorRef, CFFileSecurityRef)>>('CFFileSecurityCreateCopy');
  late final _CFFileSecurityCreateCopy =
      _CFFileSecurityCreateCopyPtr.asFunction<
          CFFileSecurityRef Function(CFAllocatorRef, CFFileSecurityRef)>();

  int CFFileSecurityCopyOwnerUUID(
    CFFileSecurityRef fileSec,
    ffi.Pointer<CFUUIDRef> ownerUUID,
  ) {
    return _CFFileSecurityCopyOwnerUUID(
      fileSec,
      ownerUUID,
    );
  }

  late final _CFFileSecurityCopyOwnerUUIDPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFFileSecurityRef,
              ffi.Pointer<CFUUIDRef>)>>('CFFileSecurityCopyOwnerUUID');
  late final _CFFileSecurityCopyOwnerUUID = _CFFileSecurityCopyOwnerUUIDPtr
      .asFunction<int Function(CFFileSecurityRef, ffi.Pointer<CFUUIDRef>)>();

  int CFFileSecuritySetOwnerUUID(
    CFFileSecurityRef fileSec,
    CFUUIDRef ownerUUID,
  ) {
    return _CFFileSecuritySetOwnerUUID(
      fileSec,
      ownerUUID,
    );
  }

  late final _CFFileSecuritySetOwnerUUIDPtr = _lookup<
          ffi.NativeFunction<Boolean Function(CFFileSecurityRef, CFUUIDRef)>>(
      'CFFileSecuritySetOwnerUUID');
  late final _CFFileSecuritySetOwnerUUID = _CFFileSecuritySetOwnerUUIDPtr
      .asFunction<int Function(CFFileSecurityRef, CFUUIDRef)>();

  int CFFileSecurityCopyGroupUUID(
    CFFileSecurityRef fileSec,
    ffi.Pointer<CFUUIDRef> groupUUID,
  ) {
    return _CFFileSecurityCopyGroupUUID(
      fileSec,
      groupUUID,
    );
  }

  late final _CFFileSecurityCopyGroupUUIDPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFFileSecurityRef,
              ffi.Pointer<CFUUIDRef>)>>('CFFileSecurityCopyGroupUUID');
  late final _CFFileSecurityCopyGroupUUID = _CFFileSecurityCopyGroupUUIDPtr
      .asFunction<int Function(CFFileSecurityRef, ffi.Pointer<CFUUIDRef>)>();

  int CFFileSecuritySetGroupUUID(
    CFFileSecurityRef fileSec,
    CFUUIDRef groupUUID,
  ) {
    return _CFFileSecuritySetGroupUUID(
      fileSec,
      groupUUID,
    );
  }

  late final _CFFileSecuritySetGroupUUIDPtr = _lookup<
          ffi.NativeFunction<Boolean Function(CFFileSecurityRef, CFUUIDRef)>>(
      'CFFileSecuritySetGroupUUID');
  late final _CFFileSecuritySetGroupUUID = _CFFileSecuritySetGroupUUIDPtr
      .asFunction<int Function(CFFileSecurityRef, CFUUIDRef)>();

  int CFFileSecurityCopyAccessControlList(
    CFFileSecurityRef fileSec,
    ffi.Pointer<acl_t> accessControlList,
  ) {
    return _CFFileSecurityCopyAccessControlList(
      fileSec,
      accessControlList,
    );
  }

  late final _CFFileSecurityCopyAccessControlListPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFFileSecurityRef,
              ffi.Pointer<acl_t>)>>('CFFileSecurityCopyAccessControlList');
  late final _CFFileSecurityCopyAccessControlList =
      _CFFileSecurityCopyAccessControlListPtr.asFunction<
          int Function(CFFileSecurityRef, ffi.Pointer<acl_t>)>();

  int CFFileSecuritySetAccessControlList(
    CFFileSecurityRef fileSec,
    acl_t accessControlList,
  ) {
    return _CFFileSecuritySetAccessControlList(
      fileSec,
      accessControlList,
    );
  }

  late final _CFFileSecuritySetAccessControlListPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFFileSecurityRef, acl_t)>>(
          'CFFileSecuritySetAccessControlList');
  late final _CFFileSecuritySetAccessControlList =
      _CFFileSecuritySetAccessControlListPtr.asFunction<
          int Function(CFFileSecurityRef, acl_t)>();

  int CFFileSecurityGetOwner(
    CFFileSecurityRef fileSec,
    ffi.Pointer<uid_t> owner,
  ) {
    return _CFFileSecurityGetOwner(
      fileSec,
      owner,
    );
  }

  late final _CFFileSecurityGetOwnerPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFFileSecurityRef,
              ffi.Pointer<uid_t>)>>('CFFileSecurityGetOwner');
  late final _CFFileSecurityGetOwner = _CFFileSecurityGetOwnerPtr.asFunction<
      int Function(CFFileSecurityRef, ffi.Pointer<uid_t>)>();

  int CFFileSecuritySetOwner(
    CFFileSecurityRef fileSec,
    int owner,
  ) {
    return _CFFileSecuritySetOwner(
      fileSec,
      owner,
    );
  }

  late final _CFFileSecuritySetOwnerPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFFileSecurityRef, uid_t)>>(
          'CFFileSecuritySetOwner');
  late final _CFFileSecuritySetOwner = _CFFileSecuritySetOwnerPtr.asFunction<
      int Function(CFFileSecurityRef, int)>();

  int CFFileSecurityGetGroup(
    CFFileSecurityRef fileSec,
    ffi.Pointer<gid_t> group,
  ) {
    return _CFFileSecurityGetGroup(
      fileSec,
      group,
    );
  }

  late final _CFFileSecurityGetGroupPtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFFileSecurityRef,
              ffi.Pointer<gid_t>)>>('CFFileSecurityGetGroup');
  late final _CFFileSecurityGetGroup = _CFFileSecurityGetGroupPtr.asFunction<
      int Function(CFFileSecurityRef, ffi.Pointer<gid_t>)>();

  int CFFileSecuritySetGroup(
    CFFileSecurityRef fileSec,
    int group,
  ) {
    return _CFFileSecuritySetGroup(
      fileSec,
      group,
    );
  }

  late final _CFFileSecuritySetGroupPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFFileSecurityRef, gid_t)>>(
          'CFFileSecuritySetGroup');
  late final _CFFileSecuritySetGroup = _CFFileSecuritySetGroupPtr.asFunction<
      int Function(CFFileSecurityRef, int)>();

  int CFFileSecurityGetMode(
    CFFileSecurityRef fileSec,
    ffi.Pointer<mode_t> mode,
  ) {
    return _CFFileSecurityGetMode(
      fileSec,
      mode,
    );
  }

  late final _CFFileSecurityGetModePtr = _lookup<
      ffi.NativeFunction<
          Boolean Function(CFFileSecurityRef,
              ffi.Pointer<mode_t>)>>('CFFileSecurityGetMode');
  late final _CFFileSecurityGetMode = _CFFileSecurityGetModePtr.asFunction<
      int Function(CFFileSecurityRef, ffi.Pointer<mode_t>)>();

  int CFFileSecuritySetMode(
    CFFileSecurityRef fileSec,
    int mode,
  ) {
    return _CFFileSecuritySetMode(
      fileSec,
      mode,
    );
  }

  late final _CFFileSecuritySetModePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFFileSecurityRef, mode_t)>>(
          'CFFileSecuritySetMode');
  late final _CFFileSecuritySetMode = _CFFileSecuritySetModePtr.asFunction<
      int Function(CFFileSecurityRef, int)>();

  DartBoolean CFFileSecurityClearProperties(
    CFFileSecurityRef fileSec,
    CFFileSecurityClearOptions clearPropertyMask,
  ) {
    return _CFFileSecurityClearProperties(
      fileSec,
      clearPropertyMask.value,
    );
  }

  late final _CFFileSecurityClearPropertiesPtr = _lookup<
          ffi
          .NativeFunction<Boolean Function(CFFileSecurityRef, CFOptionFlags)>>(
      'CFFileSecurityClearProperties');
  late final _CFFileSecurityClearProperties = _CFFileSecurityClearPropertiesPtr
      .asFunction<int Function(CFFileSecurityRef, int)>();

  CFStringRef CFStringTokenizerCopyBestStringLanguage(
    CFStringRef string,
    CFRange range,
  ) {
    return _CFStringTokenizerCopyBestStringLanguage(
      string,
      range,
    );
  }

  late final _CFStringTokenizerCopyBestStringLanguagePtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFStringRef, CFRange)>>(
          'CFStringTokenizerCopyBestStringLanguage');
  late final _CFStringTokenizerCopyBestStringLanguage =
      _CFStringTokenizerCopyBestStringLanguagePtr.asFunction<
          CFStringRef Function(CFStringRef, CFRange)>();

  int CFStringTokenizerGetTypeID() {
    return _CFStringTokenizerGetTypeID();
  }

  late final _CFStringTokenizerGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFStringTokenizerGetTypeID');
  late final _CFStringTokenizerGetTypeID =
      _CFStringTokenizerGetTypeIDPtr.asFunction<int Function()>();

  CFStringTokenizerRef CFStringTokenizerCreate(
    CFAllocatorRef alloc,
    CFStringRef string,
    CFRange range,
    int options,
    CFLocaleRef locale,
  ) {
    return _CFStringTokenizerCreate(
      alloc,
      string,
      range,
      options,
      locale,
    );
  }

  late final _CFStringTokenizerCreatePtr = _lookup<
      ffi.NativeFunction<
          CFStringTokenizerRef Function(CFAllocatorRef, CFStringRef, CFRange,
              CFOptionFlags, CFLocaleRef)>>('CFStringTokenizerCreate');
  late final _CFStringTokenizerCreate = _CFStringTokenizerCreatePtr.asFunction<
      CFStringTokenizerRef Function(
          CFAllocatorRef, CFStringRef, CFRange, int, CFLocaleRef)>();

  void CFStringTokenizerSetString(
    CFStringTokenizerRef tokenizer,
    CFStringRef string,
    CFRange range,
  ) {
    return _CFStringTokenizerSetString(
      tokenizer,
      string,
      range,
    );
  }

  late final _CFStringTokenizerSetStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFStringTokenizerRef, CFStringRef,
              CFRange)>>('CFStringTokenizerSetString');
  late final _CFStringTokenizerSetString = _CFStringTokenizerSetStringPtr
      .asFunction<void Function(CFStringTokenizerRef, CFStringRef, CFRange)>();

  CFStringTokenizerTokenType CFStringTokenizerGoToTokenAtIndex(
    CFStringTokenizerRef tokenizer,
    DartCFIndex index,
  ) {
    return CFStringTokenizerTokenType.fromValue(
        _CFStringTokenizerGoToTokenAtIndex(
      tokenizer,
      index,
    ));
  }

  late final _CFStringTokenizerGoToTokenAtIndexPtr = _lookup<
      ffi.NativeFunction<
          CFOptionFlags Function(CFStringTokenizerRef,
              CFIndex)>>('CFStringTokenizerGoToTokenAtIndex');
  late final _CFStringTokenizerGoToTokenAtIndex =
      _CFStringTokenizerGoToTokenAtIndexPtr.asFunction<
          int Function(CFStringTokenizerRef, int)>();

  CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(
    CFStringTokenizerRef tokenizer,
  ) {
    return CFStringTokenizerTokenType.fromValue(
        _CFStringTokenizerAdvanceToNextToken(
      tokenizer,
    ));
  }

  late final _CFStringTokenizerAdvanceToNextTokenPtr =
      _lookup<ffi.NativeFunction<CFOptionFlags Function(CFStringTokenizerRef)>>(
          'CFStringTokenizerAdvanceToNextToken');
  late final _CFStringTokenizerAdvanceToNextToken =
      _CFStringTokenizerAdvanceToNextTokenPtr.asFunction<
          int Function(CFStringTokenizerRef)>();

  CFRange CFStringTokenizerGetCurrentTokenRange(
    CFStringTokenizerRef tokenizer,
  ) {
    return _CFStringTokenizerGetCurrentTokenRange(
      tokenizer,
    );
  }

  late final _CFStringTokenizerGetCurrentTokenRangePtr =
      _lookup<ffi.NativeFunction<CFRange Function(CFStringTokenizerRef)>>(
          'CFStringTokenizerGetCurrentTokenRange');
  late final _CFStringTokenizerGetCurrentTokenRange =
      _CFStringTokenizerGetCurrentTokenRangePtr.asFunction<
          CFRange Function(CFStringTokenizerRef)>();

  CFTypeRef CFStringTokenizerCopyCurrentTokenAttribute(
    CFStringTokenizerRef tokenizer,
    int attribute,
  ) {
    return _CFStringTokenizerCopyCurrentTokenAttribute(
      tokenizer,
      attribute,
    );
  }

  late final _CFStringTokenizerCopyCurrentTokenAttributePtr = _lookup<
      ffi.NativeFunction<
          CFTypeRef Function(CFStringTokenizerRef,
              CFOptionFlags)>>('CFStringTokenizerCopyCurrentTokenAttribute');
  late final _CFStringTokenizerCopyCurrentTokenAttribute =
      _CFStringTokenizerCopyCurrentTokenAttributePtr.asFunction<
          CFTypeRef Function(CFStringTokenizerRef, int)>();

  int CFStringTokenizerGetCurrentSubTokens(
    CFStringTokenizerRef tokenizer,
    ffi.Pointer<CFRange> ranges,
    int maxRangeLength,
    CFMutableArrayRef derivedSubTokens,
  ) {
    return _CFStringTokenizerGetCurrentSubTokens(
      tokenizer,
      ranges,
      maxRangeLength,
      derivedSubTokens,
    );
  }

  late final _CFStringTokenizerGetCurrentSubTokensPtr = _lookup<
      ffi.NativeFunction<
          CFIndex Function(CFStringTokenizerRef, ffi.Pointer<CFRange>, CFIndex,
              CFMutableArrayRef)>>('CFStringTokenizerGetCurrentSubTokens');
  late final _CFStringTokenizerGetCurrentSubTokens =
      _CFStringTokenizerGetCurrentSubTokensPtr.asFunction<
          int Function(CFStringTokenizerRef, ffi.Pointer<CFRange>, int,
              CFMutableArrayRef)>();

  int CFFileDescriptorGetTypeID() {
    return _CFFileDescriptorGetTypeID();
  }

  late final _CFFileDescriptorGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFFileDescriptorGetTypeID');
  late final _CFFileDescriptorGetTypeID =
      _CFFileDescriptorGetTypeIDPtr.asFunction<int Function()>();

  CFFileDescriptorRef CFFileDescriptorCreate(
    CFAllocatorRef allocator,
    int fd,
    int closeOnInvalidate,
    CFFileDescriptorCallBack callout,
    ffi.Pointer<CFFileDescriptorContext> context,
  ) {
    return _CFFileDescriptorCreate(
      allocator,
      fd,
      closeOnInvalidate,
      callout,
      context,
    );
  }

  late final _CFFileDescriptorCreatePtr = _lookup<
      ffi.NativeFunction<
          CFFileDescriptorRef Function(
              CFAllocatorRef,
              CFFileDescriptorNativeDescriptor,
              Boolean,
              CFFileDescriptorCallBack,
              ffi.Pointer<CFFileDescriptorContext>)>>('CFFileDescriptorCreate');
  late final _CFFileDescriptorCreate = _CFFileDescriptorCreatePtr.asFunction<
      CFFileDescriptorRef Function(CFAllocatorRef, int, int,
          CFFileDescriptorCallBack, ffi.Pointer<CFFileDescriptorContext>)>();

  int CFFileDescriptorGetNativeDescriptor(
    CFFileDescriptorRef f,
  ) {
    return _CFFileDescriptorGetNativeDescriptor(
      f,
    );
  }

  late final _CFFileDescriptorGetNativeDescriptorPtr = _lookup<
      ffi.NativeFunction<
          CFFileDescriptorNativeDescriptor Function(
              CFFileDescriptorRef)>>('CFFileDescriptorGetNativeDescriptor');
  late final _CFFileDescriptorGetNativeDescriptor =
      _CFFileDescriptorGetNativeDescriptorPtr.asFunction<
          int Function(CFFileDescriptorRef)>();

  void CFFileDescriptorGetContext(
    CFFileDescriptorRef f,
    ffi.Pointer<CFFileDescriptorContext> context,
  ) {
    return _CFFileDescriptorGetContext(
      f,
      context,
    );
  }

  late final _CFFileDescriptorGetContextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  CFFileDescriptorRef, ffi.Pointer<CFFileDescriptorContext>)>>(
      'CFFileDescriptorGetContext');
  late final _CFFileDescriptorGetContext =
      _CFFileDescriptorGetContextPtr.asFunction<
          void Function(
              CFFileDescriptorRef, ffi.Pointer<CFFileDescriptorContext>)>();

  void CFFileDescriptorEnableCallBacks(
    CFFileDescriptorRef f,
    int callBackTypes,
  ) {
    return _CFFileDescriptorEnableCallBacks(
      f,
      callBackTypes,
    );
  }

  late final _CFFileDescriptorEnableCallBacksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFFileDescriptorRef,
              CFOptionFlags)>>('CFFileDescriptorEnableCallBacks');
  late final _CFFileDescriptorEnableCallBacks =
      _CFFileDescriptorEnableCallBacksPtr.asFunction<
          void Function(CFFileDescriptorRef, int)>();

  void CFFileDescriptorDisableCallBacks(
    CFFileDescriptorRef f,
    int callBackTypes,
  ) {
    return _CFFileDescriptorDisableCallBacks(
      f,
      callBackTypes,
    );
  }

  late final _CFFileDescriptorDisableCallBacksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFFileDescriptorRef,
              CFOptionFlags)>>('CFFileDescriptorDisableCallBacks');
  late final _CFFileDescriptorDisableCallBacks =
      _CFFileDescriptorDisableCallBacksPtr.asFunction<
          void Function(CFFileDescriptorRef, int)>();

  void CFFileDescriptorInvalidate(
    CFFileDescriptorRef f,
  ) {
    return _CFFileDescriptorInvalidate(
      f,
    );
  }

  late final _CFFileDescriptorInvalidatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(CFFileDescriptorRef)>>(
          'CFFileDescriptorInvalidate');
  late final _CFFileDescriptorInvalidate = _CFFileDescriptorInvalidatePtr
      .asFunction<void Function(CFFileDescriptorRef)>();

  int CFFileDescriptorIsValid(
    CFFileDescriptorRef f,
  ) {
    return _CFFileDescriptorIsValid(
      f,
    );
  }

  late final _CFFileDescriptorIsValidPtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFFileDescriptorRef)>>(
          'CFFileDescriptorIsValid');
  late final _CFFileDescriptorIsValid = _CFFileDescriptorIsValidPtr.asFunction<
      int Function(CFFileDescriptorRef)>();

  CFRunLoopSourceRef CFFileDescriptorCreateRunLoopSource(
    CFAllocatorRef allocator,
    CFFileDescriptorRef f,
    int order,
  ) {
    return _CFFileDescriptorCreateRunLoopSource(
      allocator,
      f,
      order,
    );
  }

  late final _CFFileDescriptorCreateRunLoopSourcePtr = _lookup<
      ffi.NativeFunction<
          CFRunLoopSourceRef Function(CFAllocatorRef, CFFileDescriptorRef,
              CFIndex)>>('CFFileDescriptorCreateRunLoopSource');
  late final _CFFileDescriptorCreateRunLoopSource =
      _CFFileDescriptorCreateRunLoopSourcePtr.asFunction<
          CFRunLoopSourceRef Function(
              CFAllocatorRef, CFFileDescriptorRef, int)>();

  int CFUserNotificationGetTypeID() {
    return _CFUserNotificationGetTypeID();
  }

  late final _CFUserNotificationGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'CFUserNotificationGetTypeID');
  late final _CFUserNotificationGetTypeID =
      _CFUserNotificationGetTypeIDPtr.asFunction<int Function()>();

  CFUserNotificationRef CFUserNotificationCreate(
    CFAllocatorRef allocator,
    double timeout,
    int flags,
    ffi.Pointer<SInt32> error,
    CFDictionaryRef dictionary,
  ) {
    return _CFUserNotificationCreate(
      allocator,
      timeout,
      flags,
      error,
      dictionary,
    );
  }

  late final _CFUserNotificationCreatePtr = _lookup<
      ffi.NativeFunction<
          CFUserNotificationRef Function(
              CFAllocatorRef,
              CFTimeInterval,
              CFOptionFlags,
              ffi.Pointer<SInt32>,
              CFDictionaryRef)>>('CFUserNotificationCreate');
  late final _CFUserNotificationCreate =
      _CFUserNotificationCreatePtr.asFunction<
          CFUserNotificationRef Function(CFAllocatorRef, double, int,
              ffi.Pointer<SInt32>, CFDictionaryRef)>();

  int CFUserNotificationReceiveResponse(
    CFUserNotificationRef userNotification,
    double timeout,
    ffi.Pointer<CFOptionFlags> responseFlags,
  ) {
    return _CFUserNotificationReceiveResponse(
      userNotification,
      timeout,
      responseFlags,
    );
  }

  late final _CFUserNotificationReceiveResponsePtr = _lookup<
          ffi.NativeFunction<
              SInt32 Function(CFUserNotificationRef, CFTimeInterval,
                  ffi.Pointer<CFOptionFlags>)>>(
      'CFUserNotificationReceiveResponse');
  late final _CFUserNotificationReceiveResponse =
      _CFUserNotificationReceiveResponsePtr.asFunction<
          int Function(
              CFUserNotificationRef, double, ffi.Pointer<CFOptionFlags>)>();

  CFStringRef CFUserNotificationGetResponseValue(
    CFUserNotificationRef userNotification,
    CFStringRef key,
    int idx,
  ) {
    return _CFUserNotificationGetResponseValue(
      userNotification,
      key,
      idx,
    );
  }

  late final _CFUserNotificationGetResponseValuePtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFUserNotificationRef, CFStringRef,
              CFIndex)>>('CFUserNotificationGetResponseValue');
  late final _CFUserNotificationGetResponseValue =
      _CFUserNotificationGetResponseValuePtr.asFunction<
          CFStringRef Function(CFUserNotificationRef, CFStringRef, int)>();

  CFDictionaryRef CFUserNotificationGetResponseDictionary(
    CFUserNotificationRef userNotification,
  ) {
    return _CFUserNotificationGetResponseDictionary(
      userNotification,
    );
  }

  late final _CFUserNotificationGetResponseDictionaryPtr = _lookup<
          ffi.NativeFunction<CFDictionaryRef Function(CFUserNotificationRef)>>(
      'CFUserNotificationGetResponseDictionary');
  late final _CFUserNotificationGetResponseDictionary =
      _CFUserNotificationGetResponseDictionaryPtr.asFunction<
          CFDictionaryRef Function(CFUserNotificationRef)>();

  int CFUserNotificationUpdate(
    CFUserNotificationRef userNotification,
    double timeout,
    int flags,
    CFDictionaryRef dictionary,
  ) {
    return _CFUserNotificationUpdate(
      userNotification,
      timeout,
      flags,
      dictionary,
    );
  }

  late final _CFUserNotificationUpdatePtr = _lookup<
      ffi.NativeFunction<
          SInt32 Function(CFUserNotificationRef, CFTimeInterval, CFOptionFlags,
              CFDictionaryRef)>>('CFUserNotificationUpdate');
  late final _CFUserNotificationUpdate =
      _CFUserNotificationUpdatePtr.asFunction<
          int Function(CFUserNotificationRef, double, int, CFDictionaryRef)>();

  int CFUserNotificationCancel(
    CFUserNotificationRef userNotification,
  ) {
    return _CFUserNotificationCancel(
      userNotification,
    );
  }

  late final _CFUserNotificationCancelPtr =
      _lookup<ffi.NativeFunction<SInt32 Function(CFUserNotificationRef)>>(
          'CFUserNotificationCancel');
  late final _CFUserNotificationCancel = _CFUserNotificationCancelPtr
      .asFunction<int Function(CFUserNotificationRef)>();

  CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource(
    CFAllocatorRef allocator,
    CFUserNotificationRef userNotification,
    CFUserNotificationCallBack callout,
    int order,
  ) {
    return _CFUserNotificationCreateRunLoopSource(
      allocator,
      userNotification,
      callout,
      order,
    );
  }

  late final _CFUserNotificationCreateRunLoopSourcePtr = _lookup<
      ffi.NativeFunction<
          CFRunLoopSourceRef Function(
              CFAllocatorRef,
              CFUserNotificationRef,
              CFUserNotificationCallBack,
              CFIndex)>>('CFUserNotificationCreateRunLoopSource');
  late final _CFUserNotificationCreateRunLoopSource =
      _CFUserNotificationCreateRunLoopSourcePtr.asFunction<
          CFRunLoopSourceRef Function(CFAllocatorRef, CFUserNotificationRef,
              CFUserNotificationCallBack, int)>();

  int CFUserNotificationDisplayNotice(
    double timeout,
    int flags,
    CFURLRef iconURL,
    CFURLRef soundURL,
    CFURLRef localizationURL,
    CFStringRef alertHeader,
    CFStringRef alertMessage,
    CFStringRef defaultButtonTitle,
  ) {
    return _CFUserNotificationDisplayNotice(
      timeout,
      flags,
      iconURL,
      soundURL,
      localizationURL,
      alertHeader,
      alertMessage,
      defaultButtonTitle,
    );
  }

  late final _CFUserNotificationDisplayNoticePtr = _lookup<
      ffi.NativeFunction<
          SInt32 Function(
              CFTimeInterval,
              CFOptionFlags,
              CFURLRef,
              CFURLRef,
              CFURLRef,
              CFStringRef,
              CFStringRef,
              CFStringRef)>>('CFUserNotificationDisplayNotice');
  late final _CFUserNotificationDisplayNotice =
      _CFUserNotificationDisplayNoticePtr.asFunction<
          int Function(double, int, CFURLRef, CFURLRef, CFURLRef, CFStringRef,
              CFStringRef, CFStringRef)>();

  int CFUserNotificationDisplayAlert(
    double timeout,
    int flags,
    CFURLRef iconURL,
    CFURLRef soundURL,
    CFURLRef localizationURL,
    CFStringRef alertHeader,
    CFStringRef alertMessage,
    CFStringRef defaultButtonTitle,
    CFStringRef alternateButtonTitle,
    CFStringRef otherButtonTitle,
    ffi.Pointer<CFOptionFlags> responseFlags,
  ) {
    return _CFUserNotificationDisplayAlert(
      timeout,
      flags,
      iconURL,
      soundURL,
      localizationURL,
      alertHeader,
      alertMessage,
      defaultButtonTitle,
      alternateButtonTitle,
      otherButtonTitle,
      responseFlags,
    );
  }

  late final _CFUserNotificationDisplayAlertPtr = _lookup<
      ffi.NativeFunction<
          SInt32 Function(
              CFTimeInterval,
              CFOptionFlags,
              CFURLRef,
              CFURLRef,
              CFURLRef,
              CFStringRef,
              CFStringRef,
              CFStringRef,
              CFStringRef,
              CFStringRef,
              ffi.Pointer<CFOptionFlags>)>>('CFUserNotificationDisplayAlert');
  late final _CFUserNotificationDisplayAlert =
      _CFUserNotificationDisplayAlertPtr.asFunction<
          int Function(
              double,
              int,
              CFURLRef,
              CFURLRef,
              CFURLRef,
              CFStringRef,
              CFStringRef,
              CFStringRef,
              CFStringRef,
              CFStringRef,
              ffi.Pointer<CFOptionFlags>)>();

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationIconURLKey =
      _lookup<CFStringRef>('kCFUserNotificationIconURLKey');

  CFStringRef get kCFUserNotificationIconURLKey =>
      _kCFUserNotificationIconURLKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationSoundURLKey =
      _lookup<CFStringRef>('kCFUserNotificationSoundURLKey');

  CFStringRef get kCFUserNotificationSoundURLKey =>
      _kCFUserNotificationSoundURLKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationLocalizationURLKey =
      _lookup<CFStringRef>('kCFUserNotificationLocalizationURLKey');

  CFStringRef get kCFUserNotificationLocalizationURLKey =>
      _kCFUserNotificationLocalizationURLKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationAlertHeaderKey =
      _lookup<CFStringRef>('kCFUserNotificationAlertHeaderKey');

  CFStringRef get kCFUserNotificationAlertHeaderKey =>
      _kCFUserNotificationAlertHeaderKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationAlertMessageKey =
      _lookup<CFStringRef>('kCFUserNotificationAlertMessageKey');

  CFStringRef get kCFUserNotificationAlertMessageKey =>
      _kCFUserNotificationAlertMessageKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFUserNotificationDefaultButtonTitleKey =
      _lookup<CFStringRef>('kCFUserNotificationDefaultButtonTitleKey');

  CFStringRef get kCFUserNotificationDefaultButtonTitleKey =>
      _kCFUserNotificationDefaultButtonTitleKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFUserNotificationAlternateButtonTitleKey =
      _lookup<CFStringRef>('kCFUserNotificationAlternateButtonTitleKey');

  CFStringRef get kCFUserNotificationAlternateButtonTitleKey =>
      _kCFUserNotificationAlternateButtonTitleKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationOtherButtonTitleKey =
      _lookup<CFStringRef>('kCFUserNotificationOtherButtonTitleKey');

  CFStringRef get kCFUserNotificationOtherButtonTitleKey =>
      _kCFUserNotificationOtherButtonTitleKey.value;

  late final ffi.Pointer<CFStringRef>
      _kCFUserNotificationProgressIndicatorValueKey =
      _lookup<CFStringRef>('kCFUserNotificationProgressIndicatorValueKey');

  CFStringRef get kCFUserNotificationProgressIndicatorValueKey =>
      _kCFUserNotificationProgressIndicatorValueKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationPopUpTitlesKey =
      _lookup<CFStringRef>('kCFUserNotificationPopUpTitlesKey');

  CFStringRef get kCFUserNotificationPopUpTitlesKey =>
      _kCFUserNotificationPopUpTitlesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationTextFieldTitlesKey =
      _lookup<CFStringRef>('kCFUserNotificationTextFieldTitlesKey');

  CFStringRef get kCFUserNotificationTextFieldTitlesKey =>
      _kCFUserNotificationTextFieldTitlesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationCheckBoxTitlesKey =
      _lookup<CFStringRef>('kCFUserNotificationCheckBoxTitlesKey');

  CFStringRef get kCFUserNotificationCheckBoxTitlesKey =>
      _kCFUserNotificationCheckBoxTitlesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationTextFieldValuesKey =
      _lookup<CFStringRef>('kCFUserNotificationTextFieldValuesKey');

  CFStringRef get kCFUserNotificationTextFieldValuesKey =>
      _kCFUserNotificationTextFieldValuesKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationPopUpSelectionKey =
      _lookup<CFStringRef>('kCFUserNotificationPopUpSelectionKey');

  CFStringRef get kCFUserNotificationPopUpSelectionKey =>
      _kCFUserNotificationPopUpSelectionKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationAlertTopMostKey =
      _lookup<CFStringRef>('kCFUserNotificationAlertTopMostKey');

  CFStringRef get kCFUserNotificationAlertTopMostKey =>
      _kCFUserNotificationAlertTopMostKey.value;

  late final ffi.Pointer<CFStringRef> _kCFUserNotificationKeyboardTypesKey =
      _lookup<CFStringRef>('kCFUserNotificationKeyboardTypesKey');

  CFStringRef get kCFUserNotificationKeyboardTypesKey =>
      _kCFUserNotificationKeyboardTypesKey.value;

  int CFXMLNodeGetTypeID() {
    return _CFXMLNodeGetTypeID();
  }

  late final _CFXMLNodeGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFXMLNodeGetTypeID');
  late final _CFXMLNodeGetTypeID =
      _CFXMLNodeGetTypeIDPtr.asFunction<int Function()>();

  CFXMLNodeRef CFXMLNodeCreate(
    CFAllocatorRef alloc,
    CFXMLNodeTypeCode xmlType,
    CFStringRef dataString,
    ffi.Pointer<ffi.Void> additionalInfoPtr,
    DartCFIndex version,
  ) {
    return _CFXMLNodeCreate(
      alloc,
      xmlType.value,
      dataString,
      additionalInfoPtr,
      version,
    );
  }

  late final _CFXMLNodeCreatePtr = _lookup<
      ffi.NativeFunction<
          CFXMLNodeRef Function(CFAllocatorRef, CFIndex, CFStringRef,
              ffi.Pointer<ffi.Void>, CFIndex)>>('CFXMLNodeCreate');
  late final _CFXMLNodeCreate = _CFXMLNodeCreatePtr.asFunction<
      CFXMLNodeRef Function(
          CFAllocatorRef, int, CFStringRef, ffi.Pointer<ffi.Void>, int)>();

  CFXMLNodeRef CFXMLNodeCreateCopy(
    CFAllocatorRef alloc,
    CFXMLNodeRef origNode,
  ) {
    return _CFXMLNodeCreateCopy(
      alloc,
      origNode,
    );
  }

  late final _CFXMLNodeCreateCopyPtr = _lookup<
          ffi
          .NativeFunction<CFXMLNodeRef Function(CFAllocatorRef, CFXMLNodeRef)>>(
      'CFXMLNodeCreateCopy');
  late final _CFXMLNodeCreateCopy = _CFXMLNodeCreateCopyPtr.asFunction<
      CFXMLNodeRef Function(CFAllocatorRef, CFXMLNodeRef)>();

  CFXMLNodeTypeCode CFXMLNodeGetTypeCode(
    CFXMLNodeRef node,
  ) {
    return CFXMLNodeTypeCode.fromValue(_CFXMLNodeGetTypeCode(
      node,
    ));
  }

  late final _CFXMLNodeGetTypeCodePtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFXMLNodeRef)>>(
          'CFXMLNodeGetTypeCode');
  late final _CFXMLNodeGetTypeCode =
      _CFXMLNodeGetTypeCodePtr.asFunction<int Function(CFXMLNodeRef)>();

  CFStringRef CFXMLNodeGetString(
    CFXMLNodeRef node,
  ) {
    return _CFXMLNodeGetString(
      node,
    );
  }

  late final _CFXMLNodeGetStringPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFXMLNodeRef)>>(
          'CFXMLNodeGetString');
  late final _CFXMLNodeGetString =
      _CFXMLNodeGetStringPtr.asFunction<CFStringRef Function(CFXMLNodeRef)>();

  ffi.Pointer<ffi.Void> CFXMLNodeGetInfoPtr(
    CFXMLNodeRef node,
  ) {
    return _CFXMLNodeGetInfoPtr(
      node,
    );
  }

  late final _CFXMLNodeGetInfoPtrPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(CFXMLNodeRef)>>(
          'CFXMLNodeGetInfoPtr');
  late final _CFXMLNodeGetInfoPtr = _CFXMLNodeGetInfoPtrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(CFXMLNodeRef)>();

  int CFXMLNodeGetVersion(
    CFXMLNodeRef node,
  ) {
    return _CFXMLNodeGetVersion(
      node,
    );
  }

  late final _CFXMLNodeGetVersionPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFXMLNodeRef)>>(
          'CFXMLNodeGetVersion');
  late final _CFXMLNodeGetVersion =
      _CFXMLNodeGetVersionPtr.asFunction<int Function(CFXMLNodeRef)>();

  CFXMLTreeRef CFXMLTreeCreateWithNode(
    CFAllocatorRef allocator,
    CFXMLNodeRef node,
  ) {
    return _CFXMLTreeCreateWithNode(
      allocator,
      node,
    );
  }

  late final _CFXMLTreeCreateWithNodePtr = _lookup<
          ffi
          .NativeFunction<CFXMLTreeRef Function(CFAllocatorRef, CFXMLNodeRef)>>(
      'CFXMLTreeCreateWithNode');
  late final _CFXMLTreeCreateWithNode = _CFXMLTreeCreateWithNodePtr.asFunction<
      CFXMLTreeRef Function(CFAllocatorRef, CFXMLNodeRef)>();

  CFXMLNodeRef CFXMLTreeGetNode(
    CFXMLTreeRef xmlTree,
  ) {
    return _CFXMLTreeGetNode(
      xmlTree,
    );
  }

  late final _CFXMLTreeGetNodePtr =
      _lookup<ffi.NativeFunction<CFXMLNodeRef Function(CFXMLTreeRef)>>(
          'CFXMLTreeGetNode');
  late final _CFXMLTreeGetNode =
      _CFXMLTreeGetNodePtr.asFunction<CFXMLNodeRef Function(CFXMLTreeRef)>();

  int CFXMLParserGetTypeID() {
    return _CFXMLParserGetTypeID();
  }

  late final _CFXMLParserGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('CFXMLParserGetTypeID');
  late final _CFXMLParserGetTypeID =
      _CFXMLParserGetTypeIDPtr.asFunction<int Function()>();

  CFXMLParserRef CFXMLParserCreate(
    CFAllocatorRef allocator,
    CFDataRef xmlData,
    CFURLRef dataSource,
    int parseOptions,
    int versionOfNodes,
    ffi.Pointer<CFXMLParserCallBacks> callBacks,
    ffi.Pointer<CFXMLParserContext> context,
  ) {
    return _CFXMLParserCreate(
      allocator,
      xmlData,
      dataSource,
      parseOptions,
      versionOfNodes,
      callBacks,
      context,
    );
  }

  late final _CFXMLParserCreatePtr = _lookup<
      ffi.NativeFunction<
          CFXMLParserRef Function(
              CFAllocatorRef,
              CFDataRef,
              CFURLRef,
              CFOptionFlags,
              CFIndex,
              ffi.Pointer<CFXMLParserCallBacks>,
              ffi.Pointer<CFXMLParserContext>)>>('CFXMLParserCreate');
  late final _CFXMLParserCreate = _CFXMLParserCreatePtr.asFunction<
      CFXMLParserRef Function(
          CFAllocatorRef,
          CFDataRef,
          CFURLRef,
          int,
          int,
          ffi.Pointer<CFXMLParserCallBacks>,
          ffi.Pointer<CFXMLParserContext>)>();

  CFXMLParserRef CFXMLParserCreateWithDataFromURL(
    CFAllocatorRef allocator,
    CFURLRef dataSource,
    int parseOptions,
    int versionOfNodes,
    ffi.Pointer<CFXMLParserCallBacks> callBacks,
    ffi.Pointer<CFXMLParserContext> context,
  ) {
    return _CFXMLParserCreateWithDataFromURL(
      allocator,
      dataSource,
      parseOptions,
      versionOfNodes,
      callBacks,
      context,
    );
  }

  late final _CFXMLParserCreateWithDataFromURLPtr = _lookup<
          ffi.NativeFunction<
              CFXMLParserRef Function(
                  CFAllocatorRef,
                  CFURLRef,
                  CFOptionFlags,
                  CFIndex,
                  ffi.Pointer<CFXMLParserCallBacks>,
                  ffi.Pointer<CFXMLParserContext>)>>(
      'CFXMLParserCreateWithDataFromURL');
  late final _CFXMLParserCreateWithDataFromURL =
      _CFXMLParserCreateWithDataFromURLPtr.asFunction<
          CFXMLParserRef Function(
              CFAllocatorRef,
              CFURLRef,
              int,
              int,
              ffi.Pointer<CFXMLParserCallBacks>,
              ffi.Pointer<CFXMLParserContext>)>();

  void CFXMLParserGetContext(
    CFXMLParserRef parser,
    ffi.Pointer<CFXMLParserContext> context,
  ) {
    return _CFXMLParserGetContext(
      parser,
      context,
    );
  }

  late final _CFXMLParserGetContextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFXMLParserRef,
              ffi.Pointer<CFXMLParserContext>)>>('CFXMLParserGetContext');
  late final _CFXMLParserGetContext = _CFXMLParserGetContextPtr.asFunction<
      void Function(CFXMLParserRef, ffi.Pointer<CFXMLParserContext>)>();

  void CFXMLParserGetCallBacks(
    CFXMLParserRef parser,
    ffi.Pointer<CFXMLParserCallBacks> callBacks,
  ) {
    return _CFXMLParserGetCallBacks(
      parser,
      callBacks,
    );
  }

  late final _CFXMLParserGetCallBacksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(CFXMLParserRef,
              ffi.Pointer<CFXMLParserCallBacks>)>>('CFXMLParserGetCallBacks');
  late final _CFXMLParserGetCallBacks = _CFXMLParserGetCallBacksPtr.asFunction<
      void Function(CFXMLParserRef, ffi.Pointer<CFXMLParserCallBacks>)>();

  CFURLRef CFXMLParserGetSourceURL(
    CFXMLParserRef parser,
  ) {
    return _CFXMLParserGetSourceURL(
      parser,
    );
  }

  late final _CFXMLParserGetSourceURLPtr =
      _lookup<ffi.NativeFunction<CFURLRef Function(CFXMLParserRef)>>(
          'CFXMLParserGetSourceURL');
  late final _CFXMLParserGetSourceURL = _CFXMLParserGetSourceURLPtr.asFunction<
      CFURLRef Function(CFXMLParserRef)>();

  int CFXMLParserGetLocation(
    CFXMLParserRef parser,
  ) {
    return _CFXMLParserGetLocation(
      parser,
    );
  }

  late final _CFXMLParserGetLocationPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFXMLParserRef)>>(
          'CFXMLParserGetLocation');
  late final _CFXMLParserGetLocation =
      _CFXMLParserGetLocationPtr.asFunction<int Function(CFXMLParserRef)>();

  int CFXMLParserGetLineNumber(
    CFXMLParserRef parser,
  ) {
    return _CFXMLParserGetLineNumber(
      parser,
    );
  }

  late final _CFXMLParserGetLineNumberPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFXMLParserRef)>>(
          'CFXMLParserGetLineNumber');
  late final _CFXMLParserGetLineNumber =
      _CFXMLParserGetLineNumberPtr.asFunction<int Function(CFXMLParserRef)>();

  ffi.Pointer<ffi.Void> CFXMLParserGetDocument(
    CFXMLParserRef parser,
  ) {
    return _CFXMLParserGetDocument(
      parser,
    );
  }

  late final _CFXMLParserGetDocumentPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(CFXMLParserRef)>>(
      'CFXMLParserGetDocument');
  late final _CFXMLParserGetDocument = _CFXMLParserGetDocumentPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(CFXMLParserRef)>();

  CFXMLParserStatusCode CFXMLParserGetStatusCode(
    CFXMLParserRef parser,
  ) {
    return CFXMLParserStatusCode.fromValue(_CFXMLParserGetStatusCode(
      parser,
    ));
  }

  late final _CFXMLParserGetStatusCodePtr =
      _lookup<ffi.NativeFunction<CFIndex Function(CFXMLParserRef)>>(
          'CFXMLParserGetStatusCode');
  late final _CFXMLParserGetStatusCode =
      _CFXMLParserGetStatusCodePtr.asFunction<int Function(CFXMLParserRef)>();

  CFStringRef CFXMLParserCopyErrorDescription(
    CFXMLParserRef parser,
  ) {
    return _CFXMLParserCopyErrorDescription(
      parser,
    );
  }

  late final _CFXMLParserCopyErrorDescriptionPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(CFXMLParserRef)>>(
          'CFXMLParserCopyErrorDescription');
  late final _CFXMLParserCopyErrorDescription =
      _CFXMLParserCopyErrorDescriptionPtr.asFunction<
          CFStringRef Function(CFXMLParserRef)>();

  void CFXMLParserAbort(
    CFXMLParserRef parser,
    CFXMLParserStatusCode errorCode,
    CFStringRef errorDescription,
  ) {
    return _CFXMLParserAbort(
      parser,
      errorCode.value,
      errorDescription,
    );
  }

  late final _CFXMLParserAbortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              CFXMLParserRef, CFIndex, CFStringRef)>>('CFXMLParserAbort');
  late final _CFXMLParserAbort = _CFXMLParserAbortPtr.asFunction<
      void Function(CFXMLParserRef, int, CFStringRef)>();

  int CFXMLParserParse(
    CFXMLParserRef parser,
  ) {
    return _CFXMLParserParse(
      parser,
    );
  }

  late final _CFXMLParserParsePtr =
      _lookup<ffi.NativeFunction<Boolean Function(CFXMLParserRef)>>(
          'CFXMLParserParse');
  late final _CFXMLParserParse =
      _CFXMLParserParsePtr.asFunction<int Function(CFXMLParserRef)>();

  CFXMLTreeRef CFXMLTreeCreateFromData(
    CFAllocatorRef allocator,
    CFDataRef xmlData,
    CFURLRef dataSource,
    int parseOptions,
    int versionOfNodes,
  ) {
    return _CFXMLTreeCreateFromData(
      allocator,
      xmlData,
      dataSource,
      parseOptions,
      versionOfNodes,
    );
  }

  late final _CFXMLTreeCreateFromDataPtr = _lookup<
      ffi.NativeFunction<
          CFXMLTreeRef Function(CFAllocatorRef, CFDataRef, CFURLRef,
              CFOptionFlags, CFIndex)>>('CFXMLTreeCreateFromData');
  late final _CFXMLTreeCreateFromData = _CFXMLTreeCreateFromDataPtr.asFunction<
      CFXMLTreeRef Function(CFAllocatorRef, CFDataRef, CFURLRef, int, int)>();

  CFXMLTreeRef CFXMLTreeCreateFromDataWithError(
    CFAllocatorRef allocator,
    CFDataRef xmlData,
    CFURLRef dataSource,
    int parseOptions,
    int versionOfNodes,
    ffi.Pointer<CFDictionaryRef> errorDict,
  ) {
    return _CFXMLTreeCreateFromDataWithError(
      allocator,
      xmlData,
      dataSource,
      parseOptions,
      versionOfNodes,
      errorDict,
    );
  }

  late final _CFXMLTreeCreateFromDataWithErrorPtr = _lookup<
          ffi.NativeFunction<
              CFXMLTreeRef Function(CFAllocatorRef, CFDataRef, CFURLRef,
                  CFOptionFlags, CFIndex, ffi.Pointer<CFDictionaryRef>)>>(
      'CFXMLTreeCreateFromDataWithError');
  late final _CFXMLTreeCreateFromDataWithError =
      _CFXMLTreeCreateFromDataWithErrorPtr.asFunction<
          CFXMLTreeRef Function(CFAllocatorRef, CFDataRef, CFURLRef, int, int,
              ffi.Pointer<CFDictionaryRef>)>();

  CFXMLTreeRef CFXMLTreeCreateWithDataFromURL(
    CFAllocatorRef allocator,
    CFURLRef dataSource,
    int parseOptions,
    int versionOfNodes,
  ) {
    return _CFXMLTreeCreateWithDataFromURL(
      allocator,
      dataSource,
      parseOptions,
      versionOfNodes,
    );
  }

  late final _CFXMLTreeCreateWithDataFromURLPtr = _lookup<
      ffi.NativeFunction<
          CFXMLTreeRef Function(CFAllocatorRef, CFURLRef, CFOptionFlags,
              CFIndex)>>('CFXMLTreeCreateWithDataFromURL');
  late final _CFXMLTreeCreateWithDataFromURL =
      _CFXMLTreeCreateWithDataFromURLPtr.asFunction<
          CFXMLTreeRef Function(CFAllocatorRef, CFURLRef, int, int)>();

  CFDataRef CFXMLTreeCreateXMLData(
    CFAllocatorRef allocator,
    CFXMLTreeRef xmlTree,
  ) {
    return _CFXMLTreeCreateXMLData(
      allocator,
      xmlTree,
    );
  }

  late final _CFXMLTreeCreateXMLDataPtr = _lookup<
          ffi.NativeFunction<CFDataRef Function(CFAllocatorRef, CFXMLTreeRef)>>(
      'CFXMLTreeCreateXMLData');
  late final _CFXMLTreeCreateXMLData = _CFXMLTreeCreateXMLDataPtr.asFunction<
      CFDataRef Function(CFAllocatorRef, CFXMLTreeRef)>();

  CFStringRef CFXMLCreateStringByEscapingEntities(
    CFAllocatorRef allocator,
    CFStringRef string,
    CFDictionaryRef entitiesDictionary,
  ) {
    return _CFXMLCreateStringByEscapingEntities(
      allocator,
      string,
      entitiesDictionary,
    );
  }

  late final _CFXMLCreateStringByEscapingEntitiesPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFStringRef,
              CFDictionaryRef)>>('CFXMLCreateStringByEscapingEntities');
  late final _CFXMLCreateStringByEscapingEntities =
      _CFXMLCreateStringByEscapingEntitiesPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, CFStringRef, CFDictionaryRef)>();

  CFStringRef CFXMLCreateStringByUnescapingEntities(
    CFAllocatorRef allocator,
    CFStringRef string,
    CFDictionaryRef entitiesDictionary,
  ) {
    return _CFXMLCreateStringByUnescapingEntities(
      allocator,
      string,
      entitiesDictionary,
    );
  }

  late final _CFXMLCreateStringByUnescapingEntitiesPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, CFStringRef,
              CFDictionaryRef)>>('CFXMLCreateStringByUnescapingEntities');
  late final _CFXMLCreateStringByUnescapingEntities =
      _CFXMLCreateStringByUnescapingEntitiesPtr.asFunction<
          CFStringRef Function(CFAllocatorRef, CFStringRef, CFDictionaryRef)>();

  late final ffi.Pointer<CFStringRef> _kCFXMLTreeErrorDescription =
      _lookup<CFStringRef>('kCFXMLTreeErrorDescription');

  CFStringRef get kCFXMLTreeErrorDescription =>
      _kCFXMLTreeErrorDescription.value;

  late final ffi.Pointer<CFStringRef> _kCFXMLTreeErrorLineNumber =
      _lookup<CFStringRef>('kCFXMLTreeErrorLineNumber');

  CFStringRef get kCFXMLTreeErrorLineNumber => _kCFXMLTreeErrorLineNumber.value;

  late final ffi.Pointer<CFStringRef> _kCFXMLTreeErrorLocation =
      _lookup<CFStringRef>('kCFXMLTreeErrorLocation');

  CFStringRef get kCFXMLTreeErrorLocation => _kCFXMLTreeErrorLocation.value;

  late final ffi.Pointer<CFStringRef> _kCFXMLTreeErrorStatusCode =
      _lookup<CFStringRef>('kCFXMLTreeErrorStatusCode');

  CFStringRef get kCFXMLTreeErrorStatusCode => _kCFXMLTreeErrorStatusCode.value;

  late final ffi.Pointer<CSSM_GUID> _gGuidCssm =
      _lookup<CSSM_GUID>('gGuidCssm');

  CSSM_GUID get gGuidCssm => _gGuidCssm.ref;

  late final ffi.Pointer<CSSM_GUID> _gGuidAppleFileDL =
      _lookup<CSSM_GUID>('gGuidAppleFileDL');

  CSSM_GUID get gGuidAppleFileDL => _gGuidAppleFileDL.ref;

  late final ffi.Pointer<CSSM_GUID> _gGuidAppleCSP =
      _lookup<CSSM_GUID>('gGuidAppleCSP');

  CSSM_GUID get gGuidAppleCSP => _gGuidAppleCSP.ref;

  late final ffi.Pointer<CSSM_GUID> _gGuidAppleCSPDL =
      _lookup<CSSM_GUID>('gGuidAppleCSPDL');

  CSSM_GUID get gGuidAppleCSPDL => _gGuidAppleCSPDL.ref;

  late final ffi.Pointer<CSSM_GUID> _gGuidAppleX509CL =
      _lookup<CSSM_GUID>('gGuidAppleX509CL');

  CSSM_GUID get gGuidAppleX509CL => _gGuidAppleX509CL.ref;

  late final ffi.Pointer<CSSM_GUID> _gGuidAppleX509TP =
      _lookup<CSSM_GUID>('gGuidAppleX509TP');

  CSSM_GUID get gGuidAppleX509TP => _gGuidAppleX509TP.ref;

  late final ffi.Pointer<CSSM_GUID> _gGuidAppleLDAPDL =
      _lookup<CSSM_GUID>('gGuidAppleLDAPDL');

  CSSM_GUID get gGuidAppleLDAPDL => _gGuidAppleLDAPDL.ref;

  late final ffi.Pointer<CSSM_GUID> _gGuidAppleDotMacTP =
      _lookup<CSSM_GUID>('gGuidAppleDotMacTP');

  CSSM_GUID get gGuidAppleDotMacTP => _gGuidAppleDotMacTP.ref;

  late final ffi.Pointer<CSSM_GUID> _gGuidAppleSdCSPDL =
      _lookup<CSSM_GUID>('gGuidAppleSdCSPDL');

  CSSM_GUID get gGuidAppleSdCSPDL => _gGuidAppleSdCSPDL.ref;

  late final ffi.Pointer<CSSM_GUID> _gGuidAppleDotMacDL =
      _lookup<CSSM_GUID>('gGuidAppleDotMacDL');

  CSSM_GUID get gGuidAppleDotMacDL => _gGuidAppleDotMacDL.ref;

  void cssmPerror(
    ffi.Pointer<ffi.Char> how,
    int error,
  ) {
    return _cssmPerror(
      how,
      error,
    );
  }

  late final _cssmPerrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, CSSM_RETURN)>>('cssmPerror');
  late final _cssmPerror =
      _cssmPerrorPtr.asFunction<void Function(ffi.Pointer<ffi.Char>, int)>();

  bool cssmOidToAlg(
    ffi.Pointer<SecAsn1Oid> oid,
    ffi.Pointer<CSSM_ALGORITHMS> alg,
  ) {
    return _cssmOidToAlg(
      oid,
      alg,
    );
  }

  late final _cssmOidToAlgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<SecAsn1Oid>,
              ffi.Pointer<CSSM_ALGORITHMS>)>>('cssmOidToAlg');
  late final _cssmOidToAlg = _cssmOidToAlgPtr.asFunction<
      bool Function(ffi.Pointer<SecAsn1Oid>, ffi.Pointer<CSSM_ALGORITHMS>)>();

  ffi.Pointer<SecAsn1Oid> cssmAlgToOid(
    int algId,
  ) {
    return _cssmAlgToOid(
      algId,
    );
  }

  late final _cssmAlgToOidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SecAsn1Oid> Function(CSSM_ALGORITHMS)>>('cssmAlgToOid');
  late final _cssmAlgToOid =
      _cssmAlgToOidPtr.asFunction<ffi.Pointer<SecAsn1Oid> Function(int)>();

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeTitle =
      _lookup<CFStringRef>('kSecPropertyTypeTitle');

  CFStringRef get kSecPropertyTypeTitle => _kSecPropertyTypeTitle.value;

  set kSecPropertyTypeTitle(CFStringRef value) =>
      _kSecPropertyTypeTitle.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeError =
      _lookup<CFStringRef>('kSecPropertyTypeError');

  CFStringRef get kSecPropertyTypeError => _kSecPropertyTypeError.value;

  set kSecPropertyTypeError(CFStringRef value) =>
      _kSecPropertyTypeError.value = value;

  late final ffi.Pointer<CFStringRef> _kSecTrustEvaluationDate =
      _lookup<CFStringRef>('kSecTrustEvaluationDate');

  CFStringRef get kSecTrustEvaluationDate => _kSecTrustEvaluationDate.value;

  set kSecTrustEvaluationDate(CFStringRef value) =>
      _kSecTrustEvaluationDate.value = value;

  late final ffi.Pointer<CFStringRef> _kSecTrustExtendedValidation =
      _lookup<CFStringRef>('kSecTrustExtendedValidation');

  CFStringRef get kSecTrustExtendedValidation =>
      _kSecTrustExtendedValidation.value;

  set kSecTrustExtendedValidation(CFStringRef value) =>
      _kSecTrustExtendedValidation.value = value;

  late final ffi.Pointer<CFStringRef> _kSecTrustOrganizationName =
      _lookup<CFStringRef>('kSecTrustOrganizationName');

  CFStringRef get kSecTrustOrganizationName => _kSecTrustOrganizationName.value;

  set kSecTrustOrganizationName(CFStringRef value) =>
      _kSecTrustOrganizationName.value = value;

  late final ffi.Pointer<CFStringRef> _kSecTrustResultValue =
      _lookup<CFStringRef>('kSecTrustResultValue');

  CFStringRef get kSecTrustResultValue => _kSecTrustResultValue.value;

  set kSecTrustResultValue(CFStringRef value) =>
      _kSecTrustResultValue.value = value;

  late final ffi.Pointer<CFStringRef> _kSecTrustRevocationChecked =
      _lookup<CFStringRef>('kSecTrustRevocationChecked');

  CFStringRef get kSecTrustRevocationChecked =>
      _kSecTrustRevocationChecked.value;

  set kSecTrustRevocationChecked(CFStringRef value) =>
      _kSecTrustRevocationChecked.value = value;

  late final ffi.Pointer<CFStringRef> _kSecTrustRevocationValidUntilDate =
      _lookup<CFStringRef>('kSecTrustRevocationValidUntilDate');

  CFStringRef get kSecTrustRevocationValidUntilDate =>
      _kSecTrustRevocationValidUntilDate.value;

  set kSecTrustRevocationValidUntilDate(CFStringRef value) =>
      _kSecTrustRevocationValidUntilDate.value = value;

  late final ffi.Pointer<CFStringRef> _kSecTrustCertificateTransparency =
      _lookup<CFStringRef>('kSecTrustCertificateTransparency');

  CFStringRef get kSecTrustCertificateTransparency =>
      _kSecTrustCertificateTransparency.value;

  set kSecTrustCertificateTransparency(CFStringRef value) =>
      _kSecTrustCertificateTransparency.value = value;

  late final ffi.Pointer<CFStringRef>
      _kSecTrustCertificateTransparencyWhiteList =
      _lookup<CFStringRef>('kSecTrustCertificateTransparencyWhiteList');

  CFStringRef get kSecTrustCertificateTransparencyWhiteList =>
      _kSecTrustCertificateTransparencyWhiteList.value;

  set kSecTrustCertificateTransparencyWhiteList(CFStringRef value) =>
      _kSecTrustCertificateTransparencyWhiteList.value = value;

  int SecTrustGetTypeID() {
    return _SecTrustGetTypeID();
  }

  late final _SecTrustGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('SecTrustGetTypeID');
  late final _SecTrustGetTypeID =
      _SecTrustGetTypeIDPtr.asFunction<int Function()>();

  int SecTrustCreateWithCertificates(
    CFTypeRef certificates,
    CFTypeRef policies,
    ffi.Pointer<SecTrustRef> trust,
  ) {
    return _SecTrustCreateWithCertificates(
      certificates,
      policies,
      trust,
    );
  }

  late final _SecTrustCreateWithCertificatesPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(CFTypeRef, CFTypeRef,
              ffi.Pointer<SecTrustRef>)>>('SecTrustCreateWithCertificates');
  late final _SecTrustCreateWithCertificates =
      _SecTrustCreateWithCertificatesPtr.asFunction<
          int Function(CFTypeRef, CFTypeRef, ffi.Pointer<SecTrustRef>)>();

  int SecTrustSetPolicies(
    SecTrustRef trust,
    CFTypeRef policies,
  ) {
    return _SecTrustSetPolicies(
      trust,
      policies,
    );
  }

  late final _SecTrustSetPoliciesPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SecTrustRef, CFTypeRef)>>(
          'SecTrustSetPolicies');
  late final _SecTrustSetPolicies = _SecTrustSetPoliciesPtr.asFunction<
      int Function(SecTrustRef, CFTypeRef)>();

  int SecTrustCopyPolicies(
    SecTrustRef trust,
    ffi.Pointer<CFArrayRef> policies,
  ) {
    return _SecTrustCopyPolicies(
      trust,
      policies,
    );
  }

  late final _SecTrustCopyPoliciesPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SecTrustRef, ffi.Pointer<CFArrayRef>)>>('SecTrustCopyPolicies');
  late final _SecTrustCopyPolicies = _SecTrustCopyPoliciesPtr.asFunction<
      int Function(SecTrustRef, ffi.Pointer<CFArrayRef>)>();

  int SecTrustSetNetworkFetchAllowed(
    SecTrustRef trust,
    int allowFetch,
  ) {
    return _SecTrustSetNetworkFetchAllowed(
      trust,
      allowFetch,
    );
  }

  late final _SecTrustSetNetworkFetchAllowedPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SecTrustRef, Boolean)>>(
          'SecTrustSetNetworkFetchAllowed');
  late final _SecTrustSetNetworkFetchAllowed =
      _SecTrustSetNetworkFetchAllowedPtr.asFunction<
          int Function(SecTrustRef, int)>();

  int SecTrustGetNetworkFetchAllowed(
    SecTrustRef trust,
    ffi.Pointer<Boolean> allowFetch,
  ) {
    return _SecTrustGetNetworkFetchAllowed(
      trust,
      allowFetch,
    );
  }

  late final _SecTrustGetNetworkFetchAllowedPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecTrustRef,
              ffi.Pointer<Boolean>)>>('SecTrustGetNetworkFetchAllowed');
  late final _SecTrustGetNetworkFetchAllowed =
      _SecTrustGetNetworkFetchAllowedPtr.asFunction<
          int Function(SecTrustRef, ffi.Pointer<Boolean>)>();

  int SecTrustSetAnchorCertificates(
    SecTrustRef trust,
    CFArrayRef anchorCertificates,
  ) {
    return _SecTrustSetAnchorCertificates(
      trust,
      anchorCertificates,
    );
  }

  late final _SecTrustSetAnchorCertificatesPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SecTrustRef, CFArrayRef)>>(
          'SecTrustSetAnchorCertificates');
  late final _SecTrustSetAnchorCertificates = _SecTrustSetAnchorCertificatesPtr
      .asFunction<int Function(SecTrustRef, CFArrayRef)>();

  int SecTrustSetAnchorCertificatesOnly(
    SecTrustRef trust,
    int anchorCertificatesOnly,
  ) {
    return _SecTrustSetAnchorCertificatesOnly(
      trust,
      anchorCertificatesOnly,
    );
  }

  late final _SecTrustSetAnchorCertificatesOnlyPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SecTrustRef, Boolean)>>(
          'SecTrustSetAnchorCertificatesOnly');
  late final _SecTrustSetAnchorCertificatesOnly =
      _SecTrustSetAnchorCertificatesOnlyPtr.asFunction<
          int Function(SecTrustRef, int)>();

  int SecTrustCopyCustomAnchorCertificates(
    SecTrustRef trust,
    ffi.Pointer<CFArrayRef> anchors,
  ) {
    return _SecTrustCopyCustomAnchorCertificates(
      trust,
      anchors,
    );
  }

  late final _SecTrustCopyCustomAnchorCertificatesPtr = _lookup<
          ffi.NativeFunction<
              OSStatus Function(SecTrustRef, ffi.Pointer<CFArrayRef>)>>(
      'SecTrustCopyCustomAnchorCertificates');
  late final _SecTrustCopyCustomAnchorCertificates =
      _SecTrustCopyCustomAnchorCertificatesPtr.asFunction<
          int Function(SecTrustRef, ffi.Pointer<CFArrayRef>)>();

  int SecTrustSetVerifyDate(
    SecTrustRef trust,
    CFDateRef verifyDate,
  ) {
    return _SecTrustSetVerifyDate(
      trust,
      verifyDate,
    );
  }

  late final _SecTrustSetVerifyDatePtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SecTrustRef, CFDateRef)>>(
          'SecTrustSetVerifyDate');
  late final _SecTrustSetVerifyDate = _SecTrustSetVerifyDatePtr.asFunction<
      int Function(SecTrustRef, CFDateRef)>();

  double SecTrustGetVerifyTime(
    SecTrustRef trust,
  ) {
    return _SecTrustGetVerifyTime(
      trust,
    );
  }

  late final _SecTrustGetVerifyTimePtr =
      _lookup<ffi.NativeFunction<CFAbsoluteTime Function(SecTrustRef)>>(
          'SecTrustGetVerifyTime');
  late final _SecTrustGetVerifyTime =
      _SecTrustGetVerifyTimePtr.asFunction<double Function(SecTrustRef)>();

  int SecTrustEvaluate(
    SecTrustRef trust,
    ffi.Pointer<ffi.Uint32> result,
  ) {
    return _SecTrustEvaluate(
      trust,
      result,
    );
  }

  late final _SecTrustEvaluatePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SecTrustRef, ffi.Pointer<ffi.Uint32>)>>('SecTrustEvaluate');
  late final _SecTrustEvaluate = _SecTrustEvaluatePtr.asFunction<
      int Function(SecTrustRef, ffi.Pointer<ffi.Uint32>)>();

  DartSInt32 SecTrustEvaluateAsync(
    SecTrustRef trust,
    Dartdispatch_queue_t? queue,
    DartSecTrustCallback result,
  ) {
    return _SecTrustEvaluateAsync(
      trust,
      queue?.ref.pointer ?? ffi.nullptr,
      result.ref.pointer,
    );
  }

  late final _SecTrustEvaluateAsyncPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecTrustRef, dispatch_queue_t,
              SecTrustCallback)>>('SecTrustEvaluateAsync');
  late final _SecTrustEvaluateAsync = _SecTrustEvaluateAsyncPtr.asFunction<
      int Function(SecTrustRef, dispatch_queue_t, SecTrustCallback)>();

  bool SecTrustEvaluateWithError(
    SecTrustRef trust,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _SecTrustEvaluateWithError(
      trust,
      error,
    );
  }

  late final _SecTrustEvaluateWithErrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(SecTrustRef,
              ffi.Pointer<CFErrorRef>)>>('SecTrustEvaluateWithError');
  late final _SecTrustEvaluateWithError = _SecTrustEvaluateWithErrorPtr
      .asFunction<bool Function(SecTrustRef, ffi.Pointer<CFErrorRef>)>();

  DartSInt32 SecTrustEvaluateAsyncWithError(
    SecTrustRef trust,
    Dartdispatch_queue_t queue,
    DartSecTrustWithErrorCallback result,
  ) {
    return _SecTrustEvaluateAsyncWithError(
      trust,
      queue.ref.pointer,
      result.ref.pointer,
    );
  }

  late final _SecTrustEvaluateAsyncWithErrorPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecTrustRef, dispatch_queue_t,
              SecTrustWithErrorCallback)>>('SecTrustEvaluateAsyncWithError');
  late final _SecTrustEvaluateAsyncWithError =
      _SecTrustEvaluateAsyncWithErrorPtr.asFunction<
          int Function(
              SecTrustRef, dispatch_queue_t, SecTrustWithErrorCallback)>();

  int SecTrustGetTrustResult(
    SecTrustRef trust,
    ffi.Pointer<ffi.Uint32> result,
  ) {
    return _SecTrustGetTrustResult(
      trust,
      result,
    );
  }

  late final _SecTrustGetTrustResultPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SecTrustRef, ffi.Pointer<ffi.Uint32>)>>('SecTrustGetTrustResult');
  late final _SecTrustGetTrustResult = _SecTrustGetTrustResultPtr.asFunction<
      int Function(SecTrustRef, ffi.Pointer<ffi.Uint32>)>();

  SecKeyRef SecTrustCopyPublicKey(
    SecTrustRef trust,
  ) {
    return _SecTrustCopyPublicKey(
      trust,
    );
  }

  late final _SecTrustCopyPublicKeyPtr =
      _lookup<ffi.NativeFunction<SecKeyRef Function(SecTrustRef)>>(
          'SecTrustCopyPublicKey');
  late final _SecTrustCopyPublicKey =
      _SecTrustCopyPublicKeyPtr.asFunction<SecKeyRef Function(SecTrustRef)>();

  SecKeyRef SecTrustCopyKey(
    SecTrustRef trust,
  ) {
    return _SecTrustCopyKey(
      trust,
    );
  }

  late final _SecTrustCopyKeyPtr =
      _lookup<ffi.NativeFunction<SecKeyRef Function(SecTrustRef)>>(
          'SecTrustCopyKey');
  late final _SecTrustCopyKey =
      _SecTrustCopyKeyPtr.asFunction<SecKeyRef Function(SecTrustRef)>();

  int SecTrustGetCertificateCount(
    SecTrustRef trust,
  ) {
    return _SecTrustGetCertificateCount(
      trust,
    );
  }

  late final _SecTrustGetCertificateCountPtr =
      _lookup<ffi.NativeFunction<CFIndex Function(SecTrustRef)>>(
          'SecTrustGetCertificateCount');
  late final _SecTrustGetCertificateCount =
      _SecTrustGetCertificateCountPtr.asFunction<int Function(SecTrustRef)>();

  SecCertificateRef SecTrustGetCertificateAtIndex(
    SecTrustRef trust,
    int ix,
  ) {
    return _SecTrustGetCertificateAtIndex(
      trust,
      ix,
    );
  }

  late final _SecTrustGetCertificateAtIndexPtr = _lookup<
          ffi.NativeFunction<SecCertificateRef Function(SecTrustRef, CFIndex)>>(
      'SecTrustGetCertificateAtIndex');
  late final _SecTrustGetCertificateAtIndex = _SecTrustGetCertificateAtIndexPtr
      .asFunction<SecCertificateRef Function(SecTrustRef, int)>();

  CFDataRef SecTrustCopyExceptions(
    SecTrustRef trust,
  ) {
    return _SecTrustCopyExceptions(
      trust,
    );
  }

  late final _SecTrustCopyExceptionsPtr =
      _lookup<ffi.NativeFunction<CFDataRef Function(SecTrustRef)>>(
          'SecTrustCopyExceptions');
  late final _SecTrustCopyExceptions =
      _SecTrustCopyExceptionsPtr.asFunction<CFDataRef Function(SecTrustRef)>();

  bool SecTrustSetExceptions(
    SecTrustRef trust,
    CFDataRef exceptions,
  ) {
    return _SecTrustSetExceptions(
      trust,
      exceptions,
    );
  }

  late final _SecTrustSetExceptionsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(SecTrustRef, CFDataRef)>>(
          'SecTrustSetExceptions');
  late final _SecTrustSetExceptions = _SecTrustSetExceptionsPtr.asFunction<
      bool Function(SecTrustRef, CFDataRef)>();

  CFArrayRef SecTrustCopyProperties(
    SecTrustRef trust,
  ) {
    return _SecTrustCopyProperties(
      trust,
    );
  }

  late final _SecTrustCopyPropertiesPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(SecTrustRef)>>(
          'SecTrustCopyProperties');
  late final _SecTrustCopyProperties =
      _SecTrustCopyPropertiesPtr.asFunction<CFArrayRef Function(SecTrustRef)>();

  CFDictionaryRef SecTrustCopyResult(
    SecTrustRef trust,
  ) {
    return _SecTrustCopyResult(
      trust,
    );
  }

  late final _SecTrustCopyResultPtr =
      _lookup<ffi.NativeFunction<CFDictionaryRef Function(SecTrustRef)>>(
          'SecTrustCopyResult');
  late final _SecTrustCopyResult = _SecTrustCopyResultPtr.asFunction<
      CFDictionaryRef Function(SecTrustRef)>();

  int SecTrustSetOCSPResponse(
    SecTrustRef trust,
    CFTypeRef responseData,
  ) {
    return _SecTrustSetOCSPResponse(
      trust,
      responseData,
    );
  }

  late final _SecTrustSetOCSPResponsePtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SecTrustRef, CFTypeRef)>>(
          'SecTrustSetOCSPResponse');
  late final _SecTrustSetOCSPResponse = _SecTrustSetOCSPResponsePtr.asFunction<
      int Function(SecTrustRef, CFTypeRef)>();

  int SecTrustSetSignedCertificateTimestamps(
    SecTrustRef trust,
    CFArrayRef sctArray,
  ) {
    return _SecTrustSetSignedCertificateTimestamps(
      trust,
      sctArray,
    );
  }

  late final _SecTrustSetSignedCertificateTimestampsPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SecTrustRef, CFArrayRef)>>(
          'SecTrustSetSignedCertificateTimestamps');
  late final _SecTrustSetSignedCertificateTimestamps =
      _SecTrustSetSignedCertificateTimestampsPtr.asFunction<
          int Function(SecTrustRef, CFArrayRef)>();

  CFArrayRef SecTrustCopyCertificateChain(
    SecTrustRef trust,
  ) {
    return _SecTrustCopyCertificateChain(
      trust,
    );
  }

  late final _SecTrustCopyCertificateChainPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(SecTrustRef)>>(
          'SecTrustCopyCertificateChain');
  late final _SecTrustCopyCertificateChain = _SecTrustCopyCertificateChainPtr
      .asFunction<CFArrayRef Function(SecTrustRef)>();

  DartSInt32 SecTrustSetOptions(
    SecTrustRef trustRef,
    SecTrustOptionFlags options,
  ) {
    return _SecTrustSetOptions(
      trustRef,
      options.value,
    );
  }

  late final _SecTrustSetOptionsPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SecTrustRef, ffi.Uint32)>>(
          'SecTrustSetOptions');
  late final _SecTrustSetOptions =
      _SecTrustSetOptionsPtr.asFunction<int Function(SecTrustRef, int)>();

  int SecTrustSetParameters(
    SecTrustRef trustRef,
    int action,
    CFDataRef actionData,
  ) {
    return _SecTrustSetParameters(
      trustRef,
      action,
      actionData,
    );
  }

  late final _SecTrustSetParametersPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecTrustRef, CSSM_TP_ACTION,
              CFDataRef)>>('SecTrustSetParameters');
  late final _SecTrustSetParameters = _SecTrustSetParametersPtr.asFunction<
      int Function(SecTrustRef, int, CFDataRef)>();

  int SecTrustSetKeychains(
    SecTrustRef trust,
    CFTypeRef keychainOrArray,
  ) {
    return _SecTrustSetKeychains(
      trust,
      keychainOrArray,
    );
  }

  late final _SecTrustSetKeychainsPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SecTrustRef, CFTypeRef)>>(
          'SecTrustSetKeychains');
  late final _SecTrustSetKeychains = _SecTrustSetKeychainsPtr.asFunction<
      int Function(SecTrustRef, CFTypeRef)>();

  int SecTrustGetResult(
    SecTrustRef trustRef,
    ffi.Pointer<ffi.Uint32> result,
    ffi.Pointer<CFArrayRef> certChain,
    ffi.Pointer<ffi.Pointer<CSSM_TP_APPLE_EVIDENCE_INFO>> statusChain,
  ) {
    return _SecTrustGetResult(
      trustRef,
      result,
      certChain,
      statusChain,
    );
  }

  late final _SecTrustGetResultPtr = _lookup<
          ffi.NativeFunction<
              OSStatus Function(
                  SecTrustRef,
                  ffi.Pointer<ffi.Uint32>,
                  ffi.Pointer<CFArrayRef>,
                  ffi.Pointer<ffi.Pointer<CSSM_TP_APPLE_EVIDENCE_INFO>>)>>(
      'SecTrustGetResult');
  late final _SecTrustGetResult = _SecTrustGetResultPtr.asFunction<
      int Function(
          SecTrustRef,
          ffi.Pointer<ffi.Uint32>,
          ffi.Pointer<CFArrayRef>,
          ffi.Pointer<ffi.Pointer<CSSM_TP_APPLE_EVIDENCE_INFO>>)>();

  int SecTrustGetCssmResult(
    SecTrustRef trust,
    ffi.Pointer<CSSM_TP_VERIFY_CONTEXT_RESULT_PTR> result,
  ) {
    return _SecTrustGetCssmResult(
      trust,
      result,
    );
  }

  late final _SecTrustGetCssmResultPtr = _lookup<
          ffi.NativeFunction<
              OSStatus Function(SecTrustRef,
                  ffi.Pointer<CSSM_TP_VERIFY_CONTEXT_RESULT_PTR>)>>(
      'SecTrustGetCssmResult');
  late final _SecTrustGetCssmResult = _SecTrustGetCssmResultPtr.asFunction<
      int Function(
          SecTrustRef, ffi.Pointer<CSSM_TP_VERIFY_CONTEXT_RESULT_PTR>)>();

  int SecTrustGetCssmResultCode(
    SecTrustRef trust,
    ffi.Pointer<OSStatus> resultCode,
  ) {
    return _SecTrustGetCssmResultCode(
      trust,
      resultCode,
    );
  }

  late final _SecTrustGetCssmResultCodePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecTrustRef,
              ffi.Pointer<OSStatus>)>>('SecTrustGetCssmResultCode');
  late final _SecTrustGetCssmResultCode = _SecTrustGetCssmResultCodePtr
      .asFunction<int Function(SecTrustRef, ffi.Pointer<OSStatus>)>();

  int SecTrustGetTPHandle(
    SecTrustRef trust,
    ffi.Pointer<CSSM_TP_HANDLE> handle,
  ) {
    return _SecTrustGetTPHandle(
      trust,
      handle,
    );
  }

  late final _SecTrustGetTPHandlePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecTrustRef,
              ffi.Pointer<CSSM_TP_HANDLE>)>>('SecTrustGetTPHandle');
  late final _SecTrustGetTPHandle = _SecTrustGetTPHandlePtr.asFunction<
      int Function(SecTrustRef, ffi.Pointer<CSSM_TP_HANDLE>)>();

  int SecTrustCopyAnchorCertificates(
    ffi.Pointer<CFArrayRef> anchors,
  ) {
    return _SecTrustCopyAnchorCertificates(
      anchors,
    );
  }

  late final _SecTrustCopyAnchorCertificatesPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(ffi.Pointer<CFArrayRef>)>>(
          'SecTrustCopyAnchorCertificates');
  late final _SecTrustCopyAnchorCertificates =
      _SecTrustCopyAnchorCertificatesPtr.asFunction<
          int Function(ffi.Pointer<CFArrayRef>)>();

  int SecCertificateGetTypeID() {
    return _SecCertificateGetTypeID();
  }

  late final _SecCertificateGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>(
          'SecCertificateGetTypeID');
  late final _SecCertificateGetTypeID =
      _SecCertificateGetTypeIDPtr.asFunction<int Function()>();

  SecCertificateRef SecCertificateCreateWithData(
    CFAllocatorRef allocator,
    CFDataRef data,
  ) {
    return _SecCertificateCreateWithData(
      allocator,
      data,
    );
  }

  late final _SecCertificateCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          SecCertificateRef Function(
              CFAllocatorRef, CFDataRef)>>('SecCertificateCreateWithData');
  late final _SecCertificateCreateWithData = _SecCertificateCreateWithDataPtr
      .asFunction<SecCertificateRef Function(CFAllocatorRef, CFDataRef)>();

  CFDataRef SecCertificateCopyData(
    SecCertificateRef certificate,
  ) {
    return _SecCertificateCopyData(
      certificate,
    );
  }

  late final _SecCertificateCopyDataPtr =
      _lookup<ffi.NativeFunction<CFDataRef Function(SecCertificateRef)>>(
          'SecCertificateCopyData');
  late final _SecCertificateCopyData = _SecCertificateCopyDataPtr.asFunction<
      CFDataRef Function(SecCertificateRef)>();

  CFStringRef SecCertificateCopySubjectSummary(
    SecCertificateRef certificate,
  ) {
    return _SecCertificateCopySubjectSummary(
      certificate,
    );
  }

  late final _SecCertificateCopySubjectSummaryPtr =
      _lookup<ffi.NativeFunction<CFStringRef Function(SecCertificateRef)>>(
          'SecCertificateCopySubjectSummary');
  late final _SecCertificateCopySubjectSummary =
      _SecCertificateCopySubjectSummaryPtr.asFunction<
          CFStringRef Function(SecCertificateRef)>();

  int SecCertificateCopyCommonName(
    SecCertificateRef certificate,
    ffi.Pointer<CFStringRef> commonName,
  ) {
    return _SecCertificateCopyCommonName(
      certificate,
      commonName,
    );
  }

  late final _SecCertificateCopyCommonNamePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecCertificateRef,
              ffi.Pointer<CFStringRef>)>>('SecCertificateCopyCommonName');
  late final _SecCertificateCopyCommonName = _SecCertificateCopyCommonNamePtr
      .asFunction<int Function(SecCertificateRef, ffi.Pointer<CFStringRef>)>();

  int SecCertificateCopyEmailAddresses(
    SecCertificateRef certificate,
    ffi.Pointer<CFArrayRef> emailAddresses,
  ) {
    return _SecCertificateCopyEmailAddresses(
      certificate,
      emailAddresses,
    );
  }

  late final _SecCertificateCopyEmailAddressesPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecCertificateRef,
              ffi.Pointer<CFArrayRef>)>>('SecCertificateCopyEmailAddresses');
  late final _SecCertificateCopyEmailAddresses =
      _SecCertificateCopyEmailAddressesPtr.asFunction<
          int Function(SecCertificateRef, ffi.Pointer<CFArrayRef>)>();

  CFDataRef SecCertificateCopyNormalizedIssuerSequence(
    SecCertificateRef certificate,
  ) {
    return _SecCertificateCopyNormalizedIssuerSequence(
      certificate,
    );
  }

  late final _SecCertificateCopyNormalizedIssuerSequencePtr =
      _lookup<ffi.NativeFunction<CFDataRef Function(SecCertificateRef)>>(
          'SecCertificateCopyNormalizedIssuerSequence');
  late final _SecCertificateCopyNormalizedIssuerSequence =
      _SecCertificateCopyNormalizedIssuerSequencePtr.asFunction<
          CFDataRef Function(SecCertificateRef)>();

  CFDataRef SecCertificateCopyNormalizedSubjectSequence(
    SecCertificateRef certificate,
  ) {
    return _SecCertificateCopyNormalizedSubjectSequence(
      certificate,
    );
  }

  late final _SecCertificateCopyNormalizedSubjectSequencePtr =
      _lookup<ffi.NativeFunction<CFDataRef Function(SecCertificateRef)>>(
          'SecCertificateCopyNormalizedSubjectSequence');
  late final _SecCertificateCopyNormalizedSubjectSequence =
      _SecCertificateCopyNormalizedSubjectSequencePtr.asFunction<
          CFDataRef Function(SecCertificateRef)>();

  SecKeyRef SecCertificateCopyKey(
    SecCertificateRef certificate,
  ) {
    return _SecCertificateCopyKey(
      certificate,
    );
  }

  late final _SecCertificateCopyKeyPtr =
      _lookup<ffi.NativeFunction<SecKeyRef Function(SecCertificateRef)>>(
          'SecCertificateCopyKey');
  late final _SecCertificateCopyKey = _SecCertificateCopyKeyPtr.asFunction<
      SecKeyRef Function(SecCertificateRef)>();

  int SecCertificateCopyPublicKey(
    SecCertificateRef certificate,
    ffi.Pointer<SecKeyRef> key,
  ) {
    return _SecCertificateCopyPublicKey(
      certificate,
      key,
    );
  }

  late final _SecCertificateCopyPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecCertificateRef,
              ffi.Pointer<SecKeyRef>)>>('SecCertificateCopyPublicKey');
  late final _SecCertificateCopyPublicKey = _SecCertificateCopyPublicKeyPtr
      .asFunction<int Function(SecCertificateRef, ffi.Pointer<SecKeyRef>)>();

  CFDataRef SecCertificateCopySerialNumberData(
    SecCertificateRef certificate,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _SecCertificateCopySerialNumberData(
      certificate,
      error,
    );
  }

  late final _SecCertificateCopySerialNumberDataPtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(SecCertificateRef,
              ffi.Pointer<CFErrorRef>)>>('SecCertificateCopySerialNumberData');
  late final _SecCertificateCopySerialNumberData =
      _SecCertificateCopySerialNumberDataPtr.asFunction<
          CFDataRef Function(SecCertificateRef, ffi.Pointer<CFErrorRef>)>();

  CFDateRef SecCertificateCopyNotValidBeforeDate(
    SecCertificateRef certificate,
  ) {
    return _SecCertificateCopyNotValidBeforeDate(
      certificate,
    );
  }

  late final _SecCertificateCopyNotValidBeforeDatePtr =
      _lookup<ffi.NativeFunction<CFDateRef Function(SecCertificateRef)>>(
          'SecCertificateCopyNotValidBeforeDate');
  late final _SecCertificateCopyNotValidBeforeDate =
      _SecCertificateCopyNotValidBeforeDatePtr.asFunction<
          CFDateRef Function(SecCertificateRef)>();

  CFDateRef SecCertificateCopyNotValidAfterDate(
    SecCertificateRef certificate,
  ) {
    return _SecCertificateCopyNotValidAfterDate(
      certificate,
    );
  }

  late final _SecCertificateCopyNotValidAfterDatePtr =
      _lookup<ffi.NativeFunction<CFDateRef Function(SecCertificateRef)>>(
          'SecCertificateCopyNotValidAfterDate');
  late final _SecCertificateCopyNotValidAfterDate =
      _SecCertificateCopyNotValidAfterDatePtr.asFunction<
          CFDateRef Function(SecCertificateRef)>();

  CFDataRef SecCertificateCopySerialNumber(
    SecCertificateRef certificate,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _SecCertificateCopySerialNumber(
      certificate,
      error,
    );
  }

  late final _SecCertificateCopySerialNumberPtr = _lookup<
      ffi.NativeFunction<
          CFDataRef Function(SecCertificateRef,
              ffi.Pointer<CFErrorRef>)>>('SecCertificateCopySerialNumber');
  late final _SecCertificateCopySerialNumber =
      _SecCertificateCopySerialNumberPtr.asFunction<
          CFDataRef Function(SecCertificateRef, ffi.Pointer<CFErrorRef>)>();

  int SecCertificateCreateFromData(
    ffi.Pointer<SecAsn1Item> data,
    int type,
    int encoding,
    ffi.Pointer<SecCertificateRef> certificate,
  ) {
    return _SecCertificateCreateFromData(
      data,
      type,
      encoding,
      certificate,
    );
  }

  late final _SecCertificateCreateFromDataPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              ffi.Pointer<SecAsn1Item>,
              CSSM_CERT_TYPE,
              CSSM_CERT_ENCODING,
              ffi.Pointer<SecCertificateRef>)>>('SecCertificateCreateFromData');
  late final _SecCertificateCreateFromData =
      _SecCertificateCreateFromDataPtr.asFunction<
          int Function(ffi.Pointer<SecAsn1Item>, int, int,
              ffi.Pointer<SecCertificateRef>)>();

  int SecCertificateAddToKeychain(
    SecCertificateRef certificate,
    SecKeychainRef keychain,
  ) {
    return _SecCertificateAddToKeychain(
      certificate,
      keychain,
    );
  }

  late final _SecCertificateAddToKeychainPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecCertificateRef,
              SecKeychainRef)>>('SecCertificateAddToKeychain');
  late final _SecCertificateAddToKeychain = _SecCertificateAddToKeychainPtr
      .asFunction<int Function(SecCertificateRef, SecKeychainRef)>();

  int SecCertificateGetData(
    SecCertificateRef certificate,
    CSSM_DATA_PTR data,
  ) {
    return _SecCertificateGetData(
      certificate,
      data,
    );
  }

  late final _SecCertificateGetDataPtr = _lookup<
          ffi
          .NativeFunction<OSStatus Function(SecCertificateRef, CSSM_DATA_PTR)>>(
      'SecCertificateGetData');
  late final _SecCertificateGetData = _SecCertificateGetDataPtr.asFunction<
      int Function(SecCertificateRef, CSSM_DATA_PTR)>();

  int SecCertificateGetType(
    SecCertificateRef certificate,
    ffi.Pointer<CSSM_CERT_TYPE> certificateType,
  ) {
    return _SecCertificateGetType(
      certificate,
      certificateType,
    );
  }

  late final _SecCertificateGetTypePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecCertificateRef,
              ffi.Pointer<CSSM_CERT_TYPE>)>>('SecCertificateGetType');
  late final _SecCertificateGetType = _SecCertificateGetTypePtr.asFunction<
      int Function(SecCertificateRef, ffi.Pointer<CSSM_CERT_TYPE>)>();

  int SecCertificateGetSubject(
    SecCertificateRef certificate,
    ffi.Pointer<ffi.Pointer<CSSM_X509_NAME>> subject,
  ) {
    return _SecCertificateGetSubject(
      certificate,
      subject,
    );
  }

  late final _SecCertificateGetSubjectPtr = _lookup<
          ffi.NativeFunction<
              OSStatus Function(SecCertificateRef,
                  ffi.Pointer<ffi.Pointer<CSSM_X509_NAME>>)>>(
      'SecCertificateGetSubject');
  late final _SecCertificateGetSubject =
      _SecCertificateGetSubjectPtr.asFunction<
          int Function(
              SecCertificateRef, ffi.Pointer<ffi.Pointer<CSSM_X509_NAME>>)>();

  int SecCertificateGetIssuer(
    SecCertificateRef certificate,
    ffi.Pointer<ffi.Pointer<CSSM_X509_NAME>> issuer,
  ) {
    return _SecCertificateGetIssuer(
      certificate,
      issuer,
    );
  }

  late final _SecCertificateGetIssuerPtr = _lookup<
          ffi.NativeFunction<
              OSStatus Function(SecCertificateRef,
                  ffi.Pointer<ffi.Pointer<CSSM_X509_NAME>>)>>(
      'SecCertificateGetIssuer');
  late final _SecCertificateGetIssuer = _SecCertificateGetIssuerPtr.asFunction<
      int Function(
          SecCertificateRef, ffi.Pointer<ffi.Pointer<CSSM_X509_NAME>>)>();

  int SecCertificateGetCLHandle(
    SecCertificateRef certificate,
    ffi.Pointer<CSSM_CL_HANDLE> clHandle,
  ) {
    return _SecCertificateGetCLHandle(
      certificate,
      clHandle,
    );
  }

  late final _SecCertificateGetCLHandlePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecCertificateRef,
              ffi.Pointer<CSSM_CL_HANDLE>)>>('SecCertificateGetCLHandle');
  late final _SecCertificateGetCLHandle =
      _SecCertificateGetCLHandlePtr.asFunction<
          int Function(SecCertificateRef, ffi.Pointer<CSSM_CL_HANDLE>)>();

  int SecCertificateGetAlgorithmID(
    SecCertificateRef certificate,
    ffi.Pointer<ffi.Pointer<SecAsn1AlgId>> algid,
  ) {
    return _SecCertificateGetAlgorithmID(
      certificate,
      algid,
    );
  }

  late final _SecCertificateGetAlgorithmIDPtr = _lookup<
          ffi.NativeFunction<
              OSStatus Function(
                  SecCertificateRef, ffi.Pointer<ffi.Pointer<SecAsn1AlgId>>)>>(
      'SecCertificateGetAlgorithmID');
  late final _SecCertificateGetAlgorithmID =
      _SecCertificateGetAlgorithmIDPtr.asFunction<
          int Function(
              SecCertificateRef, ffi.Pointer<ffi.Pointer<SecAsn1AlgId>>)>();

  int SecCertificateCopyPreference(
    CFStringRef name,
    int keyUsage,
    ffi.Pointer<SecCertificateRef> certificate,
  ) {
    return _SecCertificateCopyPreference(
      name,
      keyUsage,
      certificate,
    );
  }

  late final _SecCertificateCopyPreferencePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(CFStringRef, uint32,
              ffi.Pointer<SecCertificateRef>)>>('SecCertificateCopyPreference');
  late final _SecCertificateCopyPreference =
      _SecCertificateCopyPreferencePtr.asFunction<
          int Function(CFStringRef, int, ffi.Pointer<SecCertificateRef>)>();

  SecCertificateRef SecCertificateCopyPreferred(
    CFStringRef name,
    CFArrayRef keyUsage,
  ) {
    return _SecCertificateCopyPreferred(
      name,
      keyUsage,
    );
  }

  late final _SecCertificateCopyPreferredPtr = _lookup<
          ffi
          .NativeFunction<SecCertificateRef Function(CFStringRef, CFArrayRef)>>(
      'SecCertificateCopyPreferred');
  late final _SecCertificateCopyPreferred = _SecCertificateCopyPreferredPtr
      .asFunction<SecCertificateRef Function(CFStringRef, CFArrayRef)>();

  int SecCertificateSetPreference(
    SecCertificateRef certificate,
    CFStringRef name,
    int keyUsage,
    CFDateRef date,
  ) {
    return _SecCertificateSetPreference(
      certificate,
      name,
      keyUsage,
      date,
    );
  }

  late final _SecCertificateSetPreferencePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecCertificateRef, CFStringRef, uint32,
              CFDateRef)>>('SecCertificateSetPreference');
  late final _SecCertificateSetPreference =
      _SecCertificateSetPreferencePtr.asFunction<
          int Function(SecCertificateRef, CFStringRef, int, CFDateRef)>();

  int SecCertificateSetPreferred(
    SecCertificateRef certificate,
    CFStringRef name,
    CFArrayRef keyUsage,
  ) {
    return _SecCertificateSetPreferred(
      certificate,
      name,
      keyUsage,
    );
  }

  late final _SecCertificateSetPreferredPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecCertificateRef, CFStringRef,
              CFArrayRef)>>('SecCertificateSetPreferred');
  late final _SecCertificateSetPreferred = _SecCertificateSetPreferredPtr
      .asFunction<int Function(SecCertificateRef, CFStringRef, CFArrayRef)>();

  late final ffi.Pointer<CFStringRef> _kSecPropertyKeyType =
      _lookup<CFStringRef>('kSecPropertyKeyType');

  CFStringRef get kSecPropertyKeyType => _kSecPropertyKeyType.value;

  set kSecPropertyKeyType(CFStringRef value) =>
      _kSecPropertyKeyType.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyKeyLabel =
      _lookup<CFStringRef>('kSecPropertyKeyLabel');

  CFStringRef get kSecPropertyKeyLabel => _kSecPropertyKeyLabel.value;

  set kSecPropertyKeyLabel(CFStringRef value) =>
      _kSecPropertyKeyLabel.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyKeyLocalizedLabel =
      _lookup<CFStringRef>('kSecPropertyKeyLocalizedLabel');

  CFStringRef get kSecPropertyKeyLocalizedLabel =>
      _kSecPropertyKeyLocalizedLabel.value;

  set kSecPropertyKeyLocalizedLabel(CFStringRef value) =>
      _kSecPropertyKeyLocalizedLabel.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyKeyValue =
      _lookup<CFStringRef>('kSecPropertyKeyValue');

  CFStringRef get kSecPropertyKeyValue => _kSecPropertyKeyValue.value;

  set kSecPropertyKeyValue(CFStringRef value) =>
      _kSecPropertyKeyValue.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeWarning =
      _lookup<CFStringRef>('kSecPropertyTypeWarning');

  CFStringRef get kSecPropertyTypeWarning => _kSecPropertyTypeWarning.value;

  set kSecPropertyTypeWarning(CFStringRef value) =>
      _kSecPropertyTypeWarning.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeSuccess =
      _lookup<CFStringRef>('kSecPropertyTypeSuccess');

  CFStringRef get kSecPropertyTypeSuccess => _kSecPropertyTypeSuccess.value;

  set kSecPropertyTypeSuccess(CFStringRef value) =>
      _kSecPropertyTypeSuccess.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeSection =
      _lookup<CFStringRef>('kSecPropertyTypeSection');

  CFStringRef get kSecPropertyTypeSection => _kSecPropertyTypeSection.value;

  set kSecPropertyTypeSection(CFStringRef value) =>
      _kSecPropertyTypeSection.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeData =
      _lookup<CFStringRef>('kSecPropertyTypeData');

  CFStringRef get kSecPropertyTypeData => _kSecPropertyTypeData.value;

  set kSecPropertyTypeData(CFStringRef value) =>
      _kSecPropertyTypeData.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeString =
      _lookup<CFStringRef>('kSecPropertyTypeString');

  CFStringRef get kSecPropertyTypeString => _kSecPropertyTypeString.value;

  set kSecPropertyTypeString(CFStringRef value) =>
      _kSecPropertyTypeString.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeURL =
      _lookup<CFStringRef>('kSecPropertyTypeURL');

  CFStringRef get kSecPropertyTypeURL => _kSecPropertyTypeURL.value;

  set kSecPropertyTypeURL(CFStringRef value) =>
      _kSecPropertyTypeURL.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeDate =
      _lookup<CFStringRef>('kSecPropertyTypeDate');

  CFStringRef get kSecPropertyTypeDate => _kSecPropertyTypeDate.value;

  set kSecPropertyTypeDate(CFStringRef value) =>
      _kSecPropertyTypeDate.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeArray =
      _lookup<CFStringRef>('kSecPropertyTypeArray');

  CFStringRef get kSecPropertyTypeArray => _kSecPropertyTypeArray.value;

  set kSecPropertyTypeArray(CFStringRef value) =>
      _kSecPropertyTypeArray.value = value;

  late final ffi.Pointer<CFStringRef> _kSecPropertyTypeNumber =
      _lookup<CFStringRef>('kSecPropertyTypeNumber');

  CFStringRef get kSecPropertyTypeNumber => _kSecPropertyTypeNumber.value;

  set kSecPropertyTypeNumber(CFStringRef value) =>
      _kSecPropertyTypeNumber.value = value;

  CFDictionaryRef SecCertificateCopyValues(
    SecCertificateRef certificate,
    CFArrayRef keys,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _SecCertificateCopyValues(
      certificate,
      keys,
      error,
    );
  }

  late final _SecCertificateCopyValuesPtr = _lookup<
      ffi.NativeFunction<
          CFDictionaryRef Function(SecCertificateRef, CFArrayRef,
              ffi.Pointer<CFErrorRef>)>>('SecCertificateCopyValues');
  late final _SecCertificateCopyValues =
      _SecCertificateCopyValuesPtr.asFunction<
          CFDictionaryRef Function(
              SecCertificateRef, CFArrayRef, ffi.Pointer<CFErrorRef>)>();

  CFStringRef SecCertificateCopyLongDescription(
    CFAllocatorRef alloc,
    SecCertificateRef certificate,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _SecCertificateCopyLongDescription(
      alloc,
      certificate,
      error,
    );
  }

  late final _SecCertificateCopyLongDescriptionPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, SecCertificateRef,
              ffi.Pointer<CFErrorRef>)>>('SecCertificateCopyLongDescription');
  late final _SecCertificateCopyLongDescription =
      _SecCertificateCopyLongDescriptionPtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, SecCertificateRef, ffi.Pointer<CFErrorRef>)>();

  CFStringRef SecCertificateCopyShortDescription(
    CFAllocatorRef alloc,
    SecCertificateRef certificate,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _SecCertificateCopyShortDescription(
      alloc,
      certificate,
      error,
    );
  }

  late final _SecCertificateCopyShortDescriptionPtr = _lookup<
      ffi.NativeFunction<
          CFStringRef Function(CFAllocatorRef, SecCertificateRef,
              ffi.Pointer<CFErrorRef>)>>('SecCertificateCopyShortDescription');
  late final _SecCertificateCopyShortDescription =
      _SecCertificateCopyShortDescriptionPtr.asFunction<
          CFStringRef Function(
              CFAllocatorRef, SecCertificateRef, ffi.Pointer<CFErrorRef>)>();

  CFDataRef SecCertificateCopyNormalizedIssuerContent(
    SecCertificateRef certificate,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _SecCertificateCopyNormalizedIssuerContent(
      certificate,
      error,
    );
  }

  late final _SecCertificateCopyNormalizedIssuerContentPtr = _lookup<
          ffi.NativeFunction<
              CFDataRef Function(SecCertificateRef, ffi.Pointer<CFErrorRef>)>>(
      'SecCertificateCopyNormalizedIssuerContent');
  late final _SecCertificateCopyNormalizedIssuerContent =
      _SecCertificateCopyNormalizedIssuerContentPtr.asFunction<
          CFDataRef Function(SecCertificateRef, ffi.Pointer<CFErrorRef>)>();

  CFDataRef SecCertificateCopyNormalizedSubjectContent(
    SecCertificateRef certificate,
    ffi.Pointer<CFErrorRef> error,
  ) {
    return _SecCertificateCopyNormalizedSubjectContent(
      certificate,
      error,
    );
  }

  late final _SecCertificateCopyNormalizedSubjectContentPtr = _lookup<
          ffi.NativeFunction<
              CFDataRef Function(SecCertificateRef, ffi.Pointer<CFErrorRef>)>>(
      'SecCertificateCopyNormalizedSubjectContent');
  late final _SecCertificateCopyNormalizedSubjectContent =
      _SecCertificateCopyNormalizedSubjectContentPtr.asFunction<
          CFDataRef Function(SecCertificateRef, ffi.Pointer<CFErrorRef>)>();

  int SecIdentityGetTypeID() {
    return _SecIdentityGetTypeID();
  }

  late final _SecIdentityGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('SecIdentityGetTypeID');
  late final _SecIdentityGetTypeID =
      _SecIdentityGetTypeIDPtr.asFunction<int Function()>();

  int SecIdentityCreateWithCertificate(
    CFTypeRef keychainOrArray,
    SecCertificateRef certificateRef,
    ffi.Pointer<SecIdentityRef> identityRef,
  ) {
    return _SecIdentityCreateWithCertificate(
      keychainOrArray,
      certificateRef,
      identityRef,
    );
  }

  late final _SecIdentityCreateWithCertificatePtr = _lookup<
          ffi.NativeFunction<
              OSStatus Function(
                  CFTypeRef, SecCertificateRef, ffi.Pointer<SecIdentityRef>)>>(
      'SecIdentityCreateWithCertificate');
  late final _SecIdentityCreateWithCertificate =
      _SecIdentityCreateWithCertificatePtr.asFunction<
          int Function(
              CFTypeRef, SecCertificateRef, ffi.Pointer<SecIdentityRef>)>();

  int SecIdentityCopyCertificate(
    SecIdentityRef identityRef,
    ffi.Pointer<SecCertificateRef> certificateRef,
  ) {
    return _SecIdentityCopyCertificate(
      identityRef,
      certificateRef,
    );
  }

  late final _SecIdentityCopyCertificatePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecIdentityRef,
              ffi.Pointer<SecCertificateRef>)>>('SecIdentityCopyCertificate');
  late final _SecIdentityCopyCertificate =
      _SecIdentityCopyCertificatePtr.asFunction<
          int Function(SecIdentityRef, ffi.Pointer<SecCertificateRef>)>();

  int SecIdentityCopyPrivateKey(
    SecIdentityRef identityRef,
    ffi.Pointer<SecKeyRef> privateKeyRef,
  ) {
    return _SecIdentityCopyPrivateKey(
      identityRef,
      privateKeyRef,
    );
  }

  late final _SecIdentityCopyPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecIdentityRef,
              ffi.Pointer<SecKeyRef>)>>('SecIdentityCopyPrivateKey');
  late final _SecIdentityCopyPrivateKey = _SecIdentityCopyPrivateKeyPtr
      .asFunction<int Function(SecIdentityRef, ffi.Pointer<SecKeyRef>)>();

  int SecIdentityCopyPreference(
    CFStringRef name,
    int keyUsage,
    CFArrayRef validIssuers,
    ffi.Pointer<SecIdentityRef> identity,
  ) {
    return _SecIdentityCopyPreference(
      name,
      keyUsage,
      validIssuers,
      identity,
    );
  }

  late final _SecIdentityCopyPreferencePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(CFStringRef, CSSM_KEYUSE, CFArrayRef,
              ffi.Pointer<SecIdentityRef>)>>('SecIdentityCopyPreference');
  late final _SecIdentityCopyPreference =
      _SecIdentityCopyPreferencePtr.asFunction<
          int Function(
              CFStringRef, int, CFArrayRef, ffi.Pointer<SecIdentityRef>)>();

  SecIdentityRef SecIdentityCopyPreferred(
    CFStringRef name,
    CFArrayRef keyUsage,
    CFArrayRef validIssuers,
  ) {
    return _SecIdentityCopyPreferred(
      name,
      keyUsage,
      validIssuers,
    );
  }

  late final _SecIdentityCopyPreferredPtr = _lookup<
      ffi.NativeFunction<
          SecIdentityRef Function(CFStringRef, CFArrayRef,
              CFArrayRef)>>('SecIdentityCopyPreferred');
  late final _SecIdentityCopyPreferred =
      _SecIdentityCopyPreferredPtr.asFunction<
          SecIdentityRef Function(CFStringRef, CFArrayRef, CFArrayRef)>();

  int SecIdentitySetPreference(
    SecIdentityRef identity,
    CFStringRef name,
    int keyUsage,
  ) {
    return _SecIdentitySetPreference(
      identity,
      name,
      keyUsage,
    );
  }

  late final _SecIdentitySetPreferencePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecIdentityRef, CFStringRef,
              CSSM_KEYUSE)>>('SecIdentitySetPreference');
  late final _SecIdentitySetPreference = _SecIdentitySetPreferencePtr
      .asFunction<int Function(SecIdentityRef, CFStringRef, int)>();

  int SecIdentitySetPreferred(
    SecIdentityRef identity,
    CFStringRef name,
    CFArrayRef keyUsage,
  ) {
    return _SecIdentitySetPreferred(
      identity,
      name,
      keyUsage,
    );
  }

  late final _SecIdentitySetPreferredPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SecIdentityRef, CFStringRef,
              CFArrayRef)>>('SecIdentitySetPreferred');
  late final _SecIdentitySetPreferred = _SecIdentitySetPreferredPtr.asFunction<
      int Function(SecIdentityRef, CFStringRef, CFArrayRef)>();

  int SecIdentityCopySystemIdentity(
    CFStringRef domain,
    ffi.Pointer<SecIdentityRef> idRef,
    ffi.Pointer<CFStringRef> actualDomain,
  ) {
    return _SecIdentityCopySystemIdentity(
      domain,
      idRef,
      actualDomain,
    );
  }

  late final _SecIdentityCopySystemIdentityPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(CFStringRef, ffi.Pointer<SecIdentityRef>,
              ffi.Pointer<CFStringRef>)>>('SecIdentityCopySystemIdentity');
  late final _SecIdentityCopySystemIdentity =
      _SecIdentityCopySystemIdentityPtr.asFunction<
          int Function(CFStringRef, ffi.Pointer<SecIdentityRef>,
              ffi.Pointer<CFStringRef>)>();

  int SecIdentitySetSystemIdentity(
    CFStringRef domain,
    SecIdentityRef idRef,
  ) {
    return _SecIdentitySetSystemIdentity(
      domain,
      idRef,
    );
  }

  late final _SecIdentitySetSystemIdentityPtr = _lookup<
          ffi.NativeFunction<OSStatus Function(CFStringRef, SecIdentityRef)>>(
      'SecIdentitySetSystemIdentity');
  late final _SecIdentitySetSystemIdentity = _SecIdentitySetSystemIdentityPtr
      .asFunction<int Function(CFStringRef, SecIdentityRef)>();

  late final ffi.Pointer<CFStringRef> _kSecIdentityDomainDefault =
      _lookup<CFStringRef>('kSecIdentityDomainDefault');

  CFStringRef get kSecIdentityDomainDefault => _kSecIdentityDomainDefault.value;

  set kSecIdentityDomainDefault(CFStringRef value) =>
      _kSecIdentityDomainDefault.value = value;

  late final ffi.Pointer<CFStringRef> _kSecIdentityDomainKerberosKDC =
      _lookup<CFStringRef>('kSecIdentityDomainKerberosKDC');

  CFStringRef get kSecIdentityDomainKerberosKDC =>
      _kSecIdentityDomainKerberosKDC.value;

  set kSecIdentityDomainKerberosKDC(CFStringRef value) =>
      _kSecIdentityDomainKerberosKDC.value = value;

  Dartsec_trust_t? sec_trust_create(
    SecTrustRef trust,
  ) {
    return _sec_trust_create(
              trust,
            ).address ==
            0
        ? null
        : objc.NSObject.castFromPointer(
            _sec_trust_create(
              trust,
            ),
            retain: false,
            release: true);
  }

  late final _sec_trust_createPtr =
      _lookup<ffi.NativeFunction<sec_trust_t Function(SecTrustRef)>>(
          'sec_trust_create');
  late final _sec_trust_create =
      _sec_trust_createPtr.asFunction<sec_trust_t Function(SecTrustRef)>();

  SecTrustRef sec_trust_copy_ref(
    Dartsec_trust_t trust,
  ) {
    return _sec_trust_copy_ref(
      trust.ref.pointer,
    );
  }

  late final _sec_trust_copy_refPtr =
      _lookup<ffi.NativeFunction<SecTrustRef Function(sec_trust_t)>>(
          'sec_trust_copy_ref');
  late final _sec_trust_copy_ref =
      _sec_trust_copy_refPtr.asFunction<SecTrustRef Function(sec_trust_t)>();

  Dartsec_identity_t? sec_identity_create(
    SecIdentityRef identity,
  ) {
    return _sec_identity_create(
              identity,
            ).address ==
            0
        ? null
        : objc.NSObject.castFromPointer(
            _sec_identity_create(
              identity,
            ),
            retain: false,
            release: true);
  }

  late final _sec_identity_createPtr =
      _lookup<ffi.NativeFunction<sec_identity_t Function(SecIdentityRef)>>(
          'sec_identity_create');
  late final _sec_identity_create = _sec_identity_createPtr
      .asFunction<sec_identity_t Function(SecIdentityRef)>();

  Dartsec_identity_t? sec_identity_create_with_certificates(
    SecIdentityRef identity,
    CFArrayRef certificates,
  ) {
    return _sec_identity_create_with_certificates(
              identity,
              certificates,
            ).address ==
            0
        ? null
        : objc.NSObject.castFromPointer(
            _sec_identity_create_with_certificates(
              identity,
              certificates,
            ),
            retain: false,
            release: true);
  }

  late final _sec_identity_create_with_certificatesPtr = _lookup<
          ffi
          .NativeFunction<sec_identity_t Function(SecIdentityRef, CFArrayRef)>>(
      'sec_identity_create_with_certificates');
  late final _sec_identity_create_with_certificates =
      _sec_identity_create_with_certificatesPtr
          .asFunction<sec_identity_t Function(SecIdentityRef, CFArrayRef)>();

  bool sec_identity_access_certificates(
    Dartsec_identity_t identity,
    objc.ObjCBlock<ffi.Void Function(objc.NSObject)> handler,
  ) {
    return _sec_identity_access_certificates(
      identity.ref.pointer,
      handler.ref.pointer,
    );
  }

  late final _sec_identity_access_certificatesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  sec_identity_t, ffi.Pointer<objc.ObjCBlockImpl>)>>(
      'sec_identity_access_certificates');
  late final _sec_identity_access_certificates =
      _sec_identity_access_certificatesPtr.asFunction<
          bool Function(sec_identity_t, ffi.Pointer<objc.ObjCBlockImpl>)>();

  SecIdentityRef sec_identity_copy_ref(
    Dartsec_identity_t identity,
  ) {
    return _sec_identity_copy_ref(
      identity.ref.pointer,
    );
  }

  late final _sec_identity_copy_refPtr =
      _lookup<ffi.NativeFunction<SecIdentityRef Function(sec_identity_t)>>(
          'sec_identity_copy_ref');
  late final _sec_identity_copy_ref = _sec_identity_copy_refPtr
      .asFunction<SecIdentityRef Function(sec_identity_t)>();

  CFArrayRef sec_identity_copy_certificates_ref(
    Dartsec_identity_t identity,
  ) {
    return _sec_identity_copy_certificates_ref(
      identity.ref.pointer,
    );
  }

  late final _sec_identity_copy_certificates_refPtr =
      _lookup<ffi.NativeFunction<CFArrayRef Function(sec_identity_t)>>(
          'sec_identity_copy_certificates_ref');
  late final _sec_identity_copy_certificates_ref =
      _sec_identity_copy_certificates_refPtr
          .asFunction<CFArrayRef Function(sec_identity_t)>();

  Dartsec_certificate_t? sec_certificate_create(
    SecCertificateRef certificate,
  ) {
    return _sec_certificate_create(
              certificate,
            ).address ==
            0
        ? null
        : objc.NSObject.castFromPointer(
            _sec_certificate_create(
              certificate,
            ),
            retain: false,
            release: true);
  }

  late final _sec_certificate_createPtr = _lookup<
          ffi.NativeFunction<sec_certificate_t Function(SecCertificateRef)>>(
      'sec_certificate_create');
  late final _sec_certificate_create = _sec_certificate_createPtr
      .asFunction<sec_certificate_t Function(SecCertificateRef)>();

  SecCertificateRef sec_certificate_copy_ref(
    Dartsec_certificate_t certificate,
  ) {
    return _sec_certificate_copy_ref(
      certificate.ref.pointer,
    );
  }

  late final _sec_certificate_copy_refPtr = _lookup<
          ffi.NativeFunction<SecCertificateRef Function(sec_certificate_t)>>(
      'sec_certificate_copy_ref');
  late final _sec_certificate_copy_ref = _sec_certificate_copy_refPtr
      .asFunction<SecCertificateRef Function(sec_certificate_t)>();

  ffi.Pointer<ffi.Char> sec_protocol_metadata_get_negotiated_protocol(
    Dartsec_protocol_metadata_t metadata,
  ) {
    return _sec_protocol_metadata_get_negotiated_protocol(
      metadata.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_get_negotiated_protocolPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(sec_protocol_metadata_t)>>(
      'sec_protocol_metadata_get_negotiated_protocol');
  late final _sec_protocol_metadata_get_negotiated_protocol =
      _sec_protocol_metadata_get_negotiated_protocolPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(sec_protocol_metadata_t)>();

  Dartdispatch_data_t? sec_protocol_metadata_copy_peer_public_key(
    Dartsec_protocol_metadata_t metadata,
  ) {
    return _sec_protocol_metadata_copy_peer_public_key(
              metadata.ref.pointer,
            ).address ==
            0
        ? null
        : objc.NSObject.castFromPointer(
            _sec_protocol_metadata_copy_peer_public_key(
              metadata.ref.pointer,
            ),
            retain: false,
            release: true);
  }

  late final _sec_protocol_metadata_copy_peer_public_keyPtr = _lookup<
          ffi
          .NativeFunction<dispatch_data_t Function(sec_protocol_metadata_t)>>(
      'sec_protocol_metadata_copy_peer_public_key');
  late final _sec_protocol_metadata_copy_peer_public_key =
      _sec_protocol_metadata_copy_peer_public_keyPtr
          .asFunction<dispatch_data_t Function(sec_protocol_metadata_t)>();

  tls_protocol_version_t
      sec_protocol_metadata_get_negotiated_tls_protocol_version(
    Dartsec_protocol_metadata_t metadata,
  ) {
    return tls_protocol_version_t
        .fromValue(_sec_protocol_metadata_get_negotiated_tls_protocol_version(
      metadata.ref.pointer,
    ));
  }

  late final _sec_protocol_metadata_get_negotiated_tls_protocol_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(sec_protocol_metadata_t)>>(
          'sec_protocol_metadata_get_negotiated_tls_protocol_version');
  late final _sec_protocol_metadata_get_negotiated_tls_protocol_version =
      _sec_protocol_metadata_get_negotiated_tls_protocol_versionPtr
          .asFunction<int Function(sec_protocol_metadata_t)>();

  SSLProtocol sec_protocol_metadata_get_negotiated_protocol_version(
    Dartsec_protocol_metadata_t metadata,
  ) {
    return SSLProtocol.fromValue(
        _sec_protocol_metadata_get_negotiated_protocol_version(
      metadata.ref.pointer,
    ));
  }

  late final _sec_protocol_metadata_get_negotiated_protocol_versionPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.UnsignedInt Function(sec_protocol_metadata_t)>>(
          'sec_protocol_metadata_get_negotiated_protocol_version');
  late final _sec_protocol_metadata_get_negotiated_protocol_version =
      _sec_protocol_metadata_get_negotiated_protocol_versionPtr
          .asFunction<int Function(sec_protocol_metadata_t)>();

  tls_ciphersuite_t sec_protocol_metadata_get_negotiated_tls_ciphersuite(
    Dartsec_protocol_metadata_t metadata,
  ) {
    return tls_ciphersuite_t
        .fromValue(_sec_protocol_metadata_get_negotiated_tls_ciphersuite(
      metadata.ref.pointer,
    ));
  }

  late final _sec_protocol_metadata_get_negotiated_tls_ciphersuitePtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function(sec_protocol_metadata_t)>>(
          'sec_protocol_metadata_get_negotiated_tls_ciphersuite');
  late final _sec_protocol_metadata_get_negotiated_tls_ciphersuite =
      _sec_protocol_metadata_get_negotiated_tls_ciphersuitePtr
          .asFunction<int Function(sec_protocol_metadata_t)>();

  DartSSLCipherSuite sec_protocol_metadata_get_negotiated_ciphersuite(
    Dartsec_protocol_metadata_t metadata,
  ) {
    return _sec_protocol_metadata_get_negotiated_ciphersuite(
      metadata.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_get_negotiated_ciphersuitePtr = _lookup<
          ffi.NativeFunction<SSLCipherSuite Function(sec_protocol_metadata_t)>>(
      'sec_protocol_metadata_get_negotiated_ciphersuite');
  late final _sec_protocol_metadata_get_negotiated_ciphersuite =
      _sec_protocol_metadata_get_negotiated_ciphersuitePtr
          .asFunction<int Function(sec_protocol_metadata_t)>();

  bool sec_protocol_metadata_get_early_data_accepted(
    Dartsec_protocol_metadata_t metadata,
  ) {
    return _sec_protocol_metadata_get_early_data_accepted(
      metadata.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_get_early_data_acceptedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(sec_protocol_metadata_t)>>(
          'sec_protocol_metadata_get_early_data_accepted');
  late final _sec_protocol_metadata_get_early_data_accepted =
      _sec_protocol_metadata_get_early_data_acceptedPtr
          .asFunction<bool Function(sec_protocol_metadata_t)>();

  bool sec_protocol_metadata_access_peer_certificate_chain(
    Dartsec_protocol_metadata_t metadata,
    objc.ObjCBlock<ffi.Void Function(objc.NSObject)> handler,
  ) {
    return _sec_protocol_metadata_access_peer_certificate_chain(
      metadata.ref.pointer,
      handler.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_access_peer_certificate_chainPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  sec_protocol_metadata_t, ffi.Pointer<objc.ObjCBlockImpl>)>>(
      'sec_protocol_metadata_access_peer_certificate_chain');
  late final _sec_protocol_metadata_access_peer_certificate_chain =
      _sec_protocol_metadata_access_peer_certificate_chainPtr.asFunction<
          bool Function(
              sec_protocol_metadata_t, ffi.Pointer<objc.ObjCBlockImpl>)>();

  bool sec_protocol_metadata_access_ocsp_response(
    Dartsec_protocol_metadata_t metadata,
    objc.ObjCBlock<ffi.Void Function(objc.NSObject)> handler,
  ) {
    return _sec_protocol_metadata_access_ocsp_response(
      metadata.ref.pointer,
      handler.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_access_ocsp_responsePtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  sec_protocol_metadata_t, ffi.Pointer<objc.ObjCBlockImpl>)>>(
      'sec_protocol_metadata_access_ocsp_response');
  late final _sec_protocol_metadata_access_ocsp_response =
      _sec_protocol_metadata_access_ocsp_responsePtr.asFunction<
          bool Function(
              sec_protocol_metadata_t, ffi.Pointer<objc.ObjCBlockImpl>)>();

  bool sec_protocol_metadata_access_supported_signature_algorithms(
    Dartsec_protocol_metadata_t metadata,
    objc.ObjCBlock<ffi.Void Function(ffi.Uint16)> handler,
  ) {
    return _sec_protocol_metadata_access_supported_signature_algorithms(
      metadata.ref.pointer,
      handler.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_access_supported_signature_algorithmsPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Bool Function(sec_protocol_metadata_t,
                      ffi.Pointer<objc.ObjCBlockImpl>)>>(
          'sec_protocol_metadata_access_supported_signature_algorithms');
  late final _sec_protocol_metadata_access_supported_signature_algorithms =
      _sec_protocol_metadata_access_supported_signature_algorithmsPtr
          .asFunction<
              bool Function(
                  sec_protocol_metadata_t, ffi.Pointer<objc.ObjCBlockImpl>)>();

  bool sec_protocol_metadata_access_distinguished_names(
    Dartsec_protocol_metadata_t metadata,
    objc.ObjCBlock<ffi.Void Function(objc.NSObject)> handler,
  ) {
    return _sec_protocol_metadata_access_distinguished_names(
      metadata.ref.pointer,
      handler.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_access_distinguished_namesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  sec_protocol_metadata_t, ffi.Pointer<objc.ObjCBlockImpl>)>>(
      'sec_protocol_metadata_access_distinguished_names');
  late final _sec_protocol_metadata_access_distinguished_names =
      _sec_protocol_metadata_access_distinguished_namesPtr.asFunction<
          bool Function(
              sec_protocol_metadata_t, ffi.Pointer<objc.ObjCBlockImpl>)>();

  bool sec_protocol_metadata_access_pre_shared_keys(
    Dartsec_protocol_metadata_t metadata,
    objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)> handler,
  ) {
    return _sec_protocol_metadata_access_pre_shared_keys(
      metadata.ref.pointer,
      handler.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_access_pre_shared_keysPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  sec_protocol_metadata_t, ffi.Pointer<objc.ObjCBlockImpl>)>>(
      'sec_protocol_metadata_access_pre_shared_keys');
  late final _sec_protocol_metadata_access_pre_shared_keys =
      _sec_protocol_metadata_access_pre_shared_keysPtr.asFunction<
          bool Function(
              sec_protocol_metadata_t, ffi.Pointer<objc.ObjCBlockImpl>)>();

  ffi.Pointer<ffi.Char> sec_protocol_metadata_get_server_name(
    Dartsec_protocol_metadata_t metadata,
  ) {
    return _sec_protocol_metadata_get_server_name(
      metadata.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_get_server_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(sec_protocol_metadata_t)>>(
      'sec_protocol_metadata_get_server_name');
  late final _sec_protocol_metadata_get_server_name =
      _sec_protocol_metadata_get_server_namePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(sec_protocol_metadata_t)>();

  bool sec_protocol_metadata_peers_are_equal(
    Dartsec_protocol_metadata_t metadataA,
    Dartsec_protocol_metadata_t metadataB,
  ) {
    return _sec_protocol_metadata_peers_are_equal(
      metadataA.ref.pointer,
      metadataB.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_peers_are_equalPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  sec_protocol_metadata_t, sec_protocol_metadata_t)>>(
      'sec_protocol_metadata_peers_are_equal');
  late final _sec_protocol_metadata_peers_are_equal =
      _sec_protocol_metadata_peers_are_equalPtr.asFunction<
          bool Function(sec_protocol_metadata_t, sec_protocol_metadata_t)>();

  bool sec_protocol_metadata_challenge_parameters_are_equal(
    Dartsec_protocol_metadata_t metadataA,
    Dartsec_protocol_metadata_t metadataB,
  ) {
    return _sec_protocol_metadata_challenge_parameters_are_equal(
      metadataA.ref.pointer,
      metadataB.ref.pointer,
    );
  }

  late final _sec_protocol_metadata_challenge_parameters_are_equalPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(
                  sec_protocol_metadata_t, sec_protocol_metadata_t)>>(
      'sec_protocol_metadata_challenge_parameters_are_equal');
  late final _sec_protocol_metadata_challenge_parameters_are_equal =
      _sec_protocol_metadata_challenge_parameters_are_equalPtr.asFunction<
          bool Function(sec_protocol_metadata_t, sec_protocol_metadata_t)>();

  Dartdispatch_data_t? sec_protocol_metadata_create_secret(
    Dartsec_protocol_metadata_t metadata,
    int label_len,
    ffi.Pointer<ffi.Char> label,
    int exporter_length,
  ) {
    return _sec_protocol_metadata_create_secret(
              metadata.ref.pointer,
              label_len,
              label,
              exporter_length,
            ).address ==
            0
        ? null
        : objc.NSObject.castFromPointer(
            _sec_protocol_metadata_create_secret(
              metadata.ref.pointer,
              label_len,
              label,
              exporter_length,
            ),
            retain: false,
            release: true);
  }

  late final _sec_protocol_metadata_create_secretPtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(
              sec_protocol_metadata_t,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('sec_protocol_metadata_create_secret');
  late final _sec_protocol_metadata_create_secret =
      _sec_protocol_metadata_create_secretPtr.asFunction<
          dispatch_data_t Function(
              sec_protocol_metadata_t, int, ffi.Pointer<ffi.Char>, int)>();

  Dartdispatch_data_t? sec_protocol_metadata_create_secret_with_context(
    Dartsec_protocol_metadata_t metadata,
    int label_len,
    ffi.Pointer<ffi.Char> label,
    int context_len,
    ffi.Pointer<ffi.Uint8> context,
    int exporter_length,
  ) {
    return _sec_protocol_metadata_create_secret_with_context(
              metadata.ref.pointer,
              label_len,
              label,
              context_len,
              context,
              exporter_length,
            ).address ==
            0
        ? null
        : objc.NSObject.castFromPointer(
            _sec_protocol_metadata_create_secret_with_context(
              metadata.ref.pointer,
              label_len,
              label,
              context_len,
              context,
              exporter_length,
            ),
            retain: false,
            release: true);
  }

  late final _sec_protocol_metadata_create_secret_with_contextPtr = _lookup<
      ffi.NativeFunction<
          dispatch_data_t Function(
              sec_protocol_metadata_t,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('sec_protocol_metadata_create_secret_with_context');
  late final _sec_protocol_metadata_create_secret_with_context =
      _sec_protocol_metadata_create_secret_with_contextPtr.asFunction<
          dispatch_data_t Function(sec_protocol_metadata_t, int,
              ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Uint8>, int)>();

  bool sec_protocol_options_are_equal(
    Dartsec_protocol_options_t optionsA,
    Dartsec_protocol_options_t optionsB,
  ) {
    return _sec_protocol_options_are_equal(
      optionsA.ref.pointer,
      optionsB.ref.pointer,
    );
  }

  late final _sec_protocol_options_are_equalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(sec_protocol_options_t,
              sec_protocol_options_t)>>('sec_protocol_options_are_equal');
  late final _sec_protocol_options_are_equal =
      _sec_protocol_options_are_equalPtr.asFunction<
          bool Function(sec_protocol_options_t, sec_protocol_options_t)>();

  void sec_protocol_options_set_local_identity(
    Dartsec_protocol_options_t options,
    Dartsec_identity_t identity,
  ) {
    return _sec_protocol_options_set_local_identity(
      options.ref.pointer,
      identity.ref.pointer,
    );
  }

  late final _sec_protocol_options_set_local_identityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(sec_protocol_options_t,
              sec_identity_t)>>('sec_protocol_options_set_local_identity');
  late final _sec_protocol_options_set_local_identity =
      _sec_protocol_options_set_local_identityPtr
          .asFunction<void Function(sec_protocol_options_t, sec_identity_t)>();

  void sec_protocol_options_append_tls_ciphersuite(
    Dartsec_protocol_options_t options,
    tls_ciphersuite_t ciphersuite,
  ) {
    return _sec_protocol_options_append_tls_ciphersuite(
      options.ref.pointer,
      ciphersuite.value,
    );
  }

  late final _sec_protocol_options_append_tls_ciphersuitePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(sec_protocol_options_t,
              ffi.Uint16)>>('sec_protocol_options_append_tls_ciphersuite');
  late final _sec_protocol_options_append_tls_ciphersuite =
      _sec_protocol_options_append_tls_ciphersuitePtr
          .asFunction<void Function(sec_protocol_options_t, int)>();

  void sec_protocol_options_add_tls_ciphersuite(
    Dartsec_protocol_options_t options,
    DartSSLCipherSuite ciphersuite,
  ) {
    return _sec_protocol_options_add_tls_ciphersuite(
      options.ref.pointer,
      ciphersuite,
    );
  }

  late final _sec_protocol_options_add_tls_ciphersuitePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(sec_protocol_options_t,
              SSLCipherSuite)>>('sec_protocol_options_add_tls_ciphersuite');
  late final _sec_protocol_options_add_tls_ciphersuite =
      _sec_protocol_options_add_tls_ciphersuitePtr
          .asFunction<void Function(sec_protocol_options_t, int)>();

  void sec_protocol_options_append_tls_ciphersuite_group(
    Dartsec_protocol_options_t options,
    tls_ciphersuite_group_t group,
  ) {
    return _sec_protocol_options_append_tls_ciphersuite_group(
      options.ref.pointer,
      group.value,
    );
  }

  late final _sec_protocol_options_append_tls_ciphersuite_groupPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(sec_protocol_options_t, ffi.Uint16)>>(
      'sec_protocol_options_append_tls_ciphersuite_group');
  late final _sec_protocol_options_append_tls_ciphersuite_group =
      _sec_protocol_options_append_tls_ciphersuite_groupPtr
          .asFunction<void Function(sec_protocol_options_t, int)>();

  void sec_protocol_options_add_tls_ciphersuite_group(
    Dartsec_protocol_options_t options,
    SSLCiphersuiteGroup group,
  ) {
    return _sec_protocol_options_add_tls_ciphersuite_group(
      options.ref.pointer,
      group.value,
    );
  }

  late final _sec_protocol_options_add_tls_ciphersuite_groupPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(sec_protocol_options_t, ffi.UnsignedInt)>>(
      'sec_protocol_options_add_tls_ciphersuite_group');
  late final _sec_protocol_options_add_tls_ciphersuite_group =
      _sec_protocol_options_add_tls_ciphersuite_groupPtr
          .asFunction<void Function(sec_protocol_options_t, int)>();

  void sec_protocol_options_set_tls_min_version(
    Dartsec_protocol_options_t options,
    SSLProtocol version,
  ) {
    return _sec_protocol_options_set_tls_min_version(
      options.ref.pointer,
      version.value,
    );
  }

  late final _sec_protocol_options_set_tls_min_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(sec_protocol_options_t,
              ffi.UnsignedInt)>>('sec_protocol_options_set_tls_min_version');
  late final _sec_protocol_options_set_tls_min_version =
      _sec_protocol_options_set_tls_min_versionPtr
          .asFunction<void Function(sec_protocol_options_t, int)>();

  void sec_protocol_options_set_min_tls_protocol_version(
    Dartsec_protocol_options_t options,
    tls_protocol_version_t version,
  ) {
    return _sec_protocol_options_set_min_tls_protocol_version(
      options.ref.pointer,
      version.value,
    );
  }

  late final _sec_protocol_options_set_min_tls_protocol_versionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(sec_protocol_options_t, ffi.Uint16)>>(
      'sec_protocol_options_set_min_tls_protocol_version');
  late final _sec_protocol_options_set_min_tls_protocol_version =
      _sec_protocol_options_set_min_tls_protocol_versionPtr
          .asFunction<void Function(sec_protocol_options_t, int)>();

  tls_protocol_version_t
      sec_protocol_options_get_default_min_tls_protocol_version() {
    return tls_protocol_version_t.fromValue(
        _sec_protocol_options_get_default_min_tls_protocol_version());
  }

  late final _sec_protocol_options_get_default_min_tls_protocol_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function()>>(
          'sec_protocol_options_get_default_min_tls_protocol_version');
  late final _sec_protocol_options_get_default_min_tls_protocol_version =
      _sec_protocol_options_get_default_min_tls_protocol_versionPtr
          .asFunction<int Function()>();

  tls_protocol_version_t
      sec_protocol_options_get_default_min_dtls_protocol_version() {
    return tls_protocol_version_t.fromValue(
        _sec_protocol_options_get_default_min_dtls_protocol_version());
  }

  late final _sec_protocol_options_get_default_min_dtls_protocol_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function()>>(
          'sec_protocol_options_get_default_min_dtls_protocol_version');
  late final _sec_protocol_options_get_default_min_dtls_protocol_version =
      _sec_protocol_options_get_default_min_dtls_protocol_versionPtr
          .asFunction<int Function()>();

  void sec_protocol_options_set_tls_max_version(
    Dartsec_protocol_options_t options,
    SSLProtocol version,
  ) {
    return _sec_protocol_options_set_tls_max_version(
      options.ref.pointer,
      version.value,
    );
  }

  late final _sec_protocol_options_set_tls_max_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(sec_protocol_options_t,
              ffi.UnsignedInt)>>('sec_protocol_options_set_tls_max_version');
  late final _sec_protocol_options_set_tls_max_version =
      _sec_protocol_options_set_tls_max_versionPtr
          .asFunction<void Function(sec_protocol_options_t, int)>();

  void sec_protocol_options_set_max_tls_protocol_version(
    Dartsec_protocol_options_t options,
    tls_protocol_version_t version,
  ) {
    return _sec_protocol_options_set_max_tls_protocol_version(
      options.ref.pointer,
      version.value,
    );
  }

  late final _sec_protocol_options_set_max_tls_protocol_versionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(sec_protocol_options_t, ffi.Uint16)>>(
      'sec_protocol_options_set_max_tls_protocol_version');
  late final _sec_protocol_options_set_max_tls_protocol_version =
      _sec_protocol_options_set_max_tls_protocol_versionPtr
          .asFunction<void Function(sec_protocol_options_t, int)>();

  tls_protocol_version_t
      sec_protocol_options_get_default_max_tls_protocol_version() {
    return tls_protocol_version_t.fromValue(
        _sec_protocol_options_get_default_max_tls_protocol_version());
  }

  late final _sec_protocol_options_get_default_max_tls_protocol_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function()>>(
          'sec_protocol_options_get_default_max_tls_protocol_version');
  late final _sec_protocol_options_get_default_max_tls_protocol_version =
      _sec_protocol_options_get_default_max_tls_protocol_versionPtr
          .asFunction<int Function()>();

  tls_protocol_version_t
      sec_protocol_options_get_default_max_dtls_protocol_version() {
    return tls_protocol_version_t.fromValue(
        _sec_protocol_options_get_default_max_dtls_protocol_version());
  }

  late final _sec_protocol_options_get_default_max_dtls_protocol_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Uint16 Function()>>(
          'sec_protocol_options_get_default_max_dtls_protocol_version');
  late final _sec_protocol_options_get_default_max_dtls_protocol_version =
      _sec_protocol_options_get_default_max_dtls_protocol_versionPtr
          .asFunction<int Function()>();

  bool sec_protocol_options_get_enable_encrypted_client_hello(
    Dartsec_protocol_options_t options,
  ) {
    return _sec_protocol_options_get_enable_encrypted_client_hello(
      options.ref.pointer,
    );
  }

  late final _sec_protocol_options_get_enable_encrypted_client_helloPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(sec_protocol_options_t)>>(
          'sec_protocol_options_get_enable_encrypted_client_hello');
  late final _sec_protocol_options_get_enable_encrypted_client_hello =
      _sec_protocol_options_get_enable_encrypted_client_helloPtr
          .asFunction<bool Function(sec_protocol_options_t)>();

  bool sec_protocol_options_get_quic_use_legacy_codepoint(
    Dartsec_protocol_options_t options,
  ) {
    return _sec_protocol_options_get_quic_use_legacy_codepoint(
      options.ref.pointer,
    );
  }

  late final _sec_protocol_options_get_quic_use_legacy_codepointPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(sec_protocol_options_t)>>(
          'sec_protocol_options_get_quic_use_legacy_codepoint');
  late final _sec_protocol_options_get_quic_use_legacy_codepoint =
      _sec_protocol_options_get_quic_use_legacy_codepointPtr
          .asFunction<bool Function(sec_protocol_options_t)>();

  void sec_protocol_options_add_tls_application_protocol(
    Dartsec_protocol_options_t options,
    ffi.Pointer<ffi.Char> application_protocol,
  ) {
    return _sec_protocol_options_add_tls_application_protocol(
      options.ref.pointer,
      application_protocol,
    );
  }

  late final _sec_protocol_options_add_tls_application_protocolPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  sec_protocol_options_t, ffi.Pointer<ffi.Char>)>>(
      'sec_protocol_options_add_tls_application_protocol');
  late final _sec_protocol_options_add_tls_application_protocol =
      _sec_protocol_options_add_tls_application_protocolPtr.asFunction<
          void Function(sec_protocol_options_t, ffi.Pointer<ffi.Char>)>();

  void sec_protocol_options_set_tls_server_name(
    Dartsec_protocol_options_t options,
    ffi.Pointer<ffi.Char> server_name,
  ) {
    return _sec_protocol_options_set_tls_server_name(
      options.ref.pointer,
      server_name,
    );
  }

  late final _sec_protocol_options_set_tls_server_namePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  sec_protocol_options_t, ffi.Pointer<ffi.Char>)>>(
      'sec_protocol_options_set_tls_server_name');
  late final _sec_protocol_options_set_tls_server_name =
      _sec_protocol_options_set_tls_server_namePtr.asFunction<
          void Function(sec_protocol_options_t, ffi.Pointer<ffi.Char>)>();

  void sec_protocol_options_set_tls_diffie_hellman_parameters(
    Dartsec_protocol_options_t options,
    Dartdispatch_data_t params,
  ) {
    return _sec_protocol_options_set_tls_diffie_hellman_parameters(
      options.ref.pointer,
      params.ref.pointer,
    );
  }

  late final _sec_protocol_options_set_tls_diffie_hellman_parametersPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(sec_protocol_options_t, dispatch_data_t)>>(
          'sec_protocol_options_set_tls_diffie_hellman_parameters');
  late final _sec_protocol_options_set_tls_diffie_hellman_parameters =
      _sec_protocol_options_set_tls_diffie_hellman_parametersPtr
          .asFunction<void Function(sec_protocol_options_t, dispatch_data_t)>();

  void sec_protocol_options_add_pre_shared_key(
    Dartsec_protocol_options_t options,
    Dartdispatch_data_t psk,
    Dartdispatch_data_t psk_identity,
  ) {
    return _sec_protocol_options_add_pre_shared_key(
      options.ref.pointer,
      psk.ref.pointer,
      psk_identity.ref.pointer,
    );
  }

  late final _sec_protocol_options_add_pre_shared_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(sec_protocol_options_t, dispatch_data_t,
              dispatch_data_t)>>('sec_protocol_options_add_pre_shared_key');
  late final _sec_protocol_options_add_pre_shared_key =
      _sec_protocol_options_add_pre_shared_keyPtr.asFunction<
          void Function(
              sec_protocol_options_t, dispatch_data_t, dispatch_data_t)>();

  void sec_protocol_options_set_tls_pre_shared_key_identity_hint(
    Dartsec_protocol_options_t options,
    Dartdispatch_data_t psk_identity_hint,
  ) {
    return _sec_protocol_options_set_tls_pre_shared_key_identity_hint(
      options.ref.pointer,
      psk_identity_hint.ref.pointer,
    );
  }

  late final _sec_protocol_options_set_tls_pre_shared_key_identity_hintPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(sec_protocol_options_t, dispatch_data_t)>>(
          'sec_protocol_options_set_tls_pre_shared_key_identity_hint');
  late final _sec_protocol_options_set_tls_pre_shared_key_identity_hint =
      _sec_protocol_options_set_tls_pre_shared_key_identity_hintPtr
          .asFunction<void Function(sec_protocol_options_t, dispatch_data_t)>();

  void sec_protocol_options_set_pre_shared_key_selection_block(
    Dartsec_protocol_options_t options,
    Dartsec_protocol_pre_shared_key_selection_t psk_selection_block,
    Dartdispatch_queue_t psk_selection_queue,
  ) {
    return _sec_protocol_options_set_pre_shared_key_selection_block(
      options.ref.pointer,
      psk_selection_block.ref.pointer,
      psk_selection_queue.ref.pointer,
    );
  }

  late final _sec_protocol_options_set_pre_shared_key_selection_blockPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(
                      sec_protocol_options_t,
                      sec_protocol_pre_shared_key_selection_t,
                      dispatch_queue_t)>>(
          'sec_protocol_options_set_pre_shared_key_selection_block');
  late final _sec_protocol_options_set_pre_shared_key_selection_block =
      _sec_protocol_options_set_pre_shared_key_selection_blockPtr.asFunction<
          void Function(sec_protocol_options_t,
              sec_protocol_pre_shared_key_selection_t, dispatch_queue_t)>();

  void sec_protocol_options_set_tls_tickets_enabled(
    Dartsec_protocol_options_t options,
    bool tickets_enabled,
  ) {
    return _sec_protocol_options_set_tls_tickets_enabled(
      options.ref.pointer,
      tickets_enabled,
    );
  }

  late final _sec_protocol_options_set_tls_tickets_enabledPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
      'sec_protocol_options_set_tls_tickets_enabled');
  late final _sec_protocol_options_set_tls_tickets_enabled =
      _sec_protocol_options_set_tls_tickets_enabledPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_tls_is_fallback_attempt(
    Dartsec_protocol_options_t options,
    bool is_fallback_attempt,
  ) {
    return _sec_protocol_options_set_tls_is_fallback_attempt(
      options.ref.pointer,
      is_fallback_attempt,
    );
  }

  late final _sec_protocol_options_set_tls_is_fallback_attemptPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
      'sec_protocol_options_set_tls_is_fallback_attempt');
  late final _sec_protocol_options_set_tls_is_fallback_attempt =
      _sec_protocol_options_set_tls_is_fallback_attemptPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_tls_resumption_enabled(
    Dartsec_protocol_options_t options,
    bool resumption_enabled,
  ) {
    return _sec_protocol_options_set_tls_resumption_enabled(
      options.ref.pointer,
      resumption_enabled,
    );
  }

  late final _sec_protocol_options_set_tls_resumption_enabledPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
      'sec_protocol_options_set_tls_resumption_enabled');
  late final _sec_protocol_options_set_tls_resumption_enabled =
      _sec_protocol_options_set_tls_resumption_enabledPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_tls_false_start_enabled(
    Dartsec_protocol_options_t options,
    bool false_start_enabled,
  ) {
    return _sec_protocol_options_set_tls_false_start_enabled(
      options.ref.pointer,
      false_start_enabled,
    );
  }

  late final _sec_protocol_options_set_tls_false_start_enabledPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
      'sec_protocol_options_set_tls_false_start_enabled');
  late final _sec_protocol_options_set_tls_false_start_enabled =
      _sec_protocol_options_set_tls_false_start_enabledPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_tls_ocsp_enabled(
    Dartsec_protocol_options_t options,
    bool ocsp_enabled,
  ) {
    return _sec_protocol_options_set_tls_ocsp_enabled(
      options.ref.pointer,
      ocsp_enabled,
    );
  }

  late final _sec_protocol_options_set_tls_ocsp_enabledPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
      'sec_protocol_options_set_tls_ocsp_enabled');
  late final _sec_protocol_options_set_tls_ocsp_enabled =
      _sec_protocol_options_set_tls_ocsp_enabledPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_tls_sct_enabled(
    Dartsec_protocol_options_t options,
    bool sct_enabled,
  ) {
    return _sec_protocol_options_set_tls_sct_enabled(
      options.ref.pointer,
      sct_enabled,
    );
  }

  late final _sec_protocol_options_set_tls_sct_enabledPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
      'sec_protocol_options_set_tls_sct_enabled');
  late final _sec_protocol_options_set_tls_sct_enabled =
      _sec_protocol_options_set_tls_sct_enabledPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_tls_renegotiation_enabled(
    Dartsec_protocol_options_t options,
    bool renegotiation_enabled,
  ) {
    return _sec_protocol_options_set_tls_renegotiation_enabled(
      options.ref.pointer,
      renegotiation_enabled,
    );
  }

  late final _sec_protocol_options_set_tls_renegotiation_enabledPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
      'sec_protocol_options_set_tls_renegotiation_enabled');
  late final _sec_protocol_options_set_tls_renegotiation_enabled =
      _sec_protocol_options_set_tls_renegotiation_enabledPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_peer_authentication_required(
    Dartsec_protocol_options_t options,
    bool peer_authentication_required,
  ) {
    return _sec_protocol_options_set_peer_authentication_required(
      options.ref.pointer,
      peer_authentication_required,
    );
  }

  late final _sec_protocol_options_set_peer_authentication_requiredPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
          'sec_protocol_options_set_peer_authentication_required');
  late final _sec_protocol_options_set_peer_authentication_required =
      _sec_protocol_options_set_peer_authentication_requiredPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_peer_authentication_optional(
    Dartsec_protocol_options_t options,
    bool peer_authentication_optional,
  ) {
    return _sec_protocol_options_set_peer_authentication_optional(
      options.ref.pointer,
      peer_authentication_optional,
    );
  }

  late final _sec_protocol_options_set_peer_authentication_optionalPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
          'sec_protocol_options_set_peer_authentication_optional');
  late final _sec_protocol_options_set_peer_authentication_optional =
      _sec_protocol_options_set_peer_authentication_optionalPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_enable_encrypted_client_hello(
    Dartsec_protocol_options_t options,
    bool enable_encrypted_client_hello,
  ) {
    return _sec_protocol_options_set_enable_encrypted_client_hello(
      options.ref.pointer,
      enable_encrypted_client_hello,
    );
  }

  late final _sec_protocol_options_set_enable_encrypted_client_helloPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
          'sec_protocol_options_set_enable_encrypted_client_hello');
  late final _sec_protocol_options_set_enable_encrypted_client_hello =
      _sec_protocol_options_set_enable_encrypted_client_helloPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_quic_use_legacy_codepoint(
    Dartsec_protocol_options_t options,
    bool quic_use_legacy_codepoint,
  ) {
    return _sec_protocol_options_set_quic_use_legacy_codepoint(
      options.ref.pointer,
      quic_use_legacy_codepoint,
    );
  }

  late final _sec_protocol_options_set_quic_use_legacy_codepointPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(sec_protocol_options_t, ffi.Bool)>>(
      'sec_protocol_options_set_quic_use_legacy_codepoint');
  late final _sec_protocol_options_set_quic_use_legacy_codepoint =
      _sec_protocol_options_set_quic_use_legacy_codepointPtr
          .asFunction<void Function(sec_protocol_options_t, bool)>();

  void sec_protocol_options_set_key_update_block(
    Dartsec_protocol_options_t options,
    Dartsec_protocol_key_update_t key_update_block,
    Dartdispatch_queue_t key_update_queue,
  ) {
    return _sec_protocol_options_set_key_update_block(
      options.ref.pointer,
      key_update_block.ref.pointer,
      key_update_queue.ref.pointer,
    );
  }

  late final _sec_protocol_options_set_key_update_blockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(sec_protocol_options_t, sec_protocol_key_update_t,
              dispatch_queue_t)>>('sec_protocol_options_set_key_update_block');
  late final _sec_protocol_options_set_key_update_block =
      _sec_protocol_options_set_key_update_blockPtr.asFunction<
          void Function(sec_protocol_options_t, sec_protocol_key_update_t,
              dispatch_queue_t)>();

  void sec_protocol_options_set_challenge_block(
    Dartsec_protocol_options_t options,
    Dartsec_protocol_challenge_t challenge_block,
    Dartdispatch_queue_t challenge_queue,
  ) {
    return _sec_protocol_options_set_challenge_block(
      options.ref.pointer,
      challenge_block.ref.pointer,
      challenge_queue.ref.pointer,
    );
  }

  late final _sec_protocol_options_set_challenge_blockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(sec_protocol_options_t, sec_protocol_challenge_t,
              dispatch_queue_t)>>('sec_protocol_options_set_challenge_block');
  late final _sec_protocol_options_set_challenge_block =
      _sec_protocol_options_set_challenge_blockPtr.asFunction<
          void Function(sec_protocol_options_t, sec_protocol_challenge_t,
              dispatch_queue_t)>();

  void sec_protocol_options_set_verify_block(
    Dartsec_protocol_options_t options,
    Dartsec_protocol_verify_t verify_block,
    Dartdispatch_queue_t verify_block_queue,
  ) {
    return _sec_protocol_options_set_verify_block(
      options.ref.pointer,
      verify_block.ref.pointer,
      verify_block_queue.ref.pointer,
    );
  }

  late final _sec_protocol_options_set_verify_blockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(sec_protocol_options_t, sec_protocol_verify_t,
              dispatch_queue_t)>>('sec_protocol_options_set_verify_block');
  late final _sec_protocol_options_set_verify_block =
      _sec_protocol_options_set_verify_blockPtr.asFunction<
          void Function(sec_protocol_options_t, sec_protocol_verify_t,
              dispatch_queue_t)>();

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_default =
      _lookup<CFStringRef>('kSSLSessionConfig_default');

  CFStringRef get kSSLSessionConfig_default => _kSSLSessionConfig_default.value;

  set kSSLSessionConfig_default(CFStringRef value) =>
      _kSSLSessionConfig_default.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_ATSv1 =
      _lookup<CFStringRef>('kSSLSessionConfig_ATSv1');

  CFStringRef get kSSLSessionConfig_ATSv1 => _kSSLSessionConfig_ATSv1.value;

  set kSSLSessionConfig_ATSv1(CFStringRef value) =>
      _kSSLSessionConfig_ATSv1.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_ATSv1_noPFS =
      _lookup<CFStringRef>('kSSLSessionConfig_ATSv1_noPFS');

  CFStringRef get kSSLSessionConfig_ATSv1_noPFS =>
      _kSSLSessionConfig_ATSv1_noPFS.value;

  set kSSLSessionConfig_ATSv1_noPFS(CFStringRef value) =>
      _kSSLSessionConfig_ATSv1_noPFS.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_standard =
      _lookup<CFStringRef>('kSSLSessionConfig_standard');

  CFStringRef get kSSLSessionConfig_standard =>
      _kSSLSessionConfig_standard.value;

  set kSSLSessionConfig_standard(CFStringRef value) =>
      _kSSLSessionConfig_standard.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_RC4_fallback =
      _lookup<CFStringRef>('kSSLSessionConfig_RC4_fallback');

  CFStringRef get kSSLSessionConfig_RC4_fallback =>
      _kSSLSessionConfig_RC4_fallback.value;

  set kSSLSessionConfig_RC4_fallback(CFStringRef value) =>
      _kSSLSessionConfig_RC4_fallback.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_TLSv1_fallback =
      _lookup<CFStringRef>('kSSLSessionConfig_TLSv1_fallback');

  CFStringRef get kSSLSessionConfig_TLSv1_fallback =>
      _kSSLSessionConfig_TLSv1_fallback.value;

  set kSSLSessionConfig_TLSv1_fallback(CFStringRef value) =>
      _kSSLSessionConfig_TLSv1_fallback.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_TLSv1_RC4_fallback =
      _lookup<CFStringRef>('kSSLSessionConfig_TLSv1_RC4_fallback');

  CFStringRef get kSSLSessionConfig_TLSv1_RC4_fallback =>
      _kSSLSessionConfig_TLSv1_RC4_fallback.value;

  set kSSLSessionConfig_TLSv1_RC4_fallback(CFStringRef value) =>
      _kSSLSessionConfig_TLSv1_RC4_fallback.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_legacy =
      _lookup<CFStringRef>('kSSLSessionConfig_legacy');

  CFStringRef get kSSLSessionConfig_legacy => _kSSLSessionConfig_legacy.value;

  set kSSLSessionConfig_legacy(CFStringRef value) =>
      _kSSLSessionConfig_legacy.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_legacy_DHE =
      _lookup<CFStringRef>('kSSLSessionConfig_legacy_DHE');

  CFStringRef get kSSLSessionConfig_legacy_DHE =>
      _kSSLSessionConfig_legacy_DHE.value;

  set kSSLSessionConfig_legacy_DHE(CFStringRef value) =>
      _kSSLSessionConfig_legacy_DHE.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_anonymous =
      _lookup<CFStringRef>('kSSLSessionConfig_anonymous');

  CFStringRef get kSSLSessionConfig_anonymous =>
      _kSSLSessionConfig_anonymous.value;

  set kSSLSessionConfig_anonymous(CFStringRef value) =>
      _kSSLSessionConfig_anonymous.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_3DES_fallback =
      _lookup<CFStringRef>('kSSLSessionConfig_3DES_fallback');

  CFStringRef get kSSLSessionConfig_3DES_fallback =>
      _kSSLSessionConfig_3DES_fallback.value;

  set kSSLSessionConfig_3DES_fallback(CFStringRef value) =>
      _kSSLSessionConfig_3DES_fallback.value = value;

  late final ffi.Pointer<CFStringRef> _kSSLSessionConfig_TLSv1_3DES_fallback =
      _lookup<CFStringRef>('kSSLSessionConfig_TLSv1_3DES_fallback');

  CFStringRef get kSSLSessionConfig_TLSv1_3DES_fallback =>
      _kSSLSessionConfig_TLSv1_3DES_fallback.value;

  set kSSLSessionConfig_TLSv1_3DES_fallback(CFStringRef value) =>
      _kSSLSessionConfig_TLSv1_3DES_fallback.value = value;

  int SSLContextGetTypeID() {
    return _SSLContextGetTypeID();
  }

  late final _SSLContextGetTypeIDPtr =
      _lookup<ffi.NativeFunction<CFTypeID Function()>>('SSLContextGetTypeID');
  late final _SSLContextGetTypeID =
      _SSLContextGetTypeIDPtr.asFunction<int Function()>();

  SSLContextRef SSLCreateContext(
    CFAllocatorRef alloc,
    SSLProtocolSide protocolSide,
    SSLConnectionType connectionType,
  ) {
    return _SSLCreateContext(
      alloc,
      protocolSide.value,
      connectionType.value,
    );
  }

  late final _SSLCreateContextPtr = _lookup<
      ffi.NativeFunction<
          SSLContextRef Function(CFAllocatorRef, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('SSLCreateContext');
  late final _SSLCreateContext = _SSLCreateContextPtr.asFunction<
      SSLContextRef Function(CFAllocatorRef, int, int)>();

  int SSLNewContext(
    int isServer,
    ffi.Pointer<SSLContextRef> contextPtr,
  ) {
    return _SSLNewContext(
      isServer,
      contextPtr,
    );
  }

  late final _SSLNewContextPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              Boolean, ffi.Pointer<SSLContextRef>)>>('SSLNewContext');
  late final _SSLNewContext = _SSLNewContextPtr.asFunction<
      int Function(int, ffi.Pointer<SSLContextRef>)>();

  int SSLDisposeContext(
    SSLContextRef context,
  ) {
    return _SSLDisposeContext(
      context,
    );
  }

  late final _SSLDisposeContextPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef)>>(
          'SSLDisposeContext');
  late final _SSLDisposeContext =
      _SSLDisposeContextPtr.asFunction<int Function(SSLContextRef)>();

  int SSLGetSessionState(
    SSLContextRef context,
    ffi.Pointer<ffi.UnsignedInt> state,
  ) {
    return _SSLGetSessionState(
      context,
      state,
    );
  }

  late final _SSLGetSessionStatePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.UnsignedInt>)>>('SSLGetSessionState');
  late final _SSLGetSessionState = _SSLGetSessionStatePtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<ffi.UnsignedInt>)>();

  DartSInt32 SSLSetSessionOption(
    SSLContextRef context,
    SSLSessionOption option,
    DartBoolean value,
  ) {
    return _SSLSetSessionOption(
      context,
      option.value,
      value,
    );
  }

  late final _SSLSetSessionOptionPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, ffi.UnsignedInt, Boolean)>>('SSLSetSessionOption');
  late final _SSLSetSessionOption = _SSLSetSessionOptionPtr.asFunction<
      int Function(SSLContextRef, int, int)>();

  DartSInt32 SSLGetSessionOption(
    SSLContextRef context,
    SSLSessionOption option,
    ffi.Pointer<Boolean> value,
  ) {
    return _SSLGetSessionOption(
      context,
      option.value,
      value,
    );
  }

  late final _SSLGetSessionOptionPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.UnsignedInt,
              ffi.Pointer<Boolean>)>>('SSLGetSessionOption');
  late final _SSLGetSessionOption = _SSLGetSessionOptionPtr.asFunction<
      int Function(SSLContextRef, int, ffi.Pointer<Boolean>)>();

  int SSLSetIOFuncs(
    SSLContextRef context,
    SSLReadFunc readFunc,
    SSLWriteFunc writeFunc,
  ) {
    return _SSLSetIOFuncs(
      context,
      readFunc,
      writeFunc,
    );
  }

  late final _SSLSetIOFuncsPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, SSLReadFunc, SSLWriteFunc)>>('SSLSetIOFuncs');
  late final _SSLSetIOFuncs = _SSLSetIOFuncsPtr.asFunction<
      int Function(SSLContextRef, SSLReadFunc, SSLWriteFunc)>();

  int SSLSetSessionConfig(
    SSLContextRef context,
    CFStringRef config,
  ) {
    return _SSLSetSessionConfig(
      context,
      config,
    );
  }

  late final _SSLSetSessionConfigPtr = _lookup<
          ffi.NativeFunction<OSStatus Function(SSLContextRef, CFStringRef)>>(
      'SSLSetSessionConfig');
  late final _SSLSetSessionConfig = _SSLSetSessionConfigPtr.asFunction<
      int Function(SSLContextRef, CFStringRef)>();

  DartSInt32 SSLSetProtocolVersionMin(
    SSLContextRef context,
    SSLProtocol minVersion,
  ) {
    return _SSLSetProtocolVersionMin(
      context,
      minVersion.value,
    );
  }

  late final _SSLSetProtocolVersionMinPtr = _lookup<
          ffi
          .NativeFunction<OSStatus Function(SSLContextRef, ffi.UnsignedInt)>>(
      'SSLSetProtocolVersionMin');
  late final _SSLSetProtocolVersionMin = _SSLSetProtocolVersionMinPtr
      .asFunction<int Function(SSLContextRef, int)>();

  int SSLGetProtocolVersionMin(
    SSLContextRef context,
    ffi.Pointer<ffi.UnsignedInt> minVersion,
  ) {
    return _SSLGetProtocolVersionMin(
      context,
      minVersion,
    );
  }

  late final _SSLGetProtocolVersionMinPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.UnsignedInt>)>>('SSLGetProtocolVersionMin');
  late final _SSLGetProtocolVersionMin = _SSLGetProtocolVersionMinPtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<ffi.UnsignedInt>)>();

  DartSInt32 SSLSetProtocolVersionMax(
    SSLContextRef context,
    SSLProtocol maxVersion,
  ) {
    return _SSLSetProtocolVersionMax(
      context,
      maxVersion.value,
    );
  }

  late final _SSLSetProtocolVersionMaxPtr = _lookup<
          ffi
          .NativeFunction<OSStatus Function(SSLContextRef, ffi.UnsignedInt)>>(
      'SSLSetProtocolVersionMax');
  late final _SSLSetProtocolVersionMax = _SSLSetProtocolVersionMaxPtr
      .asFunction<int Function(SSLContextRef, int)>();

  int SSLGetProtocolVersionMax(
    SSLContextRef context,
    ffi.Pointer<ffi.UnsignedInt> maxVersion,
  ) {
    return _SSLGetProtocolVersionMax(
      context,
      maxVersion,
    );
  }

  late final _SSLGetProtocolVersionMaxPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.UnsignedInt>)>>('SSLGetProtocolVersionMax');
  late final _SSLGetProtocolVersionMax = _SSLGetProtocolVersionMaxPtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<ffi.UnsignedInt>)>();

  DartSInt32 SSLSetProtocolVersionEnabled(
    SSLContextRef context,
    SSLProtocol protocol,
    DartBoolean enable,
  ) {
    return _SSLSetProtocolVersionEnabled(
      context,
      protocol.value,
      enable,
    );
  }

  late final _SSLSetProtocolVersionEnabledPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.UnsignedInt,
              Boolean)>>('SSLSetProtocolVersionEnabled');
  late final _SSLSetProtocolVersionEnabled = _SSLSetProtocolVersionEnabledPtr
      .asFunction<int Function(SSLContextRef, int, int)>();

  DartSInt32 SSLGetProtocolVersionEnabled(
    SSLContextRef context,
    SSLProtocol protocol,
    ffi.Pointer<Boolean> enable,
  ) {
    return _SSLGetProtocolVersionEnabled(
      context,
      protocol.value,
      enable,
    );
  }

  late final _SSLGetProtocolVersionEnabledPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.UnsignedInt,
              ffi.Pointer<Boolean>)>>('SSLGetProtocolVersionEnabled');
  late final _SSLGetProtocolVersionEnabled = _SSLGetProtocolVersionEnabledPtr
      .asFunction<int Function(SSLContextRef, int, ffi.Pointer<Boolean>)>();

  DartSInt32 SSLSetProtocolVersion(
    SSLContextRef context,
    SSLProtocol version,
  ) {
    return _SSLSetProtocolVersion(
      context,
      version.value,
    );
  }

  late final _SSLSetProtocolVersionPtr = _lookup<
          ffi
          .NativeFunction<OSStatus Function(SSLContextRef, ffi.UnsignedInt)>>(
      'SSLSetProtocolVersion');
  late final _SSLSetProtocolVersion =
      _SSLSetProtocolVersionPtr.asFunction<int Function(SSLContextRef, int)>();

  int SSLGetProtocolVersion(
    SSLContextRef context,
    ffi.Pointer<ffi.UnsignedInt> protocol,
  ) {
    return _SSLGetProtocolVersion(
      context,
      protocol,
    );
  }

  late final _SSLGetProtocolVersionPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.UnsignedInt>)>>('SSLGetProtocolVersion');
  late final _SSLGetProtocolVersion = _SSLGetProtocolVersionPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<ffi.UnsignedInt>)>();

  int SSLSetCertificate(
    SSLContextRef context,
    CFArrayRef certRefs,
  ) {
    return _SSLSetCertificate(
      context,
      certRefs,
    );
  }

  late final _SSLSetCertificatePtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, CFArrayRef)>>(
          'SSLSetCertificate');
  late final _SSLSetCertificate = _SSLSetCertificatePtr.asFunction<
      int Function(SSLContextRef, CFArrayRef)>();

  int SSLSetConnection(
    SSLContextRef context,
    SSLConnectionRef connection,
  ) {
    return _SSLSetConnection(
      context,
      connection,
    );
  }

  late final _SSLSetConnectionPtr = _lookup<
          ffi
          .NativeFunction<OSStatus Function(SSLContextRef, SSLConnectionRef)>>(
      'SSLSetConnection');
  late final _SSLSetConnection = _SSLSetConnectionPtr.asFunction<
      int Function(SSLContextRef, SSLConnectionRef)>();

  int SSLGetConnection(
    SSLContextRef context,
    ffi.Pointer<SSLConnectionRef> connection,
  ) {
    return _SSLGetConnection(
      context,
      connection,
    );
  }

  late final _SSLGetConnectionPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<SSLConnectionRef>)>>('SSLGetConnection');
  late final _SSLGetConnection = _SSLGetConnectionPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<SSLConnectionRef>)>();

  int SSLSetPeerDomainName(
    SSLContextRef context,
    ffi.Pointer<ffi.Char> peerName,
    int peerNameLen,
  ) {
    return _SSLSetPeerDomainName(
      context,
      peerName,
      peerNameLen,
    );
  }

  late final _SSLSetPeerDomainNamePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('SSLSetPeerDomainName');
  late final _SSLSetPeerDomainName = _SSLSetPeerDomainNamePtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<ffi.Char>, int)>();

  int SSLGetPeerDomainNameLength(
    SSLContextRef context,
    ffi.Pointer<ffi.Size> peerNameLen,
  ) {
    return _SSLGetPeerDomainNameLength(
      context,
      peerNameLen,
    );
  }

  late final _SSLGetPeerDomainNameLengthPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.Size>)>>('SSLGetPeerDomainNameLength');
  late final _SSLGetPeerDomainNameLength = _SSLGetPeerDomainNameLengthPtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<ffi.Size>)>();

  int SSLGetPeerDomainName(
    SSLContextRef context,
    ffi.Pointer<ffi.Char> peerName,
    ffi.Pointer<ffi.Size> peerNameLen,
  ) {
    return _SSLGetPeerDomainName(
      context,
      peerName,
      peerNameLen,
    );
  }

  late final _SSLGetPeerDomainNamePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Size>)>>('SSLGetPeerDomainName');
  late final _SSLGetPeerDomainName = _SSLGetPeerDomainNamePtr.asFunction<
      int Function(
          SSLContextRef, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>();

  int SSLCopyRequestedPeerNameLength(
    SSLContextRef ctx,
    ffi.Pointer<ffi.Size> peerNameLen,
  ) {
    return _SSLCopyRequestedPeerNameLength(
      ctx,
      peerNameLen,
    );
  }

  late final _SSLCopyRequestedPeerNameLengthPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.Size>)>>('SSLCopyRequestedPeerNameLength');
  late final _SSLCopyRequestedPeerNameLength =
      _SSLCopyRequestedPeerNameLengthPtr.asFunction<
          int Function(SSLContextRef, ffi.Pointer<ffi.Size>)>();

  int SSLCopyRequestedPeerName(
    SSLContextRef context,
    ffi.Pointer<ffi.Char> peerName,
    ffi.Pointer<ffi.Size> peerNameLen,
  ) {
    return _SSLCopyRequestedPeerName(
      context,
      peerName,
      peerNameLen,
    );
  }

  late final _SSLCopyRequestedPeerNamePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Size>)>>('SSLCopyRequestedPeerName');
  late final _SSLCopyRequestedPeerName =
      _SSLCopyRequestedPeerNamePtr.asFunction<
          int Function(
              SSLContextRef, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>)>();

  int SSLSetDatagramHelloCookie(
    SSLContextRef dtlsContext,
    ffi.Pointer<ffi.Void> cookie,
    int cookieLen,
  ) {
    return _SSLSetDatagramHelloCookie(
      dtlsContext,
      cookie,
      cookieLen,
    );
  }

  late final _SSLSetDatagramHelloCookiePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SSLSetDatagramHelloCookie');
  late final _SSLSetDatagramHelloCookie = _SSLSetDatagramHelloCookiePtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<ffi.Void>, int)>();

  int SSLSetMaxDatagramRecordSize(
    SSLContextRef dtlsContext,
    int maxSize,
  ) {
    return _SSLSetMaxDatagramRecordSize(
      dtlsContext,
      maxSize,
    );
  }

  late final _SSLSetMaxDatagramRecordSizePtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, ffi.Size)>>(
          'SSLSetMaxDatagramRecordSize');
  late final _SSLSetMaxDatagramRecordSize = _SSLSetMaxDatagramRecordSizePtr
      .asFunction<int Function(SSLContextRef, int)>();

  int SSLGetMaxDatagramRecordSize(
    SSLContextRef dtlsContext,
    ffi.Pointer<ffi.Size> maxSize,
  ) {
    return _SSLGetMaxDatagramRecordSize(
      dtlsContext,
      maxSize,
    );
  }

  late final _SSLGetMaxDatagramRecordSizePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.Size>)>>('SSLGetMaxDatagramRecordSize');
  late final _SSLGetMaxDatagramRecordSize = _SSLGetMaxDatagramRecordSizePtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<ffi.Size>)>();

  int SSLGetNegotiatedProtocolVersion(
    SSLContextRef context,
    ffi.Pointer<ffi.UnsignedInt> protocol,
  ) {
    return _SSLGetNegotiatedProtocolVersion(
      context,
      protocol,
    );
  }

  late final _SSLGetNegotiatedProtocolVersionPtr = _lookup<
          ffi.NativeFunction<
              OSStatus Function(SSLContextRef, ffi.Pointer<ffi.UnsignedInt>)>>(
      'SSLGetNegotiatedProtocolVersion');
  late final _SSLGetNegotiatedProtocolVersion =
      _SSLGetNegotiatedProtocolVersionPtr.asFunction<
          int Function(SSLContextRef, ffi.Pointer<ffi.UnsignedInt>)>();

  int SSLGetNumberSupportedCiphers(
    SSLContextRef context,
    ffi.Pointer<ffi.Size> numCiphers,
  ) {
    return _SSLGetNumberSupportedCiphers(
      context,
      numCiphers,
    );
  }

  late final _SSLGetNumberSupportedCiphersPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.Size>)>>('SSLGetNumberSupportedCiphers');
  late final _SSLGetNumberSupportedCiphers = _SSLGetNumberSupportedCiphersPtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<ffi.Size>)>();

  int SSLGetSupportedCiphers(
    SSLContextRef context,
    ffi.Pointer<SSLCipherSuite> ciphers,
    ffi.Pointer<ffi.Size> numCiphers,
  ) {
    return _SSLGetSupportedCiphers(
      context,
      ciphers,
      numCiphers,
    );
  }

  late final _SSLGetSupportedCiphersPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<SSLCipherSuite>,
              ffi.Pointer<ffi.Size>)>>('SSLGetSupportedCiphers');
  late final _SSLGetSupportedCiphers = _SSLGetSupportedCiphersPtr.asFunction<
      int Function(
          SSLContextRef, ffi.Pointer<SSLCipherSuite>, ffi.Pointer<ffi.Size>)>();

  int SSLGetNumberEnabledCiphers(
    SSLContextRef context,
    ffi.Pointer<ffi.Size> numCiphers,
  ) {
    return _SSLGetNumberEnabledCiphers(
      context,
      numCiphers,
    );
  }

  late final _SSLGetNumberEnabledCiphersPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.Size>)>>('SSLGetNumberEnabledCiphers');
  late final _SSLGetNumberEnabledCiphers = _SSLGetNumberEnabledCiphersPtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<ffi.Size>)>();

  int SSLSetEnabledCiphers(
    SSLContextRef context,
    ffi.Pointer<SSLCipherSuite> ciphers,
    int numCiphers,
  ) {
    return _SSLSetEnabledCiphers(
      context,
      ciphers,
      numCiphers,
    );
  }

  late final _SSLSetEnabledCiphersPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<SSLCipherSuite>,
              ffi.Size)>>('SSLSetEnabledCiphers');
  late final _SSLSetEnabledCiphers = _SSLSetEnabledCiphersPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<SSLCipherSuite>, int)>();

  int SSLGetEnabledCiphers(
    SSLContextRef context,
    ffi.Pointer<SSLCipherSuite> ciphers,
    ffi.Pointer<ffi.Size> numCiphers,
  ) {
    return _SSLGetEnabledCiphers(
      context,
      ciphers,
      numCiphers,
    );
  }

  late final _SSLGetEnabledCiphersPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<SSLCipherSuite>,
              ffi.Pointer<ffi.Size>)>>('SSLGetEnabledCiphers');
  late final _SSLGetEnabledCiphers = _SSLGetEnabledCiphersPtr.asFunction<
      int Function(
          SSLContextRef, ffi.Pointer<SSLCipherSuite>, ffi.Pointer<ffi.Size>)>();

  int SSLSetSessionTicketsEnabled(
    SSLContextRef context,
    int enabled,
  ) {
    return _SSLSetSessionTicketsEnabled(
      context,
      enabled,
    );
  }

  late final _SSLSetSessionTicketsEnabledPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, Boolean)>>(
          'SSLSetSessionTicketsEnabled');
  late final _SSLSetSessionTicketsEnabled = _SSLSetSessionTicketsEnabledPtr
      .asFunction<int Function(SSLContextRef, int)>();

  int SSLSetEnableCertVerify(
    SSLContextRef context,
    int enableVerify,
  ) {
    return _SSLSetEnableCertVerify(
      context,
      enableVerify,
    );
  }

  late final _SSLSetEnableCertVerifyPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, Boolean)>>(
          'SSLSetEnableCertVerify');
  late final _SSLSetEnableCertVerify =
      _SSLSetEnableCertVerifyPtr.asFunction<int Function(SSLContextRef, int)>();

  int SSLGetEnableCertVerify(
    SSLContextRef context,
    ffi.Pointer<Boolean> enableVerify,
  ) {
    return _SSLGetEnableCertVerify(
      context,
      enableVerify,
    );
  }

  late final _SSLGetEnableCertVerifyPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, ffi.Pointer<Boolean>)>>('SSLGetEnableCertVerify');
  late final _SSLGetEnableCertVerify = _SSLGetEnableCertVerifyPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<Boolean>)>();

  int SSLSetAllowsExpiredCerts(
    SSLContextRef context,
    int allowsExpired,
  ) {
    return _SSLSetAllowsExpiredCerts(
      context,
      allowsExpired,
    );
  }

  late final _SSLSetAllowsExpiredCertsPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, Boolean)>>(
          'SSLSetAllowsExpiredCerts');
  late final _SSLSetAllowsExpiredCerts = _SSLSetAllowsExpiredCertsPtr
      .asFunction<int Function(SSLContextRef, int)>();

  int SSLGetAllowsExpiredCerts(
    SSLContextRef context,
    ffi.Pointer<Boolean> allowsExpired,
  ) {
    return _SSLGetAllowsExpiredCerts(
      context,
      allowsExpired,
    );
  }

  late final _SSLGetAllowsExpiredCertsPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<Boolean>)>>('SSLGetAllowsExpiredCerts');
  late final _SSLGetAllowsExpiredCerts = _SSLGetAllowsExpiredCertsPtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<Boolean>)>();

  int SSLSetAllowsExpiredRoots(
    SSLContextRef context,
    int allowsExpired,
  ) {
    return _SSLSetAllowsExpiredRoots(
      context,
      allowsExpired,
    );
  }

  late final _SSLSetAllowsExpiredRootsPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, Boolean)>>(
          'SSLSetAllowsExpiredRoots');
  late final _SSLSetAllowsExpiredRoots = _SSLSetAllowsExpiredRootsPtr
      .asFunction<int Function(SSLContextRef, int)>();

  int SSLGetAllowsExpiredRoots(
    SSLContextRef context,
    ffi.Pointer<Boolean> allowsExpired,
  ) {
    return _SSLGetAllowsExpiredRoots(
      context,
      allowsExpired,
    );
  }

  late final _SSLGetAllowsExpiredRootsPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<Boolean>)>>('SSLGetAllowsExpiredRoots');
  late final _SSLGetAllowsExpiredRoots = _SSLGetAllowsExpiredRootsPtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<Boolean>)>();

  int SSLSetAllowsAnyRoot(
    SSLContextRef context,
    int anyRoot,
  ) {
    return _SSLSetAllowsAnyRoot(
      context,
      anyRoot,
    );
  }

  late final _SSLSetAllowsAnyRootPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, Boolean)>>(
          'SSLSetAllowsAnyRoot');
  late final _SSLSetAllowsAnyRoot =
      _SSLSetAllowsAnyRootPtr.asFunction<int Function(SSLContextRef, int)>();

  int SSLGetAllowsAnyRoot(
    SSLContextRef context,
    ffi.Pointer<Boolean> anyRoot,
  ) {
    return _SSLGetAllowsAnyRoot(
      context,
      anyRoot,
    );
  }

  late final _SSLGetAllowsAnyRootPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, ffi.Pointer<Boolean>)>>('SSLGetAllowsAnyRoot');
  late final _SSLGetAllowsAnyRoot = _SSLGetAllowsAnyRootPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<Boolean>)>();

  int SSLSetTrustedRoots(
    SSLContextRef context,
    CFArrayRef trustedRoots,
    int replaceExisting,
  ) {
    return _SSLSetTrustedRoots(
      context,
      trustedRoots,
      replaceExisting,
    );
  }

  late final _SSLSetTrustedRootsPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, CFArrayRef, Boolean)>>('SSLSetTrustedRoots');
  late final _SSLSetTrustedRoots = _SSLSetTrustedRootsPtr.asFunction<
      int Function(SSLContextRef, CFArrayRef, int)>();

  int SSLCopyTrustedRoots(
    SSLContextRef context,
    ffi.Pointer<CFArrayRef> trustedRoots,
  ) {
    return _SSLCopyTrustedRoots(
      context,
      trustedRoots,
    );
  }

  late final _SSLCopyTrustedRootsPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, ffi.Pointer<CFArrayRef>)>>('SSLCopyTrustedRoots');
  late final _SSLCopyTrustedRoots = _SSLCopyTrustedRootsPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<CFArrayRef>)>();

  int SSLCopyPeerCertificates(
    SSLContextRef context,
    ffi.Pointer<CFArrayRef> certs,
  ) {
    return _SSLCopyPeerCertificates(
      context,
      certs,
    );
  }

  late final _SSLCopyPeerCertificatesPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<CFArrayRef>)>>('SSLCopyPeerCertificates');
  late final _SSLCopyPeerCertificates = _SSLCopyPeerCertificatesPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<CFArrayRef>)>();

  int SSLCopyPeerTrust(
    SSLContextRef context,
    ffi.Pointer<SecTrustRef> trust,
  ) {
    return _SSLCopyPeerTrust(
      context,
      trust,
    );
  }

  late final _SSLCopyPeerTrustPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, ffi.Pointer<SecTrustRef>)>>('SSLCopyPeerTrust');
  late final _SSLCopyPeerTrust = _SSLCopyPeerTrustPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<SecTrustRef>)>();

  int SSLSetPeerID(
    SSLContextRef context,
    ffi.Pointer<ffi.Void> peerID,
    int peerIDLen,
  ) {
    return _SSLSetPeerID(
      context,
      peerID,
      peerIDLen,
    );
  }

  late final _SSLSetPeerIDPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, ffi.Pointer<ffi.Void>, ffi.Size)>>('SSLSetPeerID');
  late final _SSLSetPeerID = _SSLSetPeerIDPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<ffi.Void>, int)>();

  int SSLGetPeerID(
    SSLContextRef context,
    ffi.Pointer<ffi.Pointer<ffi.Void>> peerID,
    ffi.Pointer<ffi.Size> peerIDLen,
  ) {
    return _SSLGetPeerID(
      context,
      peerID,
      peerIDLen,
    );
  }

  late final _SSLGetPeerIDPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>)>>('SSLGetPeerID');
  late final _SSLGetPeerID = _SSLGetPeerIDPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<ffi.Pointer<ffi.Void>>,
          ffi.Pointer<ffi.Size>)>();

  int SSLGetNegotiatedCipher(
    SSLContextRef context,
    ffi.Pointer<SSLCipherSuite> cipherSuite,
  ) {
    return _SSLGetNegotiatedCipher(
      context,
      cipherSuite,
    );
  }

  late final _SSLGetNegotiatedCipherPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<SSLCipherSuite>)>>('SSLGetNegotiatedCipher');
  late final _SSLGetNegotiatedCipher = _SSLGetNegotiatedCipherPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<SSLCipherSuite>)>();

  int SSLSetALPNProtocols(
    SSLContextRef context,
    CFArrayRef protocols,
  ) {
    return _SSLSetALPNProtocols(
      context,
      protocols,
    );
  }

  late final _SSLSetALPNProtocolsPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, CFArrayRef)>>(
          'SSLSetALPNProtocols');
  late final _SSLSetALPNProtocols = _SSLSetALPNProtocolsPtr.asFunction<
      int Function(SSLContextRef, CFArrayRef)>();

  int SSLCopyALPNProtocols(
    SSLContextRef context,
    ffi.Pointer<CFArrayRef> protocols,
  ) {
    return _SSLCopyALPNProtocols(
      context,
      protocols,
    );
  }

  late final _SSLCopyALPNProtocolsPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, ffi.Pointer<CFArrayRef>)>>('SSLCopyALPNProtocols');
  late final _SSLCopyALPNProtocols = _SSLCopyALPNProtocolsPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<CFArrayRef>)>();

  int SSLSetOCSPResponse(
    SSLContextRef context,
    CFDataRef response,
  ) {
    return _SSLSetOCSPResponse(
      context,
      response,
    );
  }

  late final _SSLSetOCSPResponsePtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, CFDataRef)>>(
          'SSLSetOCSPResponse');
  late final _SSLSetOCSPResponse = _SSLSetOCSPResponsePtr.asFunction<
      int Function(SSLContextRef, CFDataRef)>();

  int SSLSetEncryptionCertificate(
    SSLContextRef context,
    CFArrayRef certRefs,
  ) {
    return _SSLSetEncryptionCertificate(
      context,
      certRefs,
    );
  }

  late final _SSLSetEncryptionCertificatePtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, CFArrayRef)>>(
          'SSLSetEncryptionCertificate');
  late final _SSLSetEncryptionCertificate = _SSLSetEncryptionCertificatePtr
      .asFunction<int Function(SSLContextRef, CFArrayRef)>();

  DartSInt32 SSLSetClientSideAuthenticate(
    SSLContextRef context,
    SSLAuthenticate auth,
  ) {
    return _SSLSetClientSideAuthenticate(
      context,
      auth.value,
    );
  }

  late final _SSLSetClientSideAuthenticatePtr = _lookup<
          ffi
          .NativeFunction<OSStatus Function(SSLContextRef, ffi.UnsignedInt)>>(
      'SSLSetClientSideAuthenticate');
  late final _SSLSetClientSideAuthenticate = _SSLSetClientSideAuthenticatePtr
      .asFunction<int Function(SSLContextRef, int)>();

  int SSLAddDistinguishedName(
    SSLContextRef context,
    ffi.Pointer<ffi.Void> derDN,
    int derDNLen,
  ) {
    return _SSLAddDistinguishedName(
      context,
      derDN,
      derDNLen,
    );
  }

  late final _SSLAddDistinguishedNamePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SSLAddDistinguishedName');
  late final _SSLAddDistinguishedName = _SSLAddDistinguishedNamePtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<ffi.Void>, int)>();

  int SSLSetCertificateAuthorities(
    SSLContextRef context,
    CFTypeRef certificateOrArray,
    int replaceExisting,
  ) {
    return _SSLSetCertificateAuthorities(
      context,
      certificateOrArray,
      replaceExisting,
    );
  }

  late final _SSLSetCertificateAuthoritiesPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, CFTypeRef,
              Boolean)>>('SSLSetCertificateAuthorities');
  late final _SSLSetCertificateAuthorities = _SSLSetCertificateAuthoritiesPtr
      .asFunction<int Function(SSLContextRef, CFTypeRef, int)>();

  int SSLCopyCertificateAuthorities(
    SSLContextRef context,
    ffi.Pointer<CFArrayRef> certificates,
  ) {
    return _SSLCopyCertificateAuthorities(
      context,
      certificates,
    );
  }

  late final _SSLCopyCertificateAuthoritiesPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<CFArrayRef>)>>('SSLCopyCertificateAuthorities');
  late final _SSLCopyCertificateAuthorities = _SSLCopyCertificateAuthoritiesPtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<CFArrayRef>)>();

  int SSLCopyDistinguishedNames(
    SSLContextRef context,
    ffi.Pointer<CFArrayRef> names,
  ) {
    return _SSLCopyDistinguishedNames(
      context,
      names,
    );
  }

  late final _SSLCopyDistinguishedNamesPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<CFArrayRef>)>>('SSLCopyDistinguishedNames');
  late final _SSLCopyDistinguishedNames = _SSLCopyDistinguishedNamesPtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<CFArrayRef>)>();

  int SSLGetClientCertificateState(
    SSLContextRef context,
    ffi.Pointer<ffi.UnsignedInt> clientState,
  ) {
    return _SSLGetClientCertificateState(
      context,
      clientState,
    );
  }

  late final _SSLGetClientCertificateStatePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.UnsignedInt>)>>('SSLGetClientCertificateState');
  late final _SSLGetClientCertificateState = _SSLGetClientCertificateStatePtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<ffi.UnsignedInt>)>();

  int SSLSetDiffieHellmanParams(
    SSLContextRef context,
    ffi.Pointer<ffi.Void> dhParams,
    int dhParamsLen,
  ) {
    return _SSLSetDiffieHellmanParams(
      context,
      dhParams,
      dhParamsLen,
    );
  }

  late final _SSLSetDiffieHellmanParamsPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('SSLSetDiffieHellmanParams');
  late final _SSLSetDiffieHellmanParams = _SSLSetDiffieHellmanParamsPtr
      .asFunction<int Function(SSLContextRef, ffi.Pointer<ffi.Void>, int)>();

  int SSLGetDiffieHellmanParams(
    SSLContextRef context,
    ffi.Pointer<ffi.Pointer<ffi.Void>> dhParams,
    ffi.Pointer<ffi.Size> dhParamsLen,
  ) {
    return _SSLGetDiffieHellmanParams(
      context,
      dhParams,
      dhParamsLen,
    );
  }

  late final _SSLGetDiffieHellmanParamsPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>)>>('SSLGetDiffieHellmanParams');
  late final _SSLGetDiffieHellmanParams =
      _SSLGetDiffieHellmanParamsPtr.asFunction<
          int Function(SSLContextRef, ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Size>)>();

  int SSLSetRsaBlinding(
    SSLContextRef context,
    int blinding,
  ) {
    return _SSLSetRsaBlinding(
      context,
      blinding,
    );
  }

  late final _SSLSetRsaBlindingPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, Boolean)>>(
          'SSLSetRsaBlinding');
  late final _SSLSetRsaBlinding =
      _SSLSetRsaBlindingPtr.asFunction<int Function(SSLContextRef, int)>();

  int SSLGetRsaBlinding(
    SSLContextRef context,
    ffi.Pointer<Boolean> blinding,
  ) {
    return _SSLGetRsaBlinding(
      context,
      blinding,
    );
  }

  late final _SSLGetRsaBlindingPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, ffi.Pointer<Boolean>)>>('SSLGetRsaBlinding');
  late final _SSLGetRsaBlinding = _SSLGetRsaBlindingPtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<Boolean>)>();

  int SSLHandshake(
    SSLContextRef context,
  ) {
    return _SSLHandshake(
      context,
    );
  }

  late final _SSLHandshakePtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef)>>(
          'SSLHandshake');
  late final _SSLHandshake =
      _SSLHandshakePtr.asFunction<int Function(SSLContextRef)>();

  int SSLReHandshake(
    SSLContextRef context,
  ) {
    return _SSLReHandshake(
      context,
    );
  }

  late final _SSLReHandshakePtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef)>>(
          'SSLReHandshake');
  late final _SSLReHandshake =
      _SSLReHandshakePtr.asFunction<int Function(SSLContextRef)>();

  int SSLWrite(
    SSLContextRef context,
    ffi.Pointer<ffi.Void> data,
    int dataLength,
    ffi.Pointer<ffi.Size> processed,
  ) {
    return _SSLWrite(
      context,
      data,
      dataLength,
      processed,
    );
  }

  late final _SSLWritePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Size>)>>('SSLWrite');
  late final _SSLWrite = _SSLWritePtr.asFunction<
      int Function(
          SSLContextRef, ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Size>)>();

  int SSLRead(
    SSLContextRef context,
    ffi.Pointer<ffi.Void> data,
    int dataLength,
    ffi.Pointer<ffi.Size> processed,
  ) {
    return _SSLRead(
      context,
      data,
      dataLength,
      processed,
    );
  }

  late final _SSLReadPtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef, ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Size>)>>('SSLRead');
  late final _SSLRead = _SSLReadPtr.asFunction<
      int Function(
          SSLContextRef, ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Size>)>();

  int SSLGetBufferedReadSize(
    SSLContextRef context,
    ffi.Pointer<ffi.Size> bufferSize,
  ) {
    return _SSLGetBufferedReadSize(
      context,
      bufferSize,
    );
  }

  late final _SSLGetBufferedReadSizePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(
              SSLContextRef, ffi.Pointer<ffi.Size>)>>('SSLGetBufferedReadSize');
  late final _SSLGetBufferedReadSize = _SSLGetBufferedReadSizePtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<ffi.Size>)>();

  int SSLGetDatagramWriteSize(
    SSLContextRef dtlsContext,
    ffi.Pointer<ffi.Size> bufSize,
  ) {
    return _SSLGetDatagramWriteSize(
      dtlsContext,
      bufSize,
    );
  }

  late final _SSLGetDatagramWriteSizePtr = _lookup<
      ffi.NativeFunction<
          OSStatus Function(SSLContextRef,
              ffi.Pointer<ffi.Size>)>>('SSLGetDatagramWriteSize');
  late final _SSLGetDatagramWriteSize = _SSLGetDatagramWriteSizePtr.asFunction<
      int Function(SSLContextRef, ffi.Pointer<ffi.Size>)>();

  int SSLClose(
    SSLContextRef context,
  ) {
    return _SSLClose(
      context,
    );
  }

  late final _SSLClosePtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef)>>('SSLClose');
  late final _SSLClose = _SSLClosePtr.asFunction<int Function(SSLContextRef)>();

  int SSLSetError(
    SSLContextRef context,
    int status,
  ) {
    return _SSLSetError(
      context,
      status,
    );
  }

  late final _SSLSetErrorPtr =
      _lookup<ffi.NativeFunction<OSStatus Function(SSLContextRef, OSStatus)>>(
          'SSLSetError');
  late final _SSLSetError =
      _SSLSetErrorPtr.asFunction<int Function(SSLContextRef, int)>();

  /// -1LL
  late final ffi.Pointer<ffi.Int64> _NSURLSessionTransferSizeUnknown =
      _lookup<ffi.Int64>('NSURLSessionTransferSizeUnknown');

  int get NSURLSessionTransferSizeUnknown =>
      _NSURLSessionTransferSizeUnknown.value;

  late final ffi.Pointer<ffi.Float> _NSURLSessionTaskPriorityDefault =
      _lookup<ffi.Float>('NSURLSessionTaskPriorityDefault');

  double get NSURLSessionTaskPriorityDefault =>
      _NSURLSessionTaskPriorityDefault.value;

  late final ffi.Pointer<ffi.Float> _NSURLSessionTaskPriorityLow =
      _lookup<ffi.Float>('NSURLSessionTaskPriorityLow');

  double get NSURLSessionTaskPriorityLow => _NSURLSessionTaskPriorityLow.value;

  late final ffi.Pointer<ffi.Float> _NSURLSessionTaskPriorityHigh =
      _lookup<ffi.Float>('NSURLSessionTaskPriorityHigh');

  double get NSURLSessionTaskPriorityHigh =>
      _NSURLSessionTaskPriorityHigh.value;

  /// Key in the userInfo dictionary of an NSError received during a failed download.
  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSURLSessionDownloadTaskResumeData =
      _lookup<ffi.Pointer<objc.ObjCObject>>(
          'NSURLSessionDownloadTaskResumeData');

  objc.NSString get NSURLSessionDownloadTaskResumeData =>
      objc.NSString.castFromPointer(_NSURLSessionDownloadTaskResumeData.value,
          retain: true, release: true);

  set NSURLSessionDownloadTaskResumeData(objc.NSString value) {
    objc.NSString.castFromPointer(_NSURLSessionDownloadTaskResumeData.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLSessionDownloadTaskResumeData.value =
        value.ref.retainAndReturnPointer();
  }

  /// Key in the userInfo dictionary of an NSError received during a failed upload.
  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSURLSessionUploadTaskResumeData =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSURLSessionUploadTaskResumeData');

  objc.NSString get NSURLSessionUploadTaskResumeData =>
      objc.NSString.castFromPointer(_NSURLSessionUploadTaskResumeData.value,
          retain: true, release: true);

  set NSURLSessionUploadTaskResumeData(objc.NSString value) {
    objc.NSString.castFromPointer(_NSURLSessionUploadTaskResumeData.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLSessionUploadTaskResumeData.value =
        value.ref.retainAndReturnPointer();
  }

  NSRange NSUnionRange(
    NSRange range1,
    NSRange range2,
  ) {
    return _NSUnionRange(
      range1,
      range2,
    );
  }

  late final _NSUnionRangePtr =
      _lookup<ffi.NativeFunction<NSRange Function(NSRange, NSRange)>>(
          'NSUnionRange');
  late final _NSUnionRange =
      _NSUnionRangePtr.asFunction<NSRange Function(NSRange, NSRange)>();

  NSRange NSIntersectionRange(
    NSRange range1,
    NSRange range2,
  ) {
    return _NSIntersectionRange(
      range1,
      range2,
    );
  }

  late final _NSIntersectionRangePtr =
      _lookup<ffi.NativeFunction<NSRange Function(NSRange, NSRange)>>(
          'NSIntersectionRange');
  late final _NSIntersectionRange =
      _NSIntersectionRangePtr.asFunction<NSRange Function(NSRange, NSRange)>();

  objc.NSString NSStringFromRange(
    NSRange range,
  ) {
    return objc.NSString.castFromPointer(
        _NSStringFromRange(
          range,
        ),
        retain: true,
        release: true);
  }

  late final _NSStringFromRangePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(NSRange)>>(
      'NSStringFromRange');
  late final _NSStringFromRange = _NSStringFromRangePtr.asFunction<
      ffi.Pointer<objc.ObjCObject> Function(NSRange)>();

  NSRange NSRangeFromString(
    objc.NSString aString,
  ) {
    return _NSRangeFromString(
      aString.ref.pointer,
    );
  }

  late final _NSRangeFromStringPtr = _lookup<
          ffi.NativeFunction<NSRange Function(ffi.Pointer<objc.ObjCObject>)>>(
      'NSRangeFromString');
  late final _NSRangeFromString = _NSRangeFromStringPtr.asFunction<
      NSRange Function(ffi.Pointer<objc.ObjCObject>)>();

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSItemProviderPreferredImageSizeKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>(
          'NSItemProviderPreferredImageSizeKey');

  objc.NSString get NSItemProviderPreferredImageSizeKey =>
      objc.NSString.castFromPointer(_NSItemProviderPreferredImageSizeKey.value,
          retain: true, release: true);

  set NSItemProviderPreferredImageSizeKey(objc.NSString value) {
    objc.NSString.castFromPointer(_NSItemProviderPreferredImageSizeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSItemProviderPreferredImageSizeKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSExtensionJavaScriptPreprocessingResultsKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>(
          'NSExtensionJavaScriptPreprocessingResultsKey');

  objc.NSString get NSExtensionJavaScriptPreprocessingResultsKey =>
      objc.NSString.castFromPointer(
          _NSExtensionJavaScriptPreprocessingResultsKey.value,
          retain: true,
          release: true);

  set NSExtensionJavaScriptPreprocessingResultsKey(objc.NSString value) {
    objc.NSString.castFromPointer(
            _NSExtensionJavaScriptPreprocessingResultsKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSExtensionJavaScriptPreprocessingResultsKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSExtensionJavaScriptFinalizeArgumentKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>(
          'NSExtensionJavaScriptFinalizeArgumentKey');

  objc.NSString get NSExtensionJavaScriptFinalizeArgumentKey =>
      objc.NSString.castFromPointer(
          _NSExtensionJavaScriptFinalizeArgumentKey.value,
          retain: true,
          release: true);

  set NSExtensionJavaScriptFinalizeArgumentKey(objc.NSString value) {
    objc.NSString.castFromPointer(
            _NSExtensionJavaScriptFinalizeArgumentKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSExtensionJavaScriptFinalizeArgumentKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSItemProviderErrorDomain =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSItemProviderErrorDomain');

  objc.NSString get NSItemProviderErrorDomain =>
      objc.NSString.castFromPointer(_NSItemProviderErrorDomain.value,
          retain: true, release: true);

  set NSItemProviderErrorDomain(objc.NSString value) {
    objc.NSString.castFromPointer(_NSItemProviderErrorDomain.value,
            retain: false, release: true)
        .ref
        .release();
    _NSItemProviderErrorDomain.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformLatinToKatakana =
      _lookup<NSStringTransform>('NSStringTransformLatinToKatakana');

  DartNSStringTransform get NSStringTransformLatinToKatakana =>
      objc.NSString.castFromPointer(_NSStringTransformLatinToKatakana.value,
          retain: true, release: true);

  set NSStringTransformLatinToKatakana(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformLatinToKatakana.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformLatinToKatakana.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformLatinToHiragana =
      _lookup<NSStringTransform>('NSStringTransformLatinToHiragana');

  DartNSStringTransform get NSStringTransformLatinToHiragana =>
      objc.NSString.castFromPointer(_NSStringTransformLatinToHiragana.value,
          retain: true, release: true);

  set NSStringTransformLatinToHiragana(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformLatinToHiragana.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformLatinToHiragana.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformLatinToHangul =
      _lookup<NSStringTransform>('NSStringTransformLatinToHangul');

  DartNSStringTransform get NSStringTransformLatinToHangul =>
      objc.NSString.castFromPointer(_NSStringTransformLatinToHangul.value,
          retain: true, release: true);

  set NSStringTransformLatinToHangul(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformLatinToHangul.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformLatinToHangul.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformLatinToArabic =
      _lookup<NSStringTransform>('NSStringTransformLatinToArabic');

  DartNSStringTransform get NSStringTransformLatinToArabic =>
      objc.NSString.castFromPointer(_NSStringTransformLatinToArabic.value,
          retain: true, release: true);

  set NSStringTransformLatinToArabic(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformLatinToArabic.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformLatinToArabic.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformLatinToHebrew =
      _lookup<NSStringTransform>('NSStringTransformLatinToHebrew');

  DartNSStringTransform get NSStringTransformLatinToHebrew =>
      objc.NSString.castFromPointer(_NSStringTransformLatinToHebrew.value,
          retain: true, release: true);

  set NSStringTransformLatinToHebrew(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformLatinToHebrew.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformLatinToHebrew.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformLatinToThai =
      _lookup<NSStringTransform>('NSStringTransformLatinToThai');

  DartNSStringTransform get NSStringTransformLatinToThai =>
      objc.NSString.castFromPointer(_NSStringTransformLatinToThai.value,
          retain: true, release: true);

  set NSStringTransformLatinToThai(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformLatinToThai.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformLatinToThai.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformLatinToCyrillic =
      _lookup<NSStringTransform>('NSStringTransformLatinToCyrillic');

  DartNSStringTransform get NSStringTransformLatinToCyrillic =>
      objc.NSString.castFromPointer(_NSStringTransformLatinToCyrillic.value,
          retain: true, release: true);

  set NSStringTransformLatinToCyrillic(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformLatinToCyrillic.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformLatinToCyrillic.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformLatinToGreek =
      _lookup<NSStringTransform>('NSStringTransformLatinToGreek');

  DartNSStringTransform get NSStringTransformLatinToGreek =>
      objc.NSString.castFromPointer(_NSStringTransformLatinToGreek.value,
          retain: true, release: true);

  set NSStringTransformLatinToGreek(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformLatinToGreek.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformLatinToGreek.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformToLatin =
      _lookup<NSStringTransform>('NSStringTransformToLatin');

  DartNSStringTransform get NSStringTransformToLatin =>
      objc.NSString.castFromPointer(_NSStringTransformToLatin.value,
          retain: true, release: true);

  set NSStringTransformToLatin(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformToLatin.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformToLatin.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformMandarinToLatin =
      _lookup<NSStringTransform>('NSStringTransformMandarinToLatin');

  DartNSStringTransform get NSStringTransformMandarinToLatin =>
      objc.NSString.castFromPointer(_NSStringTransformMandarinToLatin.value,
          retain: true, release: true);

  set NSStringTransformMandarinToLatin(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformMandarinToLatin.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformMandarinToLatin.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform>
      _NSStringTransformHiraganaToKatakana =
      _lookup<NSStringTransform>('NSStringTransformHiraganaToKatakana');

  DartNSStringTransform get NSStringTransformHiraganaToKatakana =>
      objc.NSString.castFromPointer(_NSStringTransformHiraganaToKatakana.value,
          retain: true, release: true);

  set NSStringTransformHiraganaToKatakana(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformHiraganaToKatakana.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformHiraganaToKatakana.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform>
      _NSStringTransformFullwidthToHalfwidth =
      _lookup<NSStringTransform>('NSStringTransformFullwidthToHalfwidth');

  DartNSStringTransform get NSStringTransformFullwidthToHalfwidth =>
      objc.NSString.castFromPointer(
          _NSStringTransformFullwidthToHalfwidth.value,
          retain: true,
          release: true);

  set NSStringTransformFullwidthToHalfwidth(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformFullwidthToHalfwidth.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformFullwidthToHalfwidth.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformToXMLHex =
      _lookup<NSStringTransform>('NSStringTransformToXMLHex');

  DartNSStringTransform get NSStringTransformToXMLHex =>
      objc.NSString.castFromPointer(_NSStringTransformToXMLHex.value,
          retain: true, release: true);

  set NSStringTransformToXMLHex(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformToXMLHex.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformToXMLHex.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformToUnicodeName =
      _lookup<NSStringTransform>('NSStringTransformToUnicodeName');

  DartNSStringTransform get NSStringTransformToUnicodeName =>
      objc.NSString.castFromPointer(_NSStringTransformToUnicodeName.value,
          retain: true, release: true);

  set NSStringTransformToUnicodeName(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformToUnicodeName.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformToUnicodeName.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform>
      _NSStringTransformStripCombiningMarks =
      _lookup<NSStringTransform>('NSStringTransformStripCombiningMarks');

  DartNSStringTransform get NSStringTransformStripCombiningMarks =>
      objc.NSString.castFromPointer(_NSStringTransformStripCombiningMarks.value,
          retain: true, release: true);

  set NSStringTransformStripCombiningMarks(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformStripCombiningMarks.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformStripCombiningMarks.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringTransform> _NSStringTransformStripDiacritics =
      _lookup<NSStringTransform>('NSStringTransformStripDiacritics');

  DartNSStringTransform get NSStringTransformStripDiacritics =>
      objc.NSString.castFromPointer(_NSStringTransformStripDiacritics.value,
          retain: true, release: true);

  set NSStringTransformStripDiacritics(DartNSStringTransform value) {
    objc.NSString.castFromPointer(_NSStringTransformStripDiacritics.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringTransformStripDiacritics.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringEncodingDetectionOptionsKey>
      _NSStringEncodingDetectionSuggestedEncodingsKey =
      _lookup<NSStringEncodingDetectionOptionsKey>(
          'NSStringEncodingDetectionSuggestedEncodingsKey');

  DartNSStringEncodingDetectionOptionsKey
      get NSStringEncodingDetectionSuggestedEncodingsKey =>
          objc.NSString.castFromPointer(
              _NSStringEncodingDetectionSuggestedEncodingsKey.value,
              retain: true,
              release: true);

  set NSStringEncodingDetectionSuggestedEncodingsKey(
      DartNSStringEncodingDetectionOptionsKey value) {
    objc.NSString.castFromPointer(
            _NSStringEncodingDetectionSuggestedEncodingsKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSStringEncodingDetectionSuggestedEncodingsKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringEncodingDetectionOptionsKey>
      _NSStringEncodingDetectionDisallowedEncodingsKey =
      _lookup<NSStringEncodingDetectionOptionsKey>(
          'NSStringEncodingDetectionDisallowedEncodingsKey');

  DartNSStringEncodingDetectionOptionsKey
      get NSStringEncodingDetectionDisallowedEncodingsKey =>
          objc.NSString.castFromPointer(
              _NSStringEncodingDetectionDisallowedEncodingsKey.value,
              retain: true,
              release: true);

  set NSStringEncodingDetectionDisallowedEncodingsKey(
      DartNSStringEncodingDetectionOptionsKey value) {
    objc.NSString.castFromPointer(
            _NSStringEncodingDetectionDisallowedEncodingsKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSStringEncodingDetectionDisallowedEncodingsKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringEncodingDetectionOptionsKey>
      _NSStringEncodingDetectionUseOnlySuggestedEncodingsKey =
      _lookup<NSStringEncodingDetectionOptionsKey>(
          'NSStringEncodingDetectionUseOnlySuggestedEncodingsKey');

  DartNSStringEncodingDetectionOptionsKey
      get NSStringEncodingDetectionUseOnlySuggestedEncodingsKey =>
          objc.NSString.castFromPointer(
              _NSStringEncodingDetectionUseOnlySuggestedEncodingsKey.value,
              retain: true,
              release: true);

  set NSStringEncodingDetectionUseOnlySuggestedEncodingsKey(
      DartNSStringEncodingDetectionOptionsKey value) {
    objc.NSString.castFromPointer(
            _NSStringEncodingDetectionUseOnlySuggestedEncodingsKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSStringEncodingDetectionUseOnlySuggestedEncodingsKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringEncodingDetectionOptionsKey>
      _NSStringEncodingDetectionAllowLossyKey =
      _lookup<NSStringEncodingDetectionOptionsKey>(
          'NSStringEncodingDetectionAllowLossyKey');

  DartNSStringEncodingDetectionOptionsKey
      get NSStringEncodingDetectionAllowLossyKey =>
          objc.NSString.castFromPointer(
              _NSStringEncodingDetectionAllowLossyKey.value,
              retain: true,
              release: true);

  set NSStringEncodingDetectionAllowLossyKey(
      DartNSStringEncodingDetectionOptionsKey value) {
    objc.NSString.castFromPointer(_NSStringEncodingDetectionAllowLossyKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringEncodingDetectionAllowLossyKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringEncodingDetectionOptionsKey>
      _NSStringEncodingDetectionFromWindowsKey =
      _lookup<NSStringEncodingDetectionOptionsKey>(
          'NSStringEncodingDetectionFromWindowsKey');

  DartNSStringEncodingDetectionOptionsKey
      get NSStringEncodingDetectionFromWindowsKey =>
          objc.NSString.castFromPointer(
              _NSStringEncodingDetectionFromWindowsKey.value,
              retain: true,
              release: true);

  set NSStringEncodingDetectionFromWindowsKey(
      DartNSStringEncodingDetectionOptionsKey value) {
    objc.NSString.castFromPointer(
            _NSStringEncodingDetectionFromWindowsKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSStringEncodingDetectionFromWindowsKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringEncodingDetectionOptionsKey>
      _NSStringEncodingDetectionLossySubstitutionKey =
      _lookup<NSStringEncodingDetectionOptionsKey>(
          'NSStringEncodingDetectionLossySubstitutionKey');

  DartNSStringEncodingDetectionOptionsKey
      get NSStringEncodingDetectionLossySubstitutionKey =>
          objc.NSString.castFromPointer(
              _NSStringEncodingDetectionLossySubstitutionKey.value,
              retain: true,
              release: true);

  set NSStringEncodingDetectionLossySubstitutionKey(
      DartNSStringEncodingDetectionOptionsKey value) {
    objc.NSString.castFromPointer(
            _NSStringEncodingDetectionLossySubstitutionKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSStringEncodingDetectionLossySubstitutionKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSStringEncodingDetectionOptionsKey>
      _NSStringEncodingDetectionLikelyLanguageKey =
      _lookup<NSStringEncodingDetectionOptionsKey>(
          'NSStringEncodingDetectionLikelyLanguageKey');

  DartNSStringEncodingDetectionOptionsKey
      get NSStringEncodingDetectionLikelyLanguageKey =>
          objc.NSString.castFromPointer(
              _NSStringEncodingDetectionLikelyLanguageKey.value,
              retain: true,
              release: true);

  set NSStringEncodingDetectionLikelyLanguageKey(
      DartNSStringEncodingDetectionOptionsKey value) {
    objc.NSString.castFromPointer(
            _NSStringEncodingDetectionLikelyLanguageKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSStringEncodingDetectionLikelyLanguageKey.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSCharacterConversionException =
      _lookup<NSExceptionName>('NSCharacterConversionException');

  DartNSExceptionName get NSCharacterConversionException =>
      objc.NSString.castFromPointer(_NSCharacterConversionException.value,
          retain: true, release: true);

  set NSCharacterConversionException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSCharacterConversionException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSCharacterConversionException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSParseErrorException =
      _lookup<NSExceptionName>('NSParseErrorException');

  DartNSExceptionName get NSParseErrorException =>
      objc.NSString.castFromPointer(_NSParseErrorException.value,
          retain: true, release: true);

  set NSParseErrorException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSParseErrorException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSParseErrorException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSHTTPPropertyStatusCodeKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSHTTPPropertyStatusCodeKey');

  objc.NSString get NSHTTPPropertyStatusCodeKey =>
      objc.NSString.castFromPointer(_NSHTTPPropertyStatusCodeKey.value,
          retain: true, release: true);

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSHTTPPropertyStatusReasonKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSHTTPPropertyStatusReasonKey');

  objc.NSString get NSHTTPPropertyStatusReasonKey =>
      objc.NSString.castFromPointer(_NSHTTPPropertyStatusReasonKey.value,
          retain: true, release: true);

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSHTTPPropertyServerHTTPVersionKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>(
          'NSHTTPPropertyServerHTTPVersionKey');

  objc.NSString get NSHTTPPropertyServerHTTPVersionKey =>
      objc.NSString.castFromPointer(_NSHTTPPropertyServerHTTPVersionKey.value,
          retain: true, release: true);

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSHTTPPropertyRedirectionHeadersKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>(
          'NSHTTPPropertyRedirectionHeadersKey');

  objc.NSString get NSHTTPPropertyRedirectionHeadersKey =>
      objc.NSString.castFromPointer(_NSHTTPPropertyRedirectionHeadersKey.value,
          retain: true, release: true);

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSHTTPPropertyErrorPageDataKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSHTTPPropertyErrorPageDataKey');

  objc.NSString get NSHTTPPropertyErrorPageDataKey =>
      objc.NSString.castFromPointer(_NSHTTPPropertyErrorPageDataKey.value,
          retain: true, release: true);

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSHTTPPropertyHTTPProxy =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSHTTPPropertyHTTPProxy');

  objc.NSString get NSHTTPPropertyHTTPProxy =>
      objc.NSString.castFromPointer(_NSHTTPPropertyHTTPProxy.value,
          retain: true, release: true);

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSFTPPropertyUserLoginKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSFTPPropertyUserLoginKey');

  objc.NSString get NSFTPPropertyUserLoginKey =>
      objc.NSString.castFromPointer(_NSFTPPropertyUserLoginKey.value,
          retain: true, release: true);

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSFTPPropertyUserPasswordKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSFTPPropertyUserPasswordKey');

  objc.NSString get NSFTPPropertyUserPasswordKey =>
      objc.NSString.castFromPointer(_NSFTPPropertyUserPasswordKey.value,
          retain: true, release: true);

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSFTPPropertyActiveTransferModeKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>(
          'NSFTPPropertyActiveTransferModeKey');

  objc.NSString get NSFTPPropertyActiveTransferModeKey =>
      objc.NSString.castFromPointer(_NSFTPPropertyActiveTransferModeKey.value,
          retain: true, release: true);

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _NSFTPPropertyFileOffsetKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSFTPPropertyFileOffsetKey');

  objc.NSString get NSFTPPropertyFileOffsetKey =>
      objc.NSString.castFromPointer(_NSFTPPropertyFileOffsetKey.value,
          retain: true, release: true);

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>> _NSFTPPropertyFTPProxy =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSFTPPropertyFTPProxy');

  objc.NSString get NSFTPPropertyFTPProxy =>
      objc.NSString.castFromPointer(_NSFTPPropertyFTPProxy.value,
          retain: true, release: true);

  /// A string constant for the "file" URL scheme. If you are using this to compare to a URL's scheme to see if it is a file URL, you should instead use the NSURL fileURL property -- the fileURL property is much faster.
  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>> _NSURLFileScheme =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSURLFileScheme');

  objc.NSString get NSURLFileScheme =>
      objc.NSString.castFromPointer(_NSURLFileScheme.value,
          retain: true, release: true);

  set NSURLFileScheme(objc.NSString value) {
    objc.NSString.castFromPointer(_NSURLFileScheme.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileScheme.value = value.ref.retainAndReturnPointer();
  }

  /// Key for the resource properties that have not been set after setResourceValues:error: returns an error, returned as an array of of strings.
  late final ffi.Pointer<NSURLResourceKey> _NSURLKeysOfUnsetValuesKey =
      _lookup<NSURLResourceKey>('NSURLKeysOfUnsetValuesKey');

  DartNSURLResourceKey get NSURLKeysOfUnsetValuesKey =>
      objc.NSString.castFromPointer(_NSURLKeysOfUnsetValuesKey.value,
          retain: true, release: true);

  set NSURLKeysOfUnsetValuesKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLKeysOfUnsetValuesKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLKeysOfUnsetValuesKey.value = value.ref.retainAndReturnPointer();
  }

  /// The resource name provided by the file system (Read-write, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLNameKey =
      _lookup<NSURLResourceKey>('NSURLNameKey');

  DartNSURLResourceKey get NSURLNameKey =>
      objc.NSString.castFromPointer(_NSURLNameKey.value,
          retain: true, release: true);

  set NSURLNameKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLNameKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLNameKey.value = value.ref.retainAndReturnPointer();
  }

  /// Localized or extension-hidden name as displayed to users (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLocalizedNameKey =
      _lookup<NSURLResourceKey>('NSURLLocalizedNameKey');

  DartNSURLResourceKey get NSURLLocalizedNameKey =>
      objc.NSString.castFromPointer(_NSURLLocalizedNameKey.value,
          retain: true, release: true);

  set NSURLLocalizedNameKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLLocalizedNameKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLLocalizedNameKey.value = value.ref.retainAndReturnPointer();
  }

  /// True for regular files (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsRegularFileKey =
      _lookup<NSURLResourceKey>('NSURLIsRegularFileKey');

  DartNSURLResourceKey get NSURLIsRegularFileKey =>
      objc.NSString.castFromPointer(_NSURLIsRegularFileKey.value,
          retain: true, release: true);

  set NSURLIsRegularFileKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsRegularFileKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsRegularFileKey.value = value.ref.retainAndReturnPointer();
  }

  /// True for directories (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsDirectoryKey =
      _lookup<NSURLResourceKey>('NSURLIsDirectoryKey');

  DartNSURLResourceKey get NSURLIsDirectoryKey =>
      objc.NSString.castFromPointer(_NSURLIsDirectoryKey.value,
          retain: true, release: true);

  set NSURLIsDirectoryKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsDirectoryKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsDirectoryKey.value = value.ref.retainAndReturnPointer();
  }

  /// True for symlinks (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsSymbolicLinkKey =
      _lookup<NSURLResourceKey>('NSURLIsSymbolicLinkKey');

  DartNSURLResourceKey get NSURLIsSymbolicLinkKey =>
      objc.NSString.castFromPointer(_NSURLIsSymbolicLinkKey.value,
          retain: true, release: true);

  set NSURLIsSymbolicLinkKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsSymbolicLinkKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsSymbolicLinkKey.value = value.ref.retainAndReturnPointer();
  }

  /// True for the root directory of a volume (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsVolumeKey =
      _lookup<NSURLResourceKey>('NSURLIsVolumeKey');

  DartNSURLResourceKey get NSURLIsVolumeKey =>
      objc.NSString.castFromPointer(_NSURLIsVolumeKey.value,
          retain: true, release: true);

  set NSURLIsVolumeKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsVolumeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsVolumeKey.value = value.ref.retainAndReturnPointer();
  }

  /// True for packaged directories (Read-only 10_6 and 10_7, read-write 10_8, value type boolean NSNumber). Note: You can only set or clear this property on directories; if you try to set this property on non-directory objects, the property is ignored. If the directory is a package for some other reason (extension type, etc), setting this property to false will have no effect.
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsPackageKey =
      _lookup<NSURLResourceKey>('NSURLIsPackageKey');

  DartNSURLResourceKey get NSURLIsPackageKey =>
      objc.NSString.castFromPointer(_NSURLIsPackageKey.value,
          retain: true, release: true);

  set NSURLIsPackageKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsPackageKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsPackageKey.value = value.ref.retainAndReturnPointer();
  }

  /// True if resource is an application (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsApplicationKey =
      _lookup<NSURLResourceKey>('NSURLIsApplicationKey');

  DartNSURLResourceKey get NSURLIsApplicationKey =>
      objc.NSString.castFromPointer(_NSURLIsApplicationKey.value,
          retain: true, release: true);

  set NSURLIsApplicationKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsApplicationKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsApplicationKey.value = value.ref.retainAndReturnPointer();
  }

  /// True if the resource is scriptable. Only applies to applications (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLApplicationIsScriptableKey =
      _lookup<NSURLResourceKey>('NSURLApplicationIsScriptableKey');

  DartNSURLResourceKey get NSURLApplicationIsScriptableKey =>
      objc.NSString.castFromPointer(_NSURLApplicationIsScriptableKey.value,
          retain: true, release: true);

  set NSURLApplicationIsScriptableKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLApplicationIsScriptableKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLApplicationIsScriptableKey.value = value.ref.retainAndReturnPointer();
  }

  /// True for system-immutable resources (Read-write, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsSystemImmutableKey =
      _lookup<NSURLResourceKey>('NSURLIsSystemImmutableKey');

  DartNSURLResourceKey get NSURLIsSystemImmutableKey =>
      objc.NSString.castFromPointer(_NSURLIsSystemImmutableKey.value,
          retain: true, release: true);

  set NSURLIsSystemImmutableKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsSystemImmutableKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsSystemImmutableKey.value = value.ref.retainAndReturnPointer();
  }

  /// True for user-immutable resources (Read-write, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsUserImmutableKey =
      _lookup<NSURLResourceKey>('NSURLIsUserImmutableKey');

  DartNSURLResourceKey get NSURLIsUserImmutableKey =>
      objc.NSString.castFromPointer(_NSURLIsUserImmutableKey.value,
          retain: true, release: true);

  set NSURLIsUserImmutableKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsUserImmutableKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsUserImmutableKey.value = value.ref.retainAndReturnPointer();
  }

  /// True for resources normally not displayed to users (Read-write, value type boolean NSNumber). Note: If the resource is a hidden because its name starts with a period, setting this property to false will not change the property.
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsHiddenKey =
      _lookup<NSURLResourceKey>('NSURLIsHiddenKey');

  DartNSURLResourceKey get NSURLIsHiddenKey =>
      objc.NSString.castFromPointer(_NSURLIsHiddenKey.value,
          retain: true, release: true);

  set NSURLIsHiddenKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsHiddenKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsHiddenKey.value = value.ref.retainAndReturnPointer();
  }

  /// True for resources whose filename extension is removed from the localized name property (Read-write, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLHasHiddenExtensionKey =
      _lookup<NSURLResourceKey>('NSURLHasHiddenExtensionKey');

  DartNSURLResourceKey get NSURLHasHiddenExtensionKey =>
      objc.NSString.castFromPointer(_NSURLHasHiddenExtensionKey.value,
          retain: true, release: true);

  set NSURLHasHiddenExtensionKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLHasHiddenExtensionKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLHasHiddenExtensionKey.value = value.ref.retainAndReturnPointer();
  }

  /// The date the resource was created (Read-write, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLCreationDateKey =
      _lookup<NSURLResourceKey>('NSURLCreationDateKey');

  DartNSURLResourceKey get NSURLCreationDateKey =>
      objc.NSString.castFromPointer(_NSURLCreationDateKey.value,
          retain: true, release: true);

  set NSURLCreationDateKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLCreationDateKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLCreationDateKey.value = value.ref.retainAndReturnPointer();
  }

  /// The date the resource was last accessed (Read-write, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLContentAccessDateKey =
      _lookup<NSURLResourceKey>('NSURLContentAccessDateKey');

  DartNSURLResourceKey get NSURLContentAccessDateKey =>
      objc.NSString.castFromPointer(_NSURLContentAccessDateKey.value,
          retain: true, release: true);

  set NSURLContentAccessDateKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLContentAccessDateKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLContentAccessDateKey.value = value.ref.retainAndReturnPointer();
  }

  /// The time the resource content was last modified (Read-write, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLContentModificationDateKey =
      _lookup<NSURLResourceKey>('NSURLContentModificationDateKey');

  DartNSURLResourceKey get NSURLContentModificationDateKey =>
      objc.NSString.castFromPointer(_NSURLContentModificationDateKey.value,
          retain: true, release: true);

  set NSURLContentModificationDateKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLContentModificationDateKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLContentModificationDateKey.value = value.ref.retainAndReturnPointer();
  }

  /// The time the resource's attributes were last modified (Read-only, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLAttributeModificationDateKey =
      _lookup<NSURLResourceKey>('NSURLAttributeModificationDateKey');

  DartNSURLResourceKey get NSURLAttributeModificationDateKey =>
      objc.NSString.castFromPointer(_NSURLAttributeModificationDateKey.value,
          retain: true, release: true);

  set NSURLAttributeModificationDateKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLAttributeModificationDateKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLAttributeModificationDateKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// Number of hard links to the resource (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLinkCountKey =
      _lookup<NSURLResourceKey>('NSURLLinkCountKey');

  DartNSURLResourceKey get NSURLLinkCountKey =>
      objc.NSString.castFromPointer(_NSURLLinkCountKey.value,
          retain: true, release: true);

  set NSURLLinkCountKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLLinkCountKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLLinkCountKey.value = value.ref.retainAndReturnPointer();
  }

  /// The resource's parent directory, if any (Read-only, value type NSURL)
  late final ffi.Pointer<NSURLResourceKey> _NSURLParentDirectoryURLKey =
      _lookup<NSURLResourceKey>('NSURLParentDirectoryURLKey');

  DartNSURLResourceKey get NSURLParentDirectoryURLKey =>
      objc.NSString.castFromPointer(_NSURLParentDirectoryURLKey.value,
          retain: true, release: true);

  set NSURLParentDirectoryURLKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLParentDirectoryURLKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLParentDirectoryURLKey.value = value.ref.retainAndReturnPointer();
  }

  /// URL of the volume on which the resource is stored (Read-only, value type NSURL)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeURLKey =
      _lookup<NSURLResourceKey>('NSURLVolumeURLKey');

  DartNSURLResourceKey get NSURLVolumeURLKey =>
      objc.NSString.castFromPointer(_NSURLVolumeURLKey.value,
          retain: true, release: true);

  set NSURLVolumeURLKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeURLKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeURLKey.value = value.ref.retainAndReturnPointer();
  }

  /// Uniform type identifier (UTI) for the resource (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLTypeIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLTypeIdentifierKey');

  DartNSURLResourceKey get NSURLTypeIdentifierKey =>
      objc.NSString.castFromPointer(_NSURLTypeIdentifierKey.value,
          retain: true, release: true);

  set NSURLTypeIdentifierKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLTypeIdentifierKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLTypeIdentifierKey.value = value.ref.retainAndReturnPointer();
  }

  /// File type (UTType) for the resource (Read-only, value type UTType)
  late final ffi.Pointer<NSURLResourceKey> _NSURLContentTypeKey =
      _lookup<NSURLResourceKey>('NSURLContentTypeKey');

  DartNSURLResourceKey get NSURLContentTypeKey =>
      objc.NSString.castFromPointer(_NSURLContentTypeKey.value,
          retain: true, release: true);

  set NSURLContentTypeKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLContentTypeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLContentTypeKey.value = value.ref.retainAndReturnPointer();
  }

  /// User-visible type or "kind" description (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLocalizedTypeDescriptionKey =
      _lookup<NSURLResourceKey>('NSURLLocalizedTypeDescriptionKey');

  DartNSURLResourceKey get NSURLLocalizedTypeDescriptionKey =>
      objc.NSString.castFromPointer(_NSURLLocalizedTypeDescriptionKey.value,
          retain: true, release: true);

  set NSURLLocalizedTypeDescriptionKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLLocalizedTypeDescriptionKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLLocalizedTypeDescriptionKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// The label number assigned to the resource (Read-write, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLabelNumberKey =
      _lookup<NSURLResourceKey>('NSURLLabelNumberKey');

  DartNSURLResourceKey get NSURLLabelNumberKey =>
      objc.NSString.castFromPointer(_NSURLLabelNumberKey.value,
          retain: true, release: true);

  set NSURLLabelNumberKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLLabelNumberKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLLabelNumberKey.value = value.ref.retainAndReturnPointer();
  }

  /// The color of the assigned label (Read-only, value type NSColor)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLabelColorKey =
      _lookup<NSURLResourceKey>('NSURLLabelColorKey');

  DartNSURLResourceKey get NSURLLabelColorKey =>
      objc.NSString.castFromPointer(_NSURLLabelColorKey.value,
          retain: true, release: true);

  set NSURLLabelColorKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLLabelColorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLLabelColorKey.value = value.ref.retainAndReturnPointer();
  }

  /// The user-visible label text (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLLocalizedLabelKey =
      _lookup<NSURLResourceKey>('NSURLLocalizedLabelKey');

  DartNSURLResourceKey get NSURLLocalizedLabelKey =>
      objc.NSString.castFromPointer(_NSURLLocalizedLabelKey.value,
          retain: true, release: true);

  set NSURLLocalizedLabelKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLLocalizedLabelKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLLocalizedLabelKey.value = value.ref.retainAndReturnPointer();
  }

  /// The icon normally displayed for the resource (Read-only, value type NSImage)
  late final ffi.Pointer<NSURLResourceKey> _NSURLEffectiveIconKey =
      _lookup<NSURLResourceKey>('NSURLEffectiveIconKey');

  DartNSURLResourceKey get NSURLEffectiveIconKey =>
      objc.NSString.castFromPointer(_NSURLEffectiveIconKey.value,
          retain: true, release: true);

  set NSURLEffectiveIconKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLEffectiveIconKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLEffectiveIconKey.value = value.ref.retainAndReturnPointer();
  }

  /// The custom icon assigned to the resource, if any (Currently not implemented, value type NSImage)
  late final ffi.Pointer<NSURLResourceKey> _NSURLCustomIconKey =
      _lookup<NSURLResourceKey>('NSURLCustomIconKey');

  DartNSURLResourceKey get NSURLCustomIconKey =>
      objc.NSString.castFromPointer(_NSURLCustomIconKey.value,
          retain: true, release: true);

  set NSURLCustomIconKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLCustomIconKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLCustomIconKey.value = value.ref.retainAndReturnPointer();
  }

  /// An identifier which can be used to compare two file system objects for equality using -isEqual (i.e, two object identifiers are equal if they have the same file system path or if the paths are linked to same inode on the same file system). This identifier is not persistent across system restarts. (Read-only, value type id <NSCopying, NSCoding, NSSecureCoding, NSObject>)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileResourceIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLFileResourceIdentifierKey');

  DartNSURLResourceKey get NSURLFileResourceIdentifierKey =>
      objc.NSString.castFromPointer(_NSURLFileResourceIdentifierKey.value,
          retain: true, release: true);

  set NSURLFileResourceIdentifierKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLFileResourceIdentifierKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileResourceIdentifierKey.value = value.ref.retainAndReturnPointer();
  }

  /// An identifier that can be used to identify the volume the file system object is on. Other objects on the same volume will have the same volume identifier and can be compared using for equality using -isEqual. This identifier is not persistent across system restarts. (Read-only, value type id <NSCopying, NSCoding, NSSecureCoding, NSObject>)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIdentifierKey');

  DartNSURLResourceKey get NSURLVolumeIdentifierKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIdentifierKey.value,
          retain: true, release: true);

  set NSURLVolumeIdentifierKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIdentifierKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIdentifierKey.value = value.ref.retainAndReturnPointer();
  }

  /// The optimal block size when reading or writing this file's data, or nil if not available. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLPreferredIOBlockSizeKey =
      _lookup<NSURLResourceKey>('NSURLPreferredIOBlockSizeKey');

  DartNSURLResourceKey get NSURLPreferredIOBlockSizeKey =>
      objc.NSString.castFromPointer(_NSURLPreferredIOBlockSizeKey.value,
          retain: true, release: true);

  set NSURLPreferredIOBlockSizeKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLPreferredIOBlockSizeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLPreferredIOBlockSizeKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if this process (as determined by EUID) can read the resource. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsReadableKey =
      _lookup<NSURLResourceKey>('NSURLIsReadableKey');

  DartNSURLResourceKey get NSURLIsReadableKey =>
      objc.NSString.castFromPointer(_NSURLIsReadableKey.value,
          retain: true, release: true);

  set NSURLIsReadableKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsReadableKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsReadableKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if this process (as determined by EUID) can write to the resource. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsWritableKey =
      _lookup<NSURLResourceKey>('NSURLIsWritableKey');

  DartNSURLResourceKey get NSURLIsWritableKey =>
      objc.NSString.castFromPointer(_NSURLIsWritableKey.value,
          retain: true, release: true);

  set NSURLIsWritableKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsWritableKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsWritableKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if this process (as determined by EUID) can execute a file resource or search a directory resource. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsExecutableKey =
      _lookup<NSURLResourceKey>('NSURLIsExecutableKey');

  DartNSURLResourceKey get NSURLIsExecutableKey =>
      objc.NSString.castFromPointer(_NSURLIsExecutableKey.value,
          retain: true, release: true);

  set NSURLIsExecutableKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsExecutableKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsExecutableKey.value = value.ref.retainAndReturnPointer();
  }

  /// The file system object's security information encapsulated in a NSFileSecurity object. (Read-write, Value type NSFileSecurity)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileSecurityKey =
      _lookup<NSURLResourceKey>('NSURLFileSecurityKey');

  DartNSURLResourceKey get NSURLFileSecurityKey =>
      objc.NSString.castFromPointer(_NSURLFileSecurityKey.value,
          retain: true, release: true);

  set NSURLFileSecurityKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLFileSecurityKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileSecurityKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if resource should be excluded from backups, false otherwise (Read-write, value type boolean NSNumber). This property is only useful for excluding cache and other application support files which are not needed in a backup. Some operations commonly made to user documents will cause this property to be reset to false and so this property should not be used on user documents.
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsExcludedFromBackupKey =
      _lookup<NSURLResourceKey>('NSURLIsExcludedFromBackupKey');

  DartNSURLResourceKey get NSURLIsExcludedFromBackupKey =>
      objc.NSString.castFromPointer(_NSURLIsExcludedFromBackupKey.value,
          retain: true, release: true);

  set NSURLIsExcludedFromBackupKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsExcludedFromBackupKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsExcludedFromBackupKey.value = value.ref.retainAndReturnPointer();
  }

  /// The array of Tag names (Read-write, value type NSArray of NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLTagNamesKey =
      _lookup<NSURLResourceKey>('NSURLTagNamesKey');

  DartNSURLResourceKey get NSURLTagNamesKey =>
      objc.NSString.castFromPointer(_NSURLTagNamesKey.value,
          retain: true, release: true);

  set NSURLTagNamesKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLTagNamesKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLTagNamesKey.value = value.ref.retainAndReturnPointer();
  }

  /// the URL's path as a file system path (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLPathKey =
      _lookup<NSURLResourceKey>('NSURLPathKey');

  DartNSURLResourceKey get NSURLPathKey =>
      objc.NSString.castFromPointer(_NSURLPathKey.value,
          retain: true, release: true);

  set NSURLPathKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLPathKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLPathKey.value = value.ref.retainAndReturnPointer();
  }

  /// the URL's path as a canonical absolute file system path (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLCanonicalPathKey =
      _lookup<NSURLResourceKey>('NSURLCanonicalPathKey');

  DartNSURLResourceKey get NSURLCanonicalPathKey =>
      objc.NSString.castFromPointer(_NSURLCanonicalPathKey.value,
          retain: true, release: true);

  set NSURLCanonicalPathKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLCanonicalPathKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLCanonicalPathKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if this URL is a file system trigger directory. Traversing or opening a file system trigger will cause an attempt to mount a file system on the trigger directory. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsMountTriggerKey =
      _lookup<NSURLResourceKey>('NSURLIsMountTriggerKey');

  DartNSURLResourceKey get NSURLIsMountTriggerKey =>
      objc.NSString.castFromPointer(_NSURLIsMountTriggerKey.value,
          retain: true, release: true);

  set NSURLIsMountTriggerKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsMountTriggerKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsMountTriggerKey.value = value.ref.retainAndReturnPointer();
  }

  /// An opaque generation identifier which can be compared using isEqual: to determine if the data in a document has been modified. For URLs which refer to the same file inode, the generation identifier will change when the data in the file's data fork is changed (changes to extended attributes or other file system metadata do not change the generation identifier). For URLs which refer to the same directory inode, the generation identifier will change when direct children of that directory are added, removed or renamed (changes to the data of the direct children of that directory will not change the generation identifier). The generation identifier is persistent across system restarts. The generation identifier is tied to a specific document on a specific volume and is not transferred when the document is copied to another volume. This property is not supported by all volumes. (Read-only, value type id <NSCopying, NSCoding, NSSecureCoding, NSObject>)
  late final ffi.Pointer<NSURLResourceKey> _NSURLGenerationIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLGenerationIdentifierKey');

  DartNSURLResourceKey get NSURLGenerationIdentifierKey =>
      objc.NSString.castFromPointer(_NSURLGenerationIdentifierKey.value,
          retain: true, release: true);

  set NSURLGenerationIdentifierKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLGenerationIdentifierKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLGenerationIdentifierKey.value = value.ref.retainAndReturnPointer();
  }

  /// The document identifier -- a value assigned by the kernel to a document (which can be either a file or directory) and is used to identify the document regardless of where it gets moved on a volume. The document identifier survives "safe save” operations; i.e it is sticky to the path it was assigned to (-replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error: is the preferred safe-save API). The document identifier is persistent across system restarts. The document identifier is not transferred when the file is copied. Document identifiers are only unique within a single volume. This property is not supported by all volumes. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLDocumentIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLDocumentIdentifierKey');

  DartNSURLResourceKey get NSURLDocumentIdentifierKey =>
      objc.NSString.castFromPointer(_NSURLDocumentIdentifierKey.value,
          retain: true, release: true);

  set NSURLDocumentIdentifierKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLDocumentIdentifierKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLDocumentIdentifierKey.value = value.ref.retainAndReturnPointer();
  }

  /// The date the resource was created, or renamed into or within its parent directory. Note that inconsistent behavior may be observed when this attribute is requested on hard-linked items. This property is not supported by all volumes. (Read-only before macOS 10.15, iOS 13.0, watchOS 6.0, and tvOS 13.0; Read-write after, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLAddedToDirectoryDateKey =
      _lookup<NSURLResourceKey>('NSURLAddedToDirectoryDateKey');

  DartNSURLResourceKey get NSURLAddedToDirectoryDateKey =>
      objc.NSString.castFromPointer(_NSURLAddedToDirectoryDateKey.value,
          retain: true, release: true);

  set NSURLAddedToDirectoryDateKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLAddedToDirectoryDateKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLAddedToDirectoryDateKey.value = value.ref.retainAndReturnPointer();
  }

  /// The quarantine properties as defined in LSQuarantine.h. To remove quarantine information from a file, pass NSNull as the value when setting this property. (Read-write, value type NSDictionary)
  late final ffi.Pointer<NSURLResourceKey> _NSURLQuarantinePropertiesKey =
      _lookup<NSURLResourceKey>('NSURLQuarantinePropertiesKey');

  DartNSURLResourceKey get NSURLQuarantinePropertiesKey =>
      objc.NSString.castFromPointer(_NSURLQuarantinePropertiesKey.value,
          retain: true, release: true);

  set NSURLQuarantinePropertiesKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLQuarantinePropertiesKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLQuarantinePropertiesKey.value = value.ref.retainAndReturnPointer();
  }

  /// Returns the file system object type. (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileResourceTypeKey =
      _lookup<NSURLResourceKey>('NSURLFileResourceTypeKey');

  DartNSURLResourceKey get NSURLFileResourceTypeKey =>
      objc.NSString.castFromPointer(_NSURLFileResourceTypeKey.value,
          retain: true, release: true);

  set NSURLFileResourceTypeKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLFileResourceTypeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileResourceTypeKey.value = value.ref.retainAndReturnPointer();
  }

  /// The file system's internal inode identifier for the item. This value is not stable for all file systems or across all mounts, so it should be used sparingly and not persisted. It is useful, for example, to match URLs from the URL enumerator with paths from FSEvents. (Read-only, value type NSNumber containing an unsigned long long).
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLFileIdentifierKey');

  DartNSURLResourceKey get NSURLFileIdentifierKey =>
      objc.NSString.castFromPointer(_NSURLFileIdentifierKey.value,
          retain: true, release: true);

  set NSURLFileIdentifierKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLFileIdentifierKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileIdentifierKey.value = value.ref.retainAndReturnPointer();
  }

  /// A 64-bit value assigned by APFS that identifies a file's content data stream. Only cloned files and their originals can have the same identifier. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileContentIdentifierKey =
      _lookup<NSURLResourceKey>('NSURLFileContentIdentifierKey');

  DartNSURLResourceKey get NSURLFileContentIdentifierKey =>
      objc.NSString.castFromPointer(_NSURLFileContentIdentifierKey.value,
          retain: true, release: true);

  set NSURLFileContentIdentifierKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLFileContentIdentifierKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileContentIdentifierKey.value = value.ref.retainAndReturnPointer();
  }

  /// True for cloned files and their originals that may share all, some, or no data blocks. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLMayShareFileContentKey =
      _lookup<NSURLResourceKey>('NSURLMayShareFileContentKey');

  DartNSURLResourceKey get NSURLMayShareFileContentKey =>
      objc.NSString.castFromPointer(_NSURLMayShareFileContentKey.value,
          retain: true, release: true);

  set NSURLMayShareFileContentKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLMayShareFileContentKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLMayShareFileContentKey.value = value.ref.retainAndReturnPointer();
  }

  /// True if the file has extended attributes. False guarantees there are none. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLMayHaveExtendedAttributesKey =
      _lookup<NSURLResourceKey>('NSURLMayHaveExtendedAttributesKey');

  DartNSURLResourceKey get NSURLMayHaveExtendedAttributesKey =>
      objc.NSString.castFromPointer(_NSURLMayHaveExtendedAttributesKey.value,
          retain: true, release: true);

  set NSURLMayHaveExtendedAttributesKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLMayHaveExtendedAttributesKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLMayHaveExtendedAttributesKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// True if the file can be deleted by the file system when asked to free space. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsPurgeableKey =
      _lookup<NSURLResourceKey>('NSURLIsPurgeableKey');

  DartNSURLResourceKey get NSURLIsPurgeableKey =>
      objc.NSString.castFromPointer(_NSURLIsPurgeableKey.value,
          retain: true, release: true);

  set NSURLIsPurgeableKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsPurgeableKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsPurgeableKey.value = value.ref.retainAndReturnPointer();
  }

  /// True if the file has sparse regions. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsSparseKey =
      _lookup<NSURLResourceKey>('NSURLIsSparseKey');

  DartNSURLResourceKey get NSURLIsSparseKey =>
      objc.NSString.castFromPointer(_NSURLIsSparseKey.value,
          retain: true, release: true);

  set NSURLIsSparseKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsSparseKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsSparseKey.value = value.ref.retainAndReturnPointer();
  }

  /// The file system object type values returned for the NSURLFileResourceTypeKey
  late final ffi.Pointer<NSURLFileResourceType>
      _NSURLFileResourceTypeNamedPipe =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeNamedPipe');

  DartNSURLFileResourceType get NSURLFileResourceTypeNamedPipe =>
      objc.NSString.castFromPointer(_NSURLFileResourceTypeNamedPipe.value,
          retain: true, release: true);

  set NSURLFileResourceTypeNamedPipe(DartNSURLFileResourceType value) {
    objc.NSString.castFromPointer(_NSURLFileResourceTypeNamedPipe.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileResourceTypeNamedPipe.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSURLFileResourceType>
      _NSURLFileResourceTypeCharacterSpecial =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeCharacterSpecial');

  DartNSURLFileResourceType get NSURLFileResourceTypeCharacterSpecial =>
      objc.NSString.castFromPointer(
          _NSURLFileResourceTypeCharacterSpecial.value,
          retain: true,
          release: true);

  set NSURLFileResourceTypeCharacterSpecial(DartNSURLFileResourceType value) {
    objc.NSString.castFromPointer(_NSURLFileResourceTypeCharacterSpecial.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileResourceTypeCharacterSpecial.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSURLFileResourceType>
      _NSURLFileResourceTypeDirectory =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeDirectory');

  DartNSURLFileResourceType get NSURLFileResourceTypeDirectory =>
      objc.NSString.castFromPointer(_NSURLFileResourceTypeDirectory.value,
          retain: true, release: true);

  set NSURLFileResourceTypeDirectory(DartNSURLFileResourceType value) {
    objc.NSString.castFromPointer(_NSURLFileResourceTypeDirectory.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileResourceTypeDirectory.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSURLFileResourceType>
      _NSURLFileResourceTypeBlockSpecial =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeBlockSpecial');

  DartNSURLFileResourceType get NSURLFileResourceTypeBlockSpecial =>
      objc.NSString.castFromPointer(_NSURLFileResourceTypeBlockSpecial.value,
          retain: true, release: true);

  set NSURLFileResourceTypeBlockSpecial(DartNSURLFileResourceType value) {
    objc.NSString.castFromPointer(_NSURLFileResourceTypeBlockSpecial.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileResourceTypeBlockSpecial.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSURLFileResourceType> _NSURLFileResourceTypeRegular =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeRegular');

  DartNSURLFileResourceType get NSURLFileResourceTypeRegular =>
      objc.NSString.castFromPointer(_NSURLFileResourceTypeRegular.value,
          retain: true, release: true);

  set NSURLFileResourceTypeRegular(DartNSURLFileResourceType value) {
    objc.NSString.castFromPointer(_NSURLFileResourceTypeRegular.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileResourceTypeRegular.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSURLFileResourceType>
      _NSURLFileResourceTypeSymbolicLink =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeSymbolicLink');

  DartNSURLFileResourceType get NSURLFileResourceTypeSymbolicLink =>
      objc.NSString.castFromPointer(_NSURLFileResourceTypeSymbolicLink.value,
          retain: true, release: true);

  set NSURLFileResourceTypeSymbolicLink(DartNSURLFileResourceType value) {
    objc.NSString.castFromPointer(_NSURLFileResourceTypeSymbolicLink.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileResourceTypeSymbolicLink.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSURLFileResourceType> _NSURLFileResourceTypeSocket =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeSocket');

  DartNSURLFileResourceType get NSURLFileResourceTypeSocket =>
      objc.NSString.castFromPointer(_NSURLFileResourceTypeSocket.value,
          retain: true, release: true);

  set NSURLFileResourceTypeSocket(DartNSURLFileResourceType value) {
    objc.NSString.castFromPointer(_NSURLFileResourceTypeSocket.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileResourceTypeSocket.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSURLFileResourceType> _NSURLFileResourceTypeUnknown =
      _lookup<NSURLFileResourceType>('NSURLFileResourceTypeUnknown');

  DartNSURLFileResourceType get NSURLFileResourceTypeUnknown =>
      objc.NSString.castFromPointer(_NSURLFileResourceTypeUnknown.value,
          retain: true, release: true);

  set NSURLFileResourceTypeUnknown(DartNSURLFileResourceType value) {
    objc.NSString.castFromPointer(_NSURLFileResourceTypeUnknown.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileResourceTypeUnknown.value = value.ref.retainAndReturnPointer();
  }

  /// dictionary of NSImage/UIImage objects keyed by size
  late final ffi.Pointer<NSURLResourceKey> _NSURLThumbnailDictionaryKey =
      _lookup<NSURLResourceKey>('NSURLThumbnailDictionaryKey');

  DartNSURLResourceKey get NSURLThumbnailDictionaryKey =>
      objc.NSString.castFromPointer(_NSURLThumbnailDictionaryKey.value,
          retain: true, release: true);

  set NSURLThumbnailDictionaryKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLThumbnailDictionaryKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLThumbnailDictionaryKey.value = value.ref.retainAndReturnPointer();
  }

  /// returns all thumbnails as a single NSImage
  late final ffi.Pointer<NSURLResourceKey> _NSURLThumbnailKey =
      _lookup<NSURLResourceKey>('NSURLThumbnailKey');

  DartNSURLResourceKey get NSURLThumbnailKey =>
      objc.NSString.castFromPointer(_NSURLThumbnailKey.value,
          retain: true, release: true);

  set NSURLThumbnailKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLThumbnailKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLThumbnailKey.value = value.ref.retainAndReturnPointer();
  }

  /// size key for a 1024 x 1024 thumbnail image
  late final ffi.Pointer<NSURLThumbnailDictionaryItem>
      _NSThumbnail1024x1024SizeKey =
      _lookup<NSURLThumbnailDictionaryItem>('NSThumbnail1024x1024SizeKey');

  DartNSURLThumbnailDictionaryItem get NSThumbnail1024x1024SizeKey =>
      objc.NSString.castFromPointer(_NSThumbnail1024x1024SizeKey.value,
          retain: true, release: true);

  set NSThumbnail1024x1024SizeKey(DartNSURLThumbnailDictionaryItem value) {
    objc.NSString.castFromPointer(_NSThumbnail1024x1024SizeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSThumbnail1024x1024SizeKey.value = value.ref.retainAndReturnPointer();
  }

  /// Total file size in bytes (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileSizeKey =
      _lookup<NSURLResourceKey>('NSURLFileSizeKey');

  DartNSURLResourceKey get NSURLFileSizeKey =>
      objc.NSString.castFromPointer(_NSURLFileSizeKey.value,
          retain: true, release: true);

  set NSURLFileSizeKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLFileSizeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileSizeKey.value = value.ref.retainAndReturnPointer();
  }

  /// Total size allocated on disk for the file in bytes (number of blocks times block size) (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileAllocatedSizeKey =
      _lookup<NSURLResourceKey>('NSURLFileAllocatedSizeKey');

  DartNSURLResourceKey get NSURLFileAllocatedSizeKey =>
      objc.NSString.castFromPointer(_NSURLFileAllocatedSizeKey.value,
          retain: true, release: true);

  set NSURLFileAllocatedSizeKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLFileAllocatedSizeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileAllocatedSizeKey.value = value.ref.retainAndReturnPointer();
  }

  /// Total displayable size of the file in bytes (this may include space used by metadata), or nil if not available. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLTotalFileSizeKey =
      _lookup<NSURLResourceKey>('NSURLTotalFileSizeKey');

  DartNSURLResourceKey get NSURLTotalFileSizeKey =>
      objc.NSString.castFromPointer(_NSURLTotalFileSizeKey.value,
          retain: true, release: true);

  set NSURLTotalFileSizeKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLTotalFileSizeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLTotalFileSizeKey.value = value.ref.retainAndReturnPointer();
  }

  /// Total allocated size of the file in bytes (this may include space used by metadata), or nil if not available. This can be less than the value returned by NSURLTotalFileSizeKey if the resource is compressed. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLTotalFileAllocatedSizeKey =
      _lookup<NSURLResourceKey>('NSURLTotalFileAllocatedSizeKey');

  DartNSURLResourceKey get NSURLTotalFileAllocatedSizeKey =>
      objc.NSString.castFromPointer(_NSURLTotalFileAllocatedSizeKey.value,
          retain: true, release: true);

  set NSURLTotalFileAllocatedSizeKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLTotalFileAllocatedSizeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLTotalFileAllocatedSizeKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the resource is a Finder alias file or a symlink, false otherwise ( Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsAliasFileKey =
      _lookup<NSURLResourceKey>('NSURLIsAliasFileKey');

  DartNSURLResourceKey get NSURLIsAliasFileKey =>
      objc.NSString.castFromPointer(_NSURLIsAliasFileKey.value,
          retain: true, release: true);

  set NSURLIsAliasFileKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsAliasFileKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsAliasFileKey.value = value.ref.retainAndReturnPointer();
  }

  /// The protection level for this file
  late final ffi.Pointer<NSURLResourceKey> _NSURLFileProtectionKey =
      _lookup<NSURLResourceKey>('NSURLFileProtectionKey');

  DartNSURLResourceKey get NSURLFileProtectionKey =>
      objc.NSString.castFromPointer(_NSURLFileProtectionKey.value,
          retain: true, release: true);

  set NSURLFileProtectionKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLFileProtectionKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileProtectionKey.value = value.ref.retainAndReturnPointer();
  }

  /// The file has no special protections associated with it. It can be read from or written to at any time.
  late final ffi.Pointer<NSURLFileProtectionType> _NSURLFileProtectionNone =
      _lookup<NSURLFileProtectionType>('NSURLFileProtectionNone');

  DartNSURLFileProtectionType get NSURLFileProtectionNone =>
      objc.NSString.castFromPointer(_NSURLFileProtectionNone.value,
          retain: true, release: true);

  set NSURLFileProtectionNone(DartNSURLFileProtectionType value) {
    objc.NSString.castFromPointer(_NSURLFileProtectionNone.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileProtectionNone.value = value.ref.retainAndReturnPointer();
  }

  /// The file is stored in an encrypted format on disk and cannot be read from or written to while the device is locked or booting. Transient data files with this protection type should be excluded from backups using NSURLIsExcludedFromBackupKey.
  late final ffi.Pointer<NSURLFileProtectionType> _NSURLFileProtectionComplete =
      _lookup<NSURLFileProtectionType>('NSURLFileProtectionComplete');

  DartNSURLFileProtectionType get NSURLFileProtectionComplete =>
      objc.NSString.castFromPointer(_NSURLFileProtectionComplete.value,
          retain: true, release: true);

  set NSURLFileProtectionComplete(DartNSURLFileProtectionType value) {
    objc.NSString.castFromPointer(_NSURLFileProtectionComplete.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileProtectionComplete.value = value.ref.retainAndReturnPointer();
  }

  /// The file is stored in an encrypted format on disk. Files can be created while the device is locked, but once closed, cannot be opened again until the device is unlocked. If the file is opened when unlocked, you may continue to access the file normally, even if the user locks the device. There is a small performance penalty when the file is created and opened, though not when being written to or read from. This can be mitigated by changing the file protection to NSURLFileProtectionComplete when the device is unlocked. Transient data files with this protection type should be excluded from backups using NSURLIsExcludedFromBackupKey.
  late final ffi.Pointer<NSURLFileProtectionType>
      _NSURLFileProtectionCompleteUnlessOpen =
      _lookup<NSURLFileProtectionType>('NSURLFileProtectionCompleteUnlessOpen');

  DartNSURLFileProtectionType get NSURLFileProtectionCompleteUnlessOpen =>
      objc.NSString.castFromPointer(
          _NSURLFileProtectionCompleteUnlessOpen.value,
          retain: true,
          release: true);

  set NSURLFileProtectionCompleteUnlessOpen(DartNSURLFileProtectionType value) {
    objc.NSString.castFromPointer(_NSURLFileProtectionCompleteUnlessOpen.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLFileProtectionCompleteUnlessOpen.value =
        value.ref.retainAndReturnPointer();
  }

  /// The file is stored in an encrypted format on disk and cannot be accessed until after the device has booted. After the user unlocks the device for the first time, your app can access the file and continue to access it even if the user subsequently locks the device.
  late final ffi.Pointer<NSURLFileProtectionType>
      _NSURLFileProtectionCompleteUntilFirstUserAuthentication =
      _lookup<NSURLFileProtectionType>(
          'NSURLFileProtectionCompleteUntilFirstUserAuthentication');

  DartNSURLFileProtectionType
      get NSURLFileProtectionCompleteUntilFirstUserAuthentication =>
          objc.NSString.castFromPointer(
              _NSURLFileProtectionCompleteUntilFirstUserAuthentication.value,
              retain: true,
              release: true);

  set NSURLFileProtectionCompleteUntilFirstUserAuthentication(
      DartNSURLFileProtectionType value) {
    objc.NSString.castFromPointer(
            _NSURLFileProtectionCompleteUntilFirstUserAuthentication.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLFileProtectionCompleteUntilFirstUserAuthentication.value =
        value.ref.retainAndReturnPointer();
  }

  /// The file is stored in an encrypted format on disk and cannot be accessed until after first unlock after the device has booted. After this first unlock, your app can access the file even while the device is locked until access expiry. Access is renewed once the user unlocks the device again.
  late final ffi.Pointer<NSURLFileProtectionType>
      _NSURLFileProtectionCompleteWhenUserInactive =
      _lookup<NSURLFileProtectionType>(
          'NSURLFileProtectionCompleteWhenUserInactive');

  DartNSURLFileProtectionType get NSURLFileProtectionCompleteWhenUserInactive =>
      objc.NSString.castFromPointer(
          _NSURLFileProtectionCompleteWhenUserInactive.value,
          retain: true,
          release: true);

  set NSURLFileProtectionCompleteWhenUserInactive(
      DartNSURLFileProtectionType value) {
    objc.NSString.castFromPointer(
            _NSURLFileProtectionCompleteWhenUserInactive.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLFileProtectionCompleteWhenUserInactive.value =
        value.ref.retainAndReturnPointer();
  }

  /// Returns the count of file system objects contained in the directory. This is a count of objects actually stored in the file system, so excludes virtual items like "." and "..". The property is useful for quickly identifying an empty directory for backup and syncing. If the URL is not a directory or the file system cannot cheaply compute the value, `nil` is returned. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLDirectoryEntryCountKey =
      _lookup<NSURLResourceKey>('NSURLDirectoryEntryCountKey');

  DartNSURLResourceKey get NSURLDirectoryEntryCountKey =>
      objc.NSString.castFromPointer(_NSURLDirectoryEntryCountKey.value,
          retain: true, release: true);

  set NSURLDirectoryEntryCountKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLDirectoryEntryCountKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLDirectoryEntryCountKey.value = value.ref.retainAndReturnPointer();
  }

  /// The user-visible volume format (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeLocalizedFormatDescriptionKey =
      _lookup<NSURLResourceKey>('NSURLVolumeLocalizedFormatDescriptionKey');

  DartNSURLResourceKey get NSURLVolumeLocalizedFormatDescriptionKey =>
      objc.NSString.castFromPointer(
          _NSURLVolumeLocalizedFormatDescriptionKey.value,
          retain: true,
          release: true);

  set NSURLVolumeLocalizedFormatDescriptionKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLVolumeLocalizedFormatDescriptionKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLVolumeLocalizedFormatDescriptionKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// Total volume capacity in bytes (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeTotalCapacityKey =
      _lookup<NSURLResourceKey>('NSURLVolumeTotalCapacityKey');

  DartNSURLResourceKey get NSURLVolumeTotalCapacityKey =>
      objc.NSString.castFromPointer(_NSURLVolumeTotalCapacityKey.value,
          retain: true, release: true);

  set NSURLVolumeTotalCapacityKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeTotalCapacityKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeTotalCapacityKey.value = value.ref.retainAndReturnPointer();
  }

  /// Total free space in bytes (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeAvailableCapacityKey =
      _lookup<NSURLResourceKey>('NSURLVolumeAvailableCapacityKey');

  DartNSURLResourceKey get NSURLVolumeAvailableCapacityKey =>
      objc.NSString.castFromPointer(_NSURLVolumeAvailableCapacityKey.value,
          retain: true, release: true);

  set NSURLVolumeAvailableCapacityKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeAvailableCapacityKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeAvailableCapacityKey.value = value.ref.retainAndReturnPointer();
  }

  /// Total number of resources on the volume (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeResourceCountKey =
      _lookup<NSURLResourceKey>('NSURLVolumeResourceCountKey');

  DartNSURLResourceKey get NSURLVolumeResourceCountKey =>
      objc.NSString.castFromPointer(_NSURLVolumeResourceCountKey.value,
          retain: true, release: true);

  set NSURLVolumeResourceCountKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeResourceCountKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeResourceCountKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume format supports persistent object identifiers and can look up file system objects by their IDs (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsPersistentIDsKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsPersistentIDsKey');

  DartNSURLResourceKey get NSURLVolumeSupportsPersistentIDsKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsPersistentIDsKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsPersistentIDsKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsPersistentIDsKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsPersistentIDsKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume format supports symbolic links (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsSymbolicLinksKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsSymbolicLinksKey');

  DartNSURLResourceKey get NSURLVolumeSupportsSymbolicLinksKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsSymbolicLinksKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsSymbolicLinksKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsSymbolicLinksKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsSymbolicLinksKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume format supports hard links (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsHardLinksKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsHardLinksKey');

  DartNSURLResourceKey get NSURLVolumeSupportsHardLinksKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsHardLinksKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsHardLinksKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsHardLinksKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsHardLinksKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume format supports a journal used to speed recovery in case of unplanned restart (such as a power outage or crash). This does not necessarily mean the volume is actively using a journal. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsJournalingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsJournalingKey');

  DartNSURLResourceKey get NSURLVolumeSupportsJournalingKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsJournalingKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsJournalingKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsJournalingKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsJournalingKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume is currently using a journal for speedy recovery after an unplanned restart. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsJournalingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsJournalingKey');

  DartNSURLResourceKey get NSURLVolumeIsJournalingKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIsJournalingKey.value,
          retain: true, release: true);

  set NSURLVolumeIsJournalingKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIsJournalingKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIsJournalingKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume format supports sparse files, that is, files which can have 'holes' that have never been written to, and thus do not consume space on disk. A sparse file may have an allocated size on disk that is less than its logical length (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsSparseFilesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsSparseFilesKey');

  DartNSURLResourceKey get NSURLVolumeSupportsSparseFilesKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsSparseFilesKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsSparseFilesKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsSparseFilesKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsSparseFilesKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// For security reasons, parts of a file (runs) that have never been written to must appear to contain zeroes. true if the volume keeps track of allocated but unwritten runs of a file so that it can substitute zeroes without actually writing zeroes to the media. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsZeroRunsKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsZeroRunsKey');

  DartNSURLResourceKey get NSURLVolumeSupportsZeroRunsKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsZeroRunsKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsZeroRunsKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsZeroRunsKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsZeroRunsKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume format treats upper and lower case characters in file and directory names as different. Otherwise an upper case character is equivalent to a lower case character, and you can't have two names that differ solely in the case of the characters. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsCaseSensitiveNamesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsCaseSensitiveNamesKey');

  DartNSURLResourceKey get NSURLVolumeSupportsCaseSensitiveNamesKey =>
      objc.NSString.castFromPointer(
          _NSURLVolumeSupportsCaseSensitiveNamesKey.value,
          retain: true,
          release: true);

  set NSURLVolumeSupportsCaseSensitiveNamesKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLVolumeSupportsCaseSensitiveNamesKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLVolumeSupportsCaseSensitiveNamesKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume format preserves the case of file and directory names.  Otherwise the volume may change the case of some characters (typically making them all upper or all lower case). (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsCasePreservedNamesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsCasePreservedNamesKey');

  DartNSURLResourceKey get NSURLVolumeSupportsCasePreservedNamesKey =>
      objc.NSString.castFromPointer(
          _NSURLVolumeSupportsCasePreservedNamesKey.value,
          retain: true,
          release: true);

  set NSURLVolumeSupportsCasePreservedNamesKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLVolumeSupportsCasePreservedNamesKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLVolumeSupportsCasePreservedNamesKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume supports reliable storage of times for the root directory. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsRootDirectoryDatesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsRootDirectoryDatesKey');

  DartNSURLResourceKey get NSURLVolumeSupportsRootDirectoryDatesKey =>
      objc.NSString.castFromPointer(
          _NSURLVolumeSupportsRootDirectoryDatesKey.value,
          retain: true,
          release: true);

  set NSURLVolumeSupportsRootDirectoryDatesKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLVolumeSupportsRootDirectoryDatesKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLVolumeSupportsRootDirectoryDatesKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume supports returning volume size values (NSURLVolumeTotalCapacityKey and NSURLVolumeAvailableCapacityKey). (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsVolumeSizesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsVolumeSizesKey');

  DartNSURLResourceKey get NSURLVolumeSupportsVolumeSizesKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsVolumeSizesKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsVolumeSizesKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsVolumeSizesKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsVolumeSizesKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume can be renamed. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsRenamingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsRenamingKey');

  DartNSURLResourceKey get NSURLVolumeSupportsRenamingKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsRenamingKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsRenamingKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsRenamingKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsRenamingKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume implements whole-file flock(2) style advisory locks, and the O_EXLOCK and O_SHLOCK flags of the open(2) call. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsAdvisoryFileLockingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsAdvisoryFileLockingKey');

  DartNSURLResourceKey get NSURLVolumeSupportsAdvisoryFileLockingKey =>
      objc.NSString.castFromPointer(
          _NSURLVolumeSupportsAdvisoryFileLockingKey.value,
          retain: true,
          release: true);

  set NSURLVolumeSupportsAdvisoryFileLockingKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLVolumeSupportsAdvisoryFileLockingKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLVolumeSupportsAdvisoryFileLockingKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume implements extended security (ACLs). (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsExtendedSecurityKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsExtendedSecurityKey');

  DartNSURLResourceKey get NSURLVolumeSupportsExtendedSecurityKey =>
      objc.NSString.castFromPointer(
          _NSURLVolumeSupportsExtendedSecurityKey.value,
          retain: true,
          release: true);

  set NSURLVolumeSupportsExtendedSecurityKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsExtendedSecurityKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsExtendedSecurityKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume should be visible via the GUI (i.e., appear on the Desktop as a separate volume). (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsBrowsableKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsBrowsableKey');

  DartNSURLResourceKey get NSURLVolumeIsBrowsableKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIsBrowsableKey.value,
          retain: true, release: true);

  set NSURLVolumeIsBrowsableKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIsBrowsableKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIsBrowsableKey.value = value.ref.retainAndReturnPointer();
  }

  /// The largest file size (in bytes) supported by this file system, or nil if this cannot be determined. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeMaximumFileSizeKey =
      _lookup<NSURLResourceKey>('NSURLVolumeMaximumFileSizeKey');

  DartNSURLResourceKey get NSURLVolumeMaximumFileSizeKey =>
      objc.NSString.castFromPointer(_NSURLVolumeMaximumFileSizeKey.value,
          retain: true, release: true);

  set NSURLVolumeMaximumFileSizeKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeMaximumFileSizeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeMaximumFileSizeKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume's media is ejectable from the drive mechanism under software control. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsEjectableKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsEjectableKey');

  DartNSURLResourceKey get NSURLVolumeIsEjectableKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIsEjectableKey.value,
          retain: true, release: true);

  set NSURLVolumeIsEjectableKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIsEjectableKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIsEjectableKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume's media is removable from the drive mechanism. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsRemovableKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsRemovableKey');

  DartNSURLResourceKey get NSURLVolumeIsRemovableKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIsRemovableKey.value,
          retain: true, release: true);

  set NSURLVolumeIsRemovableKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIsRemovableKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIsRemovableKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume's device is connected to an internal bus, false if connected to an external bus, or nil if not available. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsInternalKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsInternalKey');

  DartNSURLResourceKey get NSURLVolumeIsInternalKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIsInternalKey.value,
          retain: true, release: true);

  set NSURLVolumeIsInternalKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIsInternalKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIsInternalKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume is automounted. Note: do not mistake this with the functionality provided by kCFURLVolumeSupportsBrowsingKey. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsAutomountedKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsAutomountedKey');

  DartNSURLResourceKey get NSURLVolumeIsAutomountedKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIsAutomountedKey.value,
          retain: true, release: true);

  set NSURLVolumeIsAutomountedKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIsAutomountedKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIsAutomountedKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume is stored on a local device. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsLocalKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsLocalKey');

  DartNSURLResourceKey get NSURLVolumeIsLocalKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIsLocalKey.value,
          retain: true, release: true);

  set NSURLVolumeIsLocalKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIsLocalKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIsLocalKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume is read-only. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsReadOnlyKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsReadOnlyKey');

  DartNSURLResourceKey get NSURLVolumeIsReadOnlyKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIsReadOnlyKey.value,
          retain: true, release: true);

  set NSURLVolumeIsReadOnlyKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIsReadOnlyKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIsReadOnlyKey.value = value.ref.retainAndReturnPointer();
  }

  /// The volume's creation date, or nil if this cannot be determined. (Read-only, value type NSDate)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeCreationDateKey =
      _lookup<NSURLResourceKey>('NSURLVolumeCreationDateKey');

  DartNSURLResourceKey get NSURLVolumeCreationDateKey =>
      objc.NSString.castFromPointer(_NSURLVolumeCreationDateKey.value,
          retain: true, release: true);

  set NSURLVolumeCreationDateKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeCreationDateKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeCreationDateKey.value = value.ref.retainAndReturnPointer();
  }

  /// The NSURL needed to remount a network volume, or nil if not available. (Read-only, value type NSURL)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeURLForRemountingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeURLForRemountingKey');

  DartNSURLResourceKey get NSURLVolumeURLForRemountingKey =>
      objc.NSString.castFromPointer(_NSURLVolumeURLForRemountingKey.value,
          retain: true, release: true);

  set NSURLVolumeURLForRemountingKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeURLForRemountingKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeURLForRemountingKey.value = value.ref.retainAndReturnPointer();
  }

  /// The volume's persistent UUID as a string, or nil if a persistent UUID is not available for the volume. (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeUUIDStringKey =
      _lookup<NSURLResourceKey>('NSURLVolumeUUIDStringKey');

  DartNSURLResourceKey get NSURLVolumeUUIDStringKey =>
      objc.NSString.castFromPointer(_NSURLVolumeUUIDStringKey.value,
          retain: true, release: true);

  set NSURLVolumeUUIDStringKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeUUIDStringKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeUUIDStringKey.value = value.ref.retainAndReturnPointer();
  }

  /// The name of the volume (Read-write if NSURLVolumeSupportsRenamingKey is YES, otherwise read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeNameKey =
      _lookup<NSURLResourceKey>('NSURLVolumeNameKey');

  DartNSURLResourceKey get NSURLVolumeNameKey =>
      objc.NSString.castFromPointer(_NSURLVolumeNameKey.value,
          retain: true, release: true);

  set NSURLVolumeNameKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeNameKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeNameKey.value = value.ref.retainAndReturnPointer();
  }

  /// The user-presentable name of the volume (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeLocalizedNameKey =
      _lookup<NSURLResourceKey>('NSURLVolumeLocalizedNameKey');

  DartNSURLResourceKey get NSURLVolumeLocalizedNameKey =>
      objc.NSString.castFromPointer(_NSURLVolumeLocalizedNameKey.value,
          retain: true, release: true);

  set NSURLVolumeLocalizedNameKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeLocalizedNameKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeLocalizedNameKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume is encrypted. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsEncryptedKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsEncryptedKey');

  DartNSURLResourceKey get NSURLVolumeIsEncryptedKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIsEncryptedKey.value,
          retain: true, release: true);

  set NSURLVolumeIsEncryptedKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIsEncryptedKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIsEncryptedKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume is the root filesystem. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeIsRootFileSystemKey =
      _lookup<NSURLResourceKey>('NSURLVolumeIsRootFileSystemKey');

  DartNSURLResourceKey get NSURLVolumeIsRootFileSystemKey =>
      objc.NSString.castFromPointer(_NSURLVolumeIsRootFileSystemKey.value,
          retain: true, release: true);

  set NSURLVolumeIsRootFileSystemKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeIsRootFileSystemKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeIsRootFileSystemKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if the volume supports transparent decompression of compressed files using decmpfs. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsCompressionKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsCompressionKey');

  DartNSURLResourceKey get NSURLVolumeSupportsCompressionKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsCompressionKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsCompressionKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsCompressionKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsCompressionKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume supports clonefile(2) (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsFileCloningKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsFileCloningKey');

  DartNSURLResourceKey get NSURLVolumeSupportsFileCloningKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsFileCloningKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsFileCloningKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsFileCloningKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsFileCloningKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume supports renamex_np(2)'s RENAME_SWAP option (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSupportsSwapRenamingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsSwapRenamingKey');

  DartNSURLResourceKey get NSURLVolumeSupportsSwapRenamingKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsSwapRenamingKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsSwapRenamingKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsSwapRenamingKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsSwapRenamingKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume supports renamex_np(2)'s RENAME_EXCL option (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsExclusiveRenamingKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsExclusiveRenamingKey');

  DartNSURLResourceKey get NSURLVolumeSupportsExclusiveRenamingKey =>
      objc.NSString.castFromPointer(
          _NSURLVolumeSupportsExclusiveRenamingKey.value,
          retain: true,
          release: true);

  set NSURLVolumeSupportsExclusiveRenamingKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLVolumeSupportsExclusiveRenamingKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLVolumeSupportsExclusiveRenamingKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume supports making files immutable with the NSURLIsUserImmutableKey or NSURLIsSystemImmutableKey properties (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsImmutableFilesKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsImmutableFilesKey');

  DartNSURLResourceKey get NSURLVolumeSupportsImmutableFilesKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsImmutableFilesKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsImmutableFilesKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsImmutableFilesKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsImmutableFilesKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the volume supports setting POSIX access permissions with the NSURLFileSecurityKey property (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsAccessPermissionsKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsAccessPermissionsKey');

  DartNSURLResourceKey get NSURLVolumeSupportsAccessPermissionsKey =>
      objc.NSString.castFromPointer(
          _NSURLVolumeSupportsAccessPermissionsKey.value,
          retain: true,
          release: true);

  set NSURLVolumeSupportsAccessPermissionsKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLVolumeSupportsAccessPermissionsKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLVolumeSupportsAccessPermissionsKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// True if the volume supports the File Protection attribute (see NSURLFileProtectionKey). (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeSupportsFileProtectionKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSupportsFileProtectionKey');

  DartNSURLResourceKey get NSURLVolumeSupportsFileProtectionKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSupportsFileProtectionKey.value,
          retain: true, release: true);

  set NSURLVolumeSupportsFileProtectionKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSupportsFileProtectionKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSupportsFileProtectionKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeAvailableCapacityForImportantUsageKey =
      _lookup<NSURLResourceKey>(
          'NSURLVolumeAvailableCapacityForImportantUsageKey');

  DartNSURLResourceKey get NSURLVolumeAvailableCapacityForImportantUsageKey =>
      objc.NSString.castFromPointer(
          _NSURLVolumeAvailableCapacityForImportantUsageKey.value,
          retain: true,
          release: true);

  set NSURLVolumeAvailableCapacityForImportantUsageKey(
      DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLVolumeAvailableCapacityForImportantUsageKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLVolumeAvailableCapacityForImportantUsageKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLVolumeAvailableCapacityForOpportunisticUsageKey =
      _lookup<NSURLResourceKey>(
          'NSURLVolumeAvailableCapacityForOpportunisticUsageKey');

  DartNSURLResourceKey
      get NSURLVolumeAvailableCapacityForOpportunisticUsageKey =>
          objc.NSString.castFromPointer(
              _NSURLVolumeAvailableCapacityForOpportunisticUsageKey.value,
              retain: true,
              release: true);

  set NSURLVolumeAvailableCapacityForOpportunisticUsageKey(
      DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLVolumeAvailableCapacityForOpportunisticUsageKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLVolumeAvailableCapacityForOpportunisticUsageKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// The name of the file system type. (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeTypeNameKey =
      _lookup<NSURLResourceKey>('NSURLVolumeTypeNameKey');

  DartNSURLResourceKey get NSURLVolumeTypeNameKey =>
      objc.NSString.castFromPointer(_NSURLVolumeTypeNameKey.value,
          retain: true, release: true);

  set NSURLVolumeTypeNameKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeTypeNameKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeTypeNameKey.value = value.ref.retainAndReturnPointer();
  }

  /// The file system subtype value. (Read-only, value type NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeSubtypeKey =
      _lookup<NSURLResourceKey>('NSURLVolumeSubtypeKey');

  DartNSURLResourceKey get NSURLVolumeSubtypeKey =>
      objc.NSString.castFromPointer(_NSURLVolumeSubtypeKey.value,
          retain: true, release: true);

  set NSURLVolumeSubtypeKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeSubtypeKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeSubtypeKey.value = value.ref.retainAndReturnPointer();
  }

  /// The volume mounted from location. (Read-only, value type NSString)
  late final ffi.Pointer<NSURLResourceKey> _NSURLVolumeMountFromLocationKey =
      _lookup<NSURLResourceKey>('NSURLVolumeMountFromLocationKey');

  DartNSURLResourceKey get NSURLVolumeMountFromLocationKey =>
      objc.NSString.castFromPointer(_NSURLVolumeMountFromLocationKey.value,
          retain: true, release: true);

  set NSURLVolumeMountFromLocationKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLVolumeMountFromLocationKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLVolumeMountFromLocationKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if this item is synced to the cloud, false if it is only a local file. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLIsUbiquitousItemKey =
      _lookup<NSURLResourceKey>('NSURLIsUbiquitousItemKey');

  DartNSURLResourceKey get NSURLIsUbiquitousItemKey =>
      objc.NSString.castFromPointer(_NSURLIsUbiquitousItemKey.value,
          retain: true, release: true);

  set NSURLIsUbiquitousItemKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLIsUbiquitousItemKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLIsUbiquitousItemKey.value = value.ref.retainAndReturnPointer();
  }

  /// true if this item has conflicts outstanding. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemHasUnresolvedConflictsKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemHasUnresolvedConflictsKey');

  DartNSURLResourceKey get NSURLUbiquitousItemHasUnresolvedConflictsKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousItemHasUnresolvedConflictsKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousItemHasUnresolvedConflictsKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousItemHasUnresolvedConflictsKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousItemHasUnresolvedConflictsKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// equivalent to NSURLUbiquitousItemDownloadingStatusKey == NSURLUbiquitousItemDownloadingStatusCurrent. Has never behaved as documented in earlier releases, hence deprecated.  (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLUbiquitousItemIsDownloadedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsDownloadedKey');

  DartNSURLResourceKey get NSURLUbiquitousItemIsDownloadedKey =>
      objc.NSString.castFromPointer(_NSURLUbiquitousItemIsDownloadedKey.value,
          retain: true, release: true);

  set NSURLUbiquitousItemIsDownloadedKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLUbiquitousItemIsDownloadedKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLUbiquitousItemIsDownloadedKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if data is being downloaded for this item. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemIsDownloadingKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsDownloadingKey');

  DartNSURLResourceKey get NSURLUbiquitousItemIsDownloadingKey =>
      objc.NSString.castFromPointer(_NSURLUbiquitousItemIsDownloadingKey.value,
          retain: true, release: true);

  set NSURLUbiquitousItemIsDownloadingKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLUbiquitousItemIsDownloadingKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLUbiquitousItemIsDownloadingKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if there is data present in the cloud for this item. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLUbiquitousItemIsUploadedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsUploadedKey');

  DartNSURLResourceKey get NSURLUbiquitousItemIsUploadedKey =>
      objc.NSString.castFromPointer(_NSURLUbiquitousItemIsUploadedKey.value,
          retain: true, release: true);

  set NSURLUbiquitousItemIsUploadedKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLUbiquitousItemIsUploadedKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLUbiquitousItemIsUploadedKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if data is being uploaded for this item. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLUbiquitousItemIsUploadingKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsUploadingKey');

  DartNSURLResourceKey get NSURLUbiquitousItemIsUploadingKey =>
      objc.NSString.castFromPointer(_NSURLUbiquitousItemIsUploadingKey.value,
          retain: true, release: true);

  set NSURLUbiquitousItemIsUploadingKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLUbiquitousItemIsUploadingKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLUbiquitousItemIsUploadingKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// Use NSMetadataQuery and NSMetadataUbiquitousItemPercentDownloadedKey on NSMetadataItem instead
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemPercentDownloadedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemPercentDownloadedKey');

  DartNSURLResourceKey get NSURLUbiquitousItemPercentDownloadedKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousItemPercentDownloadedKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousItemPercentDownloadedKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousItemPercentDownloadedKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousItemPercentDownloadedKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// Use NSMetadataQuery and NSMetadataUbiquitousItemPercentUploadedKey on NSMetadataItem instead
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemPercentUploadedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemPercentUploadedKey');

  DartNSURLResourceKey get NSURLUbiquitousItemPercentUploadedKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousItemPercentUploadedKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousItemPercentUploadedKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLUbiquitousItemPercentUploadedKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLUbiquitousItemPercentUploadedKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// returns the download status of this item. (Read-only, value type NSString). Possible values below.
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemDownloadingStatusKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemDownloadingStatusKey');

  DartNSURLResourceKey get NSURLUbiquitousItemDownloadingStatusKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousItemDownloadingStatusKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousItemDownloadingStatusKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousItemDownloadingStatusKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousItemDownloadingStatusKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// returns the error when downloading the item from iCloud failed, see the NSUbiquitousFile section in FoundationErrors.h (Read-only, value type NSError)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemDownloadingErrorKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemDownloadingErrorKey');

  DartNSURLResourceKey get NSURLUbiquitousItemDownloadingErrorKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousItemDownloadingErrorKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousItemDownloadingErrorKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLUbiquitousItemDownloadingErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLUbiquitousItemDownloadingErrorKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// returns the error when uploading the item to iCloud failed, see the NSUbiquitousFile section in FoundationErrors.h (Read-only, value type NSError)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemUploadingErrorKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemUploadingErrorKey');

  DartNSURLResourceKey get NSURLUbiquitousItemUploadingErrorKey =>
      objc.NSString.castFromPointer(_NSURLUbiquitousItemUploadingErrorKey.value,
          retain: true, release: true);

  set NSURLUbiquitousItemUploadingErrorKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLUbiquitousItemUploadingErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLUbiquitousItemUploadingErrorKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// returns whether a download of this item has already been requested with an API like -startDownloadingUbiquitousItemAtURL:error: (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemDownloadRequestedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemDownloadRequestedKey');

  DartNSURLResourceKey get NSURLUbiquitousItemDownloadRequestedKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousItemDownloadRequestedKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousItemDownloadRequestedKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousItemDownloadRequestedKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousItemDownloadRequestedKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// returns the name of this item's container as displayed to users.
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemContainerDisplayNameKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemContainerDisplayNameKey');

  DartNSURLResourceKey get NSURLUbiquitousItemContainerDisplayNameKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousItemContainerDisplayNameKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousItemContainerDisplayNameKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousItemContainerDisplayNameKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousItemContainerDisplayNameKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the item is excluded from sync, which means it is locally on disk but won't be available on the server. An excluded item is no longer ubiquitous. (Read-write, value type boolean NSNumber
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousItemIsExcludedFromSyncKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsExcludedFromSyncKey');

  DartNSURLResourceKey get NSURLUbiquitousItemIsExcludedFromSyncKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousItemIsExcludedFromSyncKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousItemIsExcludedFromSyncKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousItemIsExcludedFromSyncKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousItemIsExcludedFromSyncKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// true if the ubiquitous item is shared. (Read-only, value type boolean NSNumber)
  late final ffi.Pointer<NSURLResourceKey> _NSURLUbiquitousItemIsSharedKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousItemIsSharedKey');

  DartNSURLResourceKey get NSURLUbiquitousItemIsSharedKey =>
      objc.NSString.castFromPointer(_NSURLUbiquitousItemIsSharedKey.value,
          retain: true, release: true);

  set NSURLUbiquitousItemIsSharedKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(_NSURLUbiquitousItemIsSharedKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLUbiquitousItemIsSharedKey.value = value.ref.retainAndReturnPointer();
  }

  /// returns the current user's role for this shared item, or nil if not shared. (Read-only, value type NSString). Possible values below.
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousSharedItemCurrentUserRoleKey =
      _lookup<NSURLResourceKey>('NSURLUbiquitousSharedItemCurrentUserRoleKey');

  DartNSURLResourceKey get NSURLUbiquitousSharedItemCurrentUserRoleKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousSharedItemCurrentUserRoleKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousSharedItemCurrentUserRoleKey(DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousSharedItemCurrentUserRoleKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousSharedItemCurrentUserRoleKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// returns the permissions for the current user, or nil if not shared. (Read-only, value type NSString). Possible values below.
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousSharedItemCurrentUserPermissionsKey =
      _lookup<NSURLResourceKey>(
          'NSURLUbiquitousSharedItemCurrentUserPermissionsKey');

  DartNSURLResourceKey get NSURLUbiquitousSharedItemCurrentUserPermissionsKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousSharedItemCurrentUserPermissionsKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousSharedItemCurrentUserPermissionsKey(
      DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousSharedItemCurrentUserPermissionsKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousSharedItemCurrentUserPermissionsKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// returns a NSPersonNameComponents, or nil if the current user. (Read-only, value type NSPersonNameComponents)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousSharedItemOwnerNameComponentsKey =
      _lookup<NSURLResourceKey>(
          'NSURLUbiquitousSharedItemOwnerNameComponentsKey');

  DartNSURLResourceKey get NSURLUbiquitousSharedItemOwnerNameComponentsKey =>
      objc.NSString.castFromPointer(
          _NSURLUbiquitousSharedItemOwnerNameComponentsKey.value,
          retain: true,
          release: true);

  set NSURLUbiquitousSharedItemOwnerNameComponentsKey(
      DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousSharedItemOwnerNameComponentsKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousSharedItemOwnerNameComponentsKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// returns a NSPersonNameComponents for the most recent editor of the document, or nil if it is the current user. (Read-only, value type NSPersonNameComponents)
  late final ffi.Pointer<NSURLResourceKey>
      _NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey =
      _lookup<NSURLResourceKey>(
          'NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey');

  DartNSURLResourceKey
      get NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey =>
          objc.NSString.castFromPointer(
              _NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey.value,
              retain: true,
              release: true);

  set NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey(
      DartNSURLResourceKey value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// this item has not been downloaded yet. Use startDownloadingUbiquitousItemAtURL:error: to download it.
  late final ffi.Pointer<NSURLUbiquitousItemDownloadingStatus>
      _NSURLUbiquitousItemDownloadingStatusNotDownloaded =
      _lookup<NSURLUbiquitousItemDownloadingStatus>(
          'NSURLUbiquitousItemDownloadingStatusNotDownloaded');

  DartNSURLUbiquitousItemDownloadingStatus
      get NSURLUbiquitousItemDownloadingStatusNotDownloaded =>
          objc.NSString.castFromPointer(
              _NSURLUbiquitousItemDownloadingStatusNotDownloaded.value,
              retain: true,
              release: true);

  set NSURLUbiquitousItemDownloadingStatusNotDownloaded(
      DartNSURLUbiquitousItemDownloadingStatus value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousItemDownloadingStatusNotDownloaded.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousItemDownloadingStatusNotDownloaded.value =
        value.ref.retainAndReturnPointer();
  }

  /// there is a local version of this item available. The most current version will get downloaded as soon as possible.
  late final ffi.Pointer<NSURLUbiquitousItemDownloadingStatus>
      _NSURLUbiquitousItemDownloadingStatusDownloaded =
      _lookup<NSURLUbiquitousItemDownloadingStatus>(
          'NSURLUbiquitousItemDownloadingStatusDownloaded');

  DartNSURLUbiquitousItemDownloadingStatus
      get NSURLUbiquitousItemDownloadingStatusDownloaded =>
          objc.NSString.castFromPointer(
              _NSURLUbiquitousItemDownloadingStatusDownloaded.value,
              retain: true,
              release: true);

  set NSURLUbiquitousItemDownloadingStatusDownloaded(
      DartNSURLUbiquitousItemDownloadingStatus value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousItemDownloadingStatusDownloaded.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousItemDownloadingStatusDownloaded.value =
        value.ref.retainAndReturnPointer();
  }

  /// there is a local version of this item and it is the most up-to-date version known to this device.
  late final ffi.Pointer<NSURLUbiquitousItemDownloadingStatus>
      _NSURLUbiquitousItemDownloadingStatusCurrent =
      _lookup<NSURLUbiquitousItemDownloadingStatus>(
          'NSURLUbiquitousItemDownloadingStatusCurrent');

  DartNSURLUbiquitousItemDownloadingStatus
      get NSURLUbiquitousItemDownloadingStatusCurrent =>
          objc.NSString.castFromPointer(
              _NSURLUbiquitousItemDownloadingStatusCurrent.value,
              retain: true,
              release: true);

  set NSURLUbiquitousItemDownloadingStatusCurrent(
      DartNSURLUbiquitousItemDownloadingStatus value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousItemDownloadingStatusCurrent.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousItemDownloadingStatusCurrent.value =
        value.ref.retainAndReturnPointer();
  }

  /// the current user is the owner of this shared item.
  late final ffi.Pointer<NSURLUbiquitousSharedItemRole>
      _NSURLUbiquitousSharedItemRoleOwner =
      _lookup<NSURLUbiquitousSharedItemRole>(
          'NSURLUbiquitousSharedItemRoleOwner');

  DartNSURLUbiquitousSharedItemRole get NSURLUbiquitousSharedItemRoleOwner =>
      objc.NSString.castFromPointer(_NSURLUbiquitousSharedItemRoleOwner.value,
          retain: true, release: true);

  set NSURLUbiquitousSharedItemRoleOwner(
      DartNSURLUbiquitousSharedItemRole value) {
    objc.NSString.castFromPointer(_NSURLUbiquitousSharedItemRoleOwner.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLUbiquitousSharedItemRoleOwner.value =
        value.ref.retainAndReturnPointer();
  }

  /// the current user is a participant of this shared item.
  late final ffi.Pointer<NSURLUbiquitousSharedItemRole>
      _NSURLUbiquitousSharedItemRoleParticipant =
      _lookup<NSURLUbiquitousSharedItemRole>(
          'NSURLUbiquitousSharedItemRoleParticipant');

  DartNSURLUbiquitousSharedItemRole
      get NSURLUbiquitousSharedItemRoleParticipant =>
          objc.NSString.castFromPointer(
              _NSURLUbiquitousSharedItemRoleParticipant.value,
              retain: true,
              release: true);

  set NSURLUbiquitousSharedItemRoleParticipant(
      DartNSURLUbiquitousSharedItemRole value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousSharedItemRoleParticipant.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousSharedItemRoleParticipant.value =
        value.ref.retainAndReturnPointer();
  }

  /// the current user is only allowed to read this item
  late final ffi.Pointer<NSURLUbiquitousSharedItemPermissions>
      _NSURLUbiquitousSharedItemPermissionsReadOnly =
      _lookup<NSURLUbiquitousSharedItemPermissions>(
          'NSURLUbiquitousSharedItemPermissionsReadOnly');

  DartNSURLUbiquitousSharedItemPermissions
      get NSURLUbiquitousSharedItemPermissionsReadOnly =>
          objc.NSString.castFromPointer(
              _NSURLUbiquitousSharedItemPermissionsReadOnly.value,
              retain: true,
              release: true);

  set NSURLUbiquitousSharedItemPermissionsReadOnly(
      DartNSURLUbiquitousSharedItemPermissions value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousSharedItemPermissionsReadOnly.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousSharedItemPermissionsReadOnly.value =
        value.ref.retainAndReturnPointer();
  }

  /// the current user is allowed to both read and write this item
  late final ffi.Pointer<NSURLUbiquitousSharedItemPermissions>
      _NSURLUbiquitousSharedItemPermissionsReadWrite =
      _lookup<NSURLUbiquitousSharedItemPermissions>(
          'NSURLUbiquitousSharedItemPermissionsReadWrite');

  DartNSURLUbiquitousSharedItemPermissions
      get NSURLUbiquitousSharedItemPermissionsReadWrite =>
          objc.NSString.castFromPointer(
              _NSURLUbiquitousSharedItemPermissionsReadWrite.value,
              retain: true,
              release: true);

  set NSURLUbiquitousSharedItemPermissionsReadWrite(
      DartNSURLUbiquitousSharedItemPermissions value) {
    objc.NSString.castFromPointer(
            _NSURLUbiquitousSharedItemPermissionsReadWrite.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSURLUbiquitousSharedItemPermissionsReadWrite.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSGenericException =
      _lookup<NSExceptionName>('NSGenericException');

  DartNSExceptionName get NSGenericException =>
      objc.NSString.castFromPointer(_NSGenericException.value,
          retain: true, release: true);

  set NSGenericException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSGenericException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSGenericException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSRangeException =
      _lookup<NSExceptionName>('NSRangeException');

  DartNSExceptionName get NSRangeException =>
      objc.NSString.castFromPointer(_NSRangeException.value,
          retain: true, release: true);

  set NSRangeException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSRangeException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSRangeException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSInvalidArgumentException =
      _lookup<NSExceptionName>('NSInvalidArgumentException');

  DartNSExceptionName get NSInvalidArgumentException =>
      objc.NSString.castFromPointer(_NSInvalidArgumentException.value,
          retain: true, release: true);

  set NSInvalidArgumentException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSInvalidArgumentException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSInvalidArgumentException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSInternalInconsistencyException =
      _lookup<NSExceptionName>('NSInternalInconsistencyException');

  DartNSExceptionName get NSInternalInconsistencyException =>
      objc.NSString.castFromPointer(_NSInternalInconsistencyException.value,
          retain: true, release: true);

  set NSInternalInconsistencyException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSInternalInconsistencyException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSInternalInconsistencyException.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSMallocException =
      _lookup<NSExceptionName>('NSMallocException');

  DartNSExceptionName get NSMallocException =>
      objc.NSString.castFromPointer(_NSMallocException.value,
          retain: true, release: true);

  set NSMallocException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSMallocException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSMallocException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSObjectInaccessibleException =
      _lookup<NSExceptionName>('NSObjectInaccessibleException');

  DartNSExceptionName get NSObjectInaccessibleException =>
      objc.NSString.castFromPointer(_NSObjectInaccessibleException.value,
          retain: true, release: true);

  set NSObjectInaccessibleException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSObjectInaccessibleException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSObjectInaccessibleException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSObjectNotAvailableException =
      _lookup<NSExceptionName>('NSObjectNotAvailableException');

  DartNSExceptionName get NSObjectNotAvailableException =>
      objc.NSString.castFromPointer(_NSObjectNotAvailableException.value,
          retain: true, release: true);

  set NSObjectNotAvailableException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSObjectNotAvailableException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSObjectNotAvailableException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSDestinationInvalidException =
      _lookup<NSExceptionName>('NSDestinationInvalidException');

  DartNSExceptionName get NSDestinationInvalidException =>
      objc.NSString.castFromPointer(_NSDestinationInvalidException.value,
          retain: true, release: true);

  set NSDestinationInvalidException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSDestinationInvalidException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSDestinationInvalidException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSPortTimeoutException =
      _lookup<NSExceptionName>('NSPortTimeoutException');

  DartNSExceptionName get NSPortTimeoutException =>
      objc.NSString.castFromPointer(_NSPortTimeoutException.value,
          retain: true, release: true);

  set NSPortTimeoutException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSPortTimeoutException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSPortTimeoutException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSInvalidSendPortException =
      _lookup<NSExceptionName>('NSInvalidSendPortException');

  DartNSExceptionName get NSInvalidSendPortException =>
      objc.NSString.castFromPointer(_NSInvalidSendPortException.value,
          retain: true, release: true);

  set NSInvalidSendPortException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSInvalidSendPortException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSInvalidSendPortException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSInvalidReceivePortException =
      _lookup<NSExceptionName>('NSInvalidReceivePortException');

  DartNSExceptionName get NSInvalidReceivePortException =>
      objc.NSString.castFromPointer(_NSInvalidReceivePortException.value,
          retain: true, release: true);

  set NSInvalidReceivePortException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSInvalidReceivePortException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSInvalidReceivePortException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSPortSendException =
      _lookup<NSExceptionName>('NSPortSendException');

  DartNSExceptionName get NSPortSendException =>
      objc.NSString.castFromPointer(_NSPortSendException.value,
          retain: true, release: true);

  set NSPortSendException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSPortSendException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSPortSendException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSPortReceiveException =
      _lookup<NSExceptionName>('NSPortReceiveException');

  DartNSExceptionName get NSPortReceiveException =>
      objc.NSString.castFromPointer(_NSPortReceiveException.value,
          retain: true, release: true);

  set NSPortReceiveException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSPortReceiveException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSPortReceiveException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSOldStyleException =
      _lookup<NSExceptionName>('NSOldStyleException');

  DartNSExceptionName get NSOldStyleException =>
      objc.NSString.castFromPointer(_NSOldStyleException.value,
          retain: true, release: true);

  set NSOldStyleException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSOldStyleException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSOldStyleException.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName> _NSInconsistentArchiveException =
      _lookup<NSExceptionName>('NSInconsistentArchiveException');

  DartNSExceptionName get NSInconsistentArchiveException =>
      objc.NSString.castFromPointer(_NSInconsistentArchiveException.value,
          retain: true, release: true);

  set NSInconsistentArchiveException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(_NSInconsistentArchiveException.value,
            retain: false, release: true)
        .ref
        .release();
    _NSInconsistentArchiveException.value = value.ref.retainAndReturnPointer();
  }

  ffi.Pointer<NSUncaughtExceptionHandler> NSGetUncaughtExceptionHandler() {
    return _NSGetUncaughtExceptionHandler();
  }

  late final _NSGetUncaughtExceptionHandlerPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<NSUncaughtExceptionHandler> Function()>>(
      'NSGetUncaughtExceptionHandler');
  late final _NSGetUncaughtExceptionHandler = _NSGetUncaughtExceptionHandlerPtr
      .asFunction<ffi.Pointer<NSUncaughtExceptionHandler> Function()>();

  void NSSetUncaughtExceptionHandler(
    ffi.Pointer<NSUncaughtExceptionHandler> arg0,
  ) {
    return _NSSetUncaughtExceptionHandler(
      arg0,
    );
  }

  late final _NSSetUncaughtExceptionHandlerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<NSUncaughtExceptionHandler>)>>(
      'NSSetUncaughtExceptionHandler');
  late final _NSSetUncaughtExceptionHandler = _NSSetUncaughtExceptionHandlerPtr
      .asFunction<void Function(ffi.Pointer<NSUncaughtExceptionHandler>)>();

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>> _NSAssertionHandlerKey =
      _lookup<ffi.Pointer<objc.ObjCObject>>('NSAssertionHandlerKey');

  objc.NSString get NSAssertionHandlerKey =>
      objc.NSString.castFromPointer(_NSAssertionHandlerKey.value,
          retain: true, release: true);

  set NSAssertionHandlerKey(objc.NSString value) {
    objc.NSString.castFromPointer(_NSAssertionHandlerKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSAssertionHandlerKey.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName>
      _NSInvocationOperationVoidResultException =
      _lookup<NSExceptionName>('NSInvocationOperationVoidResultException');

  DartNSExceptionName get NSInvocationOperationVoidResultException =>
      objc.NSString.castFromPointer(
          _NSInvocationOperationVoidResultException.value,
          retain: true,
          release: true);

  set NSInvocationOperationVoidResultException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(
            _NSInvocationOperationVoidResultException.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSInvocationOperationVoidResultException.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSExceptionName>
      _NSInvocationOperationCancelledException =
      _lookup<NSExceptionName>('NSInvocationOperationCancelledException');

  DartNSExceptionName get NSInvocationOperationCancelledException =>
      objc.NSString.castFromPointer(
          _NSInvocationOperationCancelledException.value,
          retain: true,
          release: true);

  set NSInvocationOperationCancelledException(DartNSExceptionName value) {
    objc.NSString.castFromPointer(
            _NSInvocationOperationCancelledException.value,
            retain: false,
            release: true)
        .ref
        .release();
    _NSInvocationOperationCancelledException.value =
        value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSInteger>
      _NSOperationQueueDefaultMaxConcurrentOperationCount =
      _lookup<NSInteger>('NSOperationQueueDefaultMaxConcurrentOperationCount');

  DartNSInteger get NSOperationQueueDefaultMaxConcurrentOperationCount =>
      _NSOperationQueueDefaultMaxConcurrentOperationCount.value;

  /// Predefined domain for errors from most AppKit and Foundation APIs.
  late final ffi.Pointer<NSErrorDomain> _NSCocoaErrorDomain =
      _lookup<NSErrorDomain>('NSCocoaErrorDomain');

  DartNSErrorDomain get NSCocoaErrorDomain =>
      objc.NSString.castFromPointer(_NSCocoaErrorDomain.value,
          retain: true, release: true);

  set NSCocoaErrorDomain(DartNSErrorDomain value) {
    objc.NSString.castFromPointer(_NSCocoaErrorDomain.value,
            retain: false, release: true)
        .ref
        .release();
    _NSCocoaErrorDomain.value = value.ref.retainAndReturnPointer();
  }

  /// Other predefined domains; value of "code" will correspond to preexisting values in these domains.
  late final ffi.Pointer<NSErrorDomain> _NSPOSIXErrorDomain =
      _lookup<NSErrorDomain>('NSPOSIXErrorDomain');

  DartNSErrorDomain get NSPOSIXErrorDomain =>
      objc.NSString.castFromPointer(_NSPOSIXErrorDomain.value,
          retain: true, release: true);

  set NSPOSIXErrorDomain(DartNSErrorDomain value) {
    objc.NSString.castFromPointer(_NSPOSIXErrorDomain.value,
            retain: false, release: true)
        .ref
        .release();
    _NSPOSIXErrorDomain.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSErrorDomain> _NSOSStatusErrorDomain =
      _lookup<NSErrorDomain>('NSOSStatusErrorDomain');

  DartNSErrorDomain get NSOSStatusErrorDomain =>
      objc.NSString.castFromPointer(_NSOSStatusErrorDomain.value,
          retain: true, release: true);

  set NSOSStatusErrorDomain(DartNSErrorDomain value) {
    objc.NSString.castFromPointer(_NSOSStatusErrorDomain.value,
            retain: false, release: true)
        .ref
        .release();
    _NSOSStatusErrorDomain.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<NSErrorDomain> _NSMachErrorDomain =
      _lookup<NSErrorDomain>('NSMachErrorDomain');

  DartNSErrorDomain get NSMachErrorDomain =>
      objc.NSString.castFromPointer(_NSMachErrorDomain.value,
          retain: true, release: true);

  set NSMachErrorDomain(DartNSErrorDomain value) {
    objc.NSString.castFromPointer(_NSMachErrorDomain.value,
            retain: false, release: true)
        .ref
        .release();
    _NSMachErrorDomain.value = value.ref.retainAndReturnPointer();
  }

  /// Key in userInfo. A recommended standard way to embed NSErrors from underlying calls. The value of this key should be an NSError.
  late final ffi.Pointer<NSErrorUserInfoKey> _NSUnderlyingErrorKey =
      _lookup<NSErrorUserInfoKey>('NSUnderlyingErrorKey');

  DartNSErrorUserInfoKey get NSUnderlyingErrorKey =>
      objc.NSString.castFromPointer(_NSUnderlyingErrorKey.value,
          retain: true, release: true);

  set NSUnderlyingErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSUnderlyingErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSUnderlyingErrorKey.value = value.ref.retainAndReturnPointer();
  }

  /// Key in userInfo. A recommended standard way to embed a list of several NSErrors from underlying calls. The value of this key should be an NSArray of NSError. This value is independent from the value of `NSUnderlyingErrorKey` - neither, one, or both may be set.
  late final ffi.Pointer<NSErrorUserInfoKey> _NSMultipleUnderlyingErrorsKey =
      _lookup<NSErrorUserInfoKey>('NSMultipleUnderlyingErrorsKey');

  DartNSErrorUserInfoKey get NSMultipleUnderlyingErrorsKey =>
      objc.NSString.castFromPointer(_NSMultipleUnderlyingErrorsKey.value,
          retain: true, release: true);

  set NSMultipleUnderlyingErrorsKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSMultipleUnderlyingErrorsKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSMultipleUnderlyingErrorsKey.value = value.ref.retainAndReturnPointer();
  }

  /// NSString, a complete sentence (or more) describing ideally both what failed and why it failed.
  late final ffi.Pointer<NSErrorUserInfoKey> _NSLocalizedDescriptionKey =
      _lookup<NSErrorUserInfoKey>('NSLocalizedDescriptionKey');

  DartNSErrorUserInfoKey get NSLocalizedDescriptionKey =>
      objc.NSString.castFromPointer(_NSLocalizedDescriptionKey.value,
          retain: true, release: true);

  set NSLocalizedDescriptionKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSLocalizedDescriptionKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSLocalizedDescriptionKey.value = value.ref.retainAndReturnPointer();
  }

  /// NSString, a complete sentence (or more) describing why the operation failed.
  late final ffi.Pointer<NSErrorUserInfoKey> _NSLocalizedFailureReasonErrorKey =
      _lookup<NSErrorUserInfoKey>('NSLocalizedFailureReasonErrorKey');

  DartNSErrorUserInfoKey get NSLocalizedFailureReasonErrorKey =>
      objc.NSString.castFromPointer(_NSLocalizedFailureReasonErrorKey.value,
          retain: true, release: true);

  set NSLocalizedFailureReasonErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSLocalizedFailureReasonErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSLocalizedFailureReasonErrorKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// NSString, a complete sentence (or more) describing what the user can do to fix the problem.
  late final ffi.Pointer<NSErrorUserInfoKey>
      _NSLocalizedRecoverySuggestionErrorKey =
      _lookup<NSErrorUserInfoKey>('NSLocalizedRecoverySuggestionErrorKey');

  DartNSErrorUserInfoKey get NSLocalizedRecoverySuggestionErrorKey =>
      objc.NSString.castFromPointer(
          _NSLocalizedRecoverySuggestionErrorKey.value,
          retain: true,
          release: true);

  set NSLocalizedRecoverySuggestionErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSLocalizedRecoverySuggestionErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSLocalizedRecoverySuggestionErrorKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// NSArray of NSStrings corresponding to button titles.
  late final ffi.Pointer<NSErrorUserInfoKey>
      _NSLocalizedRecoveryOptionsErrorKey =
      _lookup<NSErrorUserInfoKey>('NSLocalizedRecoveryOptionsErrorKey');

  DartNSErrorUserInfoKey get NSLocalizedRecoveryOptionsErrorKey =>
      objc.NSString.castFromPointer(_NSLocalizedRecoveryOptionsErrorKey.value,
          retain: true, release: true);

  set NSLocalizedRecoveryOptionsErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSLocalizedRecoveryOptionsErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSLocalizedRecoveryOptionsErrorKey.value =
        value.ref.retainAndReturnPointer();
  }

  /// Instance of a subclass of NSObject that conforms to the NSErrorRecoveryAttempting informal protocol
  late final ffi.Pointer<NSErrorUserInfoKey> _NSRecoveryAttempterErrorKey =
      _lookup<NSErrorUserInfoKey>('NSRecoveryAttempterErrorKey');

  DartNSErrorUserInfoKey get NSRecoveryAttempterErrorKey =>
      objc.NSString.castFromPointer(_NSRecoveryAttempterErrorKey.value,
          retain: true, release: true);

  set NSRecoveryAttempterErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSRecoveryAttempterErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSRecoveryAttempterErrorKey.value = value.ref.retainAndReturnPointer();
  }

  /// NSString containing a help anchor
  late final ffi.Pointer<NSErrorUserInfoKey> _NSHelpAnchorErrorKey =
      _lookup<NSErrorUserInfoKey>('NSHelpAnchorErrorKey');

  DartNSErrorUserInfoKey get NSHelpAnchorErrorKey =>
      objc.NSString.castFromPointer(_NSHelpAnchorErrorKey.value,
          retain: true, release: true);

  set NSHelpAnchorErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSHelpAnchorErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSHelpAnchorErrorKey.value = value.ref.retainAndReturnPointer();
  }

  /// NSString. This provides a string which will be shown when constructing the debugDescription of the NSError, to be used when debugging or when formatting the error with %@.  This string will never be used in localizedDescription, so will not be shown to the user.
  late final ffi.Pointer<NSErrorUserInfoKey> _NSDebugDescriptionErrorKey =
      _lookup<NSErrorUserInfoKey>('NSDebugDescriptionErrorKey');

  DartNSErrorUserInfoKey get NSDebugDescriptionErrorKey =>
      objc.NSString.castFromPointer(_NSDebugDescriptionErrorKey.value,
          retain: true, release: true);

  set NSDebugDescriptionErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSDebugDescriptionErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSDebugDescriptionErrorKey.value = value.ref.retainAndReturnPointer();
  }

  /// NSString, a complete sentence (or more) describing what failed.  Setting a value for this key in userInfo dictionary of errors received from framework APIs is a good way to customize and fine tune the localizedDescription of an NSError.  As an example, for Foundation error code NSFileWriteOutOfSpaceError, setting the value of this key to "The image library could not be saved." will allow the localizedDescription of the error to come out as "The image library could not be saved. The volume Macintosh HD is out of space." rather than the default (say) “You can't save the file ImgDatabaseV2 because the volume Macintosh HD is out of space."
  late final ffi.Pointer<NSErrorUserInfoKey> _NSLocalizedFailureErrorKey =
      _lookup<NSErrorUserInfoKey>('NSLocalizedFailureErrorKey');

  DartNSErrorUserInfoKey get NSLocalizedFailureErrorKey =>
      objc.NSString.castFromPointer(_NSLocalizedFailureErrorKey.value,
          retain: true, release: true);

  set NSLocalizedFailureErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSLocalizedFailureErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSLocalizedFailureErrorKey.value = value.ref.retainAndReturnPointer();
  }

  /// NSNumber containing NSStringEncoding
  late final ffi.Pointer<NSErrorUserInfoKey> _NSStringEncodingErrorKey =
      _lookup<NSErrorUserInfoKey>('NSStringEncodingErrorKey');

  DartNSErrorUserInfoKey get NSStringEncodingErrorKey =>
      objc.NSString.castFromPointer(_NSStringEncodingErrorKey.value,
          retain: true, release: true);

  set NSStringEncodingErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSStringEncodingErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSStringEncodingErrorKey.value = value.ref.retainAndReturnPointer();
  }

  /// NSURL
  late final ffi.Pointer<NSErrorUserInfoKey> _NSURLErrorKey =
      _lookup<NSErrorUserInfoKey>('NSURLErrorKey');

  DartNSErrorUserInfoKey get NSURLErrorKey =>
      objc.NSString.castFromPointer(_NSURLErrorKey.value,
          retain: true, release: true);

  set NSURLErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSURLErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSURLErrorKey.value = value.ref.retainAndReturnPointer();
  }

  /// NSString
  late final ffi.Pointer<NSErrorUserInfoKey> _NSFilePathErrorKey =
      _lookup<NSErrorUserInfoKey>('NSFilePathErrorKey');

  DartNSErrorUserInfoKey get NSFilePathErrorKey =>
      objc.NSString.castFromPointer(_NSFilePathErrorKey.value,
          retain: true, release: true);

  set NSFilePathErrorKey(DartNSErrorUserInfoKey value) {
    objc.NSString.castFromPointer(_NSFilePathErrorKey.value,
            retain: false, release: true)
        .ref
        .release();
    _NSFilePathErrorKey.value = value.ref.retainAndReturnPointer();
  }

  /// Create a block useable as a
  /// `URLSession:downloadTask:didFinishDownloadingToURL:` that can be used to
  /// make an async Dart callback behave synchronously.
  Dart_DidFinish adaptFinishWithLock(
    Dart_DidFinishWithLock block,
  ) {
    return ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL
        .castFromPointer(
            _adaptFinishWithLock(
              block.ref.pointer,
            ),
            retain: true,
            release: true);
  }

  late final _adaptFinishWithLockPtr =
      _lookup<ffi.NativeFunction<_DidFinish Function(_DidFinishWithLock)>>(
          'adaptFinishWithLock');
  late final _adaptFinishWithLock = _adaptFinishWithLockPtr
      .asFunction<_DidFinish Function(_DidFinishWithLock)>();
}

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_1o83rbn(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_1o83rbn(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_tg5tbv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_tg5tbv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_1dqvvol(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_1dqvvol(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_6enxqz(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_6enxqz(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_18kzm6a(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_18kzm6a(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_9o8504(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_9o8504(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_og5b6y(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_og5b6y(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_gwxhxt(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_gwxhxt(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_k73ff5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_k73ff5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_15f11yh(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_15f11yh(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_18qun1e(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_18qun1e(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_o762yo(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_o762yo(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_r8gdi7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_r8gdi7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_16sve1d(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_16sve1d(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_xx612k(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_xx612k(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_1otpo83(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_1otpo83(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_l2g8ke(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_l2g8ke(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_n8yd09(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_n8yd09(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_bklti2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_bklti2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_jyim80(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_jyim80(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_h68abb(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_h68abb(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_ly2579(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_ly2579(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_1lx650f(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_1lx650f(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_1p9ui4q(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_1p9ui4q(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_1b3bb6a(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_1b3bb6a(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_lmc3p5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_lmc3p5(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_t8l8el(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_t8l8el(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_vhbh5h(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_vhbh5h(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_zuf90e(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_zuf90e(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapListenerBlock_mlcr8l(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>,
            ffi.Pointer<
                ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>)>(
    isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _NativeCupertinoHttp_wrapBlockingBlock_mlcr8l(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>> newWaiter,
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      awaitWaiter,
);

typedef __int8_t = ffi.SignedChar;
typedef Dart__int8_t = int;
typedef __uint8_t = ffi.UnsignedChar;
typedef Dart__uint8_t = int;
typedef __int16_t = ffi.Short;
typedef Dart__int16_t = int;
typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;
typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;
typedef __uint64_t = ffi.UnsignedLongLong;
typedef Dart__uint64_t = int;
typedef __darwin_intptr_t = ffi.Long;
typedef Dart__darwin_intptr_t = int;
typedef __darwin_natural_t = ffi.UnsignedInt;
typedef Dart__darwin_natural_t = int;
typedef __darwin_ct_rune_t = ffi.Int;
typedef Dart__darwin_ct_rune_t = int;

final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

typedef __darwin_mbstate_t = __mbstate_t;
typedef __darwin_ptrdiff_t = ffi.Long;
typedef Dart__darwin_ptrdiff_t = int;
typedef __darwin_size_t = ffi.UnsignedLong;
typedef Dart__darwin_size_t = int;
typedef __builtin_va_list = ffi.Pointer<ffi.Char>;
typedef __darwin_va_list = __builtin_va_list;
typedef __darwin_wchar_t = ffi.Int;
typedef Dart__darwin_wchar_t = int;
typedef __darwin_rune_t = __darwin_wchar_t;
typedef __darwin_wint_t = ffi.Int;
typedef Dart__darwin_wint_t = int;
typedef __darwin_clock_t = ffi.UnsignedLong;
typedef Dart__darwin_clock_t = int;
typedef __darwin_socklen_t = __uint32_t;
typedef __darwin_ssize_t = ffi.Long;
typedef Dart__darwin_ssize_t = int;
typedef __darwin_time_t = ffi.Long;
typedef Dart__darwin_time_t = int;
typedef __darwin_blkcnt_t = __int64_t;
typedef __darwin_blksize_t = __int32_t;
typedef __darwin_dev_t = __int32_t;
typedef __darwin_fsblkcnt_t = ffi.UnsignedInt;
typedef Dart__darwin_fsblkcnt_t = int;
typedef __darwin_fsfilcnt_t = ffi.UnsignedInt;
typedef Dart__darwin_fsfilcnt_t = int;
typedef __darwin_gid_t = __uint32_t;
typedef __darwin_id_t = __uint32_t;
typedef __darwin_ino64_t = __uint64_t;
typedef __darwin_ino_t = __darwin_ino64_t;
typedef __darwin_mach_port_name_t = __darwin_natural_t;
typedef __darwin_mach_port_t = __darwin_mach_port_name_t;
typedef __darwin_mode_t = __uint16_t;
typedef __darwin_off_t = __int64_t;
typedef __darwin_pid_t = __int32_t;
typedef __darwin_sigset_t = __uint32_t;
typedef __darwin_suseconds_t = __int32_t;
typedef __darwin_uid_t = __uint32_t;
typedef __darwin_useconds_t = __uint32_t;

final class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;
typedef __darwin_pthread_cond_t = _opaque_pthread_cond_t;
typedef __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
typedef __darwin_pthread_key_t = ffi.UnsignedLong;
typedef Dart__darwin_pthread_key_t = int;
typedef __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
typedef __darwin_pthread_once_t = _opaque_pthread_once_t;
typedef __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
typedef __darwin_pthread_t = ffi.Pointer<_opaque_pthread_t>;
typedef __darwin_nl_item = ffi.Int;
typedef Dart__darwin_nl_item = int;
typedef __darwin_wctrans_t = ffi.Int;
typedef Dart__darwin_wctrans_t = int;
typedef __darwin_wctype_t = __uint32_t;

enum idtype_t {
  P_ALL(0),
  P_PID(1),
  P_PGID(2);

  final int value;
  const idtype_t(this.value);

  static idtype_t fromValue(int value) => switch (value) {
        0 => P_ALL,
        1 => P_PID,
        2 => P_PGID,
        _ => throw ArgumentError("Unknown value for idtype_t: $value"),
      };
}

typedef pid_t = __darwin_pid_t;
typedef id_t = __darwin_id_t;
typedef sig_atomic_t = ffi.Int;
typedef Dartsig_atomic_t = int;
typedef u_int8_t = ffi.UnsignedChar;
typedef Dartu_int8_t = int;
typedef u_int16_t = ffi.UnsignedShort;
typedef Dartu_int16_t = int;
typedef u_int32_t = ffi.UnsignedInt;
typedef Dartu_int32_t = int;
typedef u_int64_t = ffi.UnsignedLongLong;
typedef Dartu_int64_t = int;
typedef register_t = ffi.Int64;
typedef Dartregister_t = int;
typedef user_addr_t = u_int64_t;
typedef user_size_t = u_int64_t;
typedef user_ssize_t = ffi.Int64;
typedef Dartuser_ssize_t = int;
typedef user_long_t = ffi.Int64;
typedef Dartuser_long_t = int;
typedef user_ulong_t = u_int64_t;
typedef user_time_t = ffi.Int64;
typedef Dartuser_time_t = int;
typedef user_off_t = ffi.Int64;
typedef Dartuser_off_t = int;
typedef syscall_arg_t = u_int64_t;

final class __darwin_arm_exception_state extends ffi.Struct {
  @__uint32_t()
  external int __exception;

  @__uint32_t()
  external int __fsr;

  @__uint32_t()
  external int __far;
}

final class __darwin_arm_exception_state64 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint32_t()
  external int __esr;

  @__uint32_t()
  external int __exception;
}

final class __darwin_arm_exception_state64_v2 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint64_t()
  external int __esr;
}

final class __darwin_arm_thread_state extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __sp;

  @__uint32_t()
  external int __lr;

  @__uint32_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;
}

final class __darwin_arm_thread_state64 extends ffi.Struct {
  @ffi.Array.multi([29])
  external ffi.Array<__uint64_t> __x;

  @__uint64_t()
  external int __fp;

  @__uint64_t()
  external int __lr;

  @__uint64_t()
  external int __sp;

  @__uint64_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;

  @__uint32_t()
  external int __pad;
}

final class __darwin_arm_vfp_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __fpscr;
}

final class __darwin_arm_neon_state64 extends ffi.Opaque {}

final class __darwin_arm_neon_state extends ffi.Opaque {}

final class __arm_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

final class __arm_legacy_debug_state extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;
}

final class __darwin_arm_debug_state32 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_debug_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

final class __darwin_mcontext32 extends ffi.Struct {
  external __darwin_arm_exception_state __es;

  external __darwin_arm_thread_state __ss;

  external __darwin_arm_vfp_state __fs;
}

final class __darwin_mcontext64 extends ffi.Opaque {}

typedef mcontext_t = ffi.Pointer<__darwin_mcontext64>;
typedef pthread_attr_t = __darwin_pthread_attr_t;

final class __darwin_sigaltstack extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @__darwin_size_t()
  external int ss_size;

  @ffi.Int()
  external int ss_flags;
}

typedef stack_t = __darwin_sigaltstack;

final class __darwin_ucontext extends ffi.Struct {
  @ffi.Int()
  external int uc_onstack;

  @__darwin_sigset_t()
  external int uc_sigmask;

  external __darwin_sigaltstack uc_stack;

  external ffi.Pointer<__darwin_ucontext> uc_link;

  @__darwin_size_t()
  external int uc_mcsize;

  external ffi.Pointer<__darwin_mcontext64> uc_mcontext;
}

typedef ucontext_t = __darwin_ucontext;
typedef sigset_t = __darwin_sigset_t;
typedef uid_t = __darwin_uid_t;

final class sigval extends ffi.Union {
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class sigevent extends ffi.Struct {
  @ffi.Int()
  external int sigev_notify;

  @ffi.Int()
  external int sigev_signo;

  external sigval sigev_value;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
      sigev_notify_function;

  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

final class __siginfo extends ffi.Struct {
  @ffi.Int()
  external int si_signo;

  @ffi.Int()
  external int si_errno;

  @ffi.Int()
  external int si_code;

  @pid_t()
  external int si_pid;

  @uid_t()
  external int si_uid;

  @ffi.Int()
  external int si_status;

  external ffi.Pointer<ffi.Void> si_addr;

  external sigval si_value;

  @ffi.Long()
  external int si_band;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef siginfo_t = __siginfo;

final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

final class __sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>> sa_tramp;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

final class sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

typedef sig_tFunction = ffi.Void Function(ffi.Int);
typedef Dartsig_tFunction = void Function(int);
typedef sig_t = ffi.Pointer<ffi.NativeFunction<sig_tFunction>>;

final class sigvec extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      sv_handler;

  @ffi.Int()
  external int sv_mask;

  @ffi.Int()
  external int sv_flags;
}

final class sigstack extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ss_sp;

  @ffi.Int()
  external int ss_onstack;
}

typedef int_least8_t = ffi.Int8;
typedef Dartint_least8_t = int;
typedef int_least16_t = ffi.Int16;
typedef Dartint_least16_t = int;
typedef int_least32_t = ffi.Int32;
typedef Dartint_least32_t = int;
typedef int_least64_t = ffi.Int64;
typedef Dartint_least64_t = int;
typedef uint_least8_t = ffi.Uint8;
typedef Dartuint_least8_t = int;
typedef uint_least16_t = ffi.Uint16;
typedef Dartuint_least16_t = int;
typedef uint_least32_t = ffi.Uint32;
typedef Dartuint_least32_t = int;
typedef uint_least64_t = ffi.Uint64;
typedef Dartuint_least64_t = int;
typedef int_fast8_t = ffi.Int8;
typedef Dartint_fast8_t = int;
typedef int_fast16_t = ffi.Int16;
typedef Dartint_fast16_t = int;
typedef int_fast32_t = ffi.Int32;
typedef Dartint_fast32_t = int;
typedef int_fast64_t = ffi.Int64;
typedef Dartint_fast64_t = int;
typedef uint_fast8_t = ffi.Uint8;
typedef Dartuint_fast8_t = int;
typedef uint_fast16_t = ffi.Uint16;
typedef Dartuint_fast16_t = int;
typedef uint_fast32_t = ffi.Uint32;
typedef Dartuint_fast32_t = int;
typedef uint_fast64_t = ffi.Uint64;
typedef Dartuint_fast64_t = int;
typedef intmax_t = ffi.Long;
typedef Dartintmax_t = int;
typedef uintmax_t = ffi.UnsignedLong;
typedef Dartuintmax_t = int;

final class timeval extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef rlim_t = __uint64_t;

final class rusage extends ffi.Struct {
  external timeval ru_utime;

  external timeval ru_stime;

  @ffi.Long()
  external int ru_maxrss;

  @ffi.Long()
  external int ru_ixrss;

  @ffi.Long()
  external int ru_idrss;

  @ffi.Long()
  external int ru_isrss;

  @ffi.Long()
  external int ru_minflt;

  @ffi.Long()
  external int ru_majflt;

  @ffi.Long()
  external int ru_nswap;

  @ffi.Long()
  external int ru_inblock;

  @ffi.Long()
  external int ru_oublock;

  @ffi.Long()
  external int ru_msgsnd;

  @ffi.Long()
  external int ru_msgrcv;

  @ffi.Long()
  external int ru_nsignals;

  @ffi.Long()
  external int ru_nvcsw;

  @ffi.Long()
  external int ru_nivcsw;
}

typedef rusage_info_t = ffi.Pointer<ffi.Void>;

final class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

final class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

final class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

final class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

final class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

final class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

final class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Uint64()
  external int ri_secure_time_in_system;

  @ffi.Uint64()
  external int ri_secure_ptime_in_system;

  @ffi.Uint64()
  external int ri_neural_footprint;

  @ffi.Uint64()
  external int ri_lifetime_max_neural_footprint;

  @ffi.Uint64()
  external int ri_interval_max_neural_footprint;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

typedef rusage_info_current = rusage_info_v6;

final class rlimit extends ffi.Struct {
  @rlim_t()
  external int rlim_cur;

  @rlim_t()
  external int rlim_max;
}

final class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

final class wait extends ffi.Opaque {}

typedef ct_rune_t = __darwin_ct_rune_t;
typedef rune_t = __darwin_rune_t;

final class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

typedef malloc_type_id_t = ffi.UnsignedLongLong;
typedef Dartmalloc_type_id_t = int;

final class _malloc_zone_t extends ffi.Opaque {}

typedef malloc_zone_t = _malloc_zone_t;
typedef dev_t = __darwin_dev_t;
typedef mode_t = __darwin_mode_t;
void _ObjCBlock_ffiVoid_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function()>>()
        .asFunction<void Function()>()();
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_fnPtrCallable = ffi.Pointer
        .fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_fnPtrTrampoline)
    .cast();
void _ObjCBlock_ffiVoid_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    (objc.getBlockClosure(block) as void Function())();
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_closureCallable = ffi.Pointer
        .fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_closureTrampoline)
    .cast();
void _ObjCBlock_ffiVoid_listenerTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) {
  (objc.getBlockClosure(block) as void Function())();
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter) {
  try {
    (objc.getBlockClosure(block) as void Function())();
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>)>.isolateLocal(
        _ObjCBlock_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>)>.listener(
        _ObjCBlock_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function()>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr) =>
      objc.ObjCBlock<ffi.Void Function()>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(void Function() fn) =>
      objc.ObjCBlock<ffi.Void Function()>(
          objc.newClosureBlock(_ObjCBlock_ffiVoid_closureCallable, () => fn()),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function()> listener(void Function() fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_listenerCallable.nativeFunction.cast(), () => fn());
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(void Function() fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_blockingCallable.nativeFunction.cast(), () => fn());
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_blockingListenerCallable.nativeFunction.cast(),
        () => fn());
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1pl9qdv, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Void Function()> {
  void call() => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

int _ObjCBlock_ffiInt_ffiVoid_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<ffi.Void> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void> arg0, ffi.Pointer<ffi.Void> arg1)>>()
        .asFunction<
            int Function(
                ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiInt_ffiVoid_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Int Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_ffiInt_ffiVoid_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_ffiInt_ffiVoid_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<ffi.Void> arg1) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiInt_ffiVoid_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Int Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_ffiInt_ffiVoid_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiInt_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<ffi.Void> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(_ObjCBlock_ffiInt_ffiVoid_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
      fromFunction(
              int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiInt_ffiVoid_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<ffi.Void> arg1) =>
                      fn(arg0, arg1)),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiInt_ffiVoid_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<ffi.Void> arg1) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<ffi.Void> arg1)>>()
          .asFunction<
              int Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0, arg1);
}

typedef ptrdiff_t = __darwin_ptrdiff_t;
typedef rsize_t = __darwin_size_t;
typedef wint_t = __darwin_wint_t;
typedef u_char = ffi.UnsignedChar;
typedef Dartu_char = int;
typedef u_short = ffi.UnsignedShort;
typedef Dartu_short = int;
typedef u_int = ffi.UnsignedInt;
typedef Dartu_int = int;
typedef u_long = ffi.UnsignedLong;
typedef Dartu_long = int;
typedef ushort = ffi.UnsignedShort;
typedef Dartushort = int;
typedef uint = ffi.UnsignedInt;
typedef Dartuint = int;
typedef u_quad_t = u_int64_t;
typedef quad_t = ffi.Int64;
typedef Dartquad_t = int;
typedef qaddr_t = ffi.Pointer<quad_t>;
typedef caddr_t = ffi.Pointer<ffi.Char>;
typedef daddr_t = ffi.Int32;
typedef Dartdaddr_t = int;
typedef fixpt_t = u_int32_t;
typedef blkcnt_t = __darwin_blkcnt_t;
typedef blksize_t = __darwin_blksize_t;
typedef gid_t = __darwin_gid_t;
typedef in_addr_t = __uint32_t;
typedef in_port_t = __uint16_t;
typedef ino_t = __darwin_ino_t;
typedef ino64_t = __darwin_ino64_t;
typedef key_t = __int32_t;
typedef nlink_t = __uint16_t;
typedef off_t = __darwin_off_t;
typedef segsz_t = ffi.Int32;
typedef Dartsegsz_t = int;
typedef swblk_t = ffi.Int32;
typedef Dartswblk_t = int;
typedef clock_t = __darwin_clock_t;
typedef ssize_t = __darwin_ssize_t;
typedef time_t = __darwin_time_t;
typedef useconds_t = __darwin_useconds_t;
typedef suseconds_t = __darwin_suseconds_t;
typedef errno_t = ffi.Int;
typedef Darterrno_t = int;

final class fd_set extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<__int32_t> fds_bits;
}

typedef fd_mask = __int32_t;
typedef pthread_cond_t = __darwin_pthread_cond_t;
typedef pthread_condattr_t = __darwin_pthread_condattr_t;
typedef pthread_mutex_t = __darwin_pthread_mutex_t;
typedef pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
typedef pthread_once_t = __darwin_pthread_once_t;
typedef pthread_rwlock_t = __darwin_pthread_rwlock_t;
typedef pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
typedef pthread_t = __darwin_pthread_t;
typedef pthread_key_t = __darwin_pthread_key_t;
typedef fsblkcnt_t = __darwin_fsblkcnt_t;
typedef fsfilcnt_t = __darwin_fsfilcnt_t;

final class objc_class extends ffi.Opaque {}

final class objc_object extends ffi.Struct {
  external ffi.Pointer<objc.ObjCObject> isaAsInt;
}

final class objc_selector extends ffi.Opaque {}

typedef IMPFunction = ffi.Void Function();
typedef DartIMPFunction = void Function();
typedef IMP = ffi.Pointer<ffi.NativeFunction<IMPFunction>>;
typedef objc_zone_t = ffi.Pointer<_malloc_zone_t>;
typedef objc_objectptr_t = ffi.Pointer<ffi.Void>;
typedef NSInteger = ffi.Long;
typedef DartNSInteger = int;
typedef NSUInteger = ffi.UnsignedLong;
typedef DartNSUInteger = int;

final class _NSZone extends ffi.Opaque {}

typedef __gnuc_va_list = __builtin_va_list;
typedef va_list = __builtin_va_list;
typedef NSExceptionName = ffi.Pointer<objc.ObjCObject>;
typedef DartNSExceptionName = objc.NSString;
typedef NSRunLoopMode = ffi.Pointer<objc.ObjCObject>;
typedef DartNSRunLoopMode = objc.NSString;
int _ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                NSInteger Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            int Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject_fnPtrCallable =
    ffi.Pointer.fromFunction<
                NSInteger Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject_closureCallable =
    ffi.Pointer.fromFunction<
                NSInteger Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSInteger Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          NSInteger Function(
              ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<NSInteger Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<NSInteger Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>(
              objc.newPointerBlock(
                  _ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSInteger Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
      fromFunction(objc.NSComparisonResult Function(objc.ObjCObjectBase, objc.ObjCObjectBase) fn) =>
          objc.ObjCBlock<NSInteger Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(objc.ObjCObjectBase(arg0, retain: true, release: true),
                              objc.ObjCObjectBase(arg1, retain: true, release: true))
                          .value),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<NSInteger Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_NSComparisonResult_objcObjCObject_objcObjCObject_CallExtension
    on objc.ObjCBlock<
        NSInteger Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)> {
  objc.NSComparisonResult call(
          objc.ObjCObjectBase arg0, objc.ObjCObjectBase arg1) =>
      objc.NSComparisonResult.fromValue(ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      NSInteger Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer));
}

typedef NSComparator = ffi.Pointer<objc.ObjCBlockImpl>;
typedef DartNSComparator = objc.ObjCBlock<
    NSInteger Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>;

enum NSQualityOfService {
  NSQualityOfServiceUserInteractive(33),
  NSQualityOfServiceUserInitiated(25),
  NSQualityOfServiceUtility(17),
  NSQualityOfServiceBackground(9),
  NSQualityOfServiceDefault(-1);

  final int value;
  const NSQualityOfService(this.value);

  static NSQualityOfService fromValue(int value) => switch (value) {
        33 => NSQualityOfServiceUserInteractive,
        25 => NSQualityOfServiceUserInitiated,
        17 => NSQualityOfServiceUtility,
        9 => NSQualityOfServiceBackground,
        -1 => NSQualityOfServiceDefault,
        _ =>
          throw ArgumentError("Unknown value for NSQualityOfService: $value"),
      };
}

typedef ptrauth_extra_data_t = ffi.UnsignedLong;
typedef Dartptrauth_extra_data_t = int;
typedef ptrauth_generic_signature_t = ffi.UnsignedLong;
typedef Dartptrauth_generic_signature_t = int;
typedef UInt8 = ffi.UnsignedChar;
typedef DartUInt8 = int;
typedef SInt8 = ffi.SignedChar;
typedef DartSInt8 = int;
typedef UInt16 = ffi.UnsignedShort;
typedef DartUInt16 = int;
typedef SInt16 = ffi.Short;
typedef DartSInt16 = int;
typedef UInt32 = ffi.UnsignedInt;
typedef DartUInt32 = int;
typedef SInt32 = ffi.Int;
typedef DartSInt32 = int;

@ffi.Packed(2)
final class wide extends ffi.Struct {
  @UInt32()
  external int lo;

  @SInt32()
  external int hi;
}

@ffi.Packed(2)
final class UnsignedWide extends ffi.Struct {
  @UInt32()
  external int lo;

  @UInt32()
  external int hi;
}

typedef SInt64 = ffi.LongLong;
typedef DartSInt64 = int;
typedef UInt64 = ffi.UnsignedLongLong;
typedef DartUInt64 = int;
typedef Fixed = SInt32;
typedef FixedPtr = ffi.Pointer<Fixed>;
typedef Fract = SInt32;
typedef FractPtr = ffi.Pointer<Fract>;
typedef UnsignedFixed = UInt32;
typedef UnsignedFixedPtr = ffi.Pointer<UnsignedFixed>;
typedef ShortFixed = ffi.Short;
typedef DartShortFixed = int;
typedef ShortFixedPtr = ffi.Pointer<ShortFixed>;
typedef Float32 = ffi.Float;
typedef DartFloat32 = double;
typedef Float64 = ffi.Double;
typedef DartFloat64 = double;

final class Float80 extends ffi.Struct {
  @SInt16()
  external int exp;

  @ffi.Array.multi([4])
  external ffi.Array<UInt16> man;
}

final class Float96 extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<SInt16> exp;

  @ffi.Array.multi([4])
  external ffi.Array<UInt16> man;
}

@ffi.Packed(2)
final class Float32Point extends ffi.Struct {
  @Float32()
  external double x;

  @Float32()
  external double y;
}

typedef Ptr = ffi.Pointer<ffi.Char>;
typedef Handle = ffi.Pointer<Ptr>;
typedef Size = ffi.Long;
typedef DartSize = int;
typedef OSErr = SInt16;
typedef OSStatus = SInt32;
typedef LogicalAddress = ffi.Pointer<ffi.Void>;
typedef ConstLogicalAddress = ffi.Pointer<ffi.Void>;
typedef PhysicalAddress = ffi.Pointer<ffi.Void>;
typedef BytePtr = ffi.Pointer<UInt8>;
typedef ByteCount = ffi.UnsignedLong;
typedef DartByteCount = int;
typedef ByteOffset = ffi.UnsignedLong;
typedef DartByteOffset = int;
typedef Duration = SInt32;
typedef AbsoluteTime = UnsignedWide;
typedef OptionBits = UInt32;
typedef ItemCount = ffi.UnsignedLong;
typedef DartItemCount = int;
typedef PBVersion = UInt32;
typedef ScriptCode = SInt16;
typedef LangCode = SInt16;
typedef RegionCode = SInt16;
typedef FourCharCode = UInt32;
typedef OSType = FourCharCode;
typedef ResType = FourCharCode;
typedef OSTypePtr = ffi.Pointer<OSType>;
typedef ResTypePtr = ffi.Pointer<ResType>;
typedef Boolean = ffi.UnsignedChar;
typedef DartBoolean = int;
typedef ProcPtrFunction = ffi.Long Function();
typedef DartProcPtrFunction = int Function();
typedef ProcPtr = ffi.Pointer<ffi.NativeFunction<ProcPtrFunction>>;
typedef Register68kProcPtrFunction = ffi.Void Function();
typedef DartRegister68kProcPtrFunction = void Function();
typedef Register68kProcPtr
    = ffi.Pointer<ffi.NativeFunction<Register68kProcPtrFunction>>;
typedef UniversalProcPtr = ProcPtr;
typedef ProcHandle = ffi.Pointer<ProcPtr>;
typedef UniversalProcHandle = ffi.Pointer<UniversalProcPtr>;
typedef PRefCon = ffi.Pointer<ffi.Void>;
typedef URefCon = ffi.Pointer<ffi.Void>;
typedef SRefCon = ffi.Pointer<ffi.Void>;
typedef UnicodeScalarValue = UInt32;
typedef UTF32Char = UInt32;
typedef UniChar = UInt16;
typedef UTF16Char = UInt16;
typedef UTF8Char = UInt8;
typedef UniCharPtr = ffi.Pointer<UniChar>;
typedef UniCharCount = ffi.UnsignedLong;
typedef DartUniCharCount = int;
typedef UniCharCountPtr = ffi.Pointer<UniCharCount>;
typedef StringPtr = ffi.Pointer<ffi.UnsignedChar>;
typedef StringHandle = ffi.Pointer<StringPtr>;
typedef ConstStringPtr = ffi.Pointer<ffi.UnsignedChar>;
typedef ConstStr255Param = ffi.Pointer<ffi.UnsignedChar>;
typedef ConstStr63Param = ffi.Pointer<ffi.UnsignedChar>;
typedef ConstStr32Param = ffi.Pointer<ffi.UnsignedChar>;
typedef ConstStr31Param = ffi.Pointer<ffi.UnsignedChar>;
typedef ConstStr27Param = ffi.Pointer<ffi.UnsignedChar>;
typedef ConstStr15Param = ffi.Pointer<ffi.UnsignedChar>;
typedef ConstStrFileNameParam = ConstStr63Param;

@ffi.Packed(2)
final class ProcessSerialNumber extends ffi.Struct {
  @UInt32()
  external int highLongOfPSN;

  @UInt32()
  external int lowLongOfPSN;
}

typedef ProcessSerialNumberPtr = ffi.Pointer<ProcessSerialNumber>;

final class Point extends ffi.Struct {
  @ffi.Short()
  external int v;

  @ffi.Short()
  external int h;
}

typedef PointPtr = ffi.Pointer<Point>;

final class Rect extends ffi.Struct {
  @ffi.Short()
  external int top;

  @ffi.Short()
  external int left;

  @ffi.Short()
  external int bottom;

  @ffi.Short()
  external int right;
}

typedef RectPtr = ffi.Pointer<Rect>;

@ffi.Packed(2)
final class FixedPoint extends ffi.Struct {
  @Fixed()
  external int x;

  @Fixed()
  external int y;
}

@ffi.Packed(2)
final class FixedRect extends ffi.Struct {
  @Fixed()
  external int left;

  @Fixed()
  external int top;

  @Fixed()
  external int right;

  @Fixed()
  external int bottom;
}

typedef CharParameter = ffi.Short;
typedef DartCharParameter = int;
typedef Style = ffi.UnsignedChar;
typedef DartStyle = int;
typedef StyleParameter = ffi.Short;
typedef DartStyleParameter = int;
typedef StyleField = Style;
typedef TimeValue = SInt32;
typedef TimeScale = SInt32;
typedef CompTimeValue = wide;
typedef TimeValue64 = SInt64;

final class TimeBaseRecord extends ffi.Opaque {}

typedef TimeBase = ffi.Pointer<TimeBaseRecord>;

@ffi.Packed(2)
final class TimeRecord extends ffi.Struct {
  external CompTimeValue value;

  @TimeScale()
  external int scale;

  external TimeBase base;
}

final class NumVersion extends ffi.Struct {
  @UInt8()
  external int nonRelRev;

  @UInt8()
  external int stage;

  @UInt8()
  external int minorAndBugRev;

  @UInt8()
  external int majorRev;
}

final class NumVersionVariant extends ffi.Union {
  external NumVersion parts;

  @UInt32()
  external int whole;
}

typedef NumVersionVariantPtr = ffi.Pointer<NumVersionVariant>;
typedef NumVersionVariantHandle = ffi.Pointer<NumVersionVariantPtr>;

final class VersRec extends ffi.Struct {
  external NumVersion numericVersion;

  @ffi.Short()
  external int countryCode;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.UnsignedChar> shortVersion;

  @ffi.Array.multi([256])
  external ffi.Array<ffi.UnsignedChar> reserved;
}

typedef VersRecPtr = ffi.Pointer<VersRec>;
typedef VersRecHndl = ffi.Pointer<VersRecPtr>;
typedef Byte = UInt8;
typedef SignedByte = SInt8;
typedef WidePtr = ffi.Pointer<wide>;
typedef UnsignedWidePtr = ffi.Pointer<UnsignedWide>;
typedef extended80 = Float80;
typedef extended96 = Float96;
typedef VHSelect = SInt8;
typedef CFAllocatorTypeID = ffi.UnsignedLongLong;
typedef DartCFAllocatorTypeID = int;
typedef CFTypeID = ffi.UnsignedLong;
typedef DartCFTypeID = int;
typedef CFOptionFlags = ffi.UnsignedLong;
typedef DartCFOptionFlags = int;
typedef CFHashCode = ffi.UnsignedLong;
typedef DartCFHashCode = int;
typedef CFIndex = ffi.Long;
typedef DartCFIndex = int;
typedef CFTypeRef = ffi.Pointer<ffi.Void>;

final class __CFString extends ffi.Opaque {}

typedef CFStringRef = ffi.Pointer<__CFString>;
typedef CFMutableStringRef = ffi.Pointer<__CFString>;
typedef CFPropertyListRef = CFTypeRef;

enum CFComparisonResult {
  kCFCompareLessThan(-1),
  kCFCompareEqualTo(0),
  kCFCompareGreaterThan(1);

  final int value;
  const CFComparisonResult(this.value);

  static CFComparisonResult fromValue(int value) => switch (value) {
        -1 => kCFCompareLessThan,
        0 => kCFCompareEqualTo,
        1 => kCFCompareGreaterThan,
        _ =>
          throw ArgumentError("Unknown value for CFComparisonResult: $value"),
      };
}

typedef CFComparatorFunctionFunction = CFIndex Function(
    ffi.Pointer<ffi.Void> val1,
    ffi.Pointer<ffi.Void> val2,
    ffi.Pointer<ffi.Void> context);
typedef DartCFComparatorFunctionFunction = CFComparisonResult Function(
    ffi.Pointer<ffi.Void> val1,
    ffi.Pointer<ffi.Void> val2,
    ffi.Pointer<ffi.Void> context);
typedef CFComparatorFunction
    = ffi.Pointer<ffi.NativeFunction<CFComparatorFunctionFunction>>;

final class CFRange extends ffi.Struct {
  @CFIndex()
  external int location;

  @CFIndex()
  external int length;
}

final class __CFNull extends ffi.Opaque {}

typedef CFNullRef = ffi.Pointer<__CFNull>;

final class __CFAllocator extends ffi.Opaque {}

typedef CFAllocatorRef = ffi.Pointer<__CFAllocator>;
typedef CFAllocatorRetainCallBackFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void> info);
typedef CFAllocatorRetainCallBack
    = ffi.Pointer<ffi.NativeFunction<CFAllocatorRetainCallBackFunction>>;
typedef CFAllocatorReleaseCallBackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> info);
typedef DartCFAllocatorReleaseCallBackFunction = void Function(
    ffi.Pointer<ffi.Void> info);
typedef CFAllocatorReleaseCallBack
    = ffi.Pointer<ffi.NativeFunction<CFAllocatorReleaseCallBackFunction>>;
typedef CFAllocatorCopyDescriptionCallBackFunction = CFStringRef Function(
    ffi.Pointer<ffi.Void> info);
typedef CFAllocatorCopyDescriptionCallBack = ffi
    .Pointer<ffi.NativeFunction<CFAllocatorCopyDescriptionCallBackFunction>>;
typedef CFAllocatorAllocateCallBackFunction = ffi.Pointer<ffi.Void> Function(
    CFIndex allocSize, CFOptionFlags hint, ffi.Pointer<ffi.Void> info);
typedef DartCFAllocatorAllocateCallBackFunction
    = ffi.Pointer<ffi.Void> Function(DartCFIndex allocSize,
        DartCFOptionFlags hint, ffi.Pointer<ffi.Void> info);
typedef CFAllocatorAllocateCallBack
    = ffi.Pointer<ffi.NativeFunction<CFAllocatorAllocateCallBackFunction>>;
typedef CFAllocatorReallocateCallBackFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void> ptr,
    CFIndex newsize,
    CFOptionFlags hint,
    ffi.Pointer<ffi.Void> info);
typedef DartCFAllocatorReallocateCallBackFunction
    = ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<ffi.Void> ptr,
        DartCFIndex newsize,
        DartCFOptionFlags hint,
        ffi.Pointer<ffi.Void> info);
typedef CFAllocatorReallocateCallBack
    = ffi.Pointer<ffi.NativeFunction<CFAllocatorReallocateCallBackFunction>>;
typedef CFAllocatorDeallocateCallBackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> ptr, ffi.Pointer<ffi.Void> info);
typedef DartCFAllocatorDeallocateCallBackFunction = void Function(
    ffi.Pointer<ffi.Void> ptr, ffi.Pointer<ffi.Void> info);
typedef CFAllocatorDeallocateCallBack
    = ffi.Pointer<ffi.NativeFunction<CFAllocatorDeallocateCallBackFunction>>;
typedef CFAllocatorPreferredSizeCallBackFunction = CFIndex Function(
    CFIndex size, CFOptionFlags hint, ffi.Pointer<ffi.Void> info);
typedef DartCFAllocatorPreferredSizeCallBackFunction = DartCFIndex Function(
    DartCFIndex size, DartCFOptionFlags hint, ffi.Pointer<ffi.Void> info);
typedef CFAllocatorPreferredSizeCallBack
    = ffi.Pointer<ffi.NativeFunction<CFAllocatorPreferredSizeCallBackFunction>>;

final class CFAllocatorContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external CFAllocatorRetainCallBack retain;

  external CFAllocatorReleaseCallBack release;

  external CFAllocatorCopyDescriptionCallBack copyDescription;

  external CFAllocatorAllocateCallBack allocate;

  external CFAllocatorReallocateCallBack reallocate;

  external CFAllocatorDeallocateCallBack deallocate;

  external CFAllocatorPreferredSizeCallBack preferredSize;
}

typedef NSZone = _NSZone;
late final _class_NSObject = objc.getClass("NSObject");
late final _sel_version = objc.registerName("version");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setVersion_ = objc.registerName("setVersion:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_classForCoder = objc.registerName("classForCoder");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_replacementObjectForCoder_ =
    objc.registerName("replacementObjectForCoder:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_awakeAfterUsingCoder_ =
    objc.registerName("awakeAfterUsingCoder:");

/// NSCoderMethods
extension NSCoderMethods on objc.NSObject {
  /// version
  static DartNSInteger version() {
    return _objc_msgSend_1hz7y9r(_class_NSObject, _sel_version);
  }

  /// setVersion:
  static void setVersion_(DartNSInteger aVersion) {
    _objc_msgSend_4sp4xj(_class_NSObject, _sel_setVersion_, aVersion);
  }

  /// classForCoder
  objc.ObjCObjectBase get classForCoder {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_classForCoder);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// replacementObjectForCoder:
  objc.ObjCObjectBase? replacementObjectForCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_replacementObjectForCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// awakeAfterUsingCoder:
  objc.ObjCObjectBase? awakeAfterUsingCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_awakeAfterUsingCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }
}

late final _sel_poseAsClass_ = objc.registerName("poseAsClass:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// NSDeprecatedMethods
extension NSDeprecatedMethods on objc.NSObject {
  /// poseAsClass:
  static void poseAsClass_(objc.ObjCObjectBase aClass) {
    _objc_msgSend_xtuoz7(
        _class_NSObject, _sel_poseAsClass_, aClass.ref.pointer);
  }
}

late final _sel_autoContentAccessingProxy =
    objc.registerName("autoContentAccessingProxy");

/// NSDiscardableContentProxy
extension NSDiscardableContentProxy on objc.NSObject {
  /// autoContentAccessingProxy
  objc.ObjCObjectBase get autoContentAccessingProxy {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_autoContentAccessingProxy);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }
}

/// !
/// @enum NSURLCacheStoragePolicy
///
/// @discussion The NSURLCacheStoragePolicy enum defines constants that
/// can be used to specify the type of storage that is allowable for an
/// NSCachedURLResponse object that is to be stored in an NSURLCache.
///
/// @constant NSURLCacheStorageAllowed Specifies that storage in an
/// NSURLCache is allowed without restriction.
///
/// @constant NSURLCacheStorageAllowedInMemoryOnly Specifies that
/// storage in an NSURLCache is allowed; however storage should be
/// done in memory only, no disk storage should be done.
///
/// @constant NSURLCacheStorageNotAllowed Specifies that storage in an
/// NSURLCache is not allowed in any fashion, either in memory or on
/// disk.
enum NSURLCacheStoragePolicy {
  NSURLCacheStorageAllowed(0),
  NSURLCacheStorageAllowedInMemoryOnly(1),
  NSURLCacheStorageNotAllowed(2);

  final int value;
  const NSURLCacheStoragePolicy(this.value);

  static NSURLCacheStoragePolicy fromValue(int value) => switch (value) {
        0 => NSURLCacheStorageAllowed,
        1 => NSURLCacheStorageAllowedInMemoryOnly,
        2 => NSURLCacheStorageNotAllowed,
        _ => throw ArgumentError(
            "Unknown value for NSURLCacheStoragePolicy: $value"),
      };
}

/// WARNING: NSCachedURLResponse is a stub. To generate bindings for this class, include
/// NSCachedURLResponse in your config's objc-interfaces list.
///
/// !
/// @class NSCachedURLResponse
/// NSCachedURLResponse is a class whose objects functions as a wrapper for
/// objects that are stored in the framework's caching system.
/// It is used to maintain characteristics and attributes of a cached
/// object.
class NSCachedURLResponse extends objc.NSObject {
  NSCachedURLResponse._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSCachedURLResponse] that points to the same underlying object as [other].
  NSCachedURLResponse.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSCachedURLResponse] that wraps the given raw object pointer.
  NSCachedURLResponse.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_NSURLCache = objc.getClass("NSURLCache");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();

/// WARNING: NSURLSessionDataTask is a stub. To generate bindings for this class, include
/// NSURLSessionDataTask in your config's objc-interfaces list.
///
/// NSURLSessionDataTask
class NSURLSessionDataTask extends NSURLSessionTask {
  NSURLSessionDataTask._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLSessionDataTask] that points to the same underlying object as [other].
  NSURLSessionDataTask.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLSessionDataTask] that wraps the given raw object pointer.
  NSURLSessionDataTask.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_storeCachedResponse_forDataTask_ =
    objc.registerName("storeCachedResponse:forDataTask:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
void _ObjCBlock_ffiVoid_NSCachedURLResponse_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSCachedURLResponse_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSCachedURLResponse_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSCachedURLResponse_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSCachedURLResponse_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSCachedURLResponse_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSCachedURLResponse_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSCachedURLResponse_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSCachedURLResponse_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSCachedURLResponse_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSCachedURLResponse_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSCachedURLResponse_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSCachedURLResponse_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSCachedURLResponse_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>`.
abstract final class ObjCBlock_ffiVoid_NSCachedURLResponse {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_NSCachedURLResponse_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> fromFunction(
          void Function(NSCachedURLResponse?) fn) =>
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSCachedURLResponse_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                  ? null
                  : NSCachedURLResponse.castFromPointer(arg0,
                      retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> listener(
      void Function(NSCachedURLResponse?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSCachedURLResponse_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : NSCachedURLResponse.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> blocking(
      void Function(NSCachedURLResponse?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSCachedURLResponse_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : NSCachedURLResponse.castFromPointer(arg0,
                retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSCachedURLResponse_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : NSCachedURLResponse.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>`.
extension ObjCBlock_ffiVoid_NSCachedURLResponse_CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> {
  void call(NSCachedURLResponse? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_getCachedResponseForDataTask_completionHandler_ =
    objc.registerName("getCachedResponseForDataTask:completionHandler:");
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_removeCachedResponseForDataTask_ =
    objc.registerName("removeCachedResponseForDataTask:");

/// NSURLSessionTaskAdditions
extension NSURLSessionTaskAdditions on NSURLCache {
  /// storeCachedResponse:forDataTask:
  void storeCachedResponse_forDataTask_(
      NSCachedURLResponse cachedResponse, NSURLSessionDataTask dataTask) {
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_storeCachedResponse_forDataTask_,
        cachedResponse.ref.pointer,
        dataTask.ref.pointer);
  }

  /// getCachedResponseForDataTask:completionHandler:
  void getCachedResponseForDataTask_completionHandler_(
      NSURLSessionDataTask dataTask,
      objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>
          completionHandler) {
    _objc_msgSend_o762yo(
        this.ref.pointer,
        _sel_getCachedResponseForDataTask_completionHandler_,
        dataTask.ref.pointer,
        completionHandler.ref.pointer);
  }

  /// removeCachedResponseForDataTask:
  void removeCachedResponseForDataTask_(NSURLSessionDataTask dataTask) {
    _objc_msgSend_xtuoz7(this.ref.pointer,
        _sel_removeCachedResponseForDataTask_, dataTask.ref.pointer);
  }
}

late final _sel_sharedURLCache = objc.registerName("sharedURLCache");
late final _sel_setSharedURLCache_ = objc.registerName("setSharedURLCache:");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_initWithMemoryCapacity_diskCapacity_diskPath_ =
    objc.registerName("initWithMemoryCapacity:diskCapacity:diskPath:");
final _objc_msgSend_1dqnse5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithMemoryCapacity_diskCapacity_directoryURL_ =
    objc.registerName("initWithMemoryCapacity:diskCapacity:directoryURL:");
late final _class_NSURLRequest = objc.getClass("NSURLRequest");
late final _sel_HTTPMethod = objc.registerName("HTTPMethod");
late final _sel_allHTTPHeaderFields = objc.registerName("allHTTPHeaderFields");
late final _sel_valueForHTTPHeaderField_ =
    objc.registerName("valueForHTTPHeaderField:");
late final _sel_HTTPBody = objc.registerName("HTTPBody");
late final _sel_HTTPBodyStream = objc.registerName("HTTPBodyStream");
late final _sel_HTTPShouldHandleCookies =
    objc.registerName("HTTPShouldHandleCookies");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_HTTPShouldUsePipelining =
    objc.registerName("HTTPShouldUsePipelining");

/// !
/// @category NSURLRequest(NSHTTPURLRequest)
/// The NSHTTPURLRequest on NSURLRequest provides methods for accessing
/// information specific to HTTP protocol requests.
extension NSHTTPURLRequest on NSURLRequest {
  /// !
  /// @abstract Returns the HTTP request method of the receiver.
  /// @result the HTTP request method of the receiver.
  objc.NSString? get HTTPMethod {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_HTTPMethod);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns a dictionary containing all the HTTP header fields
  /// of the receiver.
  /// @result a dictionary containing all the HTTP header fields of the
  /// receiver.
  objc.NSDictionary? get allHTTPHeaderFields {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_allHTTPHeaderFields);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @method valueForHTTPHeaderField:
  /// @abstract Returns the value which corresponds to the given header
  /// field. Note that, in keeping with the HTTP RFC, HTTP header field
  /// names are case-insensitive.
  /// @param field the header field name to use for the lookup
  /// (case-insensitive).
  /// @result the value associated with the given header field, or nil if
  /// there is no value associated with the given header field.
  objc.NSString? valueForHTTPHeaderField_(objc.NSString field) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_valueForHTTPHeaderField_, field.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the request body data of the receiver.
  /// @discussion This data is sent as the message body of the request, as
  /// in done in an HTTP POST request.
  /// @result The request body data of the receiver.
  objc.NSData? get HTTPBody {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_HTTPBody);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the request body stream of the receiver
  /// if any has been set
  /// @discussion The stream is returned for examination only; it is
  /// not safe for the caller to manipulate the stream in any way.  Also
  /// note that the HTTPBodyStream and HTTPBody are mutually exclusive - only
  /// one can be set on a given request.  Also note that the body stream is
  /// preserved across copies, but is LOST when the request is coded via the
  /// NSCoding protocol
  /// @result The request body stream of the receiver.
  objc.NSInputStream? get HTTPBodyStream {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_HTTPBodyStream);
    return _ret.address == 0
        ? null
        : objc.NSInputStream.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Determine whether default cookie handling will happen for
  /// this request.
  /// @discussion NOTE: This value is not used prior to 10.3
  /// @result YES if cookies will be sent with and set for this request;
  /// otherwise NO.
  bool get HTTPShouldHandleCookies {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_HTTPShouldHandleCookies);
  }

  /// !
  /// @abstract Reports whether the receiver is not expected to wait for the
  /// previous response before transmitting.
  /// @result YES if the receiver should transmit before the previous response
  /// is received.  NO if the receiver should wait for the previous response
  /// before transmitting.
  bool get HTTPShouldUsePipelining {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_HTTPShouldUsePipelining);
  }
}

late final _sel_requestWithURL_ = objc.registerName("requestWithURL:");
late final _sel_supportsSecureCoding =
    objc.registerName("supportsSecureCoding");
bool _ObjCBlock_bool_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>) fn) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_bool_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0)),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

/// !
/// @enum NSURLRequestCachePolicy
///
/// @discussion The NSURLRequestCachePolicy enum defines constants that
/// can be used to specify the type of interactions that take place with
/// the caching system when the URL loading system processes a request.
/// Specifically, these constants cover interactions that have to do
/// with whether already-existing cache data is returned to satisfy a
/// URL load request.
///
/// @constant NSURLRequestUseProtocolCachePolicy Specifies that the
/// caching logic defined in the protocol implementation, if any, is
/// used for a particular URL load request. This is the default policy
/// for URL load requests.
///
/// @constant NSURLRequestReloadIgnoringLocalCacheData Specifies that the
/// data for the URL load should be loaded from the origin source. No
/// existing local cache data, regardless of its freshness or validity,
/// should be used to satisfy a URL load request.
///
/// @constant NSURLRequestReloadIgnoringLocalAndRemoteCacheData Specifies that
/// not only should the local cache data be ignored, but that proxies and
/// other intermediates should be instructed to disregard their caches
/// so far as the protocol allows.
///
/// @constant NSURLRequestReloadIgnoringCacheData Older name for
/// NSURLRequestReloadIgnoringLocalCacheData.
///
/// @constant NSURLRequestReturnCacheDataElseLoad Specifies that the
/// existing cache data should be used to satisfy a URL load request,
/// regardless of its age or expiration date. However, if there is no
/// existing data in the cache corresponding to a URL load request,
/// the URL is loaded from the origin source.
///
/// @constant NSURLRequestReturnCacheDataDontLoad Specifies that the
/// existing cache data should be used to satisfy a URL load request,
/// regardless of its age or expiration date. However, if there is no
/// existing data in the cache corresponding to a URL load request, no
/// attempt is made to load the URL from the origin source, and the
/// load is considered to have failed. This constant specifies a
/// behavior that is similar to an "offline" mode.
///
/// @constant NSURLRequestReloadRevalidatingCacheData Specifies that
/// the existing cache data may be used provided the origin source
/// confirms its validity, otherwise the URL is loaded from the
/// origin source.
enum NSURLRequestCachePolicy {
  NSURLRequestUseProtocolCachePolicy(0),
  NSURLRequestReloadIgnoringLocalCacheData(1),
  NSURLRequestReloadIgnoringLocalAndRemoteCacheData(4),
  NSURLRequestReturnCacheDataElseLoad(2),
  NSURLRequestReturnCacheDataDontLoad(3),
  NSURLRequestReloadRevalidatingCacheData(5);

  static const NSURLRequestReloadIgnoringCacheData =
      NSURLRequestReloadIgnoringLocalCacheData;

  final int value;
  const NSURLRequestCachePolicy(this.value);

  static NSURLRequestCachePolicy fromValue(int value) => switch (value) {
        0 => NSURLRequestUseProtocolCachePolicy,
        1 => NSURLRequestReloadIgnoringLocalCacheData,
        4 => NSURLRequestReloadIgnoringLocalAndRemoteCacheData,
        2 => NSURLRequestReturnCacheDataElseLoad,
        3 => NSURLRequestReturnCacheDataDontLoad,
        5 => NSURLRequestReloadRevalidatingCacheData,
        _ => throw ArgumentError(
            "Unknown value for NSURLRequestCachePolicy: $value"),
      };

  @override
  String toString() {
    if (this == NSURLRequestReloadIgnoringLocalCacheData)
      return "NSURLRequestCachePolicy.NSURLRequestReloadIgnoringLocalCacheData, NSURLRequestCachePolicy.NSURLRequestReloadIgnoringCacheData";
    return super.toString();
  }
}

typedef NSTimeInterval = ffi.Double;
typedef DartNSTimeInterval = double;
late final _sel_requestWithURL_cachePolicy_timeoutInterval_ =
    objc.registerName("requestWithURL:cachePolicy:timeoutInterval:");
final _objc_msgSend_1ajs603 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            double)>();
late final _sel_initWithURL_ = objc.registerName("initWithURL:");
late final _sel_initWithURL_cachePolicy_timeoutInterval_ =
    objc.registerName("initWithURL:cachePolicy:timeoutInterval:");
late final _sel_URL = objc.registerName("URL");
late final _sel_cachePolicy = objc.registerName("cachePolicy");
final _objc_msgSend_8jm3uo = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSUInteger Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_timeoutInterval = objc.registerName("timeoutInterval");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_mainDocumentURL = objc.registerName("mainDocumentURL");

/// !
/// @enum NSURLRequestNetworkServiceType
///
/// @discussion The NSURLRequestNetworkServiceType enum defines constants that
/// can be used to specify the service type to associate with this request.  The
/// service type is used to provide the networking layers a hint of the purpose
/// of the request.
///
/// @constant NSURLNetworkServiceTypeDefault Is the default value for an NSURLRequest
/// when created.  This value should be left unchanged for the vast majority of requests.
///
/// @constant NSURLNetworkServiceTypeVoIP Specifies that the request is for voice over IP
/// control traffic.
///
/// @constant NSURLNetworkServiceTypeVideo Specifies that the request is for video
/// traffic.
///
/// @constant NSURLNetworkServiceTypeBackground Specifies that the request is for background
/// traffic (such as a file download).
///
/// @constant NSURLNetworkServiceTypeVoice Specifies that the request is for voice data.
///
/// @constant NSURLNetworkServiceTypeResponsiveData Specifies that the request is for responsive (time sensitive) data.
///
/// @constant NSURLNetworkServiceTypeAVStreaming Specifies that the request is streaming audio/video data.
///
/// @constant NSURLNetworkServiceTypeResponsiveAV Specifies that the request is for responsive (time sensitive) audio/video data.
///
/// @constant NSURLNetworkServiceTypeCallSignaling Specifies that the request is for call signaling.
enum NSURLRequestNetworkServiceType {
  /// Standard internet traffic
  NSURLNetworkServiceTypeDefault(0),

  /// Voice over IP control traffic
  NSURLNetworkServiceTypeVoIP(1),

  /// Video traffic
  NSURLNetworkServiceTypeVideo(2),

  /// Background traffic
  NSURLNetworkServiceTypeBackground(3),

  /// Voice data
  NSURLNetworkServiceTypeVoice(4),

  /// Responsive data
  NSURLNetworkServiceTypeResponsiveData(6),

  /// Multimedia Audio/Video Streaming
  NSURLNetworkServiceTypeAVStreaming(8),

  /// Responsive Multimedia Audio/Video
  NSURLNetworkServiceTypeResponsiveAV(9),

  /// Call Signaling
  NSURLNetworkServiceTypeCallSignaling(11);

  final int value;
  const NSURLRequestNetworkServiceType(this.value);

  static NSURLRequestNetworkServiceType fromValue(int value) => switch (value) {
        0 => NSURLNetworkServiceTypeDefault,
        1 => NSURLNetworkServiceTypeVoIP,
        2 => NSURLNetworkServiceTypeVideo,
        3 => NSURLNetworkServiceTypeBackground,
        4 => NSURLNetworkServiceTypeVoice,
        6 => NSURLNetworkServiceTypeResponsiveData,
        8 => NSURLNetworkServiceTypeAVStreaming,
        9 => NSURLNetworkServiceTypeResponsiveAV,
        11 => NSURLNetworkServiceTypeCallSignaling,
        _ => throw ArgumentError(
            "Unknown value for NSURLRequestNetworkServiceType: $value"),
      };
}

late final _sel_networkServiceType = objc.registerName("networkServiceType");
final _objc_msgSend_t4uaw1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSUInteger Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_allowsCellularAccess =
    objc.registerName("allowsCellularAccess");
late final _sel_allowsExpensiveNetworkAccess =
    objc.registerName("allowsExpensiveNetworkAccess");
late final _sel_allowsConstrainedNetworkAccess =
    objc.registerName("allowsConstrainedNetworkAccess");
late final _sel_assumesHTTP3Capable = objc.registerName("assumesHTTP3Capable");

/// !
/// @enum NSURLRequestAttribution
///
/// @discussion The NSURLRequestAttribution enum is used to indicate whether the
/// user or developer specified the URL.
///
/// @constant NSURLRequestAttributionDeveloper Indicates that the URL was specified
/// by the developer. This is the default value for an NSURLRequest when created.
///
/// @constant NSURLRequestAttributionUser Indicates that the URL was specified by
/// the user.
enum NSURLRequestAttribution {
  NSURLRequestAttributionDeveloper(0),
  NSURLRequestAttributionUser(1);

  final int value;
  const NSURLRequestAttribution(this.value);

  static NSURLRequestAttribution fromValue(int value) => switch (value) {
        0 => NSURLRequestAttributionDeveloper,
        1 => NSURLRequestAttributionUser,
        _ => throw ArgumentError(
            "Unknown value for NSURLRequestAttribution: $value"),
      };
}

late final _sel_attribution = objc.registerName("attribution");
final _objc_msgSend_i3avs9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSUInteger Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_requiresDNSSECValidation =
    objc.registerName("requiresDNSSECValidation");
late final _sel_allowsPersistentDNS = objc.registerName("allowsPersistentDNS");
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<_NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<_NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease()),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");
late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(
                          arg0,
                          objc.NSCoder.castFromPointer(arg1,
                              retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      listener(void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSCoder.castFromPointer(arg1, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      blocking(void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSCoder.castFromPointer(arg1, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSCoder.castFromPointer(arg1, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_18v1jvf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
          .pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");
instancetype _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                instancetype Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            instancetype Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_NSCoder_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as instancetype Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_NSCoder_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
              ffi.Pointer<ffi.Void>, objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
                  ffi.Pointer<ffi.Void>,
                  objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
              ffi.Pointer<ffi.Void>, objc.NSCoder)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
                      ffi.Pointer<ffi.Void>, objc.NSCoder)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(
          Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
          objc.newClosureBlock(
              _ObjCBlock_instancetype_ffiVoid_NSCoder_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: true, release: true))
                      ?.ref
                      .retainAndReturnPointer() ??
                  ffi.nullptr),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder_CallExtension
    on objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
            ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true);
}

/// NSURLRequest
class NSURLRequest extends objc.NSObject {
  NSURLRequest._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLRequest] that points to the same underlying object as [other].
  NSURLRequest.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLRequest] that wraps the given raw object pointer.
  NSURLRequest.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLRequest].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSURLRequest);
  }

  /// !
  /// @method requestWithURL:
  /// @abstract Allocates and initializes an NSURLRequest with the given
  /// URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSURLRequest requestWithURL_(objc.NSURL URL) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSURLRequest, _sel_requestWithURL_, URL.ref.pointer);
    return NSURLRequest.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_NSURLRequest, _sel_supportsSecureCoding);
  }

  /// !
  /// @method requestWithURL:cachePolicy:timeoutInterval:
  /// @abstract Allocates and initializes a NSURLRequest with the given
  /// URL and cache policy.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSURLRequest requestWithURL_cachePolicy_timeoutInterval_(
      objc.NSURL URL,
      NSURLRequestCachePolicy cachePolicy,
      DartNSTimeInterval timeoutInterval) {
    final _ret = _objc_msgSend_1ajs603(
        _class_NSURLRequest,
        _sel_requestWithURL_cachePolicy_timeoutInterval_,
        URL.ref.pointer,
        cachePolicy.value,
        timeoutInterval);
    return NSURLRequest.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @method initWithURL:
  /// @abstract Initializes an NSURLRequest with the given URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result An initialized NSURLRequest.
  NSURLRequest initWithURL_(objc.NSURL URL) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.retainAndReturnPointer(), _sel_initWithURL_, URL.ref.pointer);
    return NSURLRequest.castFromPointer(_ret, retain: false, release: true);
  }

  /// !
  /// @method initWithURL:
  /// @abstract Initializes an NSURLRequest with the given URL and
  /// cache policy.
  /// @discussion This is the designated initializer for the
  /// NSURLRequest class.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result An initialized NSURLRequest.
  NSURLRequest initWithURL_cachePolicy_timeoutInterval_(objc.NSURL URL,
      NSURLRequestCachePolicy cachePolicy, DartNSTimeInterval timeoutInterval) {
    final _ret = _objc_msgSend_1ajs603(
        this.ref.retainAndReturnPointer(),
        _sel_initWithURL_cachePolicy_timeoutInterval_,
        URL.ref.pointer,
        cachePolicy.value,
        timeoutInterval);
    return NSURLRequest.castFromPointer(_ret, retain: false, release: true);
  }

  /// !
  /// @abstract Returns the URL of the receiver.
  /// @result The URL of the receiver.
  objc.NSURL? get URL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_URL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the cache policy of the receiver.
  /// @result The cache policy of the receiver.
  NSURLRequestCachePolicy get cachePolicy {
    final _ret = _objc_msgSend_8jm3uo(this.ref.pointer, _sel_cachePolicy);
    return NSURLRequestCachePolicy.fromValue(_ret);
  }

  /// !
  /// @abstract Returns the timeout interval of the receiver.
  /// @discussion The timeout interval specifies the limit on the idle
  /// interval allotted to a request in the process of loading. The "idle
  /// interval" is defined as the period of time that has passed since the
  /// last instance of load activity occurred for a request that is in the
  /// process of loading. Hence, when an instance of load activity occurs
  /// (e.g. bytes are received from the network for a request), the idle
  /// interval for a request is reset to 0. If the idle interval ever
  /// becomes greater than or equal to the timeout interval, the request
  /// is considered to have timed out. This timeout interval is measured
  /// in seconds.
  /// @result The timeout interval of the receiver.
  DartNSTimeInterval get timeoutInterval {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_timeoutInterval)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_timeoutInterval);
  }

  /// !
  /// @abstract The main document URL associated with this load.
  /// @discussion This URL is used for the cookie "same domain as main
  /// document" policy, and attributing the request as a sub-resource
  /// of a user-specified URL. There may also be other future uses.
  /// See setMainDocumentURL:
  /// @result The main document URL.
  objc.NSURL? get mainDocumentURL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_mainDocumentURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the NSURLRequestNetworkServiceType associated with this request.
  /// @discussion  This will return NSURLNetworkServiceTypeDefault for requests that have
  /// not explicitly set a networkServiceType (using the setNetworkServiceType method).
  /// @result The NSURLRequestNetworkServiceType associated with this request.
  NSURLRequestNetworkServiceType get networkServiceType {
    final _ret =
        _objc_msgSend_t4uaw1(this.ref.pointer, _sel_networkServiceType);
    return NSURLRequestNetworkServiceType.fromValue(_ret);
  }

  /// !
  /// @abstract returns whether a connection created with this request is allowed to use
  /// the built in cellular radios (if present).
  /// @result YES if the receiver is allowed to use the built in cellular radios to
  /// satisfy the request, NO otherwise.
  bool get allowsCellularAccess {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_allowsCellularAccess);
  }

  /// !
  /// @abstract returns whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as expensive.
  /// @result YES if the receiver is allowed to use an interface marked as expensive to
  /// satisfy the request, NO otherwise.
  bool get allowsExpensiveNetworkAccess {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_allowsExpensiveNetworkAccess);
  }

  /// !
  /// @abstract returns whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as constrained.
  /// @result YES if the receiver is allowed to use an interface marked as constrained to
  /// satisfy the request, NO otherwise.
  bool get allowsConstrainedNetworkAccess {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_allowsConstrainedNetworkAccess);
  }

  /// !
  /// @abstract returns whether we assume that server supports HTTP/3. Enables QUIC
  /// racing without HTTP/3 service discovery.
  /// @result YES if server endpoint is known to support HTTP/3. Defaults to NO.
  /// The default may be YES in a future OS update.
  bool get assumesHTTP3Capable {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_assumesHTTP3Capable);
  }

  /// !
  /// @abstract Returns the NSURLRequestAttribution associated with this request.
  /// @discussion This will return NSURLRequestAttributionDeveloper for requests that
  /// have not explicitly set an attribution.
  /// @result The NSURLRequestAttribution associated with this request.
  NSURLRequestAttribution get attribution {
    final _ret = _objc_msgSend_i3avs9(this.ref.pointer, _sel_attribution);
    return NSURLRequestAttribution.fromValue(_ret);
  }

  /// !
  /// @abstract sets whether a request is required to do DNSSEC validation during DNS lookup.
  /// @discussion YES, if the DNS lookup for this request should require DNSSEC validation,
  /// No otherwise. Defaults to NO.
  bool get requiresDNSSECValidation {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_requiresDNSSECValidation);
  }

  /// !
  /// @abstract Allows storing and usage of DNS answers, potentially beyond TTL expiry,
  /// in a persistent per-process cache. This should only be set for hostnames whose resolutions
  /// are not expected to change across networks.
  /// @discussion YES, if the DNS lookup for this request is allowed to use a persistent per-process cache,
  /// NO otherwise. Defaults to NO.
  bool get allowsPersistentDNS {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_allowsPersistentDNS);
  }

  /// init
  NSURLRequest init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSURLRequest.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSURLRequest new1() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLRequest, _sel_new);
    return NSURLRequest.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLRequest allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_NSURLRequest, _sel_allocWithZone_, zone);
    return NSURLRequest.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSURLRequest alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLRequest, _sel_alloc);
    return NSURLRequest.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  NSURLRequest self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSURLRequest.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSURLRequest retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSURLRequest.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSURLRequest autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSURLRequest.castFromPointer(_ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder_(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  NSURLRequest? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : NSURLRequest.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _sel_cachedResponseForRequest_ =
    objc.registerName("cachedResponseForRequest:");
late final _sel_storeCachedResponse_forRequest_ =
    objc.registerName("storeCachedResponse:forRequest:");
late final _sel_removeCachedResponseForRequest_ =
    objc.registerName("removeCachedResponseForRequest:");
late final _sel_removeAllCachedResponses =
    objc.registerName("removeAllCachedResponses");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_removeCachedResponsesSinceDate_ =
    objc.registerName("removeCachedResponsesSinceDate:");
late final _sel_memoryCapacity = objc.registerName("memoryCapacity");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setMemoryCapacity_ = objc.registerName("setMemoryCapacity:");
final _objc_msgSend_1i9r4xy = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_diskCapacity = objc.registerName("diskCapacity");
late final _sel_setDiskCapacity_ = objc.registerName("setDiskCapacity:");
late final _sel_currentMemoryUsage = objc.registerName("currentMemoryUsage");
late final _sel_currentDiskUsage = objc.registerName("currentDiskUsage");

/// NSURLCache
class NSURLCache extends objc.NSObject {
  NSURLCache._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLCache] that points to the same underlying object as [other].
  NSURLCache.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLCache] that wraps the given raw object pointer.
  NSURLCache.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLCache].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSURLCache);
  }

  /// !
  /// @property sharedURLCache
  /// @abstract Returns the shared NSURLCache instance or
  /// sets the NSURLCache instance shared by all clients of
  /// the current process. This will be the new object returned when
  /// calls to the <tt>sharedURLCache</tt> method are made.
  /// @discussion Unless set explicitly through a call to
  /// <tt>+setSharedURLCache:</tt>, this method returns an NSURLCache
  /// instance created with the following default values:
  /// <ul>
  /// <li>Memory capacity: 4 megabytes (4 * 1024 * 1024 bytes)
  /// <li>Disk capacity: 20 megabytes (20 * 1024 * 1024 bytes)
  /// <li>Disk path: <nobr>(user home directory)/Library/Caches/(application bundle id)</nobr>
  /// </ul>
  /// <p>Users who do not have special caching requirements or
  /// constraints should find the default shared cache instance
  /// acceptable. If this default shared cache instance is not
  /// acceptable, <tt>+setSharedURLCache:</tt> can be called to set a
  /// different NSURLCache instance to be returned from this method.
  /// Callers should take care to ensure that the setter is called
  /// at a time when no other caller has a reference to the previously-set
  /// shared URL cache. This is to prevent storing cache data from
  /// becoming unexpectedly unretrievable.
  /// @result the shared NSURLCache instance.
  static NSURLCache getSharedURLCache() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLCache, _sel_sharedURLCache);
    return NSURLCache.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @property sharedURLCache
  /// @abstract Returns the shared NSURLCache instance or
  /// sets the NSURLCache instance shared by all clients of
  /// the current process. This will be the new object returned when
  /// calls to the <tt>sharedURLCache</tt> method are made.
  /// @discussion Unless set explicitly through a call to
  /// <tt>+setSharedURLCache:</tt>, this method returns an NSURLCache
  /// instance created with the following default values:
  /// <ul>
  /// <li>Memory capacity: 4 megabytes (4 * 1024 * 1024 bytes)
  /// <li>Disk capacity: 20 megabytes (20 * 1024 * 1024 bytes)
  /// <li>Disk path: <nobr>(user home directory)/Library/Caches/(application bundle id)</nobr>
  /// </ul>
  /// <p>Users who do not have special caching requirements or
  /// constraints should find the default shared cache instance
  /// acceptable. If this default shared cache instance is not
  /// acceptable, <tt>+setSharedURLCache:</tt> can be called to set a
  /// different NSURLCache instance to be returned from this method.
  /// Callers should take care to ensure that the setter is called
  /// at a time when no other caller has a reference to the previously-set
  /// shared URL cache. This is to prevent storing cache data from
  /// becoming unexpectedly unretrievable.
  /// @result the shared NSURLCache instance.
  static void setSharedURLCache(NSURLCache value) {
    _objc_msgSend_xtuoz7(
        _class_NSURLCache, _sel_setSharedURLCache_, value.ref.pointer);
  }

  /// !
  /// @method initWithMemoryCapacity:diskCapacity:diskPath:
  /// @abstract Initializes an NSURLCache with the given capacity and
  /// path.
  /// @discussion The returned NSURLCache is backed by disk, so
  /// developers can be more liberal with space when choosing the
  /// capacity for this kind of cache. A disk cache measured in the tens
  /// of megabytes should be acceptable in most cases.
  /// @param memoryCapacity the capacity, measured in bytes, for the cache in memory.
  /// @param diskCapacity the capacity, measured in bytes, for the cache on disk.
  /// @param path the path on disk where the cache data is stored.
  /// @result an initialized NSURLCache, with the given capacity, backed
  /// by disk.
  NSURLCache initWithMemoryCapacity_diskCapacity_diskPath_(
      DartNSUInteger memoryCapacity,
      DartNSUInteger diskCapacity,
      objc.NSString? path) {
    final _ret = _objc_msgSend_1dqnse5(
        this.ref.retainAndReturnPointer(),
        _sel_initWithMemoryCapacity_diskCapacity_diskPath_,
        memoryCapacity,
        diskCapacity,
        path?.ref.pointer ?? ffi.nullptr);
    return NSURLCache.castFromPointer(_ret, retain: false, release: true);
  }

  /// !
  /// @method initWithMemoryCapacity:diskCapacity:directoryURL:
  /// @abstract Initializes an NSURLCache with the given capacity and directory.
  /// @param memoryCapacity the capacity, measured in bytes, for the cache in memory. Or 0 to disable memory cache.
  /// @param diskCapacity the capacity, measured in bytes, for the cache on disk. Or 0 to disable disk cache.
  /// @param directoryURL the path to a directory on disk where the cache data is stored. Or nil for default directory.
  /// @result an initialized NSURLCache, with the given capacity, optionally backed by disk.
  NSURLCache initWithMemoryCapacity_diskCapacity_directoryURL_(
      DartNSUInteger memoryCapacity,
      DartNSUInteger diskCapacity,
      objc.NSURL? directoryURL) {
    final _ret = _objc_msgSend_1dqnse5(
        this.ref.retainAndReturnPointer(),
        _sel_initWithMemoryCapacity_diskCapacity_directoryURL_,
        memoryCapacity,
        diskCapacity,
        directoryURL?.ref.pointer ?? ffi.nullptr);
    return NSURLCache.castFromPointer(_ret, retain: false, release: true);
  }

  /// !
  /// @method cachedResponseForRequest:
  /// @abstract Returns the NSCachedURLResponse stored in the cache with
  /// the given request.
  /// @discussion The method returns nil if there is no
  /// NSCachedURLResponse stored using the given request.
  /// @param request the NSURLRequest to use as a key for the lookup.
  /// @result The NSCachedURLResponse stored in the cache with the given
  /// request, or nil if there is no NSCachedURLResponse stored with the
  /// given request.
  NSCachedURLResponse? cachedResponseForRequest_(NSURLRequest request) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_cachedResponseForRequest_, request.ref.pointer);
    return _ret.address == 0
        ? null
        : NSCachedURLResponse.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// !
  /// @method storeCachedResponse:forRequest:
  /// @abstract Stores the given NSCachedURLResponse in the cache using
  /// the given request.
  /// @param cachedResponse The cached response to store.
  /// @param request the NSURLRequest to use as a key for the storage.
  void storeCachedResponse_forRequest_(
      NSCachedURLResponse cachedResponse, NSURLRequest request) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_storeCachedResponse_forRequest_,
        cachedResponse.ref.pointer, request.ref.pointer);
  }

  /// !
  /// @method removeCachedResponseForRequest:
  /// @abstract Removes the NSCachedURLResponse from the cache that is
  /// stored using the given request.
  /// @discussion No action is taken if there is no NSCachedURLResponse
  /// stored with the given request.
  /// @param request the NSURLRequest to use as a key for the lookup.
  void removeCachedResponseForRequest_(NSURLRequest request) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeCachedResponseForRequest_,
        request.ref.pointer);
  }

  /// !
  /// @method removeAllCachedResponses
  /// @abstract Clears the given cache, removing all NSCachedURLResponse
  /// objects that it stores.
  void removeAllCachedResponses() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeAllCachedResponses);
  }

  /// !
  /// @method removeCachedResponsesSince:
  /// @abstract Clears the given cache of any cached responses since the provided date.
  void removeCachedResponsesSinceDate_(objc.NSDate date) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeCachedResponsesSinceDate_,
        date.ref.pointer);
  }

  /// !
  /// @abstract In-memory capacity of the receiver.
  /// @discussion At the time this call is made, the in-memory cache will truncate its contents to the size given, if necessary.
  /// @result The in-memory capacity, measured in bytes, for the receiver.
  DartNSUInteger get memoryCapacity {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_memoryCapacity);
  }

  /// !
  /// @abstract In-memory capacity of the receiver.
  /// @discussion At the time this call is made, the in-memory cache will truncate its contents to the size given, if necessary.
  /// @result The in-memory capacity, measured in bytes, for the receiver.
  set memoryCapacity(DartNSUInteger value) {
    _objc_msgSend_1i9r4xy(this.ref.pointer, _sel_setMemoryCapacity_, value);
  }

  /// !
  /// @abstract The on-disk capacity of the receiver.
  /// @discussion The on-disk capacity, measured in bytes, for the receiver. On mutation the on-disk cache will truncate its contents to the size given, if necessary.
  DartNSUInteger get diskCapacity {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_diskCapacity);
  }

  /// !
  /// @abstract The on-disk capacity of the receiver.
  /// @discussion The on-disk capacity, measured in bytes, for the receiver. On mutation the on-disk cache will truncate its contents to the size given, if necessary.
  set diskCapacity(DartNSUInteger value) {
    _objc_msgSend_1i9r4xy(this.ref.pointer, _sel_setDiskCapacity_, value);
  }

  /// !
  /// @abstract Returns the current amount of space consumed by the
  /// in-memory cache of the receiver.
  /// @discussion This size, measured in bytes, indicates the current
  /// usage of the in-memory cache.
  /// @result the current usage of the in-memory cache of the receiver.
  DartNSUInteger get currentMemoryUsage {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_currentMemoryUsage);
  }

  /// !
  /// @abstract Returns the current amount of space consumed by the
  /// on-disk cache of the receiver.
  /// @discussion This size, measured in bytes, indicates the current
  /// usage of the on-disk cache.
  /// @result the current usage of the on-disk cache of the receiver.
  DartNSUInteger get currentDiskUsage {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_currentDiskUsage);
  }

  /// init
  NSURLCache init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSURLCache.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSURLCache new1() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLCache, _sel_new);
    return NSURLCache.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLCache allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_NSURLCache, _sel_allocWithZone_, zone);
    return NSURLCache.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSURLCache alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLCache, _sel_alloc);
    return NSURLCache.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  NSURLCache self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSURLCache.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSURLCache retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSURLCache.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSURLCache autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSURLCache.castFromPointer(_ret, retain: true, release: true);
  }
}

typedef NSNotificationName = ffi.Pointer<objc.ObjCObject>;
typedef DartNSNotificationName = objc.NSString;
late final _class_NSNotification = objc.getClass("NSNotification");
late final _sel_notificationWithName_object_ =
    objc.registerName("notificationWithName:object:");
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_notificationWithName_object_userInfo_ =
    objc.registerName("notificationWithName:object:userInfo:");
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();

/// NSNotificationCreation
extension NSNotificationCreation on objc.NSNotification {
  /// notificationWithName:object:
  static objc.NSNotification notificationWithName_object_(
      DartNSNotificationName aName, objc.ObjCObjectBase? anObject) {
    final _ret = _objc_msgSend_15qeuct(
        _class_NSNotification,
        _sel_notificationWithName_object_,
        aName.ref.pointer,
        anObject?.ref.pointer ?? ffi.nullptr);
    return objc.NSNotification.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// notificationWithName:object:userInfo:
  static objc.NSNotification notificationWithName_object_userInfo_(
      DartNSNotificationName aName,
      objc.ObjCObjectBase? anObject,
      objc.NSDictionary? aUserInfo) {
    final _ret = _objc_msgSend_11spmsz(
        _class_NSNotification,
        _sel_notificationWithName_object_userInfo_,
        aName.ref.pointer,
        anObject?.ref.pointer ?? ffi.nullptr,
        aUserInfo?.ref.pointer ?? ffi.nullptr);
    return objc.NSNotification.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// init
  objc.NSNotification init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return objc.NSNotification.castFromPointer(_ret,
        retain: false, release: true);
  }
}

late final _class_NSDate = objc.getClass("NSDate");
late final _sel_timeIntervalSinceDate_ =
    objc.registerName("timeIntervalSinceDate:");
final _objc_msgSend_mabicu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_mabicuFpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        double Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_timeIntervalSinceNow =
    objc.registerName("timeIntervalSinceNow");
late final _sel_timeIntervalSince1970 =
    objc.registerName("timeIntervalSince1970");
late final _sel_addTimeInterval_ = objc.registerName("addTimeInterval:");
final _objc_msgSend_oa8mke = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_dateByAddingTimeInterval_ =
    objc.registerName("dateByAddingTimeInterval:");
late final _sel_earlierDate_ = objc.registerName("earlierDate:");
late final _sel_laterDate_ = objc.registerName("laterDate:");
late final _sel_compare_ = objc.registerName("compare:");
final _objc_msgSend_1ym6zyw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSInteger Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_isEqualToDate_ = objc.registerName("isEqualToDate:");
late final _sel_description = objc.registerName("description");
late final _sel_descriptionWithLocale_ =
    objc.registerName("descriptionWithLocale:");
late final _sel_timeIntervalSinceReferenceDate =
    objc.registerName("timeIntervalSinceReferenceDate");

/// NSExtendedDate
extension NSExtendedDate on objc.NSDate {
  /// timeIntervalSinceDate:
  DartNSTimeInterval timeIntervalSinceDate_(objc.NSDate anotherDate) {
    return objc.useMsgSendVariants
        ? _objc_msgSend_mabicuFpret(this.ref.pointer,
            _sel_timeIntervalSinceDate_, anotherDate.ref.pointer)
        : _objc_msgSend_mabicu(this.ref.pointer, _sel_timeIntervalSinceDate_,
            anotherDate.ref.pointer);
  }

  /// timeIntervalSinceNow
  DartNSTimeInterval get timeIntervalSinceNow {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            this.ref.pointer, _sel_timeIntervalSinceNow)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_timeIntervalSinceNow);
  }

  /// timeIntervalSince1970
  DartNSTimeInterval get timeIntervalSince1970 {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            this.ref.pointer, _sel_timeIntervalSince1970)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_timeIntervalSince1970);
  }

  /// addTimeInterval:
  objc.ObjCObjectBase addTimeInterval_(DartNSTimeInterval seconds) {
    final _ret =
        _objc_msgSend_oa8mke(this.ref.pointer, _sel_addTimeInterval_, seconds);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// dateByAddingTimeInterval:
  objc.NSDate dateByAddingTimeInterval_(DartNSTimeInterval ti) {
    final _ret = _objc_msgSend_oa8mke(
        this.ref.pointer, _sel_dateByAddingTimeInterval_, ti);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// earlierDate:
  objc.NSDate earlierDate_(objc.NSDate anotherDate) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_earlierDate_, anotherDate.ref.pointer);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// laterDate:
  objc.NSDate laterDate_(objc.NSDate anotherDate) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_laterDate_, anotherDate.ref.pointer);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// compare:
  objc.NSComparisonResult compare_(objc.NSDate other) {
    final _ret = _objc_msgSend_1ym6zyw(
        this.ref.pointer, _sel_compare_, other.ref.pointer);
    return objc.NSComparisonResult.fromValue(_ret);
  }

  /// isEqualToDate:
  bool isEqualToDate_(objc.NSDate otherDate) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isEqualToDate_, otherDate.ref.pointer);
  }

  /// description
  objc.NSString get description {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_description);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// descriptionWithLocale:
  objc.NSString descriptionWithLocale_(objc.ObjCObjectBase? locale) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_descriptionWithLocale_, locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// timeIntervalSinceReferenceDate
  static DartNSTimeInterval getTimeIntervalSinceReferenceDate() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            _class_NSDate, _sel_timeIntervalSinceReferenceDate)
        : _objc_msgSend_1ukqyt8(
            _class_NSDate, _sel_timeIntervalSinceReferenceDate);
  }
}

late final _sel_date = objc.registerName("date");
late final _sel_dateWithTimeIntervalSinceNow_ =
    objc.registerName("dateWithTimeIntervalSinceNow:");
late final _sel_dateWithTimeIntervalSinceReferenceDate_ =
    objc.registerName("dateWithTimeIntervalSinceReferenceDate:");
late final _sel_dateWithTimeIntervalSince1970_ =
    objc.registerName("dateWithTimeIntervalSince1970:");
late final _sel_dateWithTimeInterval_sinceDate_ =
    objc.registerName("dateWithTimeInterval:sinceDate:");
final _objc_msgSend_1ozwf6k = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_distantFuture = objc.registerName("distantFuture");
late final _sel_distantPast = objc.registerName("distantPast");
late final _sel_now = objc.registerName("now");
late final _sel_initWithTimeIntervalSinceNow_ =
    objc.registerName("initWithTimeIntervalSinceNow:");
late final _sel_initWithTimeIntervalSince1970_ =
    objc.registerName("initWithTimeIntervalSince1970:");
late final _sel_initWithTimeInterval_sinceDate_ =
    objc.registerName("initWithTimeInterval:sinceDate:");

/// NSDateCreation
extension NSDateCreation on objc.NSDate {
  /// date
  static objc.NSDate date() {
    final _ret = _objc_msgSend_151sglz(_class_NSDate, _sel_date);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// dateWithTimeIntervalSinceNow:
  static objc.NSDate dateWithTimeIntervalSinceNow_(DartNSTimeInterval secs) {
    final _ret = _objc_msgSend_oa8mke(
        _class_NSDate, _sel_dateWithTimeIntervalSinceNow_, secs);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// dateWithTimeIntervalSinceReferenceDate:
  static objc.NSDate dateWithTimeIntervalSinceReferenceDate_(
      DartNSTimeInterval ti) {
    final _ret = _objc_msgSend_oa8mke(
        _class_NSDate, _sel_dateWithTimeIntervalSinceReferenceDate_, ti);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// dateWithTimeIntervalSince1970:
  static objc.NSDate dateWithTimeIntervalSince1970_(DartNSTimeInterval secs) {
    final _ret = _objc_msgSend_oa8mke(
        _class_NSDate, _sel_dateWithTimeIntervalSince1970_, secs);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// dateWithTimeInterval:sinceDate:
  static objc.NSDate dateWithTimeInterval_sinceDate_(
      DartNSTimeInterval secsToBeAdded, objc.NSDate date) {
    final _ret = _objc_msgSend_1ozwf6k(_class_NSDate,
        _sel_dateWithTimeInterval_sinceDate_, secsToBeAdded, date.ref.pointer);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// distantFuture
  static objc.NSDate getDistantFuture() {
    final _ret = _objc_msgSend_151sglz(_class_NSDate, _sel_distantFuture);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// distantPast
  static objc.NSDate getDistantPast() {
    final _ret = _objc_msgSend_151sglz(_class_NSDate, _sel_distantPast);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// now
  static objc.NSDate getNow() {
    final _ret = _objc_msgSend_151sglz(_class_NSDate, _sel_now);
    return objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithTimeIntervalSinceNow:
  objc.NSDate initWithTimeIntervalSinceNow_(DartNSTimeInterval secs) {
    final _ret = _objc_msgSend_oa8mke(this.ref.retainAndReturnPointer(),
        _sel_initWithTimeIntervalSinceNow_, secs);
    return objc.NSDate.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithTimeIntervalSince1970:
  objc.NSDate initWithTimeIntervalSince1970_(DartNSTimeInterval secs) {
    final _ret = _objc_msgSend_oa8mke(this.ref.retainAndReturnPointer(),
        _sel_initWithTimeIntervalSince1970_, secs);
    return objc.NSDate.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithTimeInterval:sinceDate:
  objc.NSDate initWithTimeInterval_sinceDate_(
      DartNSTimeInterval secsToBeAdded, objc.NSDate date) {
    final _ret = _objc_msgSend_1ozwf6k(this.ref.retainAndReturnPointer(),
        _sel_initWithTimeInterval_sinceDate_, secsToBeAdded, date.ref.pointer);
    return objc.NSDate.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _class_NSMutableURLRequest = objc.getClass("NSMutableURLRequest");
late final _sel_setHTTPMethod_ = objc.registerName("setHTTPMethod:");
late final _sel_setAllHTTPHeaderFields_ =
    objc.registerName("setAllHTTPHeaderFields:");
late final _sel_setValue_forHTTPHeaderField_ =
    objc.registerName("setValue:forHTTPHeaderField:");
late final _sel_addValue_forHTTPHeaderField_ =
    objc.registerName("addValue:forHTTPHeaderField:");
late final _sel_setHTTPBody_ = objc.registerName("setHTTPBody:");
late final _sel_setHTTPBodyStream_ = objc.registerName("setHTTPBodyStream:");
late final _sel_setHTTPShouldHandleCookies_ =
    objc.registerName("setHTTPShouldHandleCookies:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_setHTTPShouldUsePipelining_ =
    objc.registerName("setHTTPShouldUsePipelining:");

/// !
/// @category NSMutableURLRequest(NSMutableHTTPURLRequest)
/// The NSMutableHTTPURLRequest on NSMutableURLRequest provides methods
/// for configuring information specific to HTTP protocol requests.
extension NSMutableHTTPURLRequest on NSMutableURLRequest {
  /// !
  /// @abstract Sets the HTTP request method of the receiver.
  objc.NSString get HTTPMethod {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_HTTPMethod);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the HTTP request method of the receiver.
  set HTTPMethod(objc.NSString value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHTTPMethod_, value.ref.pointer);
  }

  /// !
  /// @abstract Sets the HTTP header fields of the receiver to the given
  /// dictionary.
  /// @discussion This method replaces all header fields that may have
  /// existed before this method call.
  /// <p>Since HTTP header fields must be string values, each object and
  /// key in the dictionary passed to this method must answer YES when
  /// sent an <tt>-isKindOfClass:[NSString class]</tt> message. If either
  /// the key or value for a key-value pair answers NO when sent this
  /// message, the key-value pair is skipped.
  objc.NSDictionary? get allHTTPHeaderFields {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_allHTTPHeaderFields);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the HTTP header fields of the receiver to the given
  /// dictionary.
  /// @discussion This method replaces all header fields that may have
  /// existed before this method call.
  /// <p>Since HTTP header fields must be string values, each object and
  /// key in the dictionary passed to this method must answer YES when
  /// sent an <tt>-isKindOfClass:[NSString class]</tt> message. If either
  /// the key or value for a key-value pair answers NO when sent this
  /// message, the key-value pair is skipped.
  set allHTTPHeaderFields(objc.NSDictionary? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setAllHTTPHeaderFields_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// !
  /// @method setValue:forHTTPHeaderField:
  /// @abstract Sets the value of the given HTTP header field.
  /// @discussion If a value was previously set for the given header
  /// field, that value is replaced with the given value. Note that, in
  /// keeping with the HTTP RFC, HTTP header field names are
  /// case-insensitive.
  /// @param value the header field value.
  /// @param field the header field name (case-insensitive).
  void setValue_forHTTPHeaderField_(objc.NSString? value, objc.NSString field) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_setValue_forHTTPHeaderField_,
        value?.ref.pointer ?? ffi.nullptr, field.ref.pointer);
  }

  /// !
  /// @method addValue:forHTTPHeaderField:
  /// @abstract Adds an HTTP header field in the current header
  /// dictionary.
  /// @discussion This method provides a way to add values to header
  /// fields incrementally. If a value was previously set for the given
  /// header field, the given value is appended to the previously-existing
  /// value. The appropriate field delimiter, a comma in the case of HTTP,
  /// is added by the implementation, and should not be added to the given
  /// value by the caller. Note that, in keeping with the HTTP RFC, HTTP
  /// header field names are case-insensitive.
  /// @param value the header field value.
  /// @param field the header field name (case-insensitive).
  void addValue_forHTTPHeaderField_(objc.NSString value, objc.NSString field) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_addValue_forHTTPHeaderField_,
        value.ref.pointer, field.ref.pointer);
  }

  /// !
  /// @abstract Sets the request body data of the receiver.
  /// @discussion This data is sent as the message body of the request, as
  /// in done in an HTTP POST request.
  objc.NSData? get HTTPBody {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_HTTPBody);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the request body data of the receiver.
  /// @discussion This data is sent as the message body of the request, as
  /// in done in an HTTP POST request.
  set HTTPBody(objc.NSData? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setHTTPBody_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// !
  /// @abstract Sets the request body to be the contents of the given stream.
  /// @discussion The provided stream should be unopened; the request will take
  /// over the stream's delegate.  The entire stream's contents will be
  /// transmitted as the HTTP body of the request.  Note that the body stream
  /// and the body data (set by setHTTPBody:, above) are mutually exclusive
  /// - setting one will clear the other.
  objc.NSInputStream? get HTTPBodyStream {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_HTTPBodyStream);
    return _ret.address == 0
        ? null
        : objc.NSInputStream.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the request body to be the contents of the given stream.
  /// @discussion The provided stream should be unopened; the request will take
  /// over the stream's delegate.  The entire stream's contents will be
  /// transmitted as the HTTP body of the request.  Note that the body stream
  /// and the body data (set by setHTTPBody:, above) are mutually exclusive
  /// - setting one will clear the other.
  set HTTPBodyStream(objc.NSInputStream? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setHTTPBodyStream_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// !
  /// @abstract Decide whether default cookie handling will happen for
  /// this request (YES if cookies should be sent with and set for this request;
  /// otherwise NO).
  /// @discussion The default is YES - in other words, cookies are sent from and
  /// stored to the cookie manager by default.
  /// NOTE: In releases prior to 10.3, this value is ignored
  bool get HTTPShouldHandleCookies {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_HTTPShouldHandleCookies);
  }

  /// !
  /// @abstract Decide whether default cookie handling will happen for
  /// this request (YES if cookies should be sent with and set for this request;
  /// otherwise NO).
  /// @discussion The default is YES - in other words, cookies are sent from and
  /// stored to the cookie manager by default.
  /// NOTE: In releases prior to 10.3, this value is ignored
  set HTTPShouldHandleCookies(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setHTTPShouldHandleCookies_, value);
  }

  /// !
  /// @abstract Sets whether the request should not wait for the previous response
  /// before transmitting (YES if the receiver should transmit before the previous response is
  /// received.  NO to wait for the previous response before transmitting)
  /// @discussion Calling this method with a YES value does not guarantee HTTP
  /// pipelining behavior.  This method may have no effect if an HTTP proxy is
  /// configured, or if the HTTP request uses an unsafe request method (e.g., POST
  /// requests will not pipeline).  Pipelining behavior also may not begin until
  /// the second request on a given TCP connection.  There may be other situations
  /// where pipelining does not occur even though YES was set.
  /// HTTP 1.1 allows the client to send multiple requests to the server without
  /// waiting for a response.  Though HTTP 1.1 requires support for pipelining,
  /// some servers report themselves as being HTTP 1.1 but do not support
  /// pipelining (disconnecting, sending resources misordered, omitting part of
  /// a resource, etc.).
  bool get HTTPShouldUsePipelining {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_HTTPShouldUsePipelining);
  }

  /// !
  /// @abstract Sets whether the request should not wait for the previous response
  /// before transmitting (YES if the receiver should transmit before the previous response is
  /// received.  NO to wait for the previous response before transmitting)
  /// @discussion Calling this method with a YES value does not guarantee HTTP
  /// pipelining behavior.  This method may have no effect if an HTTP proxy is
  /// configured, or if the HTTP request uses an unsafe request method (e.g., POST
  /// requests will not pipeline).  Pipelining behavior also may not begin until
  /// the second request on a given TCP connection.  There may be other situations
  /// where pipelining does not occur even though YES was set.
  /// HTTP 1.1 allows the client to send multiple requests to the server without
  /// waiting for a response.  Though HTTP 1.1 requires support for pipelining,
  /// some servers report themselves as being HTTP 1.1 but do not support
  /// pipelining (disconnecting, sending resources misordered, omitting part of
  /// a resource, etc.).
  set HTTPShouldUsePipelining(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setHTTPShouldUsePipelining_, value);
  }
}

late final _sel_setURL_ = objc.registerName("setURL:");
late final _sel_setCachePolicy_ = objc.registerName("setCachePolicy:");
final _objc_msgSend_1yjxuv2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, NSUInteger)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setTimeoutInterval_ = objc.registerName("setTimeoutInterval:");
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_setMainDocumentURL_ = objc.registerName("setMainDocumentURL:");
late final _sel_setNetworkServiceType_ =
    objc.registerName("setNetworkServiceType:");
final _objc_msgSend_1mse4s1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, NSUInteger)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setAllowsCellularAccess_ =
    objc.registerName("setAllowsCellularAccess:");
late final _sel_setAllowsExpensiveNetworkAccess_ =
    objc.registerName("setAllowsExpensiveNetworkAccess:");
late final _sel_setAllowsConstrainedNetworkAccess_ =
    objc.registerName("setAllowsConstrainedNetworkAccess:");
late final _sel_setAssumesHTTP3Capable_ =
    objc.registerName("setAssumesHTTP3Capable:");
late final _sel_setAttribution_ = objc.registerName("setAttribution:");
final _objc_msgSend_1nw1jep = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, NSUInteger)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setRequiresDNSSECValidation_ =
    objc.registerName("setRequiresDNSSECValidation:");
late final _sel_setAllowsPersistentDNS_ =
    objc.registerName("setAllowsPersistentDNS:");

/// !
/// @class NSMutableURLRequest
///
/// @abstract An NSMutableURLRequest object represents a mutable URL load
/// request in a manner independent of protocol and URL scheme.
///
/// @discussion This specialization of NSURLRequest is provided to aid
/// developers who may find it more convenient to mutate a single request
/// object for a series of URL loads instead of creating an immutable
/// NSURLRequest for each load. This programming model is supported by
/// the following contract stipulation between NSMutableURLRequest and
/// NSURLConnection: NSURLConnection makes a deep copy of each
/// NSMutableURLRequest object passed to one of its initializers.
/// <p>NSMutableURLRequest is designed to be extended to support
/// protocol-specific data by adding categories to access a property
/// object provided in an interface targeted at protocol implementors.
/// <ul>
/// <li>Protocol implementors should direct their attention to the
/// NSMutableURLRequestExtensibility category on
/// NSMutableURLRequest for more information on how to provide
/// extensions on NSMutableURLRequest to support protocol-specific
/// request information.
/// <li>Clients of this API who wish to create NSMutableURLRequest
/// objects to load URL content should consult the protocol-specific
/// NSMutableURLRequest categories that are available. The
/// NSMutableHTTPURLRequest category on NSMutableURLRequest is an
/// example.
/// </ul>
class NSMutableURLRequest extends NSURLRequest {
  NSMutableURLRequest._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSMutableURLRequest] that points to the same underlying object as [other].
  NSMutableURLRequest.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSMutableURLRequest] that wraps the given raw object pointer.
  NSMutableURLRequest.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSMutableURLRequest].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSMutableURLRequest);
  }

  /// !
  /// @abstract The URL of the receiver.
  objc.NSURL? get URL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_URL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract The URL of the receiver.
  set URL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setURL_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// !
  /// @abstract The cache policy of the receiver.
  NSURLRequestCachePolicy get cachePolicy {
    final _ret = _objc_msgSend_8jm3uo(this.ref.pointer, _sel_cachePolicy);
    return NSURLRequestCachePolicy.fromValue(_ret);
  }

  /// !
  /// @abstract The cache policy of the receiver.
  set cachePolicy(NSURLRequestCachePolicy value) {
    _objc_msgSend_1yjxuv2(this.ref.pointer, _sel_setCachePolicy_, value.value);
  }

  /// !
  /// @abstract Sets the timeout interval of the receiver.
  /// @discussion The timeout interval specifies the limit on the idle
  /// interval allotted to a request in the process of loading. The "idle
  /// interval" is defined as the period of time that has passed since the
  /// last instance of load activity occurred for a request that is in the
  /// process of loading. Hence, when an instance of load activity occurs
  /// (e.g. bytes are received from the network for a request), the idle
  /// interval for a request is reset to 0. If the idle interval ever
  /// becomes greater than or equal to the timeout interval, the request
  /// is considered to have timed out. This timeout interval is measured
  /// in seconds.
  DartNSTimeInterval get timeoutInterval {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_timeoutInterval)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_timeoutInterval);
  }

  /// !
  /// @abstract Sets the timeout interval of the receiver.
  /// @discussion The timeout interval specifies the limit on the idle
  /// interval allotted to a request in the process of loading. The "idle
  /// interval" is defined as the period of time that has passed since the
  /// last instance of load activity occurred for a request that is in the
  /// process of loading. Hence, when an instance of load activity occurs
  /// (e.g. bytes are received from the network for a request), the idle
  /// interval for a request is reset to 0. If the idle interval ever
  /// becomes greater than or equal to the timeout interval, the request
  /// is considered to have timed out. This timeout interval is measured
  /// in seconds.
  set timeoutInterval(DartNSTimeInterval value) {
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setTimeoutInterval_, value);
  }

  /// !
  /// @abstract Sets the main document URL
  /// @discussion The caller should pass the URL for an appropriate main
  /// document, if known. For example, when loading a web page, the URL
  /// of the main html document for the top-level frame should be
  /// passed.  This main document is used to implement the cookie "only
  /// from same domain as main document" policy, attributing this request
  /// as a sub-resource of a user-specified URL, and possibly other things
  /// in the future.
  objc.NSURL? get mainDocumentURL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_mainDocumentURL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Sets the main document URL
  /// @discussion The caller should pass the URL for an appropriate main
  /// document, if known. For example, when loading a web page, the URL
  /// of the main html document for the top-level frame should be
  /// passed.  This main document is used to implement the cookie "only
  /// from same domain as main document" policy, attributing this request
  /// as a sub-resource of a user-specified URL, and possibly other things
  /// in the future.
  set mainDocumentURL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMainDocumentURL_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// !
  /// @abstract Sets the NSURLRequestNetworkServiceType to associate with this request
  /// @discussion This method is used to provide the network layers with a hint as to the purpose
  /// of the request.  Most clients should not need to use this method.
  NSURLRequestNetworkServiceType get networkServiceType {
    final _ret =
        _objc_msgSend_t4uaw1(this.ref.pointer, _sel_networkServiceType);
    return NSURLRequestNetworkServiceType.fromValue(_ret);
  }

  /// !
  /// @abstract Sets the NSURLRequestNetworkServiceType to associate with this request
  /// @discussion This method is used to provide the network layers with a hint as to the purpose
  /// of the request.  Most clients should not need to use this method.
  set networkServiceType(NSURLRequestNetworkServiceType value) {
    _objc_msgSend_1mse4s1(
        this.ref.pointer, _sel_setNetworkServiceType_, value.value);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// the built in cellular radios (if present).
  /// @discussion NO if the receiver should not be allowed to use the built in
  /// cellular radios to satisfy the request, YES otherwise.  The default is YES.
  bool get allowsCellularAccess {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_allowsCellularAccess);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// the built in cellular radios (if present).
  /// @discussion NO if the receiver should not be allowed to use the built in
  /// cellular radios to satisfy the request, YES otherwise.  The default is YES.
  set allowsCellularAccess(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAllowsCellularAccess_, value);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as expensive.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as expensive to
  /// satisfy the request, YES otherwise.
  bool get allowsExpensiveNetworkAccess {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_allowsExpensiveNetworkAccess);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as expensive.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as expensive to
  /// satisfy the request, YES otherwise.
  set allowsExpensiveNetworkAccess(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAllowsExpensiveNetworkAccess_, value);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as constrained.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as constrained to
  /// satisfy the request, YES otherwise.
  bool get allowsConstrainedNetworkAccess {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_allowsConstrainedNetworkAccess);
  }

  /// !
  /// @abstract sets whether a connection created with this request is allowed to use
  /// network interfaces which have been marked as constrained.
  /// @discussion NO if the receiver should not be allowed to use an interface marked as constrained to
  /// satisfy the request, YES otherwise.
  set allowsConstrainedNetworkAccess(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAllowsConstrainedNetworkAccess_, value);
  }

  /// !
  /// @abstract returns whether we assume that server supports HTTP/3. Enables QUIC
  /// racing without HTTP/3 service discovery.
  /// @result YES if server endpoint is known to support HTTP/3. Defaults to NO.
  /// The default may be YES in a future OS update.
  bool get assumesHTTP3Capable {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_assumesHTTP3Capable);
  }

  /// !
  /// @abstract returns whether we assume that server supports HTTP/3. Enables QUIC
  /// racing without HTTP/3 service discovery.
  /// @result YES if server endpoint is known to support HTTP/3. Defaults to NO.
  /// The default may be YES in a future OS update.
  set assumesHTTP3Capable(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAssumesHTTP3Capable_, value);
  }

  /// !
  /// @abstract Sets the NSURLRequestAttribution to associate with this request.
  /// @discussion Set to NSURLRequestAttributionUser if the URL was specified by the
  /// user. Defaults to NSURLRequestAttributionDeveloper.
  NSURLRequestAttribution get attribution {
    final _ret = _objc_msgSend_i3avs9(this.ref.pointer, _sel_attribution);
    return NSURLRequestAttribution.fromValue(_ret);
  }

  /// !
  /// @abstract Sets the NSURLRequestAttribution to associate with this request.
  /// @discussion Set to NSURLRequestAttributionUser if the URL was specified by the
  /// user. Defaults to NSURLRequestAttributionDeveloper.
  set attribution(NSURLRequestAttribution value) {
    _objc_msgSend_1nw1jep(this.ref.pointer, _sel_setAttribution_, value.value);
  }

  /// !
  /// @abstract sets whether a request is required to do DNSSEC validation during DNS lookup.
  /// @discussion YES, if the DNS lookup for this request should require DNSSEC validation,
  /// No otherwise. Defaults to NO.
  bool get requiresDNSSECValidation {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_requiresDNSSECValidation);
  }

  /// !
  /// @abstract sets whether a request is required to do DNSSEC validation during DNS lookup.
  /// @discussion YES, if the DNS lookup for this request should require DNSSEC validation,
  /// No otherwise. Defaults to NO.
  set requiresDNSSECValidation(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setRequiresDNSSECValidation_, value);
  }

  /// !
  /// @abstract Allows storing and usage of DNS answers, potentially beyond TTL expiry,
  /// in a persistent per-process cache. This should only be set for hostnames whose resolutions
  /// are not expected to change across networks.
  /// @discussion YES, if the DNS lookup for this request is allowed to use a persistent per-process cache,
  /// NO otherwise. Defaults to NO.
  bool get allowsPersistentDNS {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_allowsPersistentDNS);
  }

  /// !
  /// @abstract Allows storing and usage of DNS answers, potentially beyond TTL expiry,
  /// in a persistent per-process cache. This should only be set for hostnames whose resolutions
  /// are not expected to change across networks.
  /// @discussion YES, if the DNS lookup for this request is allowed to use a persistent per-process cache,
  /// NO otherwise. Defaults to NO.
  set allowsPersistentDNS(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAllowsPersistentDNS_, value);
  }

  /// !
  /// @method requestWithURL:
  /// @abstract Allocates and initializes an NSURLRequest with the given
  /// URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSMutableURLRequest requestWithURL_(objc.NSURL URL) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSMutableURLRequest, _sel_requestWithURL_, URL.ref.pointer);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_NSMutableURLRequest, _sel_supportsSecureCoding);
  }

  /// !
  /// @method requestWithURL:cachePolicy:timeoutInterval:
  /// @abstract Allocates and initializes a NSURLRequest with the given
  /// URL and cache policy.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result A newly-created and autoreleased NSURLRequest instance.
  static NSMutableURLRequest requestWithURL_cachePolicy_timeoutInterval_(
      objc.NSURL URL,
      NSURLRequestCachePolicy cachePolicy,
      DartNSTimeInterval timeoutInterval) {
    final _ret = _objc_msgSend_1ajs603(
        _class_NSMutableURLRequest,
        _sel_requestWithURL_cachePolicy_timeoutInterval_,
        URL.ref.pointer,
        cachePolicy.value,
        timeoutInterval);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// !
  /// @method initWithURL:
  /// @abstract Initializes an NSURLRequest with the given URL.
  /// @discussion Default values are used for cache policy
  /// (NSURLRequestUseProtocolCachePolicy) and timeout interval (60
  /// seconds).
  /// @param URL The URL for the request.
  /// @result An initialized NSURLRequest.
  NSMutableURLRequest initWithURL_(objc.NSURL URL) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.retainAndReturnPointer(), _sel_initWithURL_, URL.ref.pointer);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// !
  /// @method initWithURL:
  /// @abstract Initializes an NSURLRequest with the given URL and
  /// cache policy.
  /// @discussion This is the designated initializer for the
  /// NSURLRequest class.
  /// @param URL The URL for the request.
  /// @param cachePolicy The cache policy for the request.
  /// @param timeoutInterval The timeout interval for the request. See the
  /// commentary for the <tt>timeoutInterval</tt> for more information on
  /// timeout intervals.
  /// @result An initialized NSURLRequest.
  NSMutableURLRequest initWithURL_cachePolicy_timeoutInterval_(objc.NSURL URL,
      NSURLRequestCachePolicy cachePolicy, DartNSTimeInterval timeoutInterval) {
    final _ret = _objc_msgSend_1ajs603(
        this.ref.retainAndReturnPointer(),
        _sel_initWithURL_cachePolicy_timeoutInterval_,
        URL.ref.pointer,
        cachePolicy.value,
        timeoutInterval);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// init
  NSMutableURLRequest init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static NSMutableURLRequest new1() {
    final _ret = _objc_msgSend_151sglz(_class_NSMutableURLRequest, _sel_new);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static NSMutableURLRequest allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_NSMutableURLRequest, _sel_allocWithZone_, zone);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static NSMutableURLRequest alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSMutableURLRequest, _sel_alloc);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  NSMutableURLRequest self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  NSMutableURLRequest retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  NSMutableURLRequest autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSMutableURLRequest.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// initWithCoder:
  NSMutableURLRequest? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : NSMutableURLRequest.castFromPointer(_ret,
            retain: false, release: true);
  }
}

enum NSHTTPCookieAcceptPolicy {
  NSHTTPCookieAcceptPolicyAlways(0),
  NSHTTPCookieAcceptPolicyNever(1),
  NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain(2);

  final int value;
  const NSHTTPCookieAcceptPolicy(this.value);

  static NSHTTPCookieAcceptPolicy fromValue(int value) => switch (value) {
        0 => NSHTTPCookieAcceptPolicyAlways,
        1 => NSHTTPCookieAcceptPolicyNever,
        2 => NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain,
        _ => throw ArgumentError(
            "Unknown value for NSHTTPCookieAcceptPolicy: $value"),
      };
}

/// WARNING: NSHTTPCookieStorage is a stub. To generate bindings for this class, include
/// NSHTTPCookieStorage in your config's objc-interfaces list.
///
/// NSHTTPCookieStorage
class NSHTTPCookieStorage extends objc.NSObject {
  NSHTTPCookieStorage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSHTTPCookieStorage] that points to the same underlying object as [other].
  NSHTTPCookieStorage.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSHTTPCookieStorage] that wraps the given raw object pointer.
  NSHTTPCookieStorage.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_NSHTTPCookieStorage = objc.getClass("NSHTTPCookieStorage");
late final _class_NSURLSessionTask = objc.getClass("NSURLSessionTask");
late final _sel_taskIdentifier = objc.registerName("taskIdentifier");
late final _sel_originalRequest = objc.registerName("originalRequest");
late final _sel_currentRequest = objc.registerName("currentRequest");
late final _class_NSURLResponse = objc.getClass("NSURLResponse");
late final _sel_initWithURL_MIMEType_expectedContentLength_textEncodingName_ =
    objc.registerName(
        "initWithURL:MIMEType:expectedContentLength:textEncodingName:");
final _objc_msgSend_l9ppnx = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_MIMEType = objc.registerName("MIMEType");
late final _sel_expectedContentLength =
    objc.registerName("expectedContentLength");
final _objc_msgSend_1k101e3 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.LongLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_textEncodingName = objc.registerName("textEncodingName");
late final _sel_suggestedFilename = objc.registerName("suggestedFilename");

/// NSURLResponse
class NSURLResponse extends objc.NSObject {
  NSURLResponse._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLResponse] that points to the same underlying object as [other].
  NSURLResponse.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLResponse] that wraps the given raw object pointer.
  NSURLResponse.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLResponse].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSURLResponse);
  }

  /// !
  /// @method initWithURL:MIMEType:expectedContentLength:textEncodingName:
  /// @abstract Initialize an NSURLResponse with the provided values.
  /// @param URL the URL
  /// @param MIMEType the MIME content type of the response
  /// @param length the expected content length of the associated data
  /// @param name the name of the text encoding for the associated data, if applicable, else nil
  /// @result The initialized NSURLResponse.
  /// @discussion This is the designated initializer for NSURLResponse.
  NSURLResponse initWithURL_MIMEType_expectedContentLength_textEncodingName_(
      objc.NSURL URL,
      objc.NSString? MIMEType,
      DartNSInteger length,
      objc.NSString? name) {
    final _ret = _objc_msgSend_l9ppnx(
        this.ref.retainAndReturnPointer(),
        _sel_initWithURL_MIMEType_expectedContentLength_textEncodingName_,
        URL.ref.pointer,
        MIMEType?.ref.pointer ?? ffi.nullptr,
        length,
        name?.ref.pointer ?? ffi.nullptr);
    return NSURLResponse.castFromPointer(_ret, retain: false, release: true);
  }

  /// !
  /// @abstract Returns the URL of the receiver.
  /// @result The URL of the receiver.
  objc.NSURL? get URL {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_URL);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the MIME type of the receiver.
  /// @discussion The MIME type is based on the information provided
  /// from an origin source. However, that value may be changed or
  /// corrected by a protocol implementation if it can be determined
  /// that the origin server or source reported the information
  /// incorrectly or imprecisely. An attempt to guess the MIME type may
  /// be made if the origin source did not report any such information.
  /// @result The MIME type of the receiver.
  objc.NSString? get MIMEType {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_MIMEType);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns the expected content length of the receiver.
  /// @discussion Some protocol implementations report a content length
  /// as part of delivering load metadata, but not all protocols
  /// guarantee the amount of data that will be delivered in actuality.
  /// Hence, this method returns an expected amount. Clients should use
  /// this value as an advisory, and should be prepared to deal with
  /// either more or less data.
  /// @result The expected content length of the receiver, or -1 if
  /// there is no expectation that can be arrived at regarding expected
  /// content length.
  int get expectedContentLength {
    return _objc_msgSend_1k101e3(this.ref.pointer, _sel_expectedContentLength);
  }

  /// !
  /// @abstract Returns the name of the text encoding of the receiver.
  /// @discussion This name will be the actual string reported by the
  /// origin source during the course of performing a protocol-specific
  /// URL load. Clients can inspect this string and convert it to an
  /// NSStringEncoding or CFStringEncoding using the methods and
  /// functions made available in the appropriate framework.
  /// @result The name of the text encoding of the receiver, or nil if no
  /// text encoding was specified.
  objc.NSString? get textEncodingName {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textEncodingName);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @abstract Returns a suggested filename if the resource were saved to disk.
  /// @discussion The method first checks if the server has specified a filename using the
  /// content disposition header. If no valid filename is specified using that mechanism,
  /// this method checks the last path component of the URL. If no valid filename can be
  /// obtained using the last path component, this method uses the URL's host as the filename.
  /// If the URL's host can't be converted to a valid filename, the filename "unknown" is used.
  /// In most cases, this method appends the proper file extension based on the MIME type.
  /// This method always returns a valid filename.
  /// @result A suggested filename to use if saving the resource to disk.
  objc.NSString? get suggestedFilename {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_suggestedFilename);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSURLResponse init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSURLResponse.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSURLResponse new1() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLResponse, _sel_new);
    return NSURLResponse.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLResponse allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_NSURLResponse, _sel_allocWithZone_, zone);
    return NSURLResponse.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSURLResponse alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLResponse, _sel_alloc);
    return NSURLResponse.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  NSURLResponse self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSURLResponse.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSURLResponse retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSURLResponse.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSURLResponse autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSURLResponse.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_NSURLResponse, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder_(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  NSURLResponse? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : NSURLResponse.castFromPointer(_ret, retain: false, release: true);
  }
}

late final _sel_response = objc.registerName("response");
late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");

/// WARNING: NSProgress is a stub. To generate bindings for this class, include
/// NSProgress in your config's objc-interfaces list.
///
/// NSProgress
class NSProgress extends objc.NSObject {
  NSProgress._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSProgress] that points to the same underlying object as [other].
  NSProgress.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSProgress] that wraps the given raw object pointer.
  NSProgress.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_progress = objc.registerName("progress");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSProgress_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSProgress_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSProgress_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSProgress_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSProgress_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSProgress_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSProgress Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<NSProgress Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<NSProgress Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSProgress Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<NSProgress Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_NSProgress_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSProgress Function(ffi.Pointer<ffi.Void>)>
      fromFunction(NSProgress Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<NSProgress Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSProgress_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease()),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<NSProgress Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSProgress_ffiVoid_CallExtension
    on objc.ObjCBlock<NSProgress Function(ffi.Pointer<ffi.Void>)> {
  NSProgress call(ffi.Pointer<ffi.Void> arg0) => NSProgress.castFromPointer(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_earliestBeginDate = objc.registerName("earliestBeginDate");
late final _sel_setEarliestBeginDate_ =
    objc.registerName("setEarliestBeginDate:");
late final _sel_countOfBytesClientExpectsToSend =
    objc.registerName("countOfBytesClientExpectsToSend");
final _objc_msgSend_pysgoz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Int64 Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setCountOfBytesClientExpectsToSend_ =
    objc.registerName("setCountOfBytesClientExpectsToSend:");
final _objc_msgSend_17gvxvj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int64)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_countOfBytesClientExpectsToReceive =
    objc.registerName("countOfBytesClientExpectsToReceive");
late final _sel_setCountOfBytesClientExpectsToReceive_ =
    objc.registerName("setCountOfBytesClientExpectsToReceive:");
late final _sel_countOfBytesSent = objc.registerName("countOfBytesSent");
late final _sel_countOfBytesReceived =
    objc.registerName("countOfBytesReceived");
late final _sel_countOfBytesExpectedToSend =
    objc.registerName("countOfBytesExpectedToSend");
late final _sel_countOfBytesExpectedToReceive =
    objc.registerName("countOfBytesExpectedToReceive");
late final _sel_taskDescription = objc.registerName("taskDescription");
late final _sel_setTaskDescription_ = objc.registerName("setTaskDescription:");
late final _sel_cancel = objc.registerName("cancel");

enum NSURLSessionTaskState {
  /// The task is currently being serviced by the session
  NSURLSessionTaskStateRunning(0),
  NSURLSessionTaskStateSuspended(1),

  /// The task has been told to cancel.  The session will receive a URLSession:task:didCompleteWithError: message.
  NSURLSessionTaskStateCanceling(2),

  /// The task has completed and the session will receive no more delegate notifications
  NSURLSessionTaskStateCompleted(3);

  final int value;
  const NSURLSessionTaskState(this.value);

  static NSURLSessionTaskState fromValue(int value) => switch (value) {
        0 => NSURLSessionTaskStateRunning,
        1 => NSURLSessionTaskStateSuspended,
        2 => NSURLSessionTaskStateCanceling,
        3 => NSURLSessionTaskStateCompleted,
        _ => throw ArgumentError(
            "Unknown value for NSURLSessionTaskState: $value"),
      };
}

late final _sel_state = objc.registerName("state");
final _objc_msgSend_1vze0g9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_error = objc.registerName("error");
late final _sel_suspend = objc.registerName("suspend");
late final _sel_resume = objc.registerName("resume");
late final _sel_priority = objc.registerName("priority");
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPriority_ = objc.registerName("setPriority:");
final _objc_msgSend_v5hmet = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Float)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_prefersIncrementalDelivery =
    objc.registerName("prefersIncrementalDelivery");
late final _sel_setPrefersIncrementalDelivery_ =
    objc.registerName("setPrefersIncrementalDelivery:");

/// NSURLSessionTask - a cancelable object that refers to the lifetime
/// of processing a given request.
class NSURLSessionTask extends objc.NSObject {
  NSURLSessionTask._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLSessionTask] that points to the same underlying object as [other].
  NSURLSessionTask.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLSessionTask] that wraps the given raw object pointer.
  NSURLSessionTask.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLSessionTask].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSURLSessionTask);
  }

  /// an identifier for this task, assigned by and unique to the owning session
  DartNSUInteger get taskIdentifier {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_taskIdentifier);
  }

  /// may be nil if this is a stream task
  NSURLRequest? get originalRequest {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_originalRequest);
    return _ret.address == 0
        ? null
        : NSURLRequest.castFromPointer(_ret, retain: true, release: true);
  }

  /// may differ from originalRequest due to http server redirection
  NSURLRequest? get currentRequest {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_currentRequest);
    return _ret.address == 0
        ? null
        : NSURLRequest.castFromPointer(_ret, retain: true, release: true);
  }

  /// may be nil if no response has been received
  NSURLResponse? get response {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_response);
    return _ret.address == 0
        ? null
        : NSURLResponse.castFromPointer(_ret, retain: true, release: true);
  }

  /// Sets a task-specific delegate. Methods not implemented on this delegate will
  /// still be forwarded to the session delegate.
  ///
  /// Cannot be modified after task resumes. Not supported on background session.
  ///
  /// Delegate is strongly referenced until the task completes, after which it is
  /// reset to `nil`.
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// Sets a task-specific delegate. Methods not implemented on this delegate will
  /// still be forwarded to the session delegate.
  ///
  /// Cannot be modified after task resumes. Not supported on background session.
  ///
  /// Delegate is strongly referenced until the task completes, after which it is
  /// reset to `nil`.
  set delegate(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// progress
  NSProgress get progress {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_progress);
    return NSProgress.castFromPointer(_ret, retain: true, release: true);
  }

  /// Start the network load for this task no earlier than the specified date. If
  /// not specified, no start delay is used.
  ///
  /// Only applies to tasks created from background NSURLSession instances; has no
  /// effect for tasks created from other session types.
  objc.NSDate? get earliestBeginDate {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_earliestBeginDate);
    return _ret.address == 0
        ? null
        : objc.NSDate.castFromPointer(_ret, retain: true, release: true);
  }

  /// Start the network load for this task no earlier than the specified date. If
  /// not specified, no start delay is used.
  ///
  /// Only applies to tasks created from background NSURLSession instances; has no
  /// effect for tasks created from other session types.
  set earliestBeginDate(objc.NSDate? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setEarliestBeginDate_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// The number of bytes that the client expects (a best-guess upper-bound) will
  /// be sent and received by this task. These values are used by system scheduling
  /// policy. If unspecified, NSURLSessionTransferSizeUnknown is used.
  int get countOfBytesClientExpectsToSend {
    return _objc_msgSend_pysgoz(
        this.ref.pointer, _sel_countOfBytesClientExpectsToSend);
  }

  /// The number of bytes that the client expects (a best-guess upper-bound) will
  /// be sent and received by this task. These values are used by system scheduling
  /// policy. If unspecified, NSURLSessionTransferSizeUnknown is used.
  set countOfBytesClientExpectsToSend(int value) {
    _objc_msgSend_17gvxvj(
        this.ref.pointer, _sel_setCountOfBytesClientExpectsToSend_, value);
  }

  /// countOfBytesClientExpectsToReceive
  int get countOfBytesClientExpectsToReceive {
    return _objc_msgSend_pysgoz(
        this.ref.pointer, _sel_countOfBytesClientExpectsToReceive);
  }

  /// setCountOfBytesClientExpectsToReceive:
  set countOfBytesClientExpectsToReceive(int value) {
    _objc_msgSend_17gvxvj(
        this.ref.pointer, _sel_setCountOfBytesClientExpectsToReceive_, value);
  }

  /// number of body bytes already sent
  int get countOfBytesSent {
    return _objc_msgSend_pysgoz(this.ref.pointer, _sel_countOfBytesSent);
  }

  /// number of body bytes already received
  int get countOfBytesReceived {
    return _objc_msgSend_pysgoz(this.ref.pointer, _sel_countOfBytesReceived);
  }

  /// number of body bytes we expect to send, derived from the Content-Length of the HTTP request
  int get countOfBytesExpectedToSend {
    return _objc_msgSend_pysgoz(
        this.ref.pointer, _sel_countOfBytesExpectedToSend);
  }

  /// number of byte bytes we expect to receive, usually derived from the Content-Length header of an HTTP response.
  int get countOfBytesExpectedToReceive {
    return _objc_msgSend_pysgoz(
        this.ref.pointer, _sel_countOfBytesExpectedToReceive);
  }

  /// The taskDescription property is available for the developer to
  /// provide a descriptive label for the task.
  objc.NSString? get taskDescription {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_taskDescription);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The taskDescription property is available for the developer to
  /// provide a descriptive label for the task.
  set taskDescription(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTaskDescription_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// -cancel returns immediately, but marks a task as being canceled.
  /// The task will signal -URLSession:task:didCompleteWithError: with an
  /// error value of { NSURLErrorDomain, NSURLErrorCancelled }.  In some
  /// cases, the task may signal other work before it acknowledges the
  /// cancelation.  -cancel may be sent to a task that has been suspended.
  void cancel() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_cancel);
  }

  /// The current state of the task within the session.
  NSURLSessionTaskState get state {
    final _ret = _objc_msgSend_1vze0g9(this.ref.pointer, _sel_state);
    return NSURLSessionTaskState.fromValue(_ret);
  }

  /// The error, if any, delivered via -URLSession:task:didCompleteWithError:
  /// This property will be nil in the event that no error occurred.
  objc.NSError? get error {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_error);
    return _ret.address == 0
        ? null
        : objc.NSError.castFromPointer(_ret, retain: true, release: true);
  }

  /// Suspending a task will prevent the NSURLSession from continuing to
  /// load data.  There may still be delegate calls made on behalf of
  /// this task (for instance, to report data received while suspending)
  /// but no further transmissions will be made on behalf of the task
  /// until -resume is sent.  The timeout timer associated with the task
  /// will be disabled while a task is suspended. -suspend and -resume are
  /// nestable.
  void suspend() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_suspend);
  }

  /// resume
  void resume() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_resume);
  }

  /// Sets a scaling factor for the priority of the task. The scaling factor is a
  /// value between 0.0 and 1.0 (inclusive), where 0.0 is considered the lowest
  /// priority and 1.0 is considered the highest.
  ///
  /// The priority is a hint and not a hard requirement of task performance. The
  /// priority of a task may be changed using this API at any time, but not all
  /// protocols support this; in these cases, the last priority that took effect
  /// will be used.
  ///
  /// If no priority is specified, the task will operate with the default priority
  /// as defined by the constant NSURLSessionTaskPriorityDefault. Two additional
  /// priority levels are provided: NSURLSessionTaskPriorityLow and
  /// NSURLSessionTaskPriorityHigh, but use is not restricted to these.
  double get priority {
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(this.ref.pointer, _sel_priority)
        : _objc_msgSend_2cgrxl(this.ref.pointer, _sel_priority);
  }

  /// Sets a scaling factor for the priority of the task. The scaling factor is a
  /// value between 0.0 and 1.0 (inclusive), where 0.0 is considered the lowest
  /// priority and 1.0 is considered the highest.
  ///
  /// The priority is a hint and not a hard requirement of task performance. The
  /// priority of a task may be changed using this API at any time, but not all
  /// protocols support this; in these cases, the last priority that took effect
  /// will be used.
  ///
  /// If no priority is specified, the task will operate with the default priority
  /// as defined by the constant NSURLSessionTaskPriorityDefault. Two additional
  /// priority levels are provided: NSURLSessionTaskPriorityLow and
  /// NSURLSessionTaskPriorityHigh, but use is not restricted to these.
  set priority(double value) {
    _objc_msgSend_v5hmet(this.ref.pointer, _sel_setPriority_, value);
  }

  /// Provides a hint indicating if incremental delivery of a partial response body
  /// would be useful for the application, or if it cannot process the response
  /// until it is complete. Indicating that incremental delivery is not desired may
  /// improve task performance. For example, if a response cannot be decoded until
  /// the entire content is received, set this property to false.
  ///
  /// Defaults to true unless this task is created with completion-handler based
  /// convenience methods, or if it is a download task.
  bool get prefersIncrementalDelivery {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_prefersIncrementalDelivery);
  }

  /// Provides a hint indicating if incremental delivery of a partial response body
  /// would be useful for the application, or if it cannot process the response
  /// until it is complete. Indicating that incremental delivery is not desired may
  /// improve task performance. For example, if a response cannot be decoded until
  /// the entire content is received, set this property to false.
  ///
  /// Defaults to true unless this task is created with completion-handler based
  /// convenience methods, or if it is a download task.
  set prefersIncrementalDelivery(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setPrefersIncrementalDelivery_, value);
  }

  /// init
  NSURLSessionTask init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSURLSessionTask.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSURLSessionTask new1() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLSessionTask, _sel_new);
    return NSURLSessionTask.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLSessionTask allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_NSURLSessionTask, _sel_allocWithZone_, zone);
    return NSURLSessionTask.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSURLSessionTask alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLSessionTask, _sel_alloc);
    return NSURLSessionTask.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  NSURLSessionTask self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSURLSessionTask.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSURLSessionTask retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSURLSessionTask.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSURLSessionTask autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSURLSessionTask.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_storeCookies_forTask_ =
    objc.registerName("storeCookies:forTask:");
void _ObjCBlock_ffiVoid_objcObjCObject_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_objcObjCObject_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_objcObjCObject_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_objcObjCObject_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_objcObjCObject_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
      fromFunction(void Function(objc.ObjCObjectBase?) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_objcObjCObject_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                      ? null
                      : objc.ObjCObjectBase(arg0,
                          retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
      listener(void Function(objc.ObjCObjectBase?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.ObjCObjectBase(arg0, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
      blocking(void Function(objc.ObjCObjectBase?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.ObjCObjectBase(arg0, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.ObjCObjectBase(arg0, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_ffiVoid_objcObjCObject_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)> {
  void call(objc.ObjCObjectBase? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_getCookiesForTask_completionHandler_ =
    objc.registerName("getCookiesForTask:completionHandler:");

/// NSURLSessionTaskAdditions
extension NSURLSessionTaskAdditions1 on NSHTTPCookieStorage {
  /// storeCookies:forTask:
  void storeCookies_forTask_(
      objc.ObjCObjectBase cookies, NSURLSessionTask task) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_storeCookies_forTask_,
        cookies.ref.pointer, task.ref.pointer);
  }

  /// getCookiesForTask:completionHandler:
  void getCookiesForTask_completionHandler_(
      NSURLSessionTask task,
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?)>
          completionHandler) {
    _objc_msgSend_o762yo(
        this.ref.pointer,
        _sel_getCookiesForTask_completionHandler_,
        task.ref.pointer,
        completionHandler.ref.pointer);
  }
}

late final _class_NSEnumerator = objc.getClass("NSEnumerator");
late final _sel_allObjects = objc.registerName("allObjects");

/// NSExtendedEnumerator
extension NSExtendedEnumerator on objc.NSEnumerator {
  /// allObjects
  objc.ObjCObjectBase get allObjects {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_allObjects);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }
}

late final _class_NSDictionary = objc.getClass("NSDictionary");
late final _sel_allKeys = objc.registerName("allKeys");
late final _sel_allKeysForObject_ = objc.registerName("allKeysForObject:");
late final _sel_allValues = objc.registerName("allValues");
late final _sel_descriptionInStringsFileFormat =
    objc.registerName("descriptionInStringsFileFormat");
late final _sel_descriptionWithLocale_indent_ =
    objc.registerName("descriptionWithLocale:indent:");
final _objc_msgSend_1k4kd9s = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_isEqualToDictionary_ =
    objc.registerName("isEqualToDictionary:");
late final _sel_objectEnumerator = objc.registerName("objectEnumerator");
late final _sel_objectsForKeys_notFoundMarker_ =
    objc.registerName("objectsForKeys:notFoundMarker:");
late final _sel_writeToURL_error_ = objc.registerName("writeToURL:error:");
final _objc_msgSend_l9p60w = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_keysSortedByValueUsingSelector_ =
    objc.registerName("keysSortedByValueUsingSelector:");
final _objc_msgSend_3ctkt6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_getObjects_andKeys_count_ =
    objc.registerName("getObjects:andKeys:count:");
final _objc_msgSend_n2svg2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            int)>();
late final _sel_objectForKeyedSubscript_ =
    objc.registerName("objectForKeyedSubscript:");
void _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<ffi.Bool> arg2)>>()
        .asFunction<
            void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<ffi.Bool> arg2) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<ffi.Bool> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>.isolateLocal(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<ffi.Bool>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<ffi.Bool> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
      fromFunction(void Function(objc.ObjCObjectBase, objc.ObjCObjectBase, ffi.Pointer<ffi.Bool>) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<ffi.Bool> arg2) => fn(
                      objc.ObjCObjectBase(arg0, retain: true, release: true),
                      objc.ObjCObjectBase(arg1, retain: true, release: true),
                      arg2)),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)> listener(
      void Function(
              objc.ObjCObjectBase, objc.ObjCObjectBase, ffi.Pointer<ffi.Bool>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(objc.ObjCObjectBase(arg0, retain: false, release: true),
                objc.ObjCObjectBase(arg1, retain: false, release: true), arg2));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1o83rbn(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)> blocking(
      void Function(
              objc.ObjCObjectBase, objc.ObjCObjectBase, ffi.Pointer<ffi.Bool>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(objc.ObjCObjectBase(arg0, retain: false, release: true),
                objc.ObjCObjectBase(arg1, retain: false, release: true), arg2));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(objc.ObjCObjectBase(arg0, retain: false, release: true),
                objc.ObjCObjectBase(arg1, retain: false, release: true), arg2));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1o83rbn, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_bool_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)> {
  void call(objc.ObjCObjectBase arg0, objc.ObjCObjectBase arg1,
          ffi.Pointer<ffi.Bool> arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<ffi.Bool> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<ffi.Bool>)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2);
}

late final _sel_enumerateKeysAndObjectsUsingBlock_ =
    objc.registerName("enumerateKeysAndObjectsUsingBlock:");
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_enumerateKeysAndObjectsWithOptions_usingBlock_ =
    objc.registerName("enumerateKeysAndObjectsWithOptions:usingBlock:");
final _objc_msgSend_yx8yc6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_keysSortedByValueUsingComparator_ =
    objc.registerName("keysSortedByValueUsingComparator:");
final _objc_msgSend_nnxkei = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_keysSortedByValueWithOptions_usingComparator_ =
    objc.registerName("keysSortedByValueWithOptions:usingComparator:");
final _objc_msgSend_1x5ew3h = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
bool _ObjCBlock_bool_objcObjCObject_objcObjCObject_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<ffi.Bool> arg2)>>()
        .asFunction<
            bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_objcObjCObject_objcObjCObject_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_bool_objcObjCObject_objcObjCObject_bool_fnPtrTrampoline,
            false)
        .cast();
bool _ObjCBlock_bool_objcObjCObject_objcObjCObject_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_objcObjCObject_objcObjCObject_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_bool_objcObjCObject_objcObjCObject_bool_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_bool_objcObjCObject_objcObjCObject_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<ffi.Bool>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<ffi.Bool> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>(
              objc.newPointerBlock(_ObjCBlock_bool_objcObjCObject_objcObjCObject_bool_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
      fromFunction(bool Function(objc.ObjCObjectBase, objc.ObjCObjectBase, ffi.Pointer<ffi.Bool>) fn) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>(
              objc.newClosureBlock(
                  _ObjCBlock_bool_objcObjCObject_objcObjCObject_bool_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<ffi.Bool> arg2) => fn(
                      objc.ObjCObjectBase(arg0, retain: true, release: true),
                      objc.ObjCObjectBase(arg1, retain: true, release: true),
                      arg2)),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_bool_objcObjCObject_objcObjCObject_bool_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)> {
  bool call(objc.ObjCObjectBase arg0, objc.ObjCObjectBase arg1,
          ffi.Pointer<ffi.Bool> arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<ffi.Bool> arg2)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<ffi.Bool>)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2);
}

late final _sel_keysOfEntriesPassingTest_ =
    objc.registerName("keysOfEntriesPassingTest:");
late final _sel_keysOfEntriesWithOptions_passingTest_ =
    objc.registerName("keysOfEntriesWithOptions:passingTest:");
final _objc_msgSend_13x5boi = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

/// NSExtendedDictionary
extension NSExtendedDictionary on objc.NSDictionary {
  /// allKeys
  objc.ObjCObjectBase get allKeys {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_allKeys);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// allKeysForObject:
  objc.ObjCObjectBase allKeysForObject_(objc.ObjCObjectBase anObject) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_allKeysForObject_, anObject.ref.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// allValues
  objc.ObjCObjectBase get allValues {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_allValues);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// description
  objc.NSString get description {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_description);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// descriptionInStringsFileFormat
  objc.NSString get descriptionInStringsFileFormat {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_descriptionInStringsFileFormat);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// descriptionWithLocale:
  objc.NSString descriptionWithLocale_(objc.ObjCObjectBase? locale) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_descriptionWithLocale_, locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// descriptionWithLocale:indent:
  objc.NSString descriptionWithLocale_indent_(
      objc.ObjCObjectBase? locale, DartNSUInteger level) {
    final _ret = _objc_msgSend_1k4kd9s(
        this.ref.pointer,
        _sel_descriptionWithLocale_indent_,
        locale?.ref.pointer ?? ffi.nullptr,
        level);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// isEqualToDictionary:
  bool isEqualToDictionary_(objc.NSDictionary otherDictionary) {
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_isEqualToDictionary_,
        otherDictionary.ref.pointer);
  }

  /// objectEnumerator
  objc.NSEnumerator objectEnumerator() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_objectEnumerator);
    return objc.NSEnumerator.castFromPointer(_ret, retain: true, release: true);
  }

  /// objectsForKeys:notFoundMarker:
  objc.ObjCObjectBase objectsForKeys_notFoundMarker_(
      objc.ObjCObjectBase keys, objc.ObjCObjectBase marker) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_objectsForKeys_notFoundMarker_,
        keys.ref.pointer,
        marker.ref.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// writeToURL:error:
  bool writeToURL_error_(
      objc.NSURL url, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    return _objc_msgSend_l9p60w(
        this.ref.pointer, _sel_writeToURL_error_, url.ref.pointer, error);
  }

  /// keysSortedByValueUsingSelector:
  objc.ObjCObjectBase keysSortedByValueUsingSelector_(
      ffi.Pointer<objc.ObjCSelector> comparator) {
    final _ret = _objc_msgSend_3ctkt6(
        this.ref.pointer, _sel_keysSortedByValueUsingSelector_, comparator);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// getObjects:andKeys:count:
  void getObjects_andKeys_count_(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> keys,
      DartNSUInteger count) {
    _objc_msgSend_n2svg2(
        this.ref.pointer, _sel_getObjects_andKeys_count_, objects, keys, count);
  }

  /// objectForKeyedSubscript:
  objc.ObjCObjectBase? objectForKeyedSubscript_(objc.ObjCObjectBase key) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_objectForKeyedSubscript_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// enumerateKeysAndObjectsUsingBlock:
  void enumerateKeysAndObjectsUsingBlock_(
      objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
          block) {
    _objc_msgSend_f167m6(this.ref.pointer,
        _sel_enumerateKeysAndObjectsUsingBlock_, block.ref.pointer);
  }

  /// enumerateKeysAndObjectsWithOptions:usingBlock:
  void enumerateKeysAndObjectsWithOptions_usingBlock_(
      objc.NSEnumerationOptions opts,
      objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
          block) {
    _objc_msgSend_yx8yc6(
        this.ref.pointer,
        _sel_enumerateKeysAndObjectsWithOptions_usingBlock_,
        opts.value,
        block.ref.pointer);
  }

  /// keysSortedByValueUsingComparator:
  objc.ObjCObjectBase keysSortedByValueUsingComparator_(
      DartNSComparator cmptr) {
    final _ret = _objc_msgSend_nnxkei(this.ref.pointer,
        _sel_keysSortedByValueUsingComparator_, cmptr.ref.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// keysSortedByValueWithOptions:usingComparator:
  objc.ObjCObjectBase keysSortedByValueWithOptions_usingComparator_(
      objc.NSSortOptions opts, DartNSComparator cmptr) {
    final _ret = _objc_msgSend_1x5ew3h(
        this.ref.pointer,
        _sel_keysSortedByValueWithOptions_usingComparator_,
        opts.value,
        cmptr.ref.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// keysOfEntriesPassingTest:
  objc.ObjCObjectBase keysOfEntriesPassingTest_(
      objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
          predicate) {
    final _ret = _objc_msgSend_nnxkei(this.ref.pointer,
        _sel_keysOfEntriesPassingTest_, predicate.ref.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// keysOfEntriesWithOptions:passingTest:
  objc.ObjCObjectBase keysOfEntriesWithOptions_passingTest_(
      objc.NSEnumerationOptions opts,
      objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
          predicate) {
    final _ret = _objc_msgSend_13x5boi(
        this.ref.pointer,
        _sel_keysOfEntriesWithOptions_passingTest_,
        opts.value,
        predicate.ref.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }
}

late final _sel_getObjects_andKeys_ = objc.registerName("getObjects:andKeys:");
final _objc_msgSend_hefmm1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_dictionaryWithContentsOfFile_ =
    objc.registerName("dictionaryWithContentsOfFile:");
late final _sel_dictionaryWithContentsOfURL_ =
    objc.registerName("dictionaryWithContentsOfURL:");
late final _sel_initWithContentsOfFile_ =
    objc.registerName("initWithContentsOfFile:");
late final _sel_initWithContentsOfURL_ =
    objc.registerName("initWithContentsOfURL:");
late final _sel_writeToFile_atomically_ =
    objc.registerName("writeToFile:atomically:");
final _objc_msgSend_1iyq28l = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_writeToURL_atomically_ =
    objc.registerName("writeToURL:atomically:");

/// NSDeprecated
extension NSDeprecated on objc.NSDictionary {
  /// getObjects:andKeys:
  void getObjects_andKeys_(ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> keys) {
    _objc_msgSend_hefmm1(
        this.ref.pointer, _sel_getObjects_andKeys_, objects, keys);
  }

  /// dictionaryWithContentsOfFile:
  static objc.NSDictionary? dictionaryWithContentsOfFile_(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(_class_NSDictionary,
        _sel_dictionaryWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// dictionaryWithContentsOfURL:
  static objc.NSDictionary? dictionaryWithContentsOfURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(_class_NSDictionary,
        _sel_dictionaryWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithContentsOfFile:
  objc.NSDictionary? initWithContentsOfFile_(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  objc.NSDictionary? initWithContentsOfURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: false, release: true);
  }

  /// writeToFile:atomically:
  bool writeToFile_atomically_(objc.NSString path, bool useAuxiliaryFile) {
    return _objc_msgSend_1iyq28l(this.ref.pointer, _sel_writeToFile_atomically_,
        path.ref.pointer, useAuxiliaryFile);
  }

  /// writeToURL:atomically:
  bool writeToURL_atomically_(objc.NSURL url, bool atomically) {
    return _objc_msgSend_1iyq28l(this.ref.pointer, _sel_writeToURL_atomically_,
        url.ref.pointer, atomically);
  }
}

late final _sel_dictionary = objc.registerName("dictionary");
late final _sel_dictionaryWithObject_forKey_ =
    objc.registerName("dictionaryWithObject:forKey:");
late final _sel_dictionaryWithObjects_forKeys_count_ =
    objc.registerName("dictionaryWithObjects:forKeys:count:");
final _objc_msgSend_1dydpdi = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            int)>();
late final _sel_dictionaryWithObjectsAndKeys_ =
    objc.registerName("dictionaryWithObjectsAndKeys:");
late final _sel_dictionaryWithDictionary_ =
    objc.registerName("dictionaryWithDictionary:");
late final _sel_dictionaryWithObjects_forKeys_ =
    objc.registerName("dictionaryWithObjects:forKeys:");
late final _sel_initWithObjectsAndKeys_ =
    objc.registerName("initWithObjectsAndKeys:");
late final _sel_initWithDictionary_ = objc.registerName("initWithDictionary:");
late final _sel_initWithDictionary_copyItems_ =
    objc.registerName("initWithDictionary:copyItems:");
final _objc_msgSend_17amj0z = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_initWithObjects_forKeys_ =
    objc.registerName("initWithObjects:forKeys:");
late final _sel_initWithContentsOfURL_error_ =
    objc.registerName("initWithContentsOfURL:error:");
final _objc_msgSend_1lhpu4m = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_dictionaryWithContentsOfURL_error_ =
    objc.registerName("dictionaryWithContentsOfURL:error:");

/// NSDictionaryCreation
extension NSDictionaryCreation on objc.NSDictionary {
  /// dictionary
  static objc.NSDictionary dictionary() {
    final _ret = _objc_msgSend_151sglz(_class_NSDictionary, _sel_dictionary);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// dictionaryWithObject:forKey:
  static objc.NSDictionary dictionaryWithObject_forKey_(
      objc.ObjCObjectBase object, objc.ObjCObjectBase key) {
    final _ret = _objc_msgSend_15qeuct(_class_NSDictionary,
        _sel_dictionaryWithObject_forKey_, object.ref.pointer, key.ref.pointer);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// dictionaryWithObjects:forKeys:count:
  static objc.NSDictionary dictionaryWithObjects_forKeys_count_(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> keys,
      DartNSUInteger cnt) {
    final _ret = _objc_msgSend_1dydpdi(_class_NSDictionary,
        _sel_dictionaryWithObjects_forKeys_count_, objects, keys, cnt);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// dictionaryWithObjectsAndKeys:
  static objc.NSDictionary dictionaryWithObjectsAndKeys_(
      objc.ObjCObjectBase firstObject) {
    final _ret = _objc_msgSend_1sotr3r(_class_NSDictionary,
        _sel_dictionaryWithObjectsAndKeys_, firstObject.ref.pointer);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// dictionaryWithDictionary:
  static objc.NSDictionary dictionaryWithDictionary_(objc.NSDictionary dict) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSDictionary, _sel_dictionaryWithDictionary_, dict.ref.pointer);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// dictionaryWithObjects:forKeys:
  static objc.NSDictionary dictionaryWithObjects_forKeys_(
      objc.ObjCObjectBase objects, objc.ObjCObjectBase keys) {
    final _ret = _objc_msgSend_15qeuct(
        _class_NSDictionary,
        _sel_dictionaryWithObjects_forKeys_,
        objects.ref.pointer,
        keys.ref.pointer);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithObjectsAndKeys:
  objc.NSDictionary initWithObjectsAndKeys_(objc.ObjCObjectBase firstObject) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithObjectsAndKeys_, firstObject.ref.pointer);
    return objc.NSDictionary.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithDictionary:
  objc.NSDictionary initWithDictionary_(objc.NSDictionary otherDictionary) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithDictionary_, otherDictionary.ref.pointer);
    return objc.NSDictionary.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithDictionary:copyItems:
  objc.NSDictionary initWithDictionary_copyItems_(
      objc.NSDictionary otherDictionary, bool flag) {
    final _ret = _objc_msgSend_17amj0z(this.ref.retainAndReturnPointer(),
        _sel_initWithDictionary_copyItems_, otherDictionary.ref.pointer, flag);
    return objc.NSDictionary.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithObjects:forKeys:
  objc.NSDictionary initWithObjects_forKeys_(
      objc.ObjCObjectBase objects, objc.ObjCObjectBase keys) {
    final _ret = _objc_msgSend_15qeuct(this.ref.retainAndReturnPointer(),
        _sel_initWithObjects_forKeys_, objects.ref.pointer, keys.ref.pointer);
    return objc.NSDictionary.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithContentsOfURL:error:
  objc.NSDictionary? initWithContentsOfURL_error_(
      objc.NSURL url, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1lhpu4m(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_error_, url.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: false, release: true);
  }

  /// dictionaryWithContentsOfURL:error:
  static objc.NSDictionary? dictionaryWithContentsOfURL_error_(
      objc.NSURL url, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1lhpu4m(_class_NSDictionary,
        _sel_dictionaryWithContentsOfURL_error_, url.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_NSMutableDictionary = objc.getClass("NSMutableDictionary");
late final _sel_addEntriesFromDictionary_ =
    objc.registerName("addEntriesFromDictionary:");
late final _sel_removeAllObjects = objc.registerName("removeAllObjects");
late final _sel_removeObjectsForKeys_ =
    objc.registerName("removeObjectsForKeys:");
late final _sel_setDictionary_ = objc.registerName("setDictionary:");
late final _sel_setObject_forKeyedSubscript_ =
    objc.registerName("setObject:forKeyedSubscript:");

/// NSExtendedMutableDictionary
extension NSExtendedMutableDictionary on objc.NSMutableDictionary {
  /// addEntriesFromDictionary:
  void addEntriesFromDictionary_(objc.NSDictionary otherDictionary) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addEntriesFromDictionary_,
        otherDictionary.ref.pointer);
  }

  /// removeAllObjects
  void removeAllObjects() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeAllObjects);
  }

  /// removeObjectsForKeys:
  void removeObjectsForKeys_(objc.ObjCObjectBase keyArray) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeObjectsForKeys_, keyArray.ref.pointer);
  }

  /// setDictionary:
  void setDictionary_(objc.NSDictionary otherDictionary) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setDictionary_, otherDictionary.ref.pointer);
  }

  /// setObject:forKeyedSubscript:
  void setObject_forKeyedSubscript_(
      objc.ObjCObjectBase? obj, objc.ObjCObjectBase key) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_setObject_forKeyedSubscript_,
        obj?.ref.pointer ?? ffi.nullptr, key.ref.pointer);
  }
}

late final _sel_dictionaryWithCapacity_ =
    objc.registerName("dictionaryWithCapacity:");
final _objc_msgSend_14hpxwa = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// NSMutableDictionaryCreation
extension NSMutableDictionaryCreation on objc.NSMutableDictionary {
  /// dictionaryWithCapacity:
  static objc.NSMutableDictionary dictionaryWithCapacity_(
      DartNSUInteger numItems) {
    final _ret = _objc_msgSend_14hpxwa(
        _class_NSMutableDictionary, _sel_dictionaryWithCapacity_, numItems);
    return objc.NSMutableDictionary.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// dictionaryWithContentsOfFile:
  static objc.NSMutableDictionary? dictionaryWithContentsOfFile_(
      objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(_class_NSMutableDictionary,
        _sel_dictionaryWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableDictionary.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// dictionaryWithContentsOfURL:
  static objc.NSMutableDictionary? dictionaryWithContentsOfURL_(
      objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(_class_NSMutableDictionary,
        _sel_dictionaryWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableDictionary.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// initWithContentsOfFile:
  objc.NSMutableDictionary? initWithContentsOfFile_(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableDictionary.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// initWithContentsOfURL:
  objc.NSMutableDictionary? initWithContentsOfURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableDictionary.castFromPointer(_ret,
            retain: false, release: true);
  }
}

late final _sel_sharedKeySetForKeys_ =
    objc.registerName("sharedKeySetForKeys:");

/// NSSharedKeySetDictionary
extension NSSharedKeySetDictionary on objc.NSDictionary {
  /// sharedKeySetForKeys:
  static objc.ObjCObjectBase sharedKeySetForKeys_(objc.ObjCObjectBase keys) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSDictionary, _sel_sharedKeySetForKeys_, keys.ref.pointer);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }
}

late final _sel_dictionaryWithSharedKeySet_ =
    objc.registerName("dictionaryWithSharedKeySet:");

/// NSSharedKeySetDictionary
extension NSSharedKeySetDictionary1 on objc.NSMutableDictionary {
  /// dictionaryWithSharedKeySet:
  static objc.NSMutableDictionary dictionaryWithSharedKeySet_(
      objc.ObjCObjectBase keyset) {
    final _ret = _objc_msgSend_1sotr3r(_class_NSMutableDictionary,
        _sel_dictionaryWithSharedKeySet_, keyset.ref.pointer);
    return objc.NSMutableDictionary.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_countByEnumeratingWithState_objects_count_ =
    objc.registerName("countByEnumeratingWithState:objects:count:");
final _objc_msgSend_1b5ysjl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.NSFastEnumerationState>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.UnsignedLong)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.NSFastEnumerationState>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            int)>();
int _ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.NSFastEnumerationState> arg1,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
        int arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                NSUInteger Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.NSFastEnumerationState> arg1,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
                    NSUInteger arg3)>>()
        .asFunction<
            int Function(
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.NSFastEnumerationState>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                int)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger_fnPtrCallable =
    ffi.Pointer.fromFunction<
                NSUInteger Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.NSFastEnumerationState>,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                    NSUInteger)>(
            _ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.NSFastEnumerationState> arg1,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
        int arg3) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.NSFastEnumerationState>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        int))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger_closureCallable =
    ffi.Pointer.fromFunction<
                NSUInteger Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.NSFastEnumerationState>,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                    NSUInteger)>(
            _ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.NSFastEnumerationState>, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.NSFastEnumerationState>,
              ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
              ffi.UnsignedLong)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.UnsignedLong Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.NSFastEnumerationState>,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                  ffi.UnsignedLong)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.NSFastEnumerationState>,
              ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
              ffi.UnsignedLong)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<NSUInteger Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.NSFastEnumerationState> arg1, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2, NSUInteger arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.UnsignedLong Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.NSFastEnumerationState>,
                      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                      ffi.UnsignedLong)>(
              objc.newPointerBlock(_ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.NSFastEnumerationState>, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>, ffi.UnsignedLong)> fromFunction(
          DartNSUInteger Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.NSFastEnumerationState>,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                  DartNSUInteger)
              fn) =>
      objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.NSFastEnumerationState>, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>, ffi.UnsignedLong)>(
          objc.newClosureBlock(
              _ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.NSFastEnumerationState> arg1, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2, int arg3) =>
                  fn(arg0, arg1, arg2, arg3)),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.NSFastEnumerationState>, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>, ffi.UnsignedLong)>`.
extension ObjCBlock_NSUInteger_ffiVoid_NSFastEnumerationState_objcObjCObject_NSUInteger_CallExtension
    on objc.ObjCBlock<
        ffi.UnsignedLong Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.NSFastEnumerationState>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.UnsignedLong)> {
  DartNSUInteger call(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.NSFastEnumerationState> arg1,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
          DartNSUInteger arg3) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  NSUInteger Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.NSFastEnumerationState> arg1,
                      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg2,
                      NSUInteger arg3)>>()
          .asFunction<
              int Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.NSFastEnumerationState>,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                  int)>()(ref.pointer, arg0, arg1, arg2, arg3);
}

/// NSGenericFastEnumeration
extension NSGenericFastEnumeration on objc.NSDictionary {
  /// countByEnumeratingWithState:objects:count:
  DartNSUInteger countByEnumeratingWithState_objects_count_(
      ffi.Pointer<objc.NSFastEnumerationState> state,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> buffer,
      DartNSUInteger len) {
    return _objc_msgSend_1b5ysjl(this.ref.pointer,
        _sel_countByEnumeratingWithState_objects_count_, state, buffer, len);
  }
}

typedef NSProgressKind = ffi.Pointer<objc.ObjCObject>;
typedef DartNSProgressKind = objc.NSString;
typedef NSProgressUserInfoKey = ffi.Pointer<objc.ObjCObject>;
typedef DartNSProgressUserInfoKey = objc.NSString;
typedef NSProgressFileOperationKind = ffi.Pointer<objc.ObjCObject>;
typedef DartNSProgressFileOperationKind = objc.NSString;
typedef NSProgressUnpublishingHandler = ffi.Pointer<objc.ObjCBlockImpl>;
typedef DartNSProgressUnpublishingHandler = objc.ObjCBlock<ffi.Void Function()>;
NSProgressUnpublishingHandler
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    NSProgressUnpublishingHandler Function(
                        ffi.Pointer<objc.ObjCObject> arg0)>>()
            .asFunction<
                NSProgressUnpublishingHandler Function(
                    ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrCallable =
    ffi.Pointer.fromFunction<
                NSProgressUnpublishingHandler Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrTrampoline)
        .cast();
NSProgressUnpublishingHandler
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0) =>
        (objc.getBlockClosure(block) as NSProgressUnpublishingHandler Function(
            ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureCallable =
    ffi.Pointer.fromFunction<
                NSProgressUnpublishingHandler Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>`.
abstract final class ObjCBlock_NSProgressUnpublishingHandler_NSProgress {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.ObjCBlock<ffi.Void Function()>? Function(
                  NSProgress)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      NSProgressUnpublishingHandler Function(
                          ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>(
          objc.newPointerBlock(
              _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)> fromFunction(
          DartNSProgressUnpublishingHandler? Function(NSProgress) fn) =>
      objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>(
          objc.newClosureBlock(
              _ObjCBlock_NSProgressUnpublishingHandler_NSProgress_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) =>
                  fn(NSProgress.castFromPointer(arg0, retain: true, release: true))
                      ?.ref
                      .retainAndAutorelease() ??
                  ffi.nullptr),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>`.
extension ObjCBlock_NSProgressUnpublishingHandler_NSProgress_CallExtension
    on objc
    .ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)> {
  DartNSProgressUnpublishingHandler? call(NSProgress arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      NSProgressUnpublishingHandler Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0)>>()
              .asFunction<NSProgressUnpublishingHandler Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : ObjCBlock_ffiVoid.castFromPointer(
          ref.pointer.ref.invoke.cast<ffi.NativeFunction<NSProgressUnpublishingHandler Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>>().asFunction<
              NSProgressUnpublishingHandler Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true);
}

typedef NSProgressPublishingHandler = ffi.Pointer<objc.ObjCBlockImpl>;
typedef DartNSProgressPublishingHandler
    = objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>;
typedef CFArrayRetainCallBackFunction = ffi.Pointer<ffi.Void> Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef CFArrayRetainCallBack
    = ffi.Pointer<ffi.NativeFunction<CFArrayRetainCallBackFunction>>;
typedef CFArrayReleaseCallBackFunction = ffi.Void Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef DartCFArrayReleaseCallBackFunction = void Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef CFArrayReleaseCallBack
    = ffi.Pointer<ffi.NativeFunction<CFArrayReleaseCallBackFunction>>;
typedef CFArrayCopyDescriptionCallBackFunction = CFStringRef Function(
    ffi.Pointer<ffi.Void> value);
typedef CFArrayCopyDescriptionCallBack
    = ffi.Pointer<ffi.NativeFunction<CFArrayCopyDescriptionCallBackFunction>>;
typedef CFArrayEqualCallBackFunction = Boolean Function(
    ffi.Pointer<ffi.Void> value1, ffi.Pointer<ffi.Void> value2);
typedef DartCFArrayEqualCallBackFunction = DartBoolean Function(
    ffi.Pointer<ffi.Void> value1, ffi.Pointer<ffi.Void> value2);
typedef CFArrayEqualCallBack
    = ffi.Pointer<ffi.NativeFunction<CFArrayEqualCallBackFunction>>;

final class CFArrayCallBacks extends ffi.Struct {
  @CFIndex()
  external int version;

  external CFArrayRetainCallBack retain;

  external CFArrayReleaseCallBack release;

  external CFArrayCopyDescriptionCallBack copyDescription;

  external CFArrayEqualCallBack equal;
}

typedef CFArrayApplierFunctionFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context);
typedef DartCFArrayApplierFunctionFunction = void Function(
    ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context);
typedef CFArrayApplierFunction
    = ffi.Pointer<ffi.NativeFunction<CFArrayApplierFunctionFunction>>;

final class __CFArray extends ffi.Opaque {}

typedef CFArrayRef = ffi.Pointer<__CFArray>;
typedef CFMutableArrayRef = ffi.Pointer<__CFArray>;
typedef os_function_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void>);
typedef Dartos_function_tFunction = void Function(ffi.Pointer<ffi.Void>);
typedef os_function_t = ffi.Pointer<ffi.NativeFunction<os_function_tFunction>>;
typedef os_block_t = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartos_block_t = objc.ObjCBlock<ffi.Void Function()>;

/// WARNING: OS_object is a stub. To generate bindings for this class, include
/// OS_object in your config's objc-interfaces list.
///
/// OS_object
class OS_object extends objc.NSObject {
  OS_object._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [OS_object] that points to the same underlying object as [other].
  OS_object.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [OS_object] that wraps the given raw object pointer.
  OS_object.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

typedef sec_object_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartsec_object_t = objc.NSObject;

final class __SecCertificate extends ffi.Opaque {}

typedef SecCertificateRef = ffi.Pointer<__SecCertificate>;
typedef OpaqueSecCertificateRef = __SecCertificate;

final class __SecIdentity extends ffi.Opaque {}

typedef SecIdentityRef = ffi.Pointer<__SecIdentity>;
typedef OpaqueSecIdentityRef = __SecIdentity;

final class __SecKey extends ffi.Opaque {}

typedef SecKeyRef = ffi.Pointer<__SecKey>;
typedef OpaqueSecKeyRef = __SecKey;

final class __SecPolicy extends ffi.Opaque {}

typedef SecPolicyRef = ffi.Pointer<__SecPolicy>;

final class __SecAccessControl extends ffi.Opaque {}

typedef SecAccessControlRef = ffi.Pointer<__SecAccessControl>;

final class __SecKeychain extends ffi.Opaque {}

typedef SecKeychainRef = ffi.Pointer<__SecKeychain>;

final class __SecKeychainItem extends ffi.Opaque {}

typedef SecKeychainItemRef = ffi.Pointer<__SecKeychainItem>;

final class __SecKeychainSearch extends ffi.Opaque {}

typedef SecKeychainSearchRef = ffi.Pointer<__SecKeychainSearch>;
typedef SecKeychainAttrType = OSType;

final class SecKeychainAttribute extends ffi.Struct {
  @SecKeychainAttrType()
  external int tag;

  @UInt32()
  external int length;

  external ffi.Pointer<ffi.Void> data;
}

typedef SecKeychainAttributePtr = ffi.Pointer<SecKeychainAttribute>;

final class SecKeychainAttributeList extends ffi.Struct {
  @UInt32()
  external int count;

  external ffi.Pointer<SecKeychainAttribute> attr;
}

typedef SecKeychainStatus = UInt32;

final class __SecTrustedApplication extends ffi.Opaque {}

typedef SecTrustedApplicationRef = ffi.Pointer<__SecTrustedApplication>;

final class __SecAccess extends ffi.Opaque {}

typedef SecAccessRef = ffi.Pointer<__SecAccess>;
typedef OpaqueSecAccessRef = __SecAccess;

final class __SecACL extends ffi.Opaque {}

typedef SecACLRef = ffi.Pointer<__SecACL>;

final class __SecPassword extends ffi.Opaque {}

typedef SecPasswordRef = ffi.Pointer<__SecPassword>;

final class SecKeychainAttributeInfo extends ffi.Struct {
  @UInt32()
  external int count;

  external ffi.Pointer<UInt32> tag;

  external ffi.Pointer<UInt32> format;
}

final class _RuneEntry extends ffi.Struct {
  @__darwin_rune_t()
  external int __min;

  @__darwin_rune_t()
  external int __max;

  @__darwin_rune_t()
  external int __map;

  external ffi.Pointer<__uint32_t> __types;
}

final class _RuneRange extends ffi.Struct {
  @ffi.Int()
  external int __nranges;

  external ffi.Pointer<_RuneEntry> __ranges;
}

final class _RuneCharClass extends ffi.Struct {
  @ffi.Array.multi([14])
  external ffi.Array<ffi.Char> __name;

  @__uint32_t()
  external int __mask;
}

final class _RuneLocale extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __magic;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> __encoding;

  external ffi.Pointer<
      ffi.NativeFunction<
          __darwin_rune_t Function(ffi.Pointer<ffi.Char>, __darwin_size_t,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>> __sgetrune;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(__darwin_rune_t, ffi.Pointer<ffi.Char>,
              __darwin_size_t, ffi.Pointer<ffi.Pointer<ffi.Char>>)>> __sputrune;

  @__darwin_rune_t()
  external int __invalid_rune;

  @ffi.Array.multi([256])
  external ffi.Array<__uint32_t> __runetype;

  @ffi.Array.multi([256])
  external ffi.Array<__darwin_rune_t> __maplower;

  @ffi.Array.multi([256])
  external ffi.Array<__darwin_rune_t> __mapupper;

  external _RuneRange __runetype_ext;

  external _RuneRange __maplower_ext;

  external _RuneRange __mapupper_ext;

  external ffi.Pointer<ffi.Void> __variable;

  @ffi.Int()
  external int __variable_len;

  @ffi.Int()
  external int __ncharclasses;

  external ffi.Pointer<_RuneCharClass> __charclasses;
}

final class lconv extends ffi.Struct {
  external ffi.Pointer<ffi.Char> decimal_point;

  external ffi.Pointer<ffi.Char> thousands_sep;

  external ffi.Pointer<ffi.Char> grouping;

  external ffi.Pointer<ffi.Char> int_curr_symbol;

  external ffi.Pointer<ffi.Char> currency_symbol;

  external ffi.Pointer<ffi.Char> mon_decimal_point;

  external ffi.Pointer<ffi.Char> mon_thousands_sep;

  external ffi.Pointer<ffi.Char> mon_grouping;

  external ffi.Pointer<ffi.Char> positive_sign;

  external ffi.Pointer<ffi.Char> negative_sign;

  @ffi.Char()
  external int int_frac_digits;

  @ffi.Char()
  external int frac_digits;

  @ffi.Char()
  external int p_cs_precedes;

  @ffi.Char()
  external int p_sep_by_space;

  @ffi.Char()
  external int n_cs_precedes;

  @ffi.Char()
  external int n_sep_by_space;

  @ffi.Char()
  external int p_sign_posn;

  @ffi.Char()
  external int n_sign_posn;

  @ffi.Char()
  external int int_p_cs_precedes;

  @ffi.Char()
  external int int_n_cs_precedes;

  @ffi.Char()
  external int int_p_sep_by_space;

  @ffi.Char()
  external int int_n_sep_by_space;

  @ffi.Char()
  external int int_p_sign_posn;

  @ffi.Char()
  external int int_n_sign_posn;
}

typedef float_t = ffi.Float;
typedef Dartfloat_t = double;
typedef double_t = ffi.Double;
typedef Dartdouble_t = double;

final class __float2 extends ffi.Struct {
  @ffi.Float()
  external double __sinval;

  @ffi.Float()
  external double __cosval;
}

final class __double2 extends ffi.Struct {
  @ffi.Double()
  external double __sinval;

  @ffi.Double()
  external double __cosval;
}

final class exception extends ffi.Struct {
  @ffi.Int()
  external int type;

  external ffi.Pointer<ffi.Char> name;

  @ffi.Double()
  external double arg1;

  @ffi.Double()
  external double arg2;

  @ffi.Double()
  external double retval;
}

typedef fpos_t = __darwin_off_t;

final class __sbuf extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _base;

  @ffi.Int()
  external int _size;
}

final class __sFILEX extends ffi.Opaque {}

final class __sFILE extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _p;

  @ffi.Int()
  external int _r;

  @ffi.Int()
  external int _w;

  @ffi.Short()
  external int _flags;

  @ffi.Short()
  external int _file;

  external __sbuf _bf;

  @ffi.Int()
  external int _lbfsize;

  external ffi.Pointer<ffi.Void> _cookie;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
      _close;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _read;

  external ffi.Pointer<
      ffi.NativeFunction<
          fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>> _seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _write;

  external __sbuf _ub;

  external ffi.Pointer<__sFILEX> _extra;

  @ffi.Int()
  external int _ur;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedChar> _ubuf;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.UnsignedChar> _nbuf;

  external __sbuf _lb;

  @ffi.Int()
  external int _blksize;

  @fpos_t()
  external int _offset;
}

typedef FILE = __sFILE;

final class timespec extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @ffi.Long()
  external int tv_nsec;
}

final class tm extends ffi.Struct {
  @ffi.Int()
  external int tm_sec;

  @ffi.Int()
  external int tm_min;

  @ffi.Int()
  external int tm_hour;

  @ffi.Int()
  external int tm_mday;

  @ffi.Int()
  external int tm_mon;

  @ffi.Int()
  external int tm_year;

  @ffi.Int()
  external int tm_wday;

  @ffi.Int()
  external int tm_yday;

  @ffi.Int()
  external int tm_isdst;

  @ffi.Long()
  external int tm_gmtoff;

  external ffi.Pointer<ffi.Char> tm_zone;
}

enum clockid_t {
  _CLOCK_REALTIME(0),
  _CLOCK_MONOTONIC(6),
  _CLOCK_MONOTONIC_RAW(4),
  _CLOCK_MONOTONIC_RAW_APPROX(5),
  _CLOCK_UPTIME_RAW(8),
  _CLOCK_UPTIME_RAW_APPROX(9),
  _CLOCK_PROCESS_CPUTIME_ID(12),
  _CLOCK_THREAD_CPUTIME_ID(16);

  final int value;
  const clockid_t(this.value);

  static clockid_t fromValue(int value) => switch (value) {
        0 => _CLOCK_REALTIME,
        6 => _CLOCK_MONOTONIC,
        4 => _CLOCK_MONOTONIC_RAW,
        5 => _CLOCK_MONOTONIC_RAW_APPROX,
        8 => _CLOCK_UPTIME_RAW,
        9 => _CLOCK_UPTIME_RAW_APPROX,
        12 => _CLOCK_PROCESS_CPUTIME_ID,
        16 => _CLOCK_THREAD_CPUTIME_ID,
        _ => throw ArgumentError("Unknown value for clockid_t: $value"),
      };
}

final class imaxdiv_t extends ffi.Struct {
  @intmax_t()
  external int quot;

  @intmax_t()
  external int rem;
}

typedef CFBagRetainCallBackFunction = ffi.Pointer<ffi.Void> Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef CFBagRetainCallBack
    = ffi.Pointer<ffi.NativeFunction<CFBagRetainCallBackFunction>>;
typedef CFBagReleaseCallBackFunction = ffi.Void Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef DartCFBagReleaseCallBackFunction = void Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef CFBagReleaseCallBack
    = ffi.Pointer<ffi.NativeFunction<CFBagReleaseCallBackFunction>>;
typedef CFBagCopyDescriptionCallBackFunction = CFStringRef Function(
    ffi.Pointer<ffi.Void> value);
typedef CFBagCopyDescriptionCallBack
    = ffi.Pointer<ffi.NativeFunction<CFBagCopyDescriptionCallBackFunction>>;
typedef CFBagEqualCallBackFunction = Boolean Function(
    ffi.Pointer<ffi.Void> value1, ffi.Pointer<ffi.Void> value2);
typedef DartCFBagEqualCallBackFunction = DartBoolean Function(
    ffi.Pointer<ffi.Void> value1, ffi.Pointer<ffi.Void> value2);
typedef CFBagEqualCallBack
    = ffi.Pointer<ffi.NativeFunction<CFBagEqualCallBackFunction>>;
typedef CFBagHashCallBackFunction = CFHashCode Function(
    ffi.Pointer<ffi.Void> value);
typedef DartCFBagHashCallBackFunction = DartCFHashCode Function(
    ffi.Pointer<ffi.Void> value);
typedef CFBagHashCallBack
    = ffi.Pointer<ffi.NativeFunction<CFBagHashCallBackFunction>>;

final class CFBagCallBacks extends ffi.Struct {
  @CFIndex()
  external int version;

  external CFBagRetainCallBack retain;

  external CFBagReleaseCallBack release;

  external CFBagCopyDescriptionCallBack copyDescription;

  external CFBagEqualCallBack equal;

  external CFBagHashCallBack hash;
}

typedef CFBagApplierFunctionFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context);
typedef DartCFBagApplierFunctionFunction = void Function(
    ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context);
typedef CFBagApplierFunction
    = ffi.Pointer<ffi.NativeFunction<CFBagApplierFunctionFunction>>;

final class __CFBag extends ffi.Opaque {}

typedef CFBagRef = ffi.Pointer<__CFBag>;
typedef CFMutableBagRef = ffi.Pointer<__CFBag>;

final class CFBinaryHeapCompareContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> info)>> retain;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> info)>>
      copyDescription;
}

final class CFBinaryHeapCallBacks extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              CFAllocatorRef allocator, ffi.Pointer<ffi.Void> ptr)>> retain;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              CFAllocatorRef allocator, ffi.Pointer<ffi.Void> ptr)>> release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> ptr)>>
      copyDescription;

  external ffi.Pointer<
      ffi.NativeFunction<
          CFIndex Function(
              ffi.Pointer<ffi.Void> ptr1,
              ffi.Pointer<ffi.Void> ptr2,
              ffi.Pointer<ffi.Void> context)>> compare;
}

typedef CFBinaryHeapApplierFunctionFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> val, ffi.Pointer<ffi.Void> context);
typedef DartCFBinaryHeapApplierFunctionFunction = void Function(
    ffi.Pointer<ffi.Void> val, ffi.Pointer<ffi.Void> context);
typedef CFBinaryHeapApplierFunction
    = ffi.Pointer<ffi.NativeFunction<CFBinaryHeapApplierFunctionFunction>>;

final class __CFBinaryHeap extends ffi.Opaque {}

typedef CFBinaryHeapRef = ffi.Pointer<__CFBinaryHeap>;
typedef CFBit = UInt32;

final class __CFBitVector extends ffi.Opaque {}

typedef CFBitVectorRef = ffi.Pointer<__CFBitVector>;
typedef CFMutableBitVectorRef = ffi.Pointer<__CFBitVector>;

@ffi.Packed(1)
final class _OSUnalignedU16 extends ffi.Struct {
  @ffi.Uint16()
  external int __val;
}

@ffi.Packed(1)
final class _OSUnalignedU32 extends ffi.Struct {
  @ffi.Uint32()
  external int __val;
}

@ffi.Packed(1)
final class _OSUnalignedU64 extends ffi.Struct {
  @ffi.Uint64()
  external int __val;
}

typedef CFByteOrder = CFIndex;

final class CFSwappedFloat32 extends ffi.Struct {
  @ffi.Uint32()
  external int v;
}

final class CFSwappedFloat64 extends ffi.Struct {
  @ffi.Uint64()
  external int v;
}

typedef CFDictionaryRetainCallBackFunction = ffi.Pointer<ffi.Void> Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef CFDictionaryRetainCallBack
    = ffi.Pointer<ffi.NativeFunction<CFDictionaryRetainCallBackFunction>>;
typedef CFDictionaryReleaseCallBackFunction = ffi.Void Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef DartCFDictionaryReleaseCallBackFunction = void Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef CFDictionaryReleaseCallBack
    = ffi.Pointer<ffi.NativeFunction<CFDictionaryReleaseCallBackFunction>>;
typedef CFDictionaryCopyDescriptionCallBackFunction = CFStringRef Function(
    ffi.Pointer<ffi.Void> value);
typedef CFDictionaryCopyDescriptionCallBack = ffi
    .Pointer<ffi.NativeFunction<CFDictionaryCopyDescriptionCallBackFunction>>;
typedef CFDictionaryEqualCallBackFunction = Boolean Function(
    ffi.Pointer<ffi.Void> value1, ffi.Pointer<ffi.Void> value2);
typedef DartCFDictionaryEqualCallBackFunction = DartBoolean Function(
    ffi.Pointer<ffi.Void> value1, ffi.Pointer<ffi.Void> value2);
typedef CFDictionaryEqualCallBack
    = ffi.Pointer<ffi.NativeFunction<CFDictionaryEqualCallBackFunction>>;
typedef CFDictionaryHashCallBackFunction = CFHashCode Function(
    ffi.Pointer<ffi.Void> value);
typedef DartCFDictionaryHashCallBackFunction = DartCFHashCode Function(
    ffi.Pointer<ffi.Void> value);
typedef CFDictionaryHashCallBack
    = ffi.Pointer<ffi.NativeFunction<CFDictionaryHashCallBackFunction>>;

final class CFDictionaryKeyCallBacks extends ffi.Struct {
  @CFIndex()
  external int version;

  external CFDictionaryRetainCallBack retain;

  external CFDictionaryReleaseCallBack release;

  external CFDictionaryCopyDescriptionCallBack copyDescription;

  external CFDictionaryEqualCallBack equal;

  external CFDictionaryHashCallBack hash;
}

final class CFDictionaryValueCallBacks extends ffi.Struct {
  @CFIndex()
  external int version;

  external CFDictionaryRetainCallBack retain;

  external CFDictionaryReleaseCallBack release;

  external CFDictionaryCopyDescriptionCallBack copyDescription;

  external CFDictionaryEqualCallBack equal;
}

typedef CFDictionaryApplierFunctionFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> value,
    ffi.Pointer<ffi.Void> context);
typedef DartCFDictionaryApplierFunctionFunction = void Function(
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> value,
    ffi.Pointer<ffi.Void> context);
typedef CFDictionaryApplierFunction
    = ffi.Pointer<ffi.NativeFunction<CFDictionaryApplierFunctionFunction>>;

final class __CFDictionary extends ffi.Opaque {}

typedef CFDictionaryRef = ffi.Pointer<__CFDictionary>;
typedef CFMutableDictionaryRef = ffi.Pointer<__CFDictionary>;
typedef CFNotificationName = CFStringRef;

final class __CFNotificationCenter extends ffi.Opaque {}

typedef CFNotificationCenterRef = ffi.Pointer<__CFNotificationCenter>;
typedef CFNotificationCallbackFunction = ffi.Void Function(
    CFNotificationCenterRef center,
    ffi.Pointer<ffi.Void> observer,
    CFNotificationName name,
    ffi.Pointer<ffi.Void> object,
    CFDictionaryRef userInfo);
typedef DartCFNotificationCallbackFunction = void Function(
    CFNotificationCenterRef center,
    ffi.Pointer<ffi.Void> observer,
    CFNotificationName name,
    ffi.Pointer<ffi.Void> object,
    CFDictionaryRef userInfo);
typedef CFNotificationCallback
    = ffi.Pointer<ffi.NativeFunction<CFNotificationCallbackFunction>>;

enum CFNotificationSuspensionBehavior {
  CFNotificationSuspensionBehaviorDrop(1),
  CFNotificationSuspensionBehaviorCoalesce(2),
  CFNotificationSuspensionBehaviorHold(3),
  CFNotificationSuspensionBehaviorDeliverImmediately(4);

  final int value;
  const CFNotificationSuspensionBehavior(this.value);

  static CFNotificationSuspensionBehavior fromValue(int value) =>
      switch (value) {
        1 => CFNotificationSuspensionBehaviorDrop,
        2 => CFNotificationSuspensionBehaviorCoalesce,
        3 => CFNotificationSuspensionBehaviorHold,
        4 => CFNotificationSuspensionBehaviorDeliverImmediately,
        _ => throw ArgumentError(
            "Unknown value for CFNotificationSuspensionBehavior: $value"),
      };
}

typedef CFLocaleIdentifier = CFStringRef;
typedef CFLocaleKey = CFStringRef;

final class __CFLocale extends ffi.Opaque {}

typedef CFLocaleRef = ffi.Pointer<__CFLocale>;

enum CFLocaleLanguageDirection {
  kCFLocaleLanguageDirectionUnknown(0),
  kCFLocaleLanguageDirectionLeftToRight(1),
  kCFLocaleLanguageDirectionRightToLeft(2),
  kCFLocaleLanguageDirectionTopToBottom(3),
  kCFLocaleLanguageDirectionBottomToTop(4);

  final int value;
  const CFLocaleLanguageDirection(this.value);

  static CFLocaleLanguageDirection fromValue(int value) => switch (value) {
        0 => kCFLocaleLanguageDirectionUnknown,
        1 => kCFLocaleLanguageDirectionLeftToRight,
        2 => kCFLocaleLanguageDirectionRightToLeft,
        3 => kCFLocaleLanguageDirectionTopToBottom,
        4 => kCFLocaleLanguageDirectionBottomToTop,
        _ => throw ArgumentError(
            "Unknown value for CFLocaleLanguageDirection: $value"),
      };
}

typedef CFCalendarIdentifier = CFStringRef;
typedef CFTimeInterval = ffi.Double;
typedef DartCFTimeInterval = double;
typedef CFAbsoluteTime = CFTimeInterval;

final class __CFDate extends ffi.Opaque {}

typedef CFDateRef = ffi.Pointer<__CFDate>;

final class __CFTimeZone extends ffi.Opaque {}

typedef CFTimeZoneRef = ffi.Pointer<__CFTimeZone>;

final class CFGregorianDate extends ffi.Struct {
  @SInt32()
  external int year;

  @SInt8()
  external int month;

  @SInt8()
  external int day;

  @SInt8()
  external int hour;

  @SInt8()
  external int minute;

  @ffi.Double()
  external double second;
}

final class CFGregorianUnits extends ffi.Struct {
  @SInt32()
  external int years;

  @SInt32()
  external int months;

  @SInt32()
  external int days;

  @SInt32()
  external int hours;

  @SInt32()
  external int minutes;

  @ffi.Double()
  external double seconds;
}

final class __CFData extends ffi.Opaque {}

typedef CFDataRef = ffi.Pointer<__CFData>;
typedef CFMutableDataRef = ffi.Pointer<__CFData>;

enum CFDataSearchFlags {
  kCFDataSearchBackwards(1),
  kCFDataSearchAnchored(2);

  final int value;
  const CFDataSearchFlags(this.value);

  static CFDataSearchFlags fromValue(int value) => switch (value) {
        1 => kCFDataSearchBackwards,
        2 => kCFDataSearchAnchored,
        _ => throw ArgumentError("Unknown value for CFDataSearchFlags: $value"),
      };
}

final class __CFCharacterSet extends ffi.Opaque {}

typedef CFCharacterSetRef = ffi.Pointer<__CFCharacterSet>;
typedef CFMutableCharacterSetRef = ffi.Pointer<__CFCharacterSet>;

enum CFCharacterSetPredefinedSet {
  kCFCharacterSetControl(1),
  kCFCharacterSetWhitespace(2),
  kCFCharacterSetWhitespaceAndNewline(3),
  kCFCharacterSetDecimalDigit(4),
  kCFCharacterSetLetter(5),
  kCFCharacterSetLowercaseLetter(6),
  kCFCharacterSetUppercaseLetter(7),
  kCFCharacterSetNonBase(8),
  kCFCharacterSetDecomposable(9),
  kCFCharacterSetAlphaNumeric(10),
  kCFCharacterSetPunctuation(11),
  kCFCharacterSetCapitalizedLetter(13),
  kCFCharacterSetSymbol(14),
  kCFCharacterSetNewline(15),
  kCFCharacterSetIllegal(12);

  final int value;
  const CFCharacterSetPredefinedSet(this.value);

  static CFCharacterSetPredefinedSet fromValue(int value) => switch (value) {
        1 => kCFCharacterSetControl,
        2 => kCFCharacterSetWhitespace,
        3 => kCFCharacterSetWhitespaceAndNewline,
        4 => kCFCharacterSetDecimalDigit,
        5 => kCFCharacterSetLetter,
        6 => kCFCharacterSetLowercaseLetter,
        7 => kCFCharacterSetUppercaseLetter,
        8 => kCFCharacterSetNonBase,
        9 => kCFCharacterSetDecomposable,
        10 => kCFCharacterSetAlphaNumeric,
        11 => kCFCharacterSetPunctuation,
        13 => kCFCharacterSetCapitalizedLetter,
        14 => kCFCharacterSetSymbol,
        15 => kCFCharacterSetNewline,
        12 => kCFCharacterSetIllegal,
        _ => throw ArgumentError(
            "Unknown value for CFCharacterSetPredefinedSet: $value"),
      };
}

typedef CFErrorDomain = CFStringRef;

final class __CFError extends ffi.Opaque {}

typedef CFErrorRef = ffi.Pointer<__CFError>;
typedef CFStringEncoding = UInt32;

enum CFStringCompareFlags {
  kCFCompareCaseInsensitive(1),
  kCFCompareBackwards(4),
  kCFCompareAnchored(8),
  kCFCompareNonliteral(16),
  kCFCompareLocalized(32),
  kCFCompareNumerically(64),
  kCFCompareDiacriticInsensitive(128),
  kCFCompareWidthInsensitive(256),
  kCFCompareForcedOrdering(512);

  final int value;
  const CFStringCompareFlags(this.value);

  static CFStringCompareFlags fromValue(int value) => switch (value) {
        1 => kCFCompareCaseInsensitive,
        4 => kCFCompareBackwards,
        8 => kCFCompareAnchored,
        16 => kCFCompareNonliteral,
        32 => kCFCompareLocalized,
        64 => kCFCompareNumerically,
        128 => kCFCompareDiacriticInsensitive,
        256 => kCFCompareWidthInsensitive,
        512 => kCFCompareForcedOrdering,
        _ =>
          throw ArgumentError("Unknown value for CFStringCompareFlags: $value"),
      };
}

enum CFStringNormalizationForm {
  kCFStringNormalizationFormD(0),
  kCFStringNormalizationFormKD(1),
  kCFStringNormalizationFormC(2),
  kCFStringNormalizationFormKC(3);

  final int value;
  const CFStringNormalizationForm(this.value);

  static CFStringNormalizationForm fromValue(int value) => switch (value) {
        0 => kCFStringNormalizationFormD,
        1 => kCFStringNormalizationFormKD,
        2 => kCFStringNormalizationFormC,
        3 => kCFStringNormalizationFormKC,
        _ => throw ArgumentError(
            "Unknown value for CFStringNormalizationForm: $value"),
      };
}

final class CFStringInlineBuffer extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<UniChar> buffer;

  external CFStringRef theString;

  external ffi.Pointer<UniChar> directUniCharBuffer;

  external ffi.Pointer<ffi.Char> directCStringBuffer;

  external CFRange rangeToBuffer;

  @CFIndex()
  external int bufferedRangeStart;

  @CFIndex()
  external int bufferedRangeEnd;
}

enum CFTimeZoneNameStyle {
  kCFTimeZoneNameStyleStandard(0),
  kCFTimeZoneNameStyleShortStandard(1),
  kCFTimeZoneNameStyleDaylightSaving(2),
  kCFTimeZoneNameStyleShortDaylightSaving(3),
  kCFTimeZoneNameStyleGeneric(4),
  kCFTimeZoneNameStyleShortGeneric(5);

  final int value;
  const CFTimeZoneNameStyle(this.value);

  static CFTimeZoneNameStyle fromValue(int value) => switch (value) {
        0 => kCFTimeZoneNameStyleStandard,
        1 => kCFTimeZoneNameStyleShortStandard,
        2 => kCFTimeZoneNameStyleDaylightSaving,
        3 => kCFTimeZoneNameStyleShortDaylightSaving,
        4 => kCFTimeZoneNameStyleGeneric,
        5 => kCFTimeZoneNameStyleShortGeneric,
        _ =>
          throw ArgumentError("Unknown value for CFTimeZoneNameStyle: $value"),
      };
}

final class __CFCalendar extends ffi.Opaque {}

typedef CFCalendarRef = ffi.Pointer<__CFCalendar>;

enum CFCalendarUnit {
  kCFCalendarUnitEra(2),
  kCFCalendarUnitYear(4),
  kCFCalendarUnitMonth(8),
  kCFCalendarUnitDay(16),
  kCFCalendarUnitHour(32),
  kCFCalendarUnitMinute(64),
  kCFCalendarUnitSecond(128),
  kCFCalendarUnitWeek(256),
  kCFCalendarUnitWeekday(512),
  kCFCalendarUnitWeekdayOrdinal(1024),
  kCFCalendarUnitQuarter(2048),
  kCFCalendarUnitWeekOfMonth(4096),
  kCFCalendarUnitWeekOfYear(8192),
  kCFCalendarUnitYearForWeekOfYear(16384),
  kCFCalendarUnitDayOfYear(65536);

  final int value;
  const CFCalendarUnit(this.value);

  static CFCalendarUnit fromValue(int value) => switch (value) {
        2 => kCFCalendarUnitEra,
        4 => kCFCalendarUnitYear,
        8 => kCFCalendarUnitMonth,
        16 => kCFCalendarUnitDay,
        32 => kCFCalendarUnitHour,
        64 => kCFCalendarUnitMinute,
        128 => kCFCalendarUnitSecond,
        256 => kCFCalendarUnitWeek,
        512 => kCFCalendarUnitWeekday,
        1024 => kCFCalendarUnitWeekdayOrdinal,
        2048 => kCFCalendarUnitQuarter,
        4096 => kCFCalendarUnitWeekOfMonth,
        8192 => kCFCalendarUnitWeekOfYear,
        16384 => kCFCalendarUnitYearForWeekOfYear,
        65536 => kCFCalendarUnitDayOfYear,
        _ => throw ArgumentError("Unknown value for CFCalendarUnit: $value"),
      };
}

typedef CGFloat = ffi.Double;
typedef DartCGFloat = double;

final class CGPoint extends ffi.Struct {
  @CGFloat()
  external double x;

  @CGFloat()
  external double y;
}

final class CGSize extends ffi.Struct {
  @CGFloat()
  external double width;

  @CGFloat()
  external double height;
}

final class CGVector extends ffi.Struct {
  @CGFloat()
  external double dx;

  @CGFloat()
  external double dy;
}

final class CGRect extends ffi.Struct {
  external CGPoint origin;

  external CGSize size;
}

final class CGAffineTransform extends ffi.Struct {
  @CGFloat()
  external double a;

  @CGFloat()
  external double b;

  @CGFloat()
  external double c;

  @CGFloat()
  external double d;

  @CGFloat()
  external double tx;

  @CGFloat()
  external double ty;
}

final class CGAffineTransformComponents extends ffi.Struct {
  external CGSize scale;

  @CGFloat()
  external double horizontalShear;

  @CGFloat()
  external double rotation;

  external CGVector translation;
}

typedef CFDateFormatterKey = CFStringRef;

final class __CFDateFormatter extends ffi.Opaque {}

typedef CFDateFormatterRef = ffi.Pointer<__CFDateFormatter>;

enum CFDateFormatterStyle {
  kCFDateFormatterNoStyle(0),
  kCFDateFormatterShortStyle(1),
  kCFDateFormatterMediumStyle(2),
  kCFDateFormatterLongStyle(3),
  kCFDateFormatterFullStyle(4);

  final int value;
  const CFDateFormatterStyle(this.value);

  static CFDateFormatterStyle fromValue(int value) => switch (value) {
        0 => kCFDateFormatterNoStyle,
        1 => kCFDateFormatterShortStyle,
        2 => kCFDateFormatterMediumStyle,
        3 => kCFDateFormatterLongStyle,
        4 => kCFDateFormatterFullStyle,
        _ =>
          throw ArgumentError("Unknown value for CFDateFormatterStyle: $value"),
      };
}

enum CFISO8601DateFormatOptions {
  kCFISO8601DateFormatWithYear(1),
  kCFISO8601DateFormatWithMonth(2),
  kCFISO8601DateFormatWithWeekOfYear(4),
  kCFISO8601DateFormatWithDay(16),
  kCFISO8601DateFormatWithTime(32),
  kCFISO8601DateFormatWithTimeZone(64),
  kCFISO8601DateFormatWithSpaceBetweenDateAndTime(128),
  kCFISO8601DateFormatWithDashSeparatorInDate(256),
  kCFISO8601DateFormatWithColonSeparatorInTime(512),
  kCFISO8601DateFormatWithColonSeparatorInTimeZone(1024),
  kCFISO8601DateFormatWithFractionalSeconds(2048),
  kCFISO8601DateFormatWithFullDate(275),
  kCFISO8601DateFormatWithFullTime(1632),
  kCFISO8601DateFormatWithInternetDateTime(1907);

  final int value;
  const CFISO8601DateFormatOptions(this.value);

  static CFISO8601DateFormatOptions fromValue(int value) => switch (value) {
        1 => kCFISO8601DateFormatWithYear,
        2 => kCFISO8601DateFormatWithMonth,
        4 => kCFISO8601DateFormatWithWeekOfYear,
        16 => kCFISO8601DateFormatWithDay,
        32 => kCFISO8601DateFormatWithTime,
        64 => kCFISO8601DateFormatWithTimeZone,
        128 => kCFISO8601DateFormatWithSpaceBetweenDateAndTime,
        256 => kCFISO8601DateFormatWithDashSeparatorInDate,
        512 => kCFISO8601DateFormatWithColonSeparatorInTime,
        1024 => kCFISO8601DateFormatWithColonSeparatorInTimeZone,
        2048 => kCFISO8601DateFormatWithFractionalSeconds,
        275 => kCFISO8601DateFormatWithFullDate,
        1632 => kCFISO8601DateFormatWithFullTime,
        1907 => kCFISO8601DateFormatWithInternetDateTime,
        _ => throw ArgumentError(
            "Unknown value for CFISO8601DateFormatOptions: $value"),
      };
}

final class __CFBoolean extends ffi.Opaque {}

typedef CFBooleanRef = ffi.Pointer<__CFBoolean>;

enum CFNumberType {
  kCFNumberSInt8Type(1),
  kCFNumberSInt16Type(2),
  kCFNumberSInt32Type(3),
  kCFNumberSInt64Type(4),
  kCFNumberFloat32Type(5),
  kCFNumberFloat64Type(6),
  kCFNumberCharType(7),
  kCFNumberShortType(8),
  kCFNumberIntType(9),
  kCFNumberLongType(10),
  kCFNumberLongLongType(11),
  kCFNumberFloatType(12),
  kCFNumberDoubleType(13),
  kCFNumberCFIndexType(14),
  kCFNumberNSIntegerType(15),
  kCFNumberCGFloatType(16);

  static const kCFNumberMaxType = kCFNumberCGFloatType;

  final int value;
  const CFNumberType(this.value);

  static CFNumberType fromValue(int value) => switch (value) {
        1 => kCFNumberSInt8Type,
        2 => kCFNumberSInt16Type,
        3 => kCFNumberSInt32Type,
        4 => kCFNumberSInt64Type,
        5 => kCFNumberFloat32Type,
        6 => kCFNumberFloat64Type,
        7 => kCFNumberCharType,
        8 => kCFNumberShortType,
        9 => kCFNumberIntType,
        10 => kCFNumberLongType,
        11 => kCFNumberLongLongType,
        12 => kCFNumberFloatType,
        13 => kCFNumberDoubleType,
        14 => kCFNumberCFIndexType,
        15 => kCFNumberNSIntegerType,
        16 => kCFNumberCGFloatType,
        _ => throw ArgumentError("Unknown value for CFNumberType: $value"),
      };

  @override
  String toString() {
    if (this == kCFNumberCGFloatType)
      return "CFNumberType.kCFNumberCGFloatType, CFNumberType.kCFNumberMaxType";
    return super.toString();
  }
}

final class __CFNumber extends ffi.Opaque {}

typedef CFNumberRef = ffi.Pointer<__CFNumber>;
typedef CFNumberFormatterKey = CFStringRef;

final class __CFNumberFormatter extends ffi.Opaque {}

typedef CFNumberFormatterRef = ffi.Pointer<__CFNumberFormatter>;

enum CFNumberFormatterStyle {
  kCFNumberFormatterNoStyle(0),
  kCFNumberFormatterDecimalStyle(1),
  kCFNumberFormatterCurrencyStyle(2),
  kCFNumberFormatterPercentStyle(3),
  kCFNumberFormatterScientificStyle(4),
  kCFNumberFormatterSpellOutStyle(5),
  kCFNumberFormatterOrdinalStyle(6),
  kCFNumberFormatterCurrencyISOCodeStyle(8),
  kCFNumberFormatterCurrencyPluralStyle(9),
  kCFNumberFormatterCurrencyAccountingStyle(10);

  final int value;
  const CFNumberFormatterStyle(this.value);

  static CFNumberFormatterStyle fromValue(int value) => switch (value) {
        0 => kCFNumberFormatterNoStyle,
        1 => kCFNumberFormatterDecimalStyle,
        2 => kCFNumberFormatterCurrencyStyle,
        3 => kCFNumberFormatterPercentStyle,
        4 => kCFNumberFormatterScientificStyle,
        5 => kCFNumberFormatterSpellOutStyle,
        6 => kCFNumberFormatterOrdinalStyle,
        8 => kCFNumberFormatterCurrencyISOCodeStyle,
        9 => kCFNumberFormatterCurrencyPluralStyle,
        10 => kCFNumberFormatterCurrencyAccountingStyle,
        _ => throw ArgumentError(
            "Unknown value for CFNumberFormatterStyle: $value"),
      };
}

enum CFURLPathStyle {
  kCFURLPOSIXPathStyle(0),
  kCFURLHFSPathStyle(1),
  kCFURLWindowsPathStyle(2);

  final int value;
  const CFURLPathStyle(this.value);

  static CFURLPathStyle fromValue(int value) => switch (value) {
        0 => kCFURLPOSIXPathStyle,
        1 => kCFURLHFSPathStyle,
        2 => kCFURLWindowsPathStyle,
        _ => throw ArgumentError("Unknown value for CFURLPathStyle: $value"),
      };
}

final class __CFURL extends ffi.Opaque {}

typedef CFURLRef = ffi.Pointer<__CFURL>;

enum CFURLComponentType {
  kCFURLComponentScheme(1),
  kCFURLComponentNetLocation(2),
  kCFURLComponentPath(3),
  kCFURLComponentResourceSpecifier(4),
  kCFURLComponentUser(5),
  kCFURLComponentPassword(6),
  kCFURLComponentUserInfo(7),
  kCFURLComponentHost(8),
  kCFURLComponentPort(9),
  kCFURLComponentParameterString(10),
  kCFURLComponentQuery(11),
  kCFURLComponentFragment(12);

  final int value;
  const CFURLComponentType(this.value);

  static CFURLComponentType fromValue(int value) => switch (value) {
        1 => kCFURLComponentScheme,
        2 => kCFURLComponentNetLocation,
        3 => kCFURLComponentPath,
        4 => kCFURLComponentResourceSpecifier,
        5 => kCFURLComponentUser,
        6 => kCFURLComponentPassword,
        7 => kCFURLComponentUserInfo,
        8 => kCFURLComponentHost,
        9 => kCFURLComponentPort,
        10 => kCFURLComponentParameterString,
        11 => kCFURLComponentQuery,
        12 => kCFURLComponentFragment,
        _ =>
          throw ArgumentError("Unknown value for CFURLComponentType: $value"),
      };
}

final class FSRef extends ffi.Opaque {}

enum CFURLBookmarkCreationOptions {
  kCFURLBookmarkCreationMinimalBookmarkMask(512),
  kCFURLBookmarkCreationSuitableForBookmarkFile(1024),
  kCFURLBookmarkCreationWithSecurityScope(2048),
  kCFURLBookmarkCreationSecurityScopeAllowOnlyReadAccess(4096),
  kCFURLBookmarkCreationWithoutImplicitSecurityScope(536870912),
  kCFURLBookmarkCreationPreferFileIDResolutionMask(256);

  final int value;
  const CFURLBookmarkCreationOptions(this.value);

  static CFURLBookmarkCreationOptions fromValue(int value) => switch (value) {
        512 => kCFURLBookmarkCreationMinimalBookmarkMask,
        1024 => kCFURLBookmarkCreationSuitableForBookmarkFile,
        2048 => kCFURLBookmarkCreationWithSecurityScope,
        4096 => kCFURLBookmarkCreationSecurityScopeAllowOnlyReadAccess,
        536870912 => kCFURLBookmarkCreationWithoutImplicitSecurityScope,
        256 => kCFURLBookmarkCreationPreferFileIDResolutionMask,
        _ => throw ArgumentError(
            "Unknown value for CFURLBookmarkCreationOptions: $value"),
      };
}

enum CFURLBookmarkResolutionOptions {
  kCFURLBookmarkResolutionWithoutUIMask(256),
  kCFURLBookmarkResolutionWithoutMountingMask(512),
  kCFURLBookmarkResolutionWithSecurityScope(1024),
  kCFURLBookmarkResolutionWithoutImplicitStartAccessing(32768);

  static const kCFBookmarkResolutionWithoutUIMask =
      kCFURLBookmarkResolutionWithoutUIMask;
  static const kCFBookmarkResolutionWithoutMountingMask =
      kCFURLBookmarkResolutionWithoutMountingMask;

  final int value;
  const CFURLBookmarkResolutionOptions(this.value);

  static CFURLBookmarkResolutionOptions fromValue(int value) => switch (value) {
        256 => kCFURLBookmarkResolutionWithoutUIMask,
        512 => kCFURLBookmarkResolutionWithoutMountingMask,
        1024 => kCFURLBookmarkResolutionWithSecurityScope,
        32768 => kCFURLBookmarkResolutionWithoutImplicitStartAccessing,
        _ => throw ArgumentError(
            "Unknown value for CFURLBookmarkResolutionOptions: $value"),
      };

  @override
  String toString() {
    if (this == kCFURLBookmarkResolutionWithoutUIMask)
      return "CFURLBookmarkResolutionOptions.kCFURLBookmarkResolutionWithoutUIMask, CFURLBookmarkResolutionOptions.kCFBookmarkResolutionWithoutUIMask";
    if (this == kCFURLBookmarkResolutionWithoutMountingMask)
      return "CFURLBookmarkResolutionOptions.kCFURLBookmarkResolutionWithoutMountingMask, CFURLBookmarkResolutionOptions.kCFBookmarkResolutionWithoutMountingMask";
    return super.toString();
  }
}

typedef CFURLBookmarkFileCreationOptions = CFOptionFlags;
typedef boolean_t = ffi.Int;
typedef Dartboolean_t = int;
typedef natural_t = __darwin_natural_t;
typedef integer_t = ffi.Int;
typedef Dartinteger_t = int;
typedef vm_offset_t = ffi.UintPtr;
typedef Dartvm_offset_t = int;
typedef vm_size_t = ffi.UintPtr;
typedef Dartvm_size_t = int;
typedef mach_vm_address_t = ffi.Uint64;
typedef Dartmach_vm_address_t = int;
typedef mach_vm_offset_t = ffi.Uint64;
typedef Dartmach_vm_offset_t = int;
typedef mach_vm_size_t = ffi.Uint64;
typedef Dartmach_vm_size_t = int;
typedef vm_map_offset_t = ffi.Uint64;
typedef Dartvm_map_offset_t = int;
typedef vm_map_address_t = ffi.Uint64;
typedef Dartvm_map_address_t = int;
typedef vm_map_size_t = ffi.Uint64;
typedef Dartvm_map_size_t = int;
typedef vm32_offset_t = ffi.Uint32;
typedef Dartvm32_offset_t = int;
typedef vm32_address_t = ffi.Uint32;
typedef Dartvm32_address_t = int;
typedef vm32_size_t = ffi.Uint32;
typedef Dartvm32_size_t = int;
typedef mach_port_context_t = vm_offset_t;
typedef mach_port_name_t = natural_t;
typedef mach_port_name_array_t = ffi.Pointer<mach_port_name_t>;
typedef mach_port_t = __darwin_mach_port_t;
typedef mach_port_array_t = ffi.Pointer<mach_port_t>;
typedef mach_port_right_t = natural_t;
typedef mach_port_type_t = natural_t;
typedef mach_port_type_array_t = ffi.Pointer<mach_port_type_t>;
typedef mach_port_urefs_t = natural_t;
typedef mach_port_delta_t = integer_t;
typedef mach_port_seqno_t = natural_t;
typedef mach_port_mscount_t = natural_t;
typedef mach_port_msgcount_t = natural_t;
typedef mach_port_rights_t = natural_t;
typedef mach_port_srights_t = ffi.UnsignedInt;
typedef Dartmach_port_srights_t = int;

final class mach_port_status extends ffi.Struct {
  @mach_port_rights_t()
  external int mps_pset;

  @mach_port_seqno_t()
  external int mps_seqno;

  @mach_port_mscount_t()
  external int mps_mscount;

  @mach_port_msgcount_t()
  external int mps_qlimit;

  @mach_port_msgcount_t()
  external int mps_msgcount;

  @mach_port_rights_t()
  external int mps_sorights;

  @boolean_t()
  external int mps_srights;

  @boolean_t()
  external int mps_pdrequest;

  @boolean_t()
  external int mps_nsrequest;

  @natural_t()
  external int mps_flags;
}

typedef mach_port_status_t = mach_port_status;

final class mach_port_limits extends ffi.Struct {
  @mach_port_msgcount_t()
  external int mpl_qlimit;
}

typedef mach_port_limits_t = mach_port_limits;

final class mach_port_info_ext extends ffi.Struct {
  external mach_port_status_t mpie_status;

  @mach_port_msgcount_t()
  external int mpie_boost_cnt;

  @ffi.Array.multi([6])
  external ffi.Array<ffi.Uint32> reserved;
}

typedef mach_port_info_ext_t = mach_port_info_ext;

final class mach_port_guard_info extends ffi.Struct {
  @ffi.Uint64()
  external int mpgi_guard;
}

typedef mach_port_guard_info_t = mach_port_guard_info;
typedef mach_port_info_t = ffi.Pointer<integer_t>;
typedef mach_port_flavor_t = ffi.Int;
typedef Dartmach_port_flavor_t = int;

final class mach_port_qos extends ffi.Opaque {}

typedef mach_port_qos_t = mach_port_qos;

final class mach_service_port_info extends ffi.Struct {
  @ffi.Array.multi([255])
  external ffi.Array<ffi.Char> mspi_string_name;

  @ffi.Uint8()
  external int mspi_domain_type;
}

typedef mach_service_port_info_data_t = mach_service_port_info;
typedef mach_service_port_info_t = ffi.Pointer<mach_service_port_info>;

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint64> reserved;

  @mach_port_name_t()
  external int work_interval_port;

  external mach_service_port_info_t service_port_info;

  @mach_port_name_t()
  external int service_port_name;
}

final class mach_port_options extends ffi.Struct {
  @ffi.Uint32()
  external int flags;

  external mach_port_limits_t mpl;

  external UnnamedUnion1 unnamed;
}

typedef mach_port_options_t = mach_port_options;
typedef mach_port_options_ptr_t = ffi.Pointer<mach_port_options_t>;
typedef CFRunLoopMode = CFStringRef;

final class __CFRunLoop extends ffi.Opaque {}

typedef CFRunLoopRef = ffi.Pointer<__CFRunLoop>;

final class __CFRunLoopSource extends ffi.Opaque {}

typedef CFRunLoopSourceRef = ffi.Pointer<__CFRunLoopSource>;

final class __CFRunLoopObserver extends ffi.Opaque {}

typedef CFRunLoopObserverRef = ffi.Pointer<__CFRunLoopObserver>;

final class __CFRunLoopTimer extends ffi.Opaque {}

typedef CFRunLoopTimerRef = ffi.Pointer<__CFRunLoopTimer>;

enum CFRunLoopRunResult {
  kCFRunLoopRunFinished(1),
  kCFRunLoopRunStopped(2),
  kCFRunLoopRunTimedOut(3),
  kCFRunLoopRunHandledSource(4);

  final int value;
  const CFRunLoopRunResult(this.value);

  static CFRunLoopRunResult fromValue(int value) => switch (value) {
        1 => kCFRunLoopRunFinished,
        2 => kCFRunLoopRunStopped,
        3 => kCFRunLoopRunTimedOut,
        4 => kCFRunLoopRunHandledSource,
        _ =>
          throw ArgumentError("Unknown value for CFRunLoopRunResult: $value"),
      };
}

enum CFRunLoopActivity {
  kCFRunLoopEntry(1),
  kCFRunLoopBeforeTimers(2),
  kCFRunLoopBeforeSources(4),
  kCFRunLoopBeforeWaiting(32),
  kCFRunLoopAfterWaiting(64),
  kCFRunLoopExit(128),
  kCFRunLoopAllActivities(268435455);

  final int value;
  const CFRunLoopActivity(this.value);

  static CFRunLoopActivity fromValue(int value) => switch (value) {
        1 => kCFRunLoopEntry,
        2 => kCFRunLoopBeforeTimers,
        4 => kCFRunLoopBeforeSources,
        32 => kCFRunLoopBeforeWaiting,
        64 => kCFRunLoopAfterWaiting,
        128 => kCFRunLoopExit,
        268435455 => kCFRunLoopAllActivities,
        _ => throw ArgumentError("Unknown value for CFRunLoopActivity: $value"),
      };
}

final class CFRunLoopSourceContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> info)>> retain;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> info)>>
      copyDescription;

  external ffi.Pointer<
      ffi.NativeFunction<
          Boolean Function(
              ffi.Pointer<ffi.Void> info1, ffi.Pointer<ffi.Void> info2)>> equal;

  external ffi.Pointer<
      ffi.NativeFunction<CFHashCode Function(ffi.Pointer<ffi.Void> info)>> hash;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> info, CFRunLoopRef rl,
              CFRunLoopMode mode)>> schedule;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> info, CFRunLoopRef rl,
              CFRunLoopMode mode)>> cancel;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      perform;
}

final class CFRunLoopSourceContext1 extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> info)>> retain;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> info)>>
      copyDescription;

  external ffi.Pointer<
      ffi.NativeFunction<
          Boolean Function(
              ffi.Pointer<ffi.Void> info1, ffi.Pointer<ffi.Void> info2)>> equal;

  external ffi.Pointer<
      ffi.NativeFunction<CFHashCode Function(ffi.Pointer<ffi.Void> info)>> hash;

  external ffi.Pointer<
          ffi.NativeFunction<mach_port_t Function(ffi.Pointer<ffi.Void> info)>>
      getPort;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void> msg,
              CFIndex size,
              CFAllocatorRef allocator,
              ffi.Pointer<ffi.Void> info)>> perform;
}

final class CFRunLoopObserverContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> info)>> retain;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> info)>>
      copyDescription;
}

typedef CFRunLoopObserverCallBackFunction = ffi.Void Function(
    CFRunLoopObserverRef observer,
    CFOptionFlags activity,
    ffi.Pointer<ffi.Void> info);
typedef DartCFRunLoopObserverCallBackFunction = void Function(
    CFRunLoopObserverRef observer,
    CFRunLoopActivity activity,
    ffi.Pointer<ffi.Void> info);
typedef CFRunLoopObserverCallBack
    = ffi.Pointer<ffi.NativeFunction<CFRunLoopObserverCallBackFunction>>;
void _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        CFRunLoopObserverRef arg0,
        int arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    CFRunLoopObserverRef arg0, CFOptionFlags arg1)>>()
        .asFunction<void Function(CFRunLoopObserverRef, int)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    CFRunLoopObserverRef, CFOptionFlags)>(
            _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            CFRunLoopObserverRef arg0,
            int arg1) =>
        (objc.getBlockClosure(block) as void Function(
            CFRunLoopObserverRef, int))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    CFRunLoopObserverRef, CFOptionFlags)>(
            _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        CFRunLoopObserverRef arg0,
        int arg1) {
  (objc.getBlockClosure(block) as void Function(CFRunLoopObserverRef, int))(
      arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, CFRunLoopObserverRef,
            CFOptionFlags)>
    _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                CFRunLoopObserverRef, CFOptionFlags)>.listener(
        _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        CFRunLoopObserverRef arg0,
        int arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(CFRunLoopObserverRef, int))(
        arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, CFRunLoopObserverRef, CFOptionFlags)>
    _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                CFRunLoopObserverRef,
                CFOptionFlags)>.isolateLocal(
        _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, CFRunLoopObserverRef, CFOptionFlags)>
    _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                CFRunLoopObserverRef,
                CFOptionFlags)>.listener(
        _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)>`.
abstract final class ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>,
                  CFOptionFlags)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(CFRunLoopObserverRef arg0, CFOptionFlags arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)>
      fromFunction(void Function(CFRunLoopObserverRef, CFRunLoopActivity) fn) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_closureCallable,
                  (CFRunLoopObserverRef arg0, int arg1) =>
                      fn(arg0, CFRunLoopActivity.fromValue(arg1))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)>
      listener(void Function(CFRunLoopObserverRef, CFRunLoopActivity) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_listenerCallable
            .nativeFunction
            .cast(),
        (CFRunLoopObserverRef arg0, int arg1) =>
            fn(arg0, CFRunLoopActivity.fromValue(arg1)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_tg5tbv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>,
            CFOptionFlags)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)>
      blocking(void Function(CFRunLoopObserverRef, CFRunLoopActivity) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_blockingCallable
            .nativeFunction
            .cast(),
        (CFRunLoopObserverRef arg0, int arg1) =>
            fn(arg0, CFRunLoopActivity.fromValue(arg1)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_blockingListenerCallable
            .nativeFunction
            .cast(),
        (CFRunLoopObserverRef arg0, int arg1) =>
            fn(arg0, CFRunLoopActivity.fromValue(arg1)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_tg5tbv, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>,
            CFOptionFlags)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)>`.
extension ObjCBlock_ffiVoid_CFRunLoopObserverRef_CFRunLoopActivity_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<__CFRunLoopObserver>, CFOptionFlags)> {
  void call(CFRunLoopObserverRef arg0, CFRunLoopActivity arg1) => ref
      .pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  CFRunLoopObserverRef arg0, CFOptionFlags arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>, CFRunLoopObserverRef,
              int)>()(ref.pointer, arg0, arg1.value);
}

final class CFRunLoopTimerContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> info)>> retain;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> info)>>
      copyDescription;
}

typedef CFRunLoopTimerCallBackFunction = ffi.Void Function(
    CFRunLoopTimerRef timer, ffi.Pointer<ffi.Void> info);
typedef DartCFRunLoopTimerCallBackFunction = void Function(
    CFRunLoopTimerRef timer, ffi.Pointer<ffi.Void> info);
typedef CFRunLoopTimerCallBack
    = ffi.Pointer<ffi.NativeFunction<CFRunLoopTimerCallBackFunction>>;
void _ObjCBlock_ffiVoid_CFRunLoopTimerRef_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, CFRunLoopTimerRef arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(CFRunLoopTimerRef arg0)>>()
        .asFunction<void Function(CFRunLoopTimerRef)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_CFRunLoopTimerRef_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, CFRunLoopTimerRef)>(
            _ObjCBlock_ffiVoid_CFRunLoopTimerRef_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_CFRunLoopTimerRef_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, CFRunLoopTimerRef arg0) =>
    (objc.getBlockClosure(block) as void Function(CFRunLoopTimerRef))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_CFRunLoopTimerRef_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, CFRunLoopTimerRef)>(
            _ObjCBlock_ffiVoid_CFRunLoopTimerRef_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_CFRunLoopTimerRef_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, CFRunLoopTimerRef arg0) {
  (objc.getBlockClosure(block) as void Function(CFRunLoopTimerRef))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, CFRunLoopTimerRef)>
    _ObjCBlock_ffiVoid_CFRunLoopTimerRef_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>, CFRunLoopTimerRef)>.listener(
        _ObjCBlock_ffiVoid_CFRunLoopTimerRef_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_CFRunLoopTimerRef_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    CFRunLoopTimerRef arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(CFRunLoopTimerRef))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, CFRunLoopTimerRef)>
    _ObjCBlock_ffiVoid_CFRunLoopTimerRef_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, CFRunLoopTimerRef)>.isolateLocal(
        _ObjCBlock_ffiVoid_CFRunLoopTimerRef_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, CFRunLoopTimerRef)>
    _ObjCBlock_ffiVoid_CFRunLoopTimerRef_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, CFRunLoopTimerRef)>.listener(
        _ObjCBlock_ffiVoid_CFRunLoopTimerRef_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>`.
abstract final class ObjCBlock_ffiVoid_CFRunLoopTimerRef {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(CFRunLoopTimerRef arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_CFRunLoopTimerRef_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>
      fromFunction(void Function(CFRunLoopTimerRef) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_CFRunLoopTimerRef_closureCallable,
                  (CFRunLoopTimerRef arg0) => fn(arg0)),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>
      listener(void Function(CFRunLoopTimerRef) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_CFRunLoopTimerRef_listenerCallable.nativeFunction
            .cast(),
        (CFRunLoopTimerRef arg0) => fn(arg0));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1dqvvol(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>
      blocking(void Function(CFRunLoopTimerRef) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_CFRunLoopTimerRef_blockingCallable.nativeFunction
            .cast(),
        (CFRunLoopTimerRef arg0) => fn(arg0));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_CFRunLoopTimerRef_blockingListenerCallable
            .nativeFunction
            .cast(),
        (CFRunLoopTimerRef arg0) => fn(arg0));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1dqvvol, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)>`.
extension ObjCBlock_ffiVoid_CFRunLoopTimerRef_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__CFRunLoopTimer>)> {
  void call(CFRunLoopTimerRef arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  CFRunLoopTimerRef arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              CFRunLoopTimerRef)>()(ref.pointer, arg0);
}

final class __CFSocket extends ffi.Opaque {}

typedef CFSocketRef = ffi.Pointer<__CFSocket>;

enum CFSocketError {
  kCFSocketSuccess(0),
  kCFSocketError(-1),
  kCFSocketTimeout(-2);

  final int value;
  const CFSocketError(this.value);

  static CFSocketError fromValue(int value) => switch (value) {
        0 => kCFSocketSuccess,
        -1 => kCFSocketError,
        -2 => kCFSocketTimeout,
        _ => throw ArgumentError("Unknown value for CFSocketError: $value"),
      };
}

final class CFSocketSignature extends ffi.Struct {
  @SInt32()
  external int protocolFamily;

  @SInt32()
  external int socketType;

  @SInt32()
  external int protocol;

  external CFDataRef address;
}

enum CFSocketCallBackType {
  kCFSocketNoCallBack(0),
  kCFSocketReadCallBack(1),
  kCFSocketAcceptCallBack(2),
  kCFSocketDataCallBack(3),
  kCFSocketConnectCallBack(4),
  kCFSocketWriteCallBack(8);

  final int value;
  const CFSocketCallBackType(this.value);

  static CFSocketCallBackType fromValue(int value) => switch (value) {
        0 => kCFSocketNoCallBack,
        1 => kCFSocketReadCallBack,
        2 => kCFSocketAcceptCallBack,
        3 => kCFSocketDataCallBack,
        4 => kCFSocketConnectCallBack,
        8 => kCFSocketWriteCallBack,
        _ =>
          throw ArgumentError("Unknown value for CFSocketCallBackType: $value"),
      };
}

typedef CFSocketCallBackFunction = ffi.Void Function(
    CFSocketRef s,
    CFOptionFlags type,
    CFDataRef address,
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.Void> info);
typedef DartCFSocketCallBackFunction = void Function(
    CFSocketRef s,
    CFSocketCallBackType type,
    CFDataRef address,
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.Void> info);
typedef CFSocketCallBack
    = ffi.Pointer<ffi.NativeFunction<CFSocketCallBackFunction>>;

final class CFSocketContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> info)>> retain;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> info)>>
      copyDescription;
}

typedef CFSocketNativeHandle = ffi.Int;
typedef DartCFSocketNativeHandle = int;

final class accessx_descriptor extends ffi.Struct {
  @ffi.UnsignedInt()
  external int ad_name_offset;

  @ffi.Int()
  external int ad_flags;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> ad_pad;
}

final class fssearchblock extends ffi.Opaque {}

final class searchstate extends ffi.Opaque {}

final class flock extends ffi.Struct {
  @off_t()
  external int l_start;

  @off_t()
  external int l_len;

  @pid_t()
  external int l_pid;

  @ffi.Short()
  external int l_type;

  @ffi.Short()
  external int l_whence;
}

final class flocktimeout extends ffi.Struct {
  external flock fl;

  external timespec timeout;
}

final class radvisory extends ffi.Struct {
  @off_t()
  external int ra_offset;

  @ffi.Int()
  external int ra_count;
}

final class fsignatures extends ffi.Struct {
  @off_t()
  external int fs_file_start;

  external ffi.Pointer<ffi.Void> fs_blob_start;

  @ffi.Size()
  external int fs_blob_size;

  @ffi.Size()
  external int fs_fsignatures_size;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Char> fs_cdhash;

  @ffi.Int()
  external int fs_hash_type;
}

typedef fsignatures_t = fsignatures;

final class fsupplement extends ffi.Struct {
  @off_t()
  external int fs_file_start;

  @off_t()
  external int fs_blob_start;

  @ffi.Size()
  external int fs_blob_size;

  @ffi.Int()
  external int fs_orig_fd;
}

typedef fsupplement_t = fsupplement;

final class fchecklv extends ffi.Struct {
  @off_t()
  external int lv_file_start;

  @ffi.Size()
  external int lv_error_message_size;

  external ffi.Pointer<ffi.Void> lv_error_message;
}

typedef fchecklv_t = fchecklv;

final class fgetsigsinfo extends ffi.Struct {
  @off_t()
  external int fg_file_start;

  @ffi.Int()
  external int fg_info_request;

  @ffi.Int()
  external int fg_sig_is_platform;
}

typedef fgetsigsinfo_t = fgetsigsinfo;

final class fstore extends ffi.Struct {
  @ffi.UnsignedInt()
  external int fst_flags;

  @ffi.Int()
  external int fst_posmode;

  @off_t()
  external int fst_offset;

  @off_t()
  external int fst_length;

  @off_t()
  external int fst_bytesalloc;
}

typedef fstore_t = fstore;

final class fpunchhole extends ffi.Struct {
  @ffi.UnsignedInt()
  external int fp_flags;

  @ffi.UnsignedInt()
  external int reserved;

  @off_t()
  external int fp_offset;

  @off_t()
  external int fp_length;
}

typedef fpunchhole_t = fpunchhole;

final class ftrimactivefile extends ffi.Struct {
  @off_t()
  external int fta_offset;

  @off_t()
  external int fta_length;
}

typedef ftrimactivefile_t = ftrimactivefile;

final class fspecread extends ffi.Struct {
  @ffi.UnsignedInt()
  external int fsr_flags;

  @ffi.UnsignedInt()
  external int reserved;

  @off_t()
  external int fsr_offset;

  @off_t()
  external int fsr_length;
}

typedef fspecread_t = fspecread;

final class fattributiontag extends ffi.Struct {
  @ffi.UnsignedInt()
  external int ft_flags;

  @ffi.UnsignedLongLong()
  external int ft_hash;

  @ffi.Array.multi([255])
  external ffi.Array<ffi.Char> ft_attribution_name;
}

typedef fattributiontag_t = fattributiontag;

@ffi.Packed(4)
final class log2phys extends ffi.Struct {
  @ffi.UnsignedInt()
  external int l2p_flags;

  @off_t()
  external int l2p_contigbytes;

  @off_t()
  external int l2p_devoffset;
}

final class _filesec extends ffi.Opaque {}

typedef filesec_t = ffi.Pointer<_filesec>;

enum filesec_property_t {
  FILESEC_OWNER(1),
  FILESEC_GROUP(2),
  FILESEC_UUID(3),
  FILESEC_MODE(4),
  FILESEC_ACL(5),
  FILESEC_GRPUUID(6),
  FILESEC_ACL_RAW(100),
  FILESEC_ACL_ALLOCSIZE(101);

  final int value;
  const filesec_property_t(this.value);

  static filesec_property_t fromValue(int value) => switch (value) {
        1 => FILESEC_OWNER,
        2 => FILESEC_GROUP,
        3 => FILESEC_UUID,
        4 => FILESEC_MODE,
        5 => FILESEC_ACL,
        6 => FILESEC_GRPUUID,
        100 => FILESEC_ACL_RAW,
        101 => FILESEC_ACL_ALLOCSIZE,
        _ =>
          throw ArgumentError("Unknown value for filesec_property_t: $value"),
      };
}

final class os_workgroup_attr_opaque_s extends ffi.Struct {
  @ffi.Uint32()
  external int sig;

  @ffi.Array.multi([60])
  external ffi.Array<ffi.Char> opaque;
}

final class os_workgroup_interval_data_opaque_s extends ffi.Struct {
  @ffi.Uint32()
  external int sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> opaque;
}

final class os_workgroup_join_token_opaque_s extends ffi.Struct {
  @ffi.Uint32()
  external int sig;

  @ffi.Array.multi([36])
  external ffi.Array<ffi.Char> opaque;
}

/// WARNING: OS_os_workgroup is a stub. To generate bindings for this class, include
/// OS_os_workgroup in your config's objc-interfaces list.
///
/// OS_os_workgroup
class OS_os_workgroup extends OS_object {
  OS_os_workgroup._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [OS_os_workgroup] that points to the same underlying object as [other].
  OS_os_workgroup.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [OS_os_workgroup] that wraps the given raw object pointer.
  OS_os_workgroup.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

typedef os_workgroup_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartos_workgroup_t = OS_os_workgroup;
typedef os_workgroup_attr_s = os_workgroup_attr_opaque_s;
typedef os_workgroup_attr_t = ffi.Pointer<os_workgroup_attr_opaque_s>;
typedef os_workgroup_join_token_s = os_workgroup_join_token_opaque_s;
typedef os_workgroup_join_token_t
    = ffi.Pointer<os_workgroup_join_token_opaque_s>;
typedef os_workgroup_index = ffi.Uint32;
typedef Dartos_workgroup_index = int;
typedef os_workgroup_working_arena_destructor_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void>);
typedef Dartos_workgroup_working_arena_destructor_tFunction = void Function(
    ffi.Pointer<ffi.Void>);
typedef os_workgroup_working_arena_destructor_t = ffi.Pointer<
    ffi.NativeFunction<os_workgroup_working_arena_destructor_tFunction>>;

final class os_workgroup_max_parallel_threads_attr_s extends ffi.Opaque {}

typedef os_workgroup_mpt_attr_s = os_workgroup_max_parallel_threads_attr_s;
typedef os_workgroup_mpt_attr_t
    = ffi.Pointer<os_workgroup_max_parallel_threads_attr_s>;
typedef os_workgroup_interval_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartos_workgroup_interval_t = OS_os_workgroup;
typedef os_workgroup_interval_data_s = os_workgroup_interval_data_opaque_s;
typedef os_workgroup_interval_data_t
    = ffi.Pointer<os_workgroup_interval_data_opaque_s>;
typedef os_workgroup_parallel_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartos_workgroup_parallel_t = OS_os_workgroup;
typedef dispatch_function_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void>);
typedef Dartdispatch_function_tFunction = void Function(ffi.Pointer<ffi.Void>);
typedef dispatch_function_t
    = ffi.Pointer<ffi.NativeFunction<dispatch_function_tFunction>>;

final class time_value extends ffi.Struct {
  @integer_t()
  external int seconds;

  @integer_t()
  external int microseconds;
}

typedef time_value_t = time_value;
typedef alarm_type_t = ffi.Int;
typedef Dartalarm_type_t = int;
typedef sleep_type_t = ffi.Int;
typedef Dartsleep_type_t = int;
typedef clock_id_t = ffi.Int;
typedef Dartclock_id_t = int;
typedef clock_flavor_t = ffi.Int;
typedef Dartclock_flavor_t = int;
typedef clock_attr_t = ffi.Pointer<ffi.Int>;
typedef clock_res_t = ffi.Int;
typedef Dartclock_res_t = int;

final class mach_timespec extends ffi.Struct {
  @ffi.UnsignedInt()
  external int tv_sec;

  @clock_res_t()
  external int tv_nsec;
}

typedef mach_timespec_t = mach_timespec;
typedef dispatch_time_t = ffi.Uint64;
typedef Dartdispatch_time_t = int;

enum qos_class_t {
  QOS_CLASS_USER_INTERACTIVE(33),
  QOS_CLASS_USER_INITIATED(25),
  QOS_CLASS_DEFAULT(21),
  QOS_CLASS_UTILITY(17),
  QOS_CLASS_BACKGROUND(9),
  QOS_CLASS_UNSPECIFIED(0);

  final int value;
  const qos_class_t(this.value);

  static qos_class_t fromValue(int value) => switch (value) {
        33 => QOS_CLASS_USER_INTERACTIVE,
        25 => QOS_CLASS_USER_INITIATED,
        21 => QOS_CLASS_DEFAULT,
        17 => QOS_CLASS_UTILITY,
        9 => QOS_CLASS_BACKGROUND,
        0 => QOS_CLASS_UNSPECIFIED,
        _ => throw ArgumentError("Unknown value for qos_class_t: $value"),
      };
}

typedef dispatch_object_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_object_t = objc.NSObject;
typedef dispatch_block_t = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartdispatch_block_t = objc.ObjCBlock<ffi.Void Function()>;
typedef dispatch_queue_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_t = objc.NSObject;
typedef dispatch_queue_global_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_global_t = objc.NSObject;
typedef dispatch_queue_serial_executor_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_serial_executor_t = objc.NSObject;
typedef dispatch_queue_serial_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_serial_t = objc.NSObject;
typedef dispatch_queue_main_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_main_t = objc.NSObject;
typedef dispatch_queue_concurrent_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_concurrent_t = objc.NSObject;
void _ObjCBlock_ffiVoid_ffiSize_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Size arg0)>>()
        .asFunction<void Function(int)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiSize_fnPtrCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Size)>(_ObjCBlock_ffiVoid_ffiSize_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiSize_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) =>
    (objc.getBlockClosure(block) as void Function(int))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiSize_closureCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Size)>(_ObjCBlock_ffiVoid_ffiSize_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiSize_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) {
  (objc.getBlockClosure(block) as void Function(int))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Size)>
    _ObjCBlock_ffiVoid_ffiSize_listenerCallable = ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Size)>.listener(_ObjCBlock_ffiVoid_ffiSize_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiSize_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Size)>
    _ObjCBlock_ffiVoid_ffiSize_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Size)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiSize_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Size)>
    _ObjCBlock_ffiVoid_ffiSize_blockingListenerCallable = ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Size)>.listener(_ObjCBlock_ffiVoid_ffiSize_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Size)>`.
abstract final class ObjCBlock_ffiVoid_ffiSize {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Size)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Size)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Size)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Size arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Size)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_ffiSize_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Size)> fromFunction(
          void Function(int) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Size)>(
          objc.newClosureBlock(_ObjCBlock_ffiVoid_ffiSize_closureCallable,
              (int arg0) => fn(arg0)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Size)> listener(
      void Function(int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiSize_listenerCallable.nativeFunction.cast(),
        (int arg0) => fn(arg0));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_6enxqz(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Size)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Size)> blocking(
      void Function(int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiSize_blockingCallable.nativeFunction.cast(),
        (int arg0) => fn(arg0));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiSize_blockingListenerCallable.nativeFunction
            .cast(),
        (int arg0) => fn(arg0));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_6enxqz, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Size)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Size)>`.
extension ObjCBlock_ffiVoid_ffiSize_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Size)> {
  void call(int arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Size arg0)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
      ref.pointer, arg0);
}

final class dispatch_queue_s extends ffi.Opaque {}

typedef dispatch_queue_priority_t = ffi.Long;
typedef Dartdispatch_queue_priority_t = int;
typedef dispatch_queue_attr_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_attr_t = objc.NSObject;

final class dispatch_queue_attr_s extends ffi.Opaque {}

enum dispatch_autorelease_frequency_t {
  DISPATCH_AUTORELEASE_FREQUENCY_INHERIT(0),
  DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM(1),
  DISPATCH_AUTORELEASE_FREQUENCY_NEVER(2);

  final int value;
  const dispatch_autorelease_frequency_t(this.value);

  static dispatch_autorelease_frequency_t fromValue(int value) =>
      switch (value) {
        0 => DISPATCH_AUTORELEASE_FREQUENCY_INHERIT,
        1 => DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM,
        2 => DISPATCH_AUTORELEASE_FREQUENCY_NEVER,
        _ => throw ArgumentError(
            "Unknown value for dispatch_autorelease_frequency_t: $value"),
      };
}

enum dispatch_block_flags_t {
  DISPATCH_BLOCK_BARRIER(1),
  DISPATCH_BLOCK_DETACHED(2),
  DISPATCH_BLOCK_ASSIGN_CURRENT(4),
  DISPATCH_BLOCK_NO_QOS_CLASS(8),
  DISPATCH_BLOCK_INHERIT_QOS_CLASS(16),
  DISPATCH_BLOCK_ENFORCE_QOS_CLASS(32);

  final int value;
  const dispatch_block_flags_t(this.value);

  static dispatch_block_flags_t fromValue(int value) => switch (value) {
        1 => DISPATCH_BLOCK_BARRIER,
        2 => DISPATCH_BLOCK_DETACHED,
        4 => DISPATCH_BLOCK_ASSIGN_CURRENT,
        8 => DISPATCH_BLOCK_NO_QOS_CLASS,
        16 => DISPATCH_BLOCK_INHERIT_QOS_CLASS,
        32 => DISPATCH_BLOCK_ENFORCE_QOS_CLASS,
        _ => throw ArgumentError(
            "Unknown value for dispatch_block_flags_t: $value"),
      };
}

typedef kern_return_t = ffi.Int;
typedef Dartkern_return_t = int;
typedef mach_msg_timeout_t = natural_t;
typedef mach_msg_bits_t = ffi.UnsignedInt;
typedef Dartmach_msg_bits_t = int;
typedef mach_msg_size_t = natural_t;
typedef mach_msg_id_t = integer_t;
typedef mach_msg_priority_t = ffi.UnsignedInt;
typedef Dartmach_msg_priority_t = int;
typedef mach_msg_type_name_t = ffi.UnsignedInt;
typedef Dartmach_msg_type_name_t = int;
typedef mach_msg_copy_options_t = ffi.UnsignedInt;
typedef Dartmach_msg_copy_options_t = int;
typedef mach_msg_guard_flags_t = ffi.UnsignedInt;
typedef Dartmach_msg_guard_flags_t = int;
typedef mach_msg_descriptor_type_t = ffi.UnsignedInt;
typedef Dartmach_msg_descriptor_type_t = int;

final class mach_msg_type_descriptor_t extends ffi.Opaque {}

final class mach_msg_port_descriptor_t extends ffi.Opaque {}

final class mach_msg_ool_descriptor32_t extends ffi.Opaque {}

final class mach_msg_ool_descriptor64_t extends ffi.Opaque {}

final class mach_msg_ool_descriptor_t extends ffi.Opaque {}

final class mach_msg_ool_ports_descriptor32_t extends ffi.Opaque {}

final class mach_msg_ool_ports_descriptor64_t extends ffi.Opaque {}

final class mach_msg_ool_ports_descriptor_t extends ffi.Opaque {}

final class mach_msg_guarded_port_descriptor32_t extends ffi.Opaque {}

final class mach_msg_guarded_port_descriptor64_t extends ffi.Opaque {}

final class mach_msg_guarded_port_descriptor_t extends ffi.Opaque {}

final class mach_msg_descriptor_t extends ffi.Opaque {}

final class mach_msg_body_t extends ffi.Struct {
  @mach_msg_size_t()
  external int msgh_descriptor_count;
}

final class mach_msg_header_t extends ffi.Struct {
  @mach_msg_bits_t()
  external int msgh_bits;

  @mach_msg_size_t()
  external int msgh_size;

  @mach_port_t()
  external int msgh_remote_port;

  @mach_port_t()
  external int msgh_local_port;

  @mach_port_name_t()
  external int msgh_voucher_port;

  @mach_msg_id_t()
  external int msgh_id;
}

final class mach_msg_base_t extends ffi.Struct {
  external mach_msg_header_t header;

  external mach_msg_body_t body;
}

typedef mach_msg_trailer_type_t = ffi.UnsignedInt;
typedef Dartmach_msg_trailer_type_t = int;
typedef mach_msg_trailer_size_t = ffi.UnsignedInt;
typedef Dartmach_msg_trailer_size_t = int;
typedef mach_msg_trailer_info_t = ffi.Pointer<ffi.Char>;

final class mach_msg_trailer_t extends ffi.Struct {
  @mach_msg_trailer_type_t()
  external int msgh_trailer_type;

  @mach_msg_trailer_size_t()
  external int msgh_trailer_size;
}

final class mach_msg_seqno_trailer_t extends ffi.Struct {
  @mach_msg_trailer_type_t()
  external int msgh_trailer_type;

  @mach_msg_trailer_size_t()
  external int msgh_trailer_size;

  @mach_port_seqno_t()
  external int msgh_seqno;
}

final class security_token_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> val;
}

final class mach_msg_security_trailer_t extends ffi.Struct {
  @mach_msg_trailer_type_t()
  external int msgh_trailer_type;

  @mach_msg_trailer_size_t()
  external int msgh_trailer_size;

  @mach_port_seqno_t()
  external int msgh_seqno;

  external security_token_t msgh_sender;
}

final class audit_token_t extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedInt> val;
}

final class mach_msg_audit_trailer_t extends ffi.Struct {
  @mach_msg_trailer_type_t()
  external int msgh_trailer_type;

  @mach_msg_trailer_size_t()
  external int msgh_trailer_size;

  @mach_port_seqno_t()
  external int msgh_seqno;

  external security_token_t msgh_sender;

  external audit_token_t msgh_audit;
}

@ffi.Packed(4)
final class mach_msg_context_trailer_t extends ffi.Struct {
  @mach_msg_trailer_type_t()
  external int msgh_trailer_type;

  @mach_msg_trailer_size_t()
  external int msgh_trailer_size;

  @mach_port_seqno_t()
  external int msgh_seqno;

  external security_token_t msgh_sender;

  external audit_token_t msgh_audit;

  @mach_port_context_t()
  external int msgh_context;
}

final class msg_labels_t extends ffi.Struct {
  @mach_port_name_t()
  external int sender;
}

typedef mach_msg_filter_id = ffi.Int;
typedef Dartmach_msg_filter_id = int;

@ffi.Packed(4)
final class mach_msg_mac_trailer_t extends ffi.Struct {
  @mach_msg_trailer_type_t()
  external int msgh_trailer_type;

  @mach_msg_trailer_size_t()
  external int msgh_trailer_size;

  @mach_port_seqno_t()
  external int msgh_seqno;

  external security_token_t msgh_sender;

  external audit_token_t msgh_audit;

  @mach_port_context_t()
  external int msgh_context;

  @mach_msg_filter_id()
  external int msgh_ad;

  external msg_labels_t msgh_labels;
}

typedef mach_msg_max_trailer_t = mach_msg_mac_trailer_t;
typedef mach_msg_format_0_trailer_t = mach_msg_security_trailer_t;
typedef mach_msg_options_t = integer_t;

final class mach_msg_empty_send_t extends ffi.Struct {
  external mach_msg_header_t header;
}

final class mach_msg_empty_rcv_t extends ffi.Struct {
  external mach_msg_header_t header;

  external mach_msg_trailer_t trailer;
}

final class mach_msg_empty_t extends ffi.Union {
  external mach_msg_empty_send_t send;

  external mach_msg_empty_rcv_t rcv;
}

typedef mach_msg_type_size_t = natural_t;
typedef mach_msg_type_number_t = natural_t;
typedef mach_msg_option_t = integer_t;
typedef mach_msg_return_t = kern_return_t;
typedef dispatch_source_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_source_t = objc.NSObject;

final class dispatch_source_type_s extends ffi.Opaque {}

typedef dispatch_source_type_t = ffi.Pointer<dispatch_source_type_s>;
typedef dispatch_source_mach_send_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_source_mach_send_flags_t = int;
typedef dispatch_source_mach_recv_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_source_mach_recv_flags_t = int;
typedef dispatch_source_memorypressure_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_source_memorypressure_flags_t = int;
typedef dispatch_source_proc_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_source_proc_flags_t = int;
typedef dispatch_source_vnode_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_source_vnode_flags_t = int;
typedef dispatch_source_timer_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_source_timer_flags_t = int;
typedef dispatch_group_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_group_t = objc.NSObject;
typedef dispatch_semaphore_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_semaphore_t = objc.NSObject;
typedef dispatch_once_t = ffi.IntPtr;
typedef Dartdispatch_once_t = int;
typedef dispatch_data_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_data_t = objc.NSObject;

final class dispatch_data_s extends ffi.Opaque {}

bool _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        dispatch_data_t arg0,
        int arg1,
        ffi.Pointer<ffi.Void> arg2,
        int arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(dispatch_data_t arg0, ffi.Size arg1,
                    ffi.Pointer<ffi.Void> arg2, ffi.Size arg3)>>()
        .asFunction<
            bool Function(dispatch_data_t, int, ffi.Pointer<ffi.Void>,
                int)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    dispatch_data_t,
                    ffi.Size,
                    ffi.Pointer<ffi.Void>,
                    ffi.Size)>(
            _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_fnPtrTrampoline,
            false)
        .cast();
bool _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        dispatch_data_t arg0,
        int arg1,
        ffi.Pointer<ffi.Void> arg2,
        int arg3) =>
    (objc.getBlockClosure(block) as bool Function(dispatch_data_t, int,
        ffi.Pointer<ffi.Void>, int))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    dispatch_data_t,
                    ffi.Size,
                    ffi.Pointer<ffi.Void>,
                    ffi.Size)>(
            _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>, ffi.Size)>`.
abstract final class ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(
              objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>, ffi.Size)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Bool Function(objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>,
                  ffi.Size)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Bool Function(objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>, ffi.Size)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(dispatch_data_t arg0, ffi.Size arg1, ffi.Pointer<ffi.Void> arg2, ffi.Size arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Bool Function(
                      objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>, ffi.Size)>(
              objc.newPointerBlock(
                  _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>, ffi.Size)> fromFunction(
          bool Function(Dartdispatch_data_t, int, ffi.Pointer<ffi.Void>, int)
              fn) =>
      objc.ObjCBlock<ffi.Bool Function(objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>, ffi.Size)>(
          objc.newClosureBlock(
              _ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_closureCallable,
              (dispatch_data_t arg0, int arg1, ffi.Pointer<ffi.Void> arg2,
                      int arg3) =>
                  fn(objc.NSObject.castFromPointer(arg0, retain: true, release: true), arg1, arg2, arg3)),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>, ffi.Size)>`.
extension ObjCBlock_bool_dispatchdatat_ffiSize_ffiVoid_ffiSize_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(
            objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>, ffi.Size)> {
  bool call(Dartdispatch_data_t arg0, int arg1, ffi.Pointer<ffi.Void> arg2,
          int arg3) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      dispatch_data_t arg0,
                      ffi.Size arg1,
                      ffi.Pointer<ffi.Void> arg2,
                      ffi.Size arg3)>>()
          .asFunction<
              bool Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  dispatch_data_t,
                  int,
                  ffi.Pointer<ffi.Void>,
                  int)>()(ref.pointer, arg0.ref.pointer, arg1, arg2, arg3);
}

typedef dispatch_data_applier_t = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartdispatch_data_applier_t = objc.ObjCBlock<
    ffi.Bool Function(
        objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>, ffi.Size)>;
typedef dispatch_fd_t = ffi.Int;
typedef Dartdispatch_fd_t = int;
void _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        dispatch_data_t arg0,
        int arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(dispatch_data_t arg0, ffi.Int arg1)>>()
        .asFunction<void Function(dispatch_data_t, int)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t, ffi.Int)>(
            _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        dispatch_data_t arg0,
        int arg1) =>
    (objc.getBlockClosure(block) as void Function(dispatch_data_t, int))(
        arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t, ffi.Int)>(
            _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, dispatch_data_t arg0, int arg1) {
  (objc.getBlockClosure(block) as void Function(dispatch_data_t, int))(
      arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t, ffi.Int)>
    _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t,
                ffi.Int)>.listener(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    dispatch_data_t arg0,
    int arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(dispatch_data_t, int))(
        arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
    ffi.Void Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<ffi.Void>,
        dispatch_data_t,
        ffi.Int)> _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_blockingCallable = ffi
    .NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, dispatch_data_t, ffi.Int)>.isolateLocal(
    _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_blockingTrampoline)
  ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, dispatch_data_t, ffi.Int)>
    _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, dispatch_data_t, ffi.Int)>.listener(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)>`.
abstract final class ObjCBlock_ffiVoid_dispatchdatat_ffiInt {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSObject, ffi.Int)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(dispatch_data_t arg0, ffi.Int arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)> fromFunction(
          void Function(Dartdispatch_data_t, int) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_closureCallable,
              (dispatch_data_t arg0, int arg1) => fn(
                  objc.NSObject.castFromPointer(arg0,
                      retain: true, release: true),
                  arg1)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)> listener(
      void Function(Dartdispatch_data_t, int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_listenerCallable.nativeFunction
            .cast(),
        (dispatch_data_t arg0, int arg1) => fn(
            objc.NSObject.castFromPointer(arg0, retain: false, release: true),
            arg1));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_18kzm6a(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)> blocking(
      void Function(Dartdispatch_data_t, int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_blockingCallable.nativeFunction
            .cast(),
        (dispatch_data_t arg0, int arg1) => fn(
            objc.NSObject.castFromPointer(arg0, retain: false, release: true),
            arg1));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt_blockingListenerCallable
            .nativeFunction
            .cast(),
        (dispatch_data_t arg0, int arg1) => fn(
            objc.NSObject.castFromPointer(arg0, retain: false, release: true),
            arg1));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_18kzm6a, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)>`.
extension ObjCBlock_ffiVoid_dispatchdatat_ffiInt_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSObject, ffi.Int)> {
  void call(Dartdispatch_data_t arg0, int arg1) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  dispatch_data_t arg0, ffi.Int arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t,
              int)>()(ref.pointer, arg0.ref.pointer, arg1);
}

void _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        dispatch_data_t arg0,
        int arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(dispatch_data_t arg0, ffi.Int arg1)>>()
        .asFunction<void Function(dispatch_data_t, int)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t, ffi.Int)>(
            _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        dispatch_data_t arg0,
        int arg1) =>
    (objc.getBlockClosure(block) as void Function(dispatch_data_t, int))(
        arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t, ffi.Int)>(
            _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, dispatch_data_t arg0, int arg1) {
  (objc.getBlockClosure(block) as void Function(dispatch_data_t, int))(
      arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t, ffi.Int)>
    _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t,
                ffi.Int)>.listener(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    dispatch_data_t arg0,
    int arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(dispatch_data_t, int))(
        arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, dispatch_data_t, ffi.Int)>
    _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, dispatch_data_t, ffi.Int)>.isolateLocal(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, dispatch_data_t, ffi.Int)>
    _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, dispatch_data_t, ffi.Int)>.listener(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)>`.
abstract final class ObjCBlock_ffiVoid_dispatchdatat_ffiInt1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSObject?, ffi.Int)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(dispatch_data_t arg0, ffi.Int arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)> fromFunction(
          void Function(Dartdispatch_data_t?, int) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_closureCallable,
              (dispatch_data_t arg0, int arg1) => fn(
                  arg0.address == 0
                      ? null
                      : objc.NSObject.castFromPointer(arg0,
                          retain: true, release: true),
                  arg1)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)> listener(
      void Function(Dartdispatch_data_t?, int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_listenerCallable.nativeFunction
            .cast(),
        (dispatch_data_t arg0, int arg1) => fn(
            arg0.address == 0
                ? null
                : objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
            arg1));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_18kzm6a(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)> blocking(
      void Function(Dartdispatch_data_t?, int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_blockingCallable.nativeFunction
            .cast(),
        (dispatch_data_t arg0, int arg1) => fn(
            arg0.address == 0
                ? null
                : objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
            arg1));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_blockingListenerCallable
            .nativeFunction
            .cast(),
        (dispatch_data_t arg0, int arg1) => fn(
            arg0.address == 0
                ? null
                : objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
            arg1));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_18kzm6a, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)>`.
extension ObjCBlock_ffiVoid_dispatchdatat_ffiInt1_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSObject?, ffi.Int)> {
  void call(Dartdispatch_data_t? arg0, int arg1) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  dispatch_data_t arg0, ffi.Int arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t,
              int)>()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1);
}

typedef dispatch_io_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_io_t = objc.NSObject;
typedef dispatch_io_type_t = ffi.UnsignedLong;
typedef Dartdispatch_io_type_t = int;
void _ObjCBlock_ffiVoid_ffiInt_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Int arg0)>>()
        .asFunction<void Function(int)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiInt_fnPtrCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Int)>(_ObjCBlock_ffiVoid_ffiInt_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiInt_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) =>
    (objc.getBlockClosure(block) as void Function(int))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiInt_closureCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Int)>(_ObjCBlock_ffiVoid_ffiInt_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiInt_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) {
  (objc.getBlockClosure(block) as void Function(int))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Int)>
    _ObjCBlock_ffiVoid_ffiInt_listenerCallable = ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Int)>.listener(_ObjCBlock_ffiVoid_ffiInt_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiInt_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Int)>
    _ObjCBlock_ffiVoid_ffiInt_blockingCallable = ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Int)>.isolateLocal(_ObjCBlock_ffiVoid_ffiInt_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Int)>
    _ObjCBlock_ffiVoid_ffiInt_blockingListenerCallable = ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Int)>.listener(_ObjCBlock_ffiVoid_ffiInt_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Int)>`.
abstract final class ObjCBlock_ffiVoid_ffiInt {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Int)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Int)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Int)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Int)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_ffiInt_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Int)> fromFunction(
          void Function(int) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Int)>(
          objc.newClosureBlock(_ObjCBlock_ffiVoid_ffiInt_closureCallable,
              (int arg0) => fn(arg0)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Int)> listener(
      void Function(int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiInt_listenerCallable.nativeFunction.cast(),
        (int arg0) => fn(arg0));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_9o8504(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Int)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Int)> blocking(
      void Function(int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiInt_blockingCallable.nativeFunction.cast(),
        (int arg0) => fn(arg0));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiInt_blockingListenerCallable.nativeFunction
            .cast(),
        (int arg0) => fn(arg0));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_9o8504, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Int)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Int)>`.
extension ObjCBlock_ffiVoid_ffiInt_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Int)> {
  void call(int arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Int arg0)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
      ref.pointer, arg0);
}

void _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        bool arg0,
        dispatch_data_t arg1,
        int arg2) =>
    block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Bool arg0, dispatch_data_t arg1, ffi.Int arg2)>>()
            .asFunction<void Function(bool, dispatch_data_t, int)>()(
        arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool,
                    dispatch_data_t, ffi.Int)>(
            _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        bool arg0,
        dispatch_data_t arg1,
        int arg2) =>
    (objc.getBlockClosure(block) as void Function(bool, dispatch_data_t, int))(
        arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool,
                    dispatch_data_t, ffi.Int)>(
            _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    bool arg0,
    dispatch_data_t arg1,
    int arg2) {
  (objc.getBlockClosure(block) as void Function(bool, dispatch_data_t, int))(
      arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool,
            dispatch_data_t, ffi.Int)>
    _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool,
                dispatch_data_t, ffi.Int)>.listener(
        _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    bool arg0,
    dispatch_data_t arg1,
    int arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(bool, dispatch_data_t, int))(
        arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Bool, dispatch_data_t, ffi.Int)>
    _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Bool,
                dispatch_data_t,
                ffi.Int)>.isolateLocal(
        _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Bool, dispatch_data_t, ffi.Int)>
    _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Bool,
                dispatch_data_t,
                ffi.Int)>.listener(
        _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>`.
abstract final class ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0, dispatch_data_t arg1, ffi.Int arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>
      fromFunction(void Function(bool, Dartdispatch_data_t?, int) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_closureCallable,
                  (bool arg0, dispatch_data_t arg1, int arg2) => fn(
                      arg0,
                      arg1.address == 0
                          ? null
                          : objc.NSObject.castFromPointer(arg1, retain: true, release: true),
                      arg2)),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>
      listener(void Function(bool, Dartdispatch_data_t?, int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_listenerCallable
            .nativeFunction
            .cast(),
        (bool arg0, dispatch_data_t arg1, int arg2) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.NSObject.castFromPointer(arg1,
                    retain: false, release: true),
            arg2));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_og5b6y(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>
      blocking(void Function(bool, Dartdispatch_data_t?, int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_blockingCallable
            .nativeFunction
            .cast(),
        (bool arg0, dispatch_data_t arg1, int arg2) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.NSObject.castFromPointer(arg1,
                    retain: false, release: true),
            arg2));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_blockingListenerCallable
            .nativeFunction
            .cast(),
        (bool arg0, dispatch_data_t arg1, int arg2) => fn(
            arg0,
            arg1.address == 0
                ? null
                : objc.NSObject.castFromPointer(arg1,
                    retain: false, release: true),
            arg2));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_og5b6y, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>`.
extension ObjCBlock_ffiVoid_bool_dispatchdatat_ffiInt_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)> {
  void call(bool arg0, Dartdispatch_data_t? arg1, int arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Bool arg0, dispatch_data_t arg1, ffi.Int arg2)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>, bool,
                      dispatch_data_t, int)>()(
          ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr, arg2);
}

typedef dispatch_io_handler_t = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartdispatch_io_handler_t
    = objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>;
typedef dispatch_io_close_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_io_close_flags_t = int;
typedef dispatch_io_interval_flags_t = ffi.UnsignedLong;
typedef Dartdispatch_io_interval_flags_t = int;
typedef dispatch_workloop_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_workloop_t = objc.NSObject;

final class CFStreamError extends ffi.Struct {
  @CFIndex()
  external int domain;

  @SInt32()
  external int error;
}

typedef CFStreamPropertyKey = CFStringRef;

enum CFStreamStatus {
  kCFStreamStatusNotOpen(0),
  kCFStreamStatusOpening(1),
  kCFStreamStatusOpen(2),
  kCFStreamStatusReading(3),
  kCFStreamStatusWriting(4),
  kCFStreamStatusAtEnd(5),
  kCFStreamStatusClosed(6),
  kCFStreamStatusError(7);

  final int value;
  const CFStreamStatus(this.value);

  static CFStreamStatus fromValue(int value) => switch (value) {
        0 => kCFStreamStatusNotOpen,
        1 => kCFStreamStatusOpening,
        2 => kCFStreamStatusOpen,
        3 => kCFStreamStatusReading,
        4 => kCFStreamStatusWriting,
        5 => kCFStreamStatusAtEnd,
        6 => kCFStreamStatusClosed,
        7 => kCFStreamStatusError,
        _ => throw ArgumentError("Unknown value for CFStreamStatus: $value"),
      };
}

enum CFStreamEventType {
  kCFStreamEventNone(0),
  kCFStreamEventOpenCompleted(1),
  kCFStreamEventHasBytesAvailable(2),
  kCFStreamEventCanAcceptBytes(4),
  kCFStreamEventErrorOccurred(8),
  kCFStreamEventEndEncountered(16);

  final int value;
  const CFStreamEventType(this.value);

  static CFStreamEventType fromValue(int value) => switch (value) {
        0 => kCFStreamEventNone,
        1 => kCFStreamEventOpenCompleted,
        2 => kCFStreamEventHasBytesAvailable,
        4 => kCFStreamEventCanAcceptBytes,
        8 => kCFStreamEventErrorOccurred,
        16 => kCFStreamEventEndEncountered,
        _ => throw ArgumentError("Unknown value for CFStreamEventType: $value"),
      };
}

final class CFStreamClientContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> info)>> retain;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> info)>>
      copyDescription;
}

final class __CFReadStream extends ffi.Opaque {}

typedef CFReadStreamRef = ffi.Pointer<__CFReadStream>;

final class __CFWriteStream extends ffi.Opaque {}

typedef CFWriteStreamRef = ffi.Pointer<__CFWriteStream>;
typedef CFReadStreamClientCallBackFunction = ffi.Void Function(
    CFReadStreamRef stream,
    CFOptionFlags type,
    ffi.Pointer<ffi.Void> clientCallBackInfo);
typedef DartCFReadStreamClientCallBackFunction = void Function(
    CFReadStreamRef stream,
    CFStreamEventType type,
    ffi.Pointer<ffi.Void> clientCallBackInfo);
typedef CFReadStreamClientCallBack
    = ffi.Pointer<ffi.NativeFunction<CFReadStreamClientCallBackFunction>>;
typedef CFWriteStreamClientCallBackFunction = ffi.Void Function(
    CFWriteStreamRef stream,
    CFOptionFlags type,
    ffi.Pointer<ffi.Void> clientCallBackInfo);
typedef DartCFWriteStreamClientCallBackFunction = void Function(
    CFWriteStreamRef stream,
    CFStreamEventType type,
    ffi.Pointer<ffi.Void> clientCallBackInfo);
typedef CFWriteStreamClientCallBack
    = ffi.Pointer<ffi.NativeFunction<CFWriteStreamClientCallBackFunction>>;

enum CFPropertyListFormat {
  kCFPropertyListOpenStepFormat(1),
  kCFPropertyListXMLFormat_v1_0(100),
  kCFPropertyListBinaryFormat_v1_0(200);

  final int value;
  const CFPropertyListFormat(this.value);

  static CFPropertyListFormat fromValue(int value) => switch (value) {
        1 => kCFPropertyListOpenStepFormat,
        100 => kCFPropertyListXMLFormat_v1_0,
        200 => kCFPropertyListBinaryFormat_v1_0,
        _ =>
          throw ArgumentError("Unknown value for CFPropertyListFormat: $value"),
      };
}

typedef CFSetRetainCallBackFunction = ffi.Pointer<ffi.Void> Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef CFSetRetainCallBack
    = ffi.Pointer<ffi.NativeFunction<CFSetRetainCallBackFunction>>;
typedef CFSetReleaseCallBackFunction = ffi.Void Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef DartCFSetReleaseCallBackFunction = void Function(
    CFAllocatorRef allocator, ffi.Pointer<ffi.Void> value);
typedef CFSetReleaseCallBack
    = ffi.Pointer<ffi.NativeFunction<CFSetReleaseCallBackFunction>>;
typedef CFSetCopyDescriptionCallBackFunction = CFStringRef Function(
    ffi.Pointer<ffi.Void> value);
typedef CFSetCopyDescriptionCallBack
    = ffi.Pointer<ffi.NativeFunction<CFSetCopyDescriptionCallBackFunction>>;
typedef CFSetEqualCallBackFunction = Boolean Function(
    ffi.Pointer<ffi.Void> value1, ffi.Pointer<ffi.Void> value2);
typedef DartCFSetEqualCallBackFunction = DartBoolean Function(
    ffi.Pointer<ffi.Void> value1, ffi.Pointer<ffi.Void> value2);
typedef CFSetEqualCallBack
    = ffi.Pointer<ffi.NativeFunction<CFSetEqualCallBackFunction>>;
typedef CFSetHashCallBackFunction = CFHashCode Function(
    ffi.Pointer<ffi.Void> value);
typedef DartCFSetHashCallBackFunction = DartCFHashCode Function(
    ffi.Pointer<ffi.Void> value);
typedef CFSetHashCallBack
    = ffi.Pointer<ffi.NativeFunction<CFSetHashCallBackFunction>>;

final class CFSetCallBacks extends ffi.Struct {
  @CFIndex()
  external int version;

  external CFSetRetainCallBack retain;

  external CFSetReleaseCallBack release;

  external CFSetCopyDescriptionCallBack copyDescription;

  external CFSetEqualCallBack equal;

  external CFSetHashCallBack hash;
}

typedef CFSetApplierFunctionFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context);
typedef DartCFSetApplierFunctionFunction = void Function(
    ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context);
typedef CFSetApplierFunction
    = ffi.Pointer<ffi.NativeFunction<CFSetApplierFunctionFunction>>;

final class __CFSet extends ffi.Opaque {}

typedef CFSetRef = ffi.Pointer<__CFSet>;
typedef CFMutableSetRef = ffi.Pointer<__CFSet>;
typedef CFTreeRetainCallBackFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void> info);
typedef CFTreeRetainCallBack
    = ffi.Pointer<ffi.NativeFunction<CFTreeRetainCallBackFunction>>;
typedef CFTreeReleaseCallBackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> info);
typedef DartCFTreeReleaseCallBackFunction = void Function(
    ffi.Pointer<ffi.Void> info);
typedef CFTreeReleaseCallBack
    = ffi.Pointer<ffi.NativeFunction<CFTreeReleaseCallBackFunction>>;
typedef CFTreeCopyDescriptionCallBackFunction = CFStringRef Function(
    ffi.Pointer<ffi.Void> info);
typedef CFTreeCopyDescriptionCallBack
    = ffi.Pointer<ffi.NativeFunction<CFTreeCopyDescriptionCallBackFunction>>;

final class CFTreeContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external CFTreeRetainCallBack retain;

  external CFTreeReleaseCallBack release;

  external CFTreeCopyDescriptionCallBack copyDescription;
}

typedef CFTreeApplierFunctionFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context);
typedef DartCFTreeApplierFunctionFunction = void Function(
    ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Void> context);
typedef CFTreeApplierFunction
    = ffi.Pointer<ffi.NativeFunction<CFTreeApplierFunctionFunction>>;

final class __CFTree extends ffi.Opaque {}

typedef CFTreeRef = ffi.Pointer<__CFTree>;

final class __CFUUID extends ffi.Opaque {}

typedef CFUUIDRef = ffi.Pointer<__CFUUID>;

final class CFUUIDBytes extends ffi.Struct {
  @UInt8()
  external int byte0;

  @UInt8()
  external int byte1;

  @UInt8()
  external int byte2;

  @UInt8()
  external int byte3;

  @UInt8()
  external int byte4;

  @UInt8()
  external int byte5;

  @UInt8()
  external int byte6;

  @UInt8()
  external int byte7;

  @UInt8()
  external int byte8;

  @UInt8()
  external int byte9;

  @UInt8()
  external int byte10;

  @UInt8()
  external int byte11;

  @UInt8()
  external int byte12;

  @UInt8()
  external int byte13;

  @UInt8()
  external int byte14;

  @UInt8()
  external int byte15;
}

typedef cpu_type_t = integer_t;
typedef cpu_subtype_t = integer_t;
typedef cpu_threadtype_t = integer_t;

final class __CFBundle extends ffi.Opaque {}

typedef CFBundleRef = ffi.Pointer<__CFBundle>;
typedef CFPlugInRef = ffi.Pointer<__CFBundle>;
typedef CFBundleRefNum = ffi.Int;
typedef DartCFBundleRefNum = int;

final class __CFMessagePort extends ffi.Opaque {}

typedef CFMessagePortRef = ffi.Pointer<__CFMessagePort>;

final class CFMessagePortContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> info)>> retain;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> info)>>
      copyDescription;
}

typedef CFMessagePortCallBackFunction = CFDataRef Function(
    CFMessagePortRef local,
    SInt32 msgid,
    CFDataRef data,
    ffi.Pointer<ffi.Void> info);
typedef DartCFMessagePortCallBackFunction = CFDataRef Function(
    CFMessagePortRef local,
    DartSInt32 msgid,
    CFDataRef data,
    ffi.Pointer<ffi.Void> info);
typedef CFMessagePortCallBack
    = ffi.Pointer<ffi.NativeFunction<CFMessagePortCallBackFunction>>;
typedef CFMessagePortInvalidationCallBackFunction = ffi.Void Function(
    CFMessagePortRef ms, ffi.Pointer<ffi.Void> info);
typedef DartCFMessagePortInvalidationCallBackFunction = void Function(
    CFMessagePortRef ms, ffi.Pointer<ffi.Void> info);
typedef CFMessagePortInvalidationCallBack = ffi
    .Pointer<ffi.NativeFunction<CFMessagePortInvalidationCallBackFunction>>;
typedef CFPlugInDynamicRegisterFunctionFunction = ffi.Void Function(
    CFPlugInRef plugIn);
typedef DartCFPlugInDynamicRegisterFunctionFunction = void Function(
    CFPlugInRef plugIn);
typedef CFPlugInDynamicRegisterFunction
    = ffi.Pointer<ffi.NativeFunction<CFPlugInDynamicRegisterFunctionFunction>>;
typedef CFPlugInUnloadFunctionFunction = ffi.Void Function(CFPlugInRef plugIn);
typedef DartCFPlugInUnloadFunctionFunction = void Function(CFPlugInRef plugIn);
typedef CFPlugInUnloadFunction
    = ffi.Pointer<ffi.NativeFunction<CFPlugInUnloadFunctionFunction>>;
typedef CFPlugInFactoryFunctionFunction = ffi.Pointer<ffi.Void> Function(
    CFAllocatorRef allocator, CFUUIDRef typeUUID);
typedef CFPlugInFactoryFunction
    = ffi.Pointer<ffi.NativeFunction<CFPlugInFactoryFunctionFunction>>;

final class __CFPlugInInstance extends ffi.Opaque {}

typedef CFPlugInInstanceRef = ffi.Pointer<__CFPlugInInstance>;
typedef CFPlugInInstanceGetInterfaceFunctionFunction = Boolean Function(
    CFPlugInInstanceRef instance,
    CFStringRef interfaceName,
    ffi.Pointer<ffi.Pointer<ffi.Void>> ftbl);
typedef DartCFPlugInInstanceGetInterfaceFunctionFunction = DartBoolean Function(
    CFPlugInInstanceRef instance,
    CFStringRef interfaceName,
    ffi.Pointer<ffi.Pointer<ffi.Void>> ftbl);
typedef CFPlugInInstanceGetInterfaceFunction = ffi
    .Pointer<ffi.NativeFunction<CFPlugInInstanceGetInterfaceFunctionFunction>>;
typedef CFPlugInInstanceDeallocateInstanceDataFunctionFunction = ffi.Void
    Function(ffi.Pointer<ffi.Void> instanceData);
typedef DartCFPlugInInstanceDeallocateInstanceDataFunctionFunction = void
    Function(ffi.Pointer<ffi.Void> instanceData);
typedef CFPlugInInstanceDeallocateInstanceDataFunction = ffi.Pointer<
    ffi.NativeFunction<CFPlugInInstanceDeallocateInstanceDataFunctionFunction>>;

final class __CFMachPort extends ffi.Opaque {}

typedef CFMachPortRef = ffi.Pointer<__CFMachPort>;

final class CFMachPortContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> info)>> retain;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> info)>>
      copyDescription;
}

typedef CFMachPortCallBackFunction = ffi.Void Function(CFMachPortRef port,
    ffi.Pointer<ffi.Void> msg, CFIndex size, ffi.Pointer<ffi.Void> info);
typedef DartCFMachPortCallBackFunction = void Function(CFMachPortRef port,
    ffi.Pointer<ffi.Void> msg, DartCFIndex size, ffi.Pointer<ffi.Void> info);
typedef CFMachPortCallBack
    = ffi.Pointer<ffi.NativeFunction<CFMachPortCallBackFunction>>;
typedef CFMachPortInvalidationCallBackFunction = ffi.Void Function(
    CFMachPortRef port, ffi.Pointer<ffi.Void> info);
typedef DartCFMachPortInvalidationCallBackFunction = void Function(
    CFMachPortRef port, ffi.Pointer<ffi.Void> info);
typedef CFMachPortInvalidationCallBack
    = ffi.Pointer<ffi.NativeFunction<CFMachPortInvalidationCallBackFunction>>;

final class __CFAttributedString extends ffi.Opaque {}

typedef CFAttributedStringRef = ffi.Pointer<__CFAttributedString>;
typedef CFMutableAttributedStringRef = ffi.Pointer<__CFAttributedString>;

final class __CFURLEnumerator extends ffi.Opaque {}

typedef CFURLEnumeratorRef = ffi.Pointer<__CFURLEnumerator>;

enum CFURLEnumeratorOptions {
  kCFURLEnumeratorDefaultBehavior(0),
  kCFURLEnumeratorDescendRecursively(1),
  kCFURLEnumeratorSkipInvisibles(2),
  kCFURLEnumeratorGenerateFileReferenceURLs(4),
  kCFURLEnumeratorSkipPackageContents(8),
  kCFURLEnumeratorIncludeDirectoriesPreOrder(16),
  kCFURLEnumeratorIncludeDirectoriesPostOrder(32),
  kCFURLEnumeratorGenerateRelativePathURLs(64);

  final int value;
  const CFURLEnumeratorOptions(this.value);

  static CFURLEnumeratorOptions fromValue(int value) => switch (value) {
        0 => kCFURLEnumeratorDefaultBehavior,
        1 => kCFURLEnumeratorDescendRecursively,
        2 => kCFURLEnumeratorSkipInvisibles,
        4 => kCFURLEnumeratorGenerateFileReferenceURLs,
        8 => kCFURLEnumeratorSkipPackageContents,
        16 => kCFURLEnumeratorIncludeDirectoriesPreOrder,
        32 => kCFURLEnumeratorIncludeDirectoriesPostOrder,
        64 => kCFURLEnumeratorGenerateRelativePathURLs,
        _ => throw ArgumentError(
            "Unknown value for CFURLEnumeratorOptions: $value"),
      };
}

enum CFURLEnumeratorResult {
  kCFURLEnumeratorSuccess(1),
  kCFURLEnumeratorEnd(2),
  kCFURLEnumeratorError(3),
  kCFURLEnumeratorDirectoryPostOrderSuccess(4);

  final int value;
  const CFURLEnumeratorResult(this.value);

  static CFURLEnumeratorResult fromValue(int value) => switch (value) {
        1 => kCFURLEnumeratorSuccess,
        2 => kCFURLEnumeratorEnd,
        3 => kCFURLEnumeratorError,
        4 => kCFURLEnumeratorDirectoryPostOrderSuccess,
        _ => throw ArgumentError(
            "Unknown value for CFURLEnumeratorResult: $value"),
      };
}

final class guid_t extends ffi.Union {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedChar> g_guid;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedInt> g_guid_asint;
}

@ffi.Packed(1)
final class ntsid_t extends ffi.Struct {
  @u_int8_t()
  external int sid_kind;

  @u_int8_t()
  external int sid_authcount;

  @ffi.Array.multi([6])
  external ffi.Array<u_int8_t> sid_authority;

  @ffi.Array.multi([16])
  external ffi.Array<u_int32_t> sid_authorities;
}

final class kauth_identity_extlookup extends ffi.Struct {
  @u_int32_t()
  external int el_seqno;

  @u_int32_t()
  external int el_result;

  @u_int32_t()
  external int el_flags;

  @__darwin_pid_t()
  external int el_info_pid;

  @u_int64_t()
  external int el_extend;

  @u_int32_t()
  external int el_info_reserved_1;

  @uid_t()
  external int el_uid;

  external guid_t el_uguid;

  @u_int32_t()
  external int el_uguid_valid;

  external ntsid_t el_usid;

  @u_int32_t()
  external int el_usid_valid;

  @gid_t()
  external int el_gid;

  external guid_t el_gguid;

  @u_int32_t()
  external int el_gguid_valid;

  external ntsid_t el_gsid;

  @u_int32_t()
  external int el_gsid_valid;

  @u_int32_t()
  external int el_member_valid;

  @u_int32_t()
  external int el_sup_grp_cnt;

  @ffi.Array.multi([16])
  external ffi.Array<gid_t> el_sup_groups;
}

final class kauth_cache_sizes extends ffi.Struct {
  @u_int32_t()
  external int kcs_group_size;

  @u_int32_t()
  external int kcs_id_size;
}

typedef kauth_ace_rights_t = u_int32_t;

final class kauth_ace extends ffi.Struct {
  external guid_t ace_applicable;

  @u_int32_t()
  external int ace_flags;

  @kauth_ace_rights_t()
  external int ace_rights;
}

typedef kauth_ace_t = ffi.Pointer<kauth_ace>;

final class kauth_acl extends ffi.Struct {
  @u_int32_t()
  external int acl_entrycount;

  @u_int32_t()
  external int acl_flags;

  @ffi.Array.multi([1])
  external ffi.Array<kauth_ace> acl_ace;
}

typedef kauth_acl_t = ffi.Pointer<kauth_acl>;

final class kauth_filesec extends ffi.Struct {
  @u_int32_t()
  external int fsec_magic;

  external guid_t fsec_owner;

  external guid_t fsec_group;

  external kauth_acl fsec_acl;
}

typedef kauth_filesec_t = ffi.Pointer<kauth_filesec>;

enum acl_perm_t {
  ACL_READ_DATA(2),
  ACL_WRITE_DATA(4),
  ACL_EXECUTE(8),
  ACL_DELETE(16),
  ACL_APPEND_DATA(32),
  ACL_DELETE_CHILD(64),
  ACL_READ_ATTRIBUTES(128),
  ACL_WRITE_ATTRIBUTES(256),
  ACL_READ_EXTATTRIBUTES(512),
  ACL_WRITE_EXTATTRIBUTES(1024),
  ACL_READ_SECURITY(2048),
  ACL_WRITE_SECURITY(4096),
  ACL_CHANGE_OWNER(8192),
  ACL_SYNCHRONIZE(1048576);

  static const ACL_LIST_DIRECTORY = ACL_READ_DATA;
  static const ACL_ADD_FILE = ACL_WRITE_DATA;
  static const ACL_SEARCH = ACL_EXECUTE;
  static const ACL_ADD_SUBDIRECTORY = ACL_APPEND_DATA;

  final int value;
  const acl_perm_t(this.value);

  static acl_perm_t fromValue(int value) => switch (value) {
        2 => ACL_READ_DATA,
        4 => ACL_WRITE_DATA,
        8 => ACL_EXECUTE,
        16 => ACL_DELETE,
        32 => ACL_APPEND_DATA,
        64 => ACL_DELETE_CHILD,
        128 => ACL_READ_ATTRIBUTES,
        256 => ACL_WRITE_ATTRIBUTES,
        512 => ACL_READ_EXTATTRIBUTES,
        1024 => ACL_WRITE_EXTATTRIBUTES,
        2048 => ACL_READ_SECURITY,
        4096 => ACL_WRITE_SECURITY,
        8192 => ACL_CHANGE_OWNER,
        1048576 => ACL_SYNCHRONIZE,
        _ => throw ArgumentError("Unknown value for acl_perm_t: $value"),
      };

  @override
  String toString() {
    if (this == ACL_READ_DATA)
      return "acl_perm_t.ACL_READ_DATA, acl_perm_t.ACL_LIST_DIRECTORY";
    if (this == ACL_WRITE_DATA)
      return "acl_perm_t.ACL_WRITE_DATA, acl_perm_t.ACL_ADD_FILE";
    if (this == ACL_EXECUTE)
      return "acl_perm_t.ACL_EXECUTE, acl_perm_t.ACL_SEARCH";
    if (this == ACL_APPEND_DATA)
      return "acl_perm_t.ACL_APPEND_DATA, acl_perm_t.ACL_ADD_SUBDIRECTORY";
    return super.toString();
  }
}

enum acl_tag_t {
  ACL_UNDEFINED_TAG(0),
  ACL_EXTENDED_ALLOW(1),
  ACL_EXTENDED_DENY(2);

  final int value;
  const acl_tag_t(this.value);

  static acl_tag_t fromValue(int value) => switch (value) {
        0 => ACL_UNDEFINED_TAG,
        1 => ACL_EXTENDED_ALLOW,
        2 => ACL_EXTENDED_DENY,
        _ => throw ArgumentError("Unknown value for acl_tag_t: $value"),
      };
}

enum acl_type_t {
  ACL_TYPE_EXTENDED(256),
  ACL_TYPE_ACCESS(0),
  ACL_TYPE_DEFAULT(1),
  ACL_TYPE_AFS(2),
  ACL_TYPE_CODA(3),
  ACL_TYPE_NTFS(4),
  ACL_TYPE_NWFS(5);

  final int value;
  const acl_type_t(this.value);

  static acl_type_t fromValue(int value) => switch (value) {
        256 => ACL_TYPE_EXTENDED,
        0 => ACL_TYPE_ACCESS,
        1 => ACL_TYPE_DEFAULT,
        2 => ACL_TYPE_AFS,
        3 => ACL_TYPE_CODA,
        4 => ACL_TYPE_NTFS,
        5 => ACL_TYPE_NWFS,
        _ => throw ArgumentError("Unknown value for acl_type_t: $value"),
      };
}

enum acl_flag_t {
  ACL_FLAG_DEFER_INHERIT(1),
  ACL_FLAG_NO_INHERIT(131072),
  ACL_ENTRY_INHERITED(16),
  ACL_ENTRY_FILE_INHERIT(32),
  ACL_ENTRY_DIRECTORY_INHERIT(64),
  ACL_ENTRY_LIMIT_INHERIT(128),
  ACL_ENTRY_ONLY_INHERIT(256);

  final int value;
  const acl_flag_t(this.value);

  static acl_flag_t fromValue(int value) => switch (value) {
        1 => ACL_FLAG_DEFER_INHERIT,
        131072 => ACL_FLAG_NO_INHERIT,
        16 => ACL_ENTRY_INHERITED,
        32 => ACL_ENTRY_FILE_INHERIT,
        64 => ACL_ENTRY_DIRECTORY_INHERIT,
        128 => ACL_ENTRY_LIMIT_INHERIT,
        256 => ACL_ENTRY_ONLY_INHERIT,
        _ => throw ArgumentError("Unknown value for acl_flag_t: $value"),
      };
}

final class _acl extends ffi.Opaque {}

final class _acl_entry extends ffi.Opaque {}

final class _acl_permset extends ffi.Opaque {}

final class _acl_flagset extends ffi.Opaque {}

typedef acl_t = ffi.Pointer<_acl>;
typedef acl_entry_t = ffi.Pointer<_acl_entry>;
typedef acl_permset_t = ffi.Pointer<_acl_permset>;
typedef acl_flagset_t = ffi.Pointer<_acl_flagset>;
typedef acl_permset_mask_t = u_int64_t;

final class __CFFileSecurity extends ffi.Opaque {}

typedef CFFileSecurityRef = ffi.Pointer<__CFFileSecurity>;

enum CFFileSecurityClearOptions {
  kCFFileSecurityClearOwner(1),
  kCFFileSecurityClearGroup(2),
  kCFFileSecurityClearMode(4),
  kCFFileSecurityClearOwnerUUID(8),
  kCFFileSecurityClearGroupUUID(16),
  kCFFileSecurityClearAccessControlList(32);

  final int value;
  const CFFileSecurityClearOptions(this.value);

  static CFFileSecurityClearOptions fromValue(int value) => switch (value) {
        1 => kCFFileSecurityClearOwner,
        2 => kCFFileSecurityClearGroup,
        4 => kCFFileSecurityClearMode,
        8 => kCFFileSecurityClearOwnerUUID,
        16 => kCFFileSecurityClearGroupUUID,
        32 => kCFFileSecurityClearAccessControlList,
        _ => throw ArgumentError(
            "Unknown value for CFFileSecurityClearOptions: $value"),
      };
}

final class __CFStringTokenizer extends ffi.Opaque {}

typedef CFStringTokenizerRef = ffi.Pointer<__CFStringTokenizer>;

enum CFStringTokenizerTokenType {
  kCFStringTokenizerTokenNone(0),
  kCFStringTokenizerTokenNormal(1),
  kCFStringTokenizerTokenHasSubTokensMask(2),
  kCFStringTokenizerTokenHasDerivedSubTokensMask(4),
  kCFStringTokenizerTokenHasHasNumbersMask(8),
  kCFStringTokenizerTokenHasNonLettersMask(16),
  kCFStringTokenizerTokenIsCJWordMask(32);

  final int value;
  const CFStringTokenizerTokenType(this.value);

  static CFStringTokenizerTokenType fromValue(int value) => switch (value) {
        0 => kCFStringTokenizerTokenNone,
        1 => kCFStringTokenizerTokenNormal,
        2 => kCFStringTokenizerTokenHasSubTokensMask,
        4 => kCFStringTokenizerTokenHasDerivedSubTokensMask,
        8 => kCFStringTokenizerTokenHasHasNumbersMask,
        16 => kCFStringTokenizerTokenHasNonLettersMask,
        32 => kCFStringTokenizerTokenIsCJWordMask,
        _ => throw ArgumentError(
            "Unknown value for CFStringTokenizerTokenType: $value"),
      };
}

typedef CFFileDescriptorNativeDescriptor = ffi.Int;
typedef DartCFFileDescriptorNativeDescriptor = int;

final class __CFFileDescriptor extends ffi.Opaque {}

typedef CFFileDescriptorRef = ffi.Pointer<__CFFileDescriptor>;
typedef CFFileDescriptorCallBackFunction = ffi.Void Function(
    CFFileDescriptorRef f,
    CFOptionFlags callBackTypes,
    ffi.Pointer<ffi.Void> info);
typedef DartCFFileDescriptorCallBackFunction = void Function(
    CFFileDescriptorRef f,
    DartCFOptionFlags callBackTypes,
    ffi.Pointer<ffi.Void> info);
typedef CFFileDescriptorCallBack
    = ffi.Pointer<ffi.NativeFunction<CFFileDescriptorCallBackFunction>>;

final class CFFileDescriptorContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> info)>> retain;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> info)>>
      release;

  external ffi.Pointer<
          ffi.NativeFunction<CFStringRef Function(ffi.Pointer<ffi.Void> info)>>
      copyDescription;
}

final class __CFUserNotification extends ffi.Opaque {}

typedef CFUserNotificationRef = ffi.Pointer<__CFUserNotification>;
typedef CFUserNotificationCallBackFunction = ffi.Void Function(
    CFUserNotificationRef userNotification, CFOptionFlags responseFlags);
typedef DartCFUserNotificationCallBackFunction = void Function(
    CFUserNotificationRef userNotification, DartCFOptionFlags responseFlags);
typedef CFUserNotificationCallBack
    = ffi.Pointer<ffi.NativeFunction<CFUserNotificationCallBackFunction>>;

final class __CFXMLNode extends ffi.Opaque {}

typedef CFXMLNodeRef = ffi.Pointer<__CFXMLNode>;
typedef CFXMLTreeRef = CFTreeRef;

enum CFXMLNodeTypeCode {
  kCFXMLNodeTypeDocument(1),
  kCFXMLNodeTypeElement(2),
  kCFXMLNodeTypeAttribute(3),
  kCFXMLNodeTypeProcessingInstruction(4),
  kCFXMLNodeTypeComment(5),
  kCFXMLNodeTypeText(6),
  kCFXMLNodeTypeCDATASection(7),
  kCFXMLNodeTypeDocumentFragment(8),
  kCFXMLNodeTypeEntity(9),
  kCFXMLNodeTypeEntityReference(10),
  kCFXMLNodeTypeDocumentType(11),
  kCFXMLNodeTypeWhitespace(12),
  kCFXMLNodeTypeNotation(13),
  kCFXMLNodeTypeElementTypeDeclaration(14),
  kCFXMLNodeTypeAttributeListDeclaration(15);

  final int value;
  const CFXMLNodeTypeCode(this.value);

  static CFXMLNodeTypeCode fromValue(int value) => switch (value) {
        1 => kCFXMLNodeTypeDocument,
        2 => kCFXMLNodeTypeElement,
        3 => kCFXMLNodeTypeAttribute,
        4 => kCFXMLNodeTypeProcessingInstruction,
        5 => kCFXMLNodeTypeComment,
        6 => kCFXMLNodeTypeText,
        7 => kCFXMLNodeTypeCDATASection,
        8 => kCFXMLNodeTypeDocumentFragment,
        9 => kCFXMLNodeTypeEntity,
        10 => kCFXMLNodeTypeEntityReference,
        11 => kCFXMLNodeTypeDocumentType,
        12 => kCFXMLNodeTypeWhitespace,
        13 => kCFXMLNodeTypeNotation,
        14 => kCFXMLNodeTypeElementTypeDeclaration,
        15 => kCFXMLNodeTypeAttributeListDeclaration,
        _ => throw ArgumentError("Unknown value for CFXMLNodeTypeCode: $value"),
      };
}

final class CFXMLElementInfo extends ffi.Struct {
  external CFDictionaryRef attributes;

  external CFArrayRef attributeOrder;

  @Boolean()
  external int isEmpty;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Char> _reserved;
}

final class CFXMLProcessingInstructionInfo extends ffi.Struct {
  external CFStringRef dataString;
}

final class CFXMLDocumentInfo extends ffi.Struct {
  external CFURLRef sourceURL;

  @CFStringEncoding()
  external int encoding;
}

final class CFXMLExternalID extends ffi.Struct {
  external CFURLRef systemID;

  external CFStringRef publicID;
}

final class CFXMLDocumentTypeInfo extends ffi.Struct {
  external CFXMLExternalID externalID;
}

final class CFXMLNotationInfo extends ffi.Struct {
  external CFXMLExternalID externalID;
}

final class CFXMLElementTypeDeclarationInfo extends ffi.Struct {
  external CFStringRef contentDescription;
}

final class CFXMLAttributeDeclarationInfo extends ffi.Struct {
  external CFStringRef attributeName;

  external CFStringRef typeString;

  external CFStringRef defaultString;
}

final class CFXMLAttributeListDeclarationInfo extends ffi.Struct {
  @CFIndex()
  external int numberOfAttributes;

  external ffi.Pointer<CFXMLAttributeDeclarationInfo> attributes;
}

enum CFXMLEntityTypeCode {
  kCFXMLEntityTypeParameter(0),
  kCFXMLEntityTypeParsedInternal(1),
  kCFXMLEntityTypeParsedExternal(2),
  kCFXMLEntityTypeUnparsed(3),
  kCFXMLEntityTypeCharacter(4);

  final int value;
  const CFXMLEntityTypeCode(this.value);

  static CFXMLEntityTypeCode fromValue(int value) => switch (value) {
        0 => kCFXMLEntityTypeParameter,
        1 => kCFXMLEntityTypeParsedInternal,
        2 => kCFXMLEntityTypeParsedExternal,
        3 => kCFXMLEntityTypeUnparsed,
        4 => kCFXMLEntityTypeCharacter,
        _ =>
          throw ArgumentError("Unknown value for CFXMLEntityTypeCode: $value"),
      };
}

final class CFXMLEntityInfo extends ffi.Struct {
  @CFIndex()
  external int entityTypeAsInt;

  CFXMLEntityTypeCode get entityType =>
      CFXMLEntityTypeCode.fromValue(entityTypeAsInt);

  external CFStringRef replacementText;

  external CFXMLExternalID entityID;

  external CFStringRef notationName;
}

final class CFXMLEntityReferenceInfo extends ffi.Struct {
  @CFIndex()
  external int entityTypeAsInt;

  CFXMLEntityTypeCode get entityType =>
      CFXMLEntityTypeCode.fromValue(entityTypeAsInt);
}

final class __CFXMLParser extends ffi.Opaque {}

typedef CFXMLParserRef = ffi.Pointer<__CFXMLParser>;

enum CFXMLParserStatusCode {
  kCFXMLStatusParseNotBegun(-2),
  kCFXMLStatusParseInProgress(-1),
  kCFXMLStatusParseSuccessful(0),
  kCFXMLErrorUnexpectedEOF(1),
  kCFXMLErrorUnknownEncoding(2),
  kCFXMLErrorEncodingConversionFailure(3),
  kCFXMLErrorMalformedProcessingInstruction(4),
  kCFXMLErrorMalformedDTD(5),
  kCFXMLErrorMalformedName(6),
  kCFXMLErrorMalformedCDSect(7),
  kCFXMLErrorMalformedCloseTag(8),
  kCFXMLErrorMalformedStartTag(9),
  kCFXMLErrorMalformedDocument(10),
  kCFXMLErrorElementlessDocument(11),
  kCFXMLErrorMalformedComment(12),
  kCFXMLErrorMalformedCharacterReference(13),
  kCFXMLErrorMalformedParsedCharacterData(14),
  kCFXMLErrorNoData(15);

  final int value;
  const CFXMLParserStatusCode(this.value);

  static CFXMLParserStatusCode fromValue(int value) => switch (value) {
        -2 => kCFXMLStatusParseNotBegun,
        -1 => kCFXMLStatusParseInProgress,
        0 => kCFXMLStatusParseSuccessful,
        1 => kCFXMLErrorUnexpectedEOF,
        2 => kCFXMLErrorUnknownEncoding,
        3 => kCFXMLErrorEncodingConversionFailure,
        4 => kCFXMLErrorMalformedProcessingInstruction,
        5 => kCFXMLErrorMalformedDTD,
        6 => kCFXMLErrorMalformedName,
        7 => kCFXMLErrorMalformedCDSect,
        8 => kCFXMLErrorMalformedCloseTag,
        9 => kCFXMLErrorMalformedStartTag,
        10 => kCFXMLErrorMalformedDocument,
        11 => kCFXMLErrorElementlessDocument,
        12 => kCFXMLErrorMalformedComment,
        13 => kCFXMLErrorMalformedCharacterReference,
        14 => kCFXMLErrorMalformedParsedCharacterData,
        15 => kCFXMLErrorNoData,
        _ => throw ArgumentError(
            "Unknown value for CFXMLParserStatusCode: $value"),
      };
}

typedef CFXMLParserCreateXMLStructureCallBackFunction
    = ffi.Pointer<ffi.Void> Function(CFXMLParserRef parser,
        CFXMLNodeRef nodeDesc, ffi.Pointer<ffi.Void> info);
typedef CFXMLParserCreateXMLStructureCallBack = ffi
    .Pointer<ffi.NativeFunction<CFXMLParserCreateXMLStructureCallBackFunction>>;
typedef CFXMLParserAddChildCallBackFunction = ffi.Void Function(
    CFXMLParserRef parser,
    ffi.Pointer<ffi.Void> parent,
    ffi.Pointer<ffi.Void> child,
    ffi.Pointer<ffi.Void> info);
typedef DartCFXMLParserAddChildCallBackFunction = void Function(
    CFXMLParserRef parser,
    ffi.Pointer<ffi.Void> parent,
    ffi.Pointer<ffi.Void> child,
    ffi.Pointer<ffi.Void> info);
typedef CFXMLParserAddChildCallBack
    = ffi.Pointer<ffi.NativeFunction<CFXMLParserAddChildCallBackFunction>>;
typedef CFXMLParserEndXMLStructureCallBackFunction = ffi.Void Function(
    CFXMLParserRef parser,
    ffi.Pointer<ffi.Void> xmlType,
    ffi.Pointer<ffi.Void> info);
typedef DartCFXMLParserEndXMLStructureCallBackFunction = void Function(
    CFXMLParserRef parser,
    ffi.Pointer<ffi.Void> xmlType,
    ffi.Pointer<ffi.Void> info);
typedef CFXMLParserEndXMLStructureCallBack = ffi
    .Pointer<ffi.NativeFunction<CFXMLParserEndXMLStructureCallBackFunction>>;
typedef CFXMLParserResolveExternalEntityCallBackFunction = CFDataRef Function(
    CFXMLParserRef parser,
    ffi.Pointer<CFXMLExternalID> extID,
    ffi.Pointer<ffi.Void> info);
typedef CFXMLParserResolveExternalEntityCallBack = ffi.Pointer<
    ffi.NativeFunction<CFXMLParserResolveExternalEntityCallBackFunction>>;
typedef CFXMLParserHandleErrorCallBackFunction = Boolean Function(
    CFXMLParserRef parser, CFIndex error, ffi.Pointer<ffi.Void> info);
typedef DartCFXMLParserHandleErrorCallBackFunction = DartBoolean Function(
    CFXMLParserRef parser,
    CFXMLParserStatusCode error,
    ffi.Pointer<ffi.Void> info);
typedef CFXMLParserHandleErrorCallBack
    = ffi.Pointer<ffi.NativeFunction<CFXMLParserHandleErrorCallBackFunction>>;

final class CFXMLParserCallBacks extends ffi.Struct {
  @CFIndex()
  external int version;

  external CFXMLParserCreateXMLStructureCallBack createXMLStructure;

  external CFXMLParserAddChildCallBack addChild;

  external CFXMLParserEndXMLStructureCallBack endXMLStructure;

  external CFXMLParserResolveExternalEntityCallBack resolveExternalEntity;

  external CFXMLParserHandleErrorCallBack handleError;
}

typedef CFXMLParserRetainCallBackFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void> info);
typedef CFXMLParserRetainCallBack
    = ffi.Pointer<ffi.NativeFunction<CFXMLParserRetainCallBackFunction>>;
typedef CFXMLParserReleaseCallBackFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> info);
typedef DartCFXMLParserReleaseCallBackFunction = void Function(
    ffi.Pointer<ffi.Void> info);
typedef CFXMLParserReleaseCallBack
    = ffi.Pointer<ffi.NativeFunction<CFXMLParserReleaseCallBackFunction>>;
typedef CFXMLParserCopyDescriptionCallBackFunction = CFStringRef Function(
    ffi.Pointer<ffi.Void> info);
typedef CFXMLParserCopyDescriptionCallBack = ffi
    .Pointer<ffi.NativeFunction<CFXMLParserCopyDescriptionCallBackFunction>>;

final class CFXMLParserContext extends ffi.Struct {
  @CFIndex()
  external int version;

  external ffi.Pointer<ffi.Void> info;

  external CFXMLParserRetainCallBack retain;

  external CFXMLParserReleaseCallBack release;

  external CFXMLParserCopyDescriptionCallBack copyDescription;
}

typedef sint64 = ffi.Int64;
typedef Dartsint64 = int;
typedef uint64 = ffi.Uint64;
typedef Dartuint64 = int;
typedef sint32 = ffi.Int32;
typedef Dartsint32 = int;
typedef sint16 = ffi.Int16;
typedef Dartsint16 = int;
typedef sint8 = ffi.Int8;
typedef Dartsint8 = int;
typedef uint32 = ffi.Uint32;
typedef Dartuint32 = int;
typedef uint16 = ffi.Uint16;
typedef Dartuint16 = int;
typedef uint8 = ffi.Uint8;
typedef Dartuint8 = int;
typedef CSSM_INTPTR = ffi.IntPtr;
typedef DartCSSM_INTPTR = int;
typedef CSSM_SIZE = ffi.Size;
typedef DartCSSM_SIZE = int;

final class cssm_data extends ffi.Struct {
  @ffi.Size()
  external int Length;

  external ffi.Pointer<ffi.Uint8> Data;
}

typedef SecAsn1Item = cssm_data;
typedef SecAsn1Oid = cssm_data;

final class SecAsn1AlgId extends ffi.Struct {
  external SecAsn1Oid algorithm;

  external SecAsn1Item parameters;
}

final class SecAsn1PubKeyInfo extends ffi.Struct {
  external SecAsn1AlgId algorithm;

  external SecAsn1Item subjectPublicKey;
}

final class SecAsn1Template_struct extends ffi.Struct {
  @ffi.Uint32()
  external int kind;

  @ffi.Uint32()
  external int offset;

  external ffi.Pointer<ffi.Void> sub;

  @ffi.Uint32()
  external int size;
}

typedef SecAsn1Template = SecAsn1Template_struct;
typedef SecAsn1TemplateChooser = ffi.NativeFunction<
    ffi.Pointer<SecAsn1Template> Function(
        ffi.Pointer<ffi.Void> arg,
        Boolean enc,
        ffi.Pointer<ffi.Char> buf,
        ffi.Size len,
        ffi.Pointer<ffi.Void> dest)>;
typedef SecAsn1TemplateChooserPtr = ffi.Pointer<SecAsn1TemplateChooser>;
typedef CSSM_HANDLE = CSSM_INTPTR;
typedef CSSM_HANDLE_PTR = ffi.Pointer<CSSM_INTPTR>;
typedef CSSM_LONG_HANDLE = uint64;
typedef CSSM_LONG_HANDLE_PTR = ffi.Pointer<uint64>;
typedef CSSM_MODULE_HANDLE = CSSM_HANDLE;
typedef CSSM_MODULE_HANDLE_PTR = ffi.Pointer<CSSM_HANDLE>;
typedef CSSM_CC_HANDLE = CSSM_LONG_HANDLE;
typedef CSSM_CSP_HANDLE = CSSM_MODULE_HANDLE;
typedef CSSM_TP_HANDLE = CSSM_MODULE_HANDLE;
typedef CSSM_AC_HANDLE = CSSM_MODULE_HANDLE;
typedef CSSM_CL_HANDLE = CSSM_MODULE_HANDLE;
typedef CSSM_DL_HANDLE = CSSM_MODULE_HANDLE;
typedef CSSM_DB_HANDLE = CSSM_MODULE_HANDLE;
typedef CSSM_BOOL = sint32;
typedef CSSM_RETURN = sint32;
typedef CSSM_DATA_PTR = ffi.Pointer<SecAsn1Item>;

final class cssm_guid extends ffi.Struct {
  @uint32()
  external int Data1;

  @uint16()
  external int Data2;

  @uint16()
  external int Data3;

  @ffi.Array.multi([8])
  external ffi.Array<uint8> Data4;
}

typedef CSSM_GUID = cssm_guid;
typedef CSSM_GUID_PTR = ffi.Pointer<cssm_guid>;
typedef CSSM_BITMASK = uint32;
typedef CSSM_KEY_HIERARCHY = CSSM_BITMASK;
typedef CSSM_PVC_MODE = CSSM_BITMASK;
typedef CSSM_PRIVILEGE_SCOPE = uint32;

final class cssm_version extends ffi.Struct {
  @uint32()
  external int Major;

  @uint32()
  external int Minor;
}

typedef CSSM_VERSION = cssm_version;
typedef CSSM_VERSION_PTR = ffi.Pointer<cssm_version>;
typedef CSSM_SERVICE_MASK = uint32;
typedef CSSM_SERVICE_TYPE = CSSM_SERVICE_MASK;

final class cssm_subservice_uid extends ffi.Struct {
  external CSSM_GUID Guid;

  external CSSM_VERSION Version;

  @uint32()
  external int SubserviceId;

  @CSSM_SERVICE_TYPE()
  external int SubserviceType;
}

typedef CSSM_SUBSERVICE_UID = cssm_subservice_uid;
typedef CSSM_SUBSERVICE_UID_PTR = ffi.Pointer<cssm_subservice_uid>;
typedef CSSM_MODULE_EVENT = uint32;
typedef CSSM_MODULE_EVENT_PTR = ffi.Pointer<uint32>;
typedef CSSM_API_ModuleEventHandlerFunction = CSSM_RETURN Function(
    ffi.Pointer<CSSM_GUID> ModuleGuid,
    ffi.Pointer<ffi.Void> AppNotifyCallbackCtx,
    uint32 SubserviceId,
    CSSM_SERVICE_TYPE ServiceType,
    CSSM_MODULE_EVENT EventType);
typedef DartCSSM_API_ModuleEventHandlerFunction = Dartsint32 Function(
    ffi.Pointer<CSSM_GUID> ModuleGuid,
    ffi.Pointer<ffi.Void> AppNotifyCallbackCtx,
    Dartuint32 SubserviceId,
    Dartuint32 ServiceType,
    Dartuint32 EventType);
typedef CSSM_API_ModuleEventHandler
    = ffi.Pointer<ffi.NativeFunction<CSSM_API_ModuleEventHandlerFunction>>;
typedef CSSM_ATTACH_FLAGS = uint32;
typedef CSSM_PRIVILEGE = uint64;
typedef CSSM_USEE_TAG = CSSM_PRIVILEGE;
typedef CSSM_NET_ADDRESS_TYPE = uint32;

final class cssm_net_address extends ffi.Struct {
  @CSSM_NET_ADDRESS_TYPE()
  external int AddressType;

  external SecAsn1Item Address;
}

typedef CSSM_NET_ADDRESS = cssm_net_address;
typedef CSSM_NET_ADDRESS_PTR = ffi.Pointer<cssm_net_address>;
typedef CSSM_NET_PROTOCOL = uint32;
typedef CSSM_CALLBACKFunction = CSSM_RETURN Function(
    CSSM_DATA_PTR OutData, ffi.Pointer<ffi.Void> CallerCtx);
typedef DartCSSM_CALLBACKFunction = Dartsint32 Function(
    CSSM_DATA_PTR OutData, ffi.Pointer<ffi.Void> CallerCtx);
typedef CSSM_CALLBACK = ffi.Pointer<ffi.NativeFunction<CSSM_CALLBACKFunction>>;

final class cssm_crypto_data extends ffi.Struct {
  external SecAsn1Item Param;

  external CSSM_CALLBACK Callback;

  external ffi.Pointer<ffi.Void> CallerCtx;
}

typedef CSSM_CRYPTO_DATA = cssm_crypto_data;
typedef CSSM_CRYPTO_DATA_PTR = ffi.Pointer<cssm_crypto_data>;
typedef CSSM_WORDID_TYPE = sint32;
typedef CSSM_LIST_ELEMENT_TYPE = uint32;
typedef CSSM_LIST_ELEMENT_TYPE_PTR = ffi.Pointer<uint32>;
typedef CSSM_LIST_TYPE = uint32;
typedef CSSM_LIST_TYPE_PTR = ffi.Pointer<uint32>;
typedef CSSM_LIST_ELEMENT_PTR = ffi.Pointer<cssm_list_element>;

final class cssm_list extends ffi.Struct {
  @CSSM_LIST_TYPE()
  external int ListType;

  external CSSM_LIST_ELEMENT_PTR Head;

  external CSSM_LIST_ELEMENT_PTR Tail;
}

typedef CSSM_LIST = cssm_list;

final class UnnamedUnion2 extends ffi.Union {
  external CSSM_LIST Sublist;

  external SecAsn1Item Word;
}

final class cssm_list_element extends ffi.Struct {
  external ffi.Pointer<cssm_list_element> NextElement;

  @CSSM_WORDID_TYPE()
  external int WordID;

  @CSSM_LIST_ELEMENT_TYPE()
  external int ElementType;

  external UnnamedUnion2 Element;
}

typedef CSSM_LIST_PTR = ffi.Pointer<cssm_list>;
typedef CSSM_LIST_ELEMENT = cssm_list_element;

final class CSSM_TUPLE extends ffi.Struct {
  external CSSM_LIST Issuer;

  external CSSM_LIST Subject;

  @CSSM_BOOL()
  external int Delegate;

  external CSSM_LIST AuthorizationTag;

  external CSSM_LIST ValidityPeriod;
}

typedef CSSM_TUPLE_PTR = ffi.Pointer<CSSM_TUPLE>;

final class cssm_tuplegroup extends ffi.Struct {
  @uint32()
  external int NumberOfTuples;

  external CSSM_TUPLE_PTR Tuples;
}

typedef CSSM_TUPLEGROUP = cssm_tuplegroup;
typedef CSSM_TUPLEGROUP_PTR = ffi.Pointer<cssm_tuplegroup>;
typedef CSSM_SAMPLE_TYPE = CSSM_WORDID_TYPE;

final class cssm_sample extends ffi.Struct {
  external CSSM_LIST TypedSample;

  external ffi.Pointer<CSSM_SUBSERVICE_UID> Verifier;
}

typedef CSSM_SAMPLE = cssm_sample;
typedef CSSM_SAMPLE_PTR = ffi.Pointer<cssm_sample>;

final class cssm_samplegroup extends ffi.Struct {
  @uint32()
  external int NumberOfSamples;

  external ffi.Pointer<CSSM_SAMPLE> Samples;
}

typedef CSSM_SAMPLEGROUP = cssm_samplegroup;
typedef CSSM_SAMPLEGROUP_PTR = ffi.Pointer<cssm_samplegroup>;
typedef CSSM_MALLOCFunction = ffi.Pointer<ffi.Void> Function(
    CSSM_SIZE size, ffi.Pointer<ffi.Void> allocref);
typedef DartCSSM_MALLOCFunction = ffi.Pointer<ffi.Void> Function(
    DartCSSM_SIZE size, ffi.Pointer<ffi.Void> allocref);
typedef CSSM_MALLOC = ffi.Pointer<ffi.NativeFunction<CSSM_MALLOCFunction>>;
typedef CSSM_FREEFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> memblock, ffi.Pointer<ffi.Void> allocref);
typedef DartCSSM_FREEFunction = void Function(
    ffi.Pointer<ffi.Void> memblock, ffi.Pointer<ffi.Void> allocref);
typedef CSSM_FREE = ffi.Pointer<ffi.NativeFunction<CSSM_FREEFunction>>;
typedef CSSM_REALLOCFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void> memblock,
    CSSM_SIZE size,
    ffi.Pointer<ffi.Void> allocref);
typedef DartCSSM_REALLOCFunction = ffi.Pointer<ffi.Void> Function(
    ffi.Pointer<ffi.Void> memblock,
    DartCSSM_SIZE size,
    ffi.Pointer<ffi.Void> allocref);
typedef CSSM_REALLOC = ffi.Pointer<ffi.NativeFunction<CSSM_REALLOCFunction>>;
typedef CSSM_CALLOCFunction = ffi.Pointer<ffi.Void> Function(
    uint32 num, CSSM_SIZE size, ffi.Pointer<ffi.Void> allocref);
typedef DartCSSM_CALLOCFunction = ffi.Pointer<ffi.Void> Function(
    Dartuint32 num, DartCSSM_SIZE size, ffi.Pointer<ffi.Void> allocref);
typedef CSSM_CALLOC = ffi.Pointer<ffi.NativeFunction<CSSM_CALLOCFunction>>;

final class cssm_memory_funcs extends ffi.Struct {
  external CSSM_MALLOC malloc_func;

  external CSSM_FREE free_func;

  external CSSM_REALLOC realloc_func;

  external CSSM_CALLOC calloc_func;

  external ffi.Pointer<ffi.Void> AllocRef;
}

typedef CSSM_MEMORY_FUNCS = cssm_memory_funcs;
typedef CSSM_MEMORY_FUNCS_PTR = ffi.Pointer<cssm_memory_funcs>;
typedef CSSM_API_MEMORY_FUNCS = CSSM_MEMORY_FUNCS;
typedef CSSM_API_MEMORY_FUNCS_PTR = ffi.Pointer<CSSM_API_MEMORY_FUNCS>;
typedef CSSM_CHALLENGE_CALLBACKFunction = CSSM_RETURN Function(
    ffi.Pointer<CSSM_LIST> Challenge,
    CSSM_SAMPLEGROUP_PTR Response,
    ffi.Pointer<ffi.Void> CallerCtx,
    ffi.Pointer<CSSM_MEMORY_FUNCS> MemFuncs);
typedef DartCSSM_CHALLENGE_CALLBACKFunction = Dartsint32 Function(
    ffi.Pointer<CSSM_LIST> Challenge,
    CSSM_SAMPLEGROUP_PTR Response,
    ffi.Pointer<ffi.Void> CallerCtx,
    ffi.Pointer<CSSM_MEMORY_FUNCS> MemFuncs);
typedef CSSM_CHALLENGE_CALLBACK
    = ffi.Pointer<ffi.NativeFunction<CSSM_CHALLENGE_CALLBACKFunction>>;
typedef CSSM_CERT_TYPE = uint32;
typedef CSSM_CERT_TYPE_PTR = ffi.Pointer<uint32>;
typedef CSSM_CERT_ENCODING = uint32;
typedef CSSM_CERT_ENCODING_PTR = ffi.Pointer<uint32>;

final class cssm_encoded_cert extends ffi.Struct {
  @CSSM_CERT_TYPE()
  external int CertType;

  @CSSM_CERT_ENCODING()
  external int CertEncoding;

  external SecAsn1Item CertBlob;
}

typedef CSSM_ENCODED_CERT = cssm_encoded_cert;
typedef CSSM_ENCODED_CERT_PTR = ffi.Pointer<cssm_encoded_cert>;
typedef CSSM_CERT_PARSE_FORMAT = uint32;
typedef CSSM_CERT_PARSE_FORMAT_PTR = ffi.Pointer<uint32>;

final class cssm_parsed_cert extends ffi.Struct {
  @CSSM_CERT_TYPE()
  external int CertType;

  @CSSM_CERT_PARSE_FORMAT()
  external int ParsedCertFormat;

  external ffi.Pointer<ffi.Void> ParsedCert;
}

typedef CSSM_PARSED_CERT = cssm_parsed_cert;
typedef CSSM_PARSED_CERT_PTR = ffi.Pointer<cssm_parsed_cert>;

final class cssm_cert_pair extends ffi.Struct {
  external CSSM_ENCODED_CERT EncodedCert;

  external CSSM_PARSED_CERT ParsedCert;
}

typedef CSSM_CERT_PAIR = cssm_cert_pair;
typedef CSSM_CERT_PAIR_PTR = ffi.Pointer<cssm_cert_pair>;
typedef CSSM_CERTGROUP_TYPE = uint32;
typedef CSSM_CERTGROUP_TYPE_PTR = ffi.Pointer<uint32>;

final class UnnamedUnion3 extends ffi.Union {
  external CSSM_DATA_PTR CertList;

  external CSSM_ENCODED_CERT_PTR EncodedCertList;

  external CSSM_PARSED_CERT_PTR ParsedCertList;

  external CSSM_CERT_PAIR_PTR PairCertList;
}

final class cssm_certgroup extends ffi.Struct {
  @CSSM_CERT_TYPE()
  external int CertType;

  @CSSM_CERT_ENCODING()
  external int CertEncoding;

  @uint32()
  external int NumCerts;

  external UnnamedUnion3 GroupList;

  @CSSM_CERTGROUP_TYPE()
  external int CertGroupType;

  external ffi.Pointer<ffi.Void> Reserved;
}

typedef CSSM_CERTGROUP = cssm_certgroup;
typedef CSSM_CERTGROUP_PTR = ffi.Pointer<cssm_certgroup>;

final class cssm_base_certs extends ffi.Struct {
  @CSSM_TP_HANDLE()
  external int TPHandle;

  @CSSM_CL_HANDLE()
  external int CLHandle;

  external CSSM_CERTGROUP Certs;
}

typedef CSSM_BASE_CERTS = cssm_base_certs;
typedef CSSM_BASE_CERTS_PTR = ffi.Pointer<cssm_base_certs>;

final class cssm_access_credentials extends ffi.Struct {
  @ffi.Array.multi([68])
  external ffi.Array<ffi.Char> EntryTag;

  external CSSM_BASE_CERTS BaseCerts;

  external CSSM_SAMPLEGROUP Samples;

  external CSSM_CHALLENGE_CALLBACK Callback;

  external ffi.Pointer<ffi.Void> CallerCtx;
}

typedef CSSM_ACCESS_CREDENTIALS = cssm_access_credentials;
typedef CSSM_ACCESS_CREDENTIALS_PTR = ffi.Pointer<cssm_access_credentials>;
typedef CSSM_ACL_SUBJECT_TYPE = sint32;
typedef CSSM_ACL_AUTHORIZATION_TAG = sint32;

final class cssm_authorizationgroup extends ffi.Struct {
  @uint32()
  external int NumberOfAuthTags;

  external ffi.Pointer<CSSM_ACL_AUTHORIZATION_TAG> AuthTags;
}

typedef CSSM_AUTHORIZATIONGROUP = cssm_authorizationgroup;
typedef CSSM_AUTHORIZATIONGROUP_PTR = ffi.Pointer<cssm_authorizationgroup>;

final class cssm_acl_validity_period extends ffi.Struct {
  external SecAsn1Item StartDate;

  external SecAsn1Item EndDate;
}

typedef CSSM_ACL_VALIDITY_PERIOD = cssm_acl_validity_period;
typedef CSSM_ACL_VALIDITY_PERIOD_PTR = ffi.Pointer<cssm_acl_validity_period>;

final class cssm_acl_entry_prototype extends ffi.Struct {
  external CSSM_LIST TypedSubject;

  @CSSM_BOOL()
  external int Delegate;

  external CSSM_AUTHORIZATIONGROUP Authorization;

  external CSSM_ACL_VALIDITY_PERIOD TimeRange;

  @ffi.Array.multi([68])
  external ffi.Array<ffi.Char> EntryTag;
}

typedef CSSM_ACL_ENTRY_PROTOTYPE = cssm_acl_entry_prototype;
typedef CSSM_ACL_ENTRY_PROTOTYPE_PTR = ffi.Pointer<cssm_acl_entry_prototype>;

final class cssm_acl_owner_prototype extends ffi.Struct {
  external CSSM_LIST TypedSubject;

  @CSSM_BOOL()
  external int Delegate;
}

typedef CSSM_ACL_OWNER_PROTOTYPE = cssm_acl_owner_prototype;
typedef CSSM_ACL_OWNER_PROTOTYPE_PTR = ffi.Pointer<cssm_acl_owner_prototype>;
typedef CSSM_ACL_SUBJECT_CALLBACKFunction = CSSM_RETURN Function(
    ffi.Pointer<CSSM_LIST> SubjectRequest,
    CSSM_LIST_PTR SubjectResponse,
    ffi.Pointer<ffi.Void> CallerContext,
    ffi.Pointer<CSSM_MEMORY_FUNCS> MemFuncs);
typedef DartCSSM_ACL_SUBJECT_CALLBACKFunction = Dartsint32 Function(
    ffi.Pointer<CSSM_LIST> SubjectRequest,
    CSSM_LIST_PTR SubjectResponse,
    ffi.Pointer<ffi.Void> CallerContext,
    ffi.Pointer<CSSM_MEMORY_FUNCS> MemFuncs);
typedef CSSM_ACL_SUBJECT_CALLBACK
    = ffi.Pointer<ffi.NativeFunction<CSSM_ACL_SUBJECT_CALLBACKFunction>>;

final class cssm_acl_entry_input extends ffi.Struct {
  external CSSM_ACL_ENTRY_PROTOTYPE Prototype;

  external CSSM_ACL_SUBJECT_CALLBACK Callback;

  external ffi.Pointer<ffi.Void> CallerContext;
}

typedef CSSM_ACL_ENTRY_INPUT = cssm_acl_entry_input;
typedef CSSM_ACL_ENTRY_INPUT_PTR = ffi.Pointer<cssm_acl_entry_input>;

final class cssm_resource_control_context extends ffi.Struct {
  external CSSM_ACCESS_CREDENTIALS_PTR AccessCred;

  external CSSM_ACL_ENTRY_INPUT InitialAclEntry;
}

typedef CSSM_RESOURCE_CONTROL_CONTEXT = cssm_resource_control_context;
typedef CSSM_RESOURCE_CONTROL_CONTEXT_PTR
    = ffi.Pointer<cssm_resource_control_context>;
typedef CSSM_ACL_HANDLE = CSSM_HANDLE;

final class cssm_acl_entry_info extends ffi.Struct {
  external CSSM_ACL_ENTRY_PROTOTYPE EntryPublicInfo;

  @CSSM_ACL_HANDLE()
  external int EntryHandle;
}

typedef CSSM_ACL_ENTRY_INFO = cssm_acl_entry_info;
typedef CSSM_ACL_ENTRY_INFO_PTR = ffi.Pointer<cssm_acl_entry_info>;
typedef CSSM_ACL_EDIT_MODE = uint32;

final class cssm_acl_edit extends ffi.Struct {
  @CSSM_ACL_EDIT_MODE()
  external int EditMode;

  @CSSM_ACL_HANDLE()
  external int OldEntryHandle;

  external ffi.Pointer<CSSM_ACL_ENTRY_INPUT> NewEntry;
}

typedef CSSM_ACL_EDIT = cssm_acl_edit;
typedef CSSM_ACL_EDIT_PTR = ffi.Pointer<cssm_acl_edit>;
typedef CSSM_PROC_ADDRFunction = ffi.Void Function();
typedef DartCSSM_PROC_ADDRFunction = void Function();
typedef CSSM_PROC_ADDR
    = ffi.Pointer<ffi.NativeFunction<CSSM_PROC_ADDRFunction>>;
typedef CSSM_PROC_ADDR_PTR = ffi.Pointer<CSSM_PROC_ADDR>;

final class cssm_func_name_addr extends ffi.Struct {
  @ffi.Array.multi([68])
  external ffi.Array<ffi.Char> Name;

  external CSSM_PROC_ADDR Address;
}

typedef CSSM_FUNC_NAME_ADDR = cssm_func_name_addr;
typedef CSSM_FUNC_NAME_ADDR_PTR = ffi.Pointer<cssm_func_name_addr>;

final class cssm_date extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<uint8> Year;

  @ffi.Array.multi([2])
  external ffi.Array<uint8> Month;

  @ffi.Array.multi([2])
  external ffi.Array<uint8> Day;
}

typedef CSSM_DATE = cssm_date;
typedef CSSM_DATE_PTR = ffi.Pointer<cssm_date>;

final class cssm_range extends ffi.Struct {
  @uint32()
  external int Min;

  @uint32()
  external int Max;
}

typedef CSSM_RANGE = cssm_range;
typedef CSSM_RANGE_PTR = ffi.Pointer<cssm_range>;

final class cssm_query_size_data extends ffi.Struct {
  @uint32()
  external int SizeInputBlock;

  @uint32()
  external int SizeOutputBlock;
}

typedef CSSM_QUERY_SIZE_DATA = cssm_query_size_data;
typedef CSSM_QUERY_SIZE_DATA_PTR = ffi.Pointer<cssm_query_size_data>;
typedef CSSM_HEADERVERSION = uint32;

final class cssm_key_size extends ffi.Struct {
  @uint32()
  external int LogicalKeySizeInBits;

  @uint32()
  external int EffectiveKeySizeInBits;
}

typedef CSSM_KEY_SIZE = cssm_key_size;
typedef CSSM_KEY_SIZE_PTR = ffi.Pointer<cssm_key_size>;
typedef CSSM_KEYBLOB_TYPE = uint32;
typedef CSSM_KEYBLOB_FORMAT = uint32;
typedef CSSM_KEYCLASS = uint32;
typedef CSSM_KEYATTR_FLAGS = uint32;
typedef CSSM_KEYUSE = uint32;
typedef CSSM_ALGORITHMS = uint32;
typedef CSSM_ENCRYPT_MODE = uint32;

final class cssm_keyheader extends ffi.Struct {
  @CSSM_HEADERVERSION()
  external int HeaderVersion;

  external CSSM_GUID CspId;

  @CSSM_KEYBLOB_TYPE()
  external int BlobType;

  @CSSM_KEYBLOB_FORMAT()
  external int Format;

  @CSSM_ALGORITHMS()
  external int AlgorithmId;

  @CSSM_KEYCLASS()
  external int KeyClass;

  @uint32()
  external int LogicalKeySizeInBits;

  @CSSM_KEYATTR_FLAGS()
  external int KeyAttr;

  @CSSM_KEYUSE()
  external int KeyUsage;

  external CSSM_DATE StartDate;

  external CSSM_DATE EndDate;

  @CSSM_ALGORITHMS()
  external int WrapAlgorithmId;

  @CSSM_ENCRYPT_MODE()
  external int WrapMode;

  @uint32()
  external int Reserved;
}

typedef CSSM_KEYHEADER = cssm_keyheader;
typedef CSSM_KEYHEADER_PTR = ffi.Pointer<cssm_keyheader>;

final class cssm_key extends ffi.Struct {
  external CSSM_KEYHEADER KeyHeader;

  external SecAsn1Item KeyData;
}

typedef CSSM_KEY = cssm_key;
typedef CSSM_KEY_PTR = ffi.Pointer<cssm_key>;
typedef CSSM_WRAP_KEY = CSSM_KEY;
typedef CSSM_WRAP_KEY_PTR = ffi.Pointer<CSSM_KEY>;
typedef CSSM_CSPTYPE = uint32;

final class cssm_dl_db_handle extends ffi.Struct {
  @CSSM_DL_HANDLE()
  external int DLHandle;

  @CSSM_DB_HANDLE()
  external int DBHandle;
}

typedef CSSM_DL_DB_HANDLE = cssm_dl_db_handle;
typedef CSSM_DL_DB_HANDLE_PTR = ffi.Pointer<cssm_dl_db_handle>;
typedef CSSM_CONTEXT_TYPE = uint32;
typedef CSSM_ATTRIBUTE_TYPE = uint32;
typedef CSSM_PADDING = uint32;
typedef CSSM_KEY_TYPE = CSSM_ALGORITHMS;

final class cssm_kr_profile extends ffi.Opaque {}

final class cssm_context_attribute_value extends ffi.Union {
  external ffi.Pointer<ffi.Char> String;

  @uint32()
  external int Uint32;

  external CSSM_ACCESS_CREDENTIALS_PTR AccessCredentials;

  external CSSM_KEY_PTR Key;

  external CSSM_DATA_PTR Data;

  @CSSM_PADDING()
  external int Padding;

  external CSSM_DATE_PTR Date;

  external CSSM_RANGE_PTR Range;

  external CSSM_CRYPTO_DATA_PTR CryptoData;

  external CSSM_VERSION_PTR Version;

  external CSSM_DL_DB_HANDLE_PTR DLDBHandle;

  external ffi.Pointer<cssm_kr_profile> KRProfile;
}

final class cssm_context_attribute extends ffi.Struct {
  @CSSM_ATTRIBUTE_TYPE()
  external int AttributeType;

  @uint32()
  external int AttributeLength;

  external cssm_context_attribute_value Attribute;
}

typedef CSSM_CONTEXT_ATTRIBUTE = cssm_context_attribute;
typedef CSSM_CONTEXT_ATTRIBUTE_PTR = ffi.Pointer<cssm_context_attribute>;

final class cssm_context extends ffi.Struct {
  @CSSM_CONTEXT_TYPE()
  external int ContextType;

  @CSSM_ALGORITHMS()
  external int AlgorithmType;

  @uint32()
  external int NumberOfAttributes;

  external CSSM_CONTEXT_ATTRIBUTE_PTR ContextAttributes;

  @CSSM_CSP_HANDLE()
  external int CSPHandle;

  @CSSM_BOOL()
  external int Privileged;

  @uint32()
  external int EncryptionProhibited;

  @uint32()
  external int WorkFactor;

  @uint32()
  external int Reserved;
}

typedef CSSM_CONTEXT = cssm_context;
typedef CSSM_CONTEXT_PTR = ffi.Pointer<cssm_context>;
typedef CSSM_SC_FLAGS = uint32;
typedef CSSM_CSP_READER_FLAGS = uint32;
typedef CSSM_CSP_FLAGS = uint32;
typedef CSSM_PKCS_OAEP_MGF = uint32;
typedef CSSM_PKCS_OAEP_PSOURCE = uint32;

final class cssm_pkcs1_oaep_params extends ffi.Struct {
  @uint32()
  external int HashAlgorithm;

  external SecAsn1Item HashParams;

  @CSSM_PKCS_OAEP_MGF()
  external int MGF;

  external SecAsn1Item MGFParams;

  @CSSM_PKCS_OAEP_PSOURCE()
  external int PSource;

  external SecAsn1Item PSourceParams;
}

typedef CSSM_PKCS1_OAEP_PARAMS = cssm_pkcs1_oaep_params;
typedef CSSM_PKCS1_OAEP_PARAMS_PTR = ffi.Pointer<cssm_pkcs1_oaep_params>;

final class cssm_csp_operational_statistics extends ffi.Struct {
  @CSSM_BOOL()
  external int UserAuthenticated;

  @CSSM_CSP_FLAGS()
  external int DeviceFlags;

  @uint32()
  external int TokenMaxSessionCount;

  @uint32()
  external int TokenOpenedSessionCount;

  @uint32()
  external int TokenMaxRWSessionCount;

  @uint32()
  external int TokenOpenedRWSessionCount;

  @uint32()
  external int TokenTotalPublicMem;

  @uint32()
  external int TokenFreePublicMem;

  @uint32()
  external int TokenTotalPrivateMem;

  @uint32()
  external int TokenFreePrivateMem;
}

typedef CSSM_CSP_OPERATIONAL_STATISTICS = cssm_csp_operational_statistics;
typedef CSSM_CSP_OPERATIONAL_STATISTICS_PTR
    = ffi.Pointer<cssm_csp_operational_statistics>;

final class cssm_pkcs5_pbkdf1_params extends ffi.Struct {
  external SecAsn1Item Passphrase;

  external SecAsn1Item InitVector;
}

typedef CSSM_PKCS5_PBKDF1_PARAMS = cssm_pkcs5_pbkdf1_params;
typedef CSSM_PKCS5_PBKDF1_PARAMS_PTR = ffi.Pointer<cssm_pkcs5_pbkdf1_params>;
typedef CSSM_PKCS5_PBKDF2_PRF = uint32;

final class cssm_pkcs5_pbkdf2_params extends ffi.Struct {
  external SecAsn1Item Passphrase;

  @CSSM_PKCS5_PBKDF2_PRF()
  external int PseudoRandomFunction;
}

typedef CSSM_PKCS5_PBKDF2_PARAMS = cssm_pkcs5_pbkdf2_params;
typedef CSSM_PKCS5_PBKDF2_PARAMS_PTR = ffi.Pointer<cssm_pkcs5_pbkdf2_params>;

final class cssm_kea_derive_params extends ffi.Struct {
  external SecAsn1Item Rb;

  external SecAsn1Item Yb;
}

typedef CSSM_KEA_DERIVE_PARAMS = cssm_kea_derive_params;
typedef CSSM_KEA_DERIVE_PARAMS_PTR = ffi.Pointer<cssm_kea_derive_params>;

final class cssm_tp_authority_id extends ffi.Struct {
  external ffi.Pointer<SecAsn1Item> AuthorityCert;

  external CSSM_NET_ADDRESS_PTR AuthorityLocation;
}

typedef CSSM_TP_AUTHORITY_ID = cssm_tp_authority_id;
typedef CSSM_TP_AUTHORITY_ID_PTR = ffi.Pointer<cssm_tp_authority_id>;
typedef CSSM_TP_AUTHORITY_REQUEST_TYPE = uint32;
typedef CSSM_TP_AUTHORITY_REQUEST_TYPE_PTR = ffi.Pointer<uint32>;
typedef CSSM_TP_VERIFICATION_RESULTS_CALLBACKFunction = CSSM_RETURN Function(
    CSSM_MODULE_HANDLE ModuleHandle,
    ffi.Pointer<ffi.Void> CallerCtx,
    CSSM_DATA_PTR VerifiedCert);
typedef DartCSSM_TP_VERIFICATION_RESULTS_CALLBACKFunction = Dartsint32 Function(
    DartCSSM_INTPTR ModuleHandle,
    ffi.Pointer<ffi.Void> CallerCtx,
    CSSM_DATA_PTR VerifiedCert);
typedef CSSM_TP_VERIFICATION_RESULTS_CALLBACK = ffi
    .Pointer<ffi.NativeFunction<CSSM_TP_VERIFICATION_RESULTS_CALLBACKFunction>>;
typedef CSSM_OID_PTR = ffi.Pointer<SecAsn1Oid>;

final class cssm_field extends ffi.Struct {
  external SecAsn1Oid FieldOid;

  external SecAsn1Item FieldValue;
}

typedef CSSM_FIELD = cssm_field;
typedef CSSM_FIELD_PTR = ffi.Pointer<cssm_field>;

final class cssm_tp_policyinfo extends ffi.Struct {
  @uint32()
  external int NumberOfPolicyIds;

  external CSSM_FIELD_PTR PolicyIds;

  external ffi.Pointer<ffi.Void> PolicyControl;
}

typedef CSSM_TP_POLICYINFO = cssm_tp_policyinfo;
typedef CSSM_TP_POLICYINFO_PTR = ffi.Pointer<cssm_tp_policyinfo>;
typedef CSSM_TP_SERVICES = uint32;
typedef CSSM_TP_ACTION = uint32;
typedef CSSM_TP_STOP_ON = uint32;
typedef CSSM_TIMESTRING = ffi.Pointer<ffi.Char>;

final class cssm_dl_db_list extends ffi.Struct {
  @uint32()
  external int NumHandles;

  external CSSM_DL_DB_HANDLE_PTR DLDBHandle;
}

typedef CSSM_DL_DB_LIST = cssm_dl_db_list;
typedef CSSM_DL_DB_LIST_PTR = ffi.Pointer<cssm_dl_db_list>;

final class cssm_tp_callerauth_context extends ffi.Struct {
  external CSSM_TP_POLICYINFO Policy;

  external CSSM_TIMESTRING VerifyTime;

  @CSSM_TP_STOP_ON()
  external int VerificationAbortOn;

  external CSSM_TP_VERIFICATION_RESULTS_CALLBACK CallbackWithVerifiedCert;

  @uint32()
  external int NumberOfAnchorCerts;

  external CSSM_DATA_PTR AnchorCerts;

  external CSSM_DL_DB_LIST_PTR DBList;

  external CSSM_ACCESS_CREDENTIALS_PTR CallerCredentials;
}

typedef CSSM_TP_CALLERAUTH_CONTEXT = cssm_tp_callerauth_context;
typedef CSSM_TP_CALLERAUTH_CONTEXT_PTR
    = ffi.Pointer<cssm_tp_callerauth_context>;
typedef CSSM_CRL_PARSE_FORMAT = uint32;
typedef CSSM_CRL_PARSE_FORMAT_PTR = ffi.Pointer<uint32>;
typedef CSSM_CRL_TYPE = uint32;
typedef CSSM_CRL_TYPE_PTR = ffi.Pointer<uint32>;
typedef CSSM_CRL_ENCODING = uint32;
typedef CSSM_CRL_ENCODING_PTR = ffi.Pointer<uint32>;

final class cssm_encoded_crl extends ffi.Struct {
  @CSSM_CRL_TYPE()
  external int CrlType;

  @CSSM_CRL_ENCODING()
  external int CrlEncoding;

  external SecAsn1Item CrlBlob;
}

typedef CSSM_ENCODED_CRL = cssm_encoded_crl;
typedef CSSM_ENCODED_CRL_PTR = ffi.Pointer<cssm_encoded_crl>;

final class cssm_parsed_crl extends ffi.Struct {
  @CSSM_CRL_TYPE()
  external int CrlType;

  @CSSM_CRL_PARSE_FORMAT()
  external int ParsedCrlFormat;

  external ffi.Pointer<ffi.Void> ParsedCrl;
}

typedef CSSM_PARSED_CRL = cssm_parsed_crl;
typedef CSSM_PARSED_CRL_PTR = ffi.Pointer<cssm_parsed_crl>;

final class cssm_crl_pair extends ffi.Struct {
  external CSSM_ENCODED_CRL EncodedCrl;

  external CSSM_PARSED_CRL ParsedCrl;
}

typedef CSSM_CRL_PAIR = cssm_crl_pair;
typedef CSSM_CRL_PAIR_PTR = ffi.Pointer<cssm_crl_pair>;
typedef CSSM_CRLGROUP_TYPE = uint32;
typedef CSSM_CRLGROUP_TYPE_PTR = ffi.Pointer<uint32>;

final class UnnamedUnion4 extends ffi.Union {
  external CSSM_DATA_PTR CrlList;

  external CSSM_ENCODED_CRL_PTR EncodedCrlList;

  external CSSM_PARSED_CRL_PTR ParsedCrlList;

  external CSSM_CRL_PAIR_PTR PairCrlList;
}

final class cssm_crlgroup extends ffi.Struct {
  @CSSM_CRL_TYPE()
  external int CrlType;

  @CSSM_CRL_ENCODING()
  external int CrlEncoding;

  @uint32()
  external int NumberOfCrls;

  external UnnamedUnion4 GroupCrlList;

  @CSSM_CRLGROUP_TYPE()
  external int CrlGroupType;
}

typedef CSSM_CRLGROUP = cssm_crlgroup;
typedef CSSM_CRLGROUP_PTR = ffi.Pointer<cssm_crlgroup>;

final class cssm_fieldgroup extends ffi.Struct {
  @ffi.Int()
  external int NumberOfFields;

  external CSSM_FIELD_PTR Fields;
}

typedef CSSM_FIELDGROUP = cssm_fieldgroup;
typedef CSSM_FIELDGROUP_PTR = ffi.Pointer<cssm_fieldgroup>;
typedef CSSM_EVIDENCE_FORM = uint32;

final class cssm_evidence extends ffi.Struct {
  @CSSM_EVIDENCE_FORM()
  external int EvidenceForm;

  external ffi.Pointer<ffi.Void> Evidence;
}

typedef CSSM_EVIDENCE = cssm_evidence;
typedef CSSM_EVIDENCE_PTR = ffi.Pointer<cssm_evidence>;

final class cssm_tp_verify_context extends ffi.Struct {
  @CSSM_TP_ACTION()
  external int Action;

  external SecAsn1Item ActionData;

  external CSSM_CRLGROUP Crls;

  external CSSM_TP_CALLERAUTH_CONTEXT_PTR Cred;
}

typedef CSSM_TP_VERIFY_CONTEXT = cssm_tp_verify_context;
typedef CSSM_TP_VERIFY_CONTEXT_PTR = ffi.Pointer<cssm_tp_verify_context>;

final class cssm_tp_verify_context_result extends ffi.Struct {
  @uint32()
  external int NumberOfEvidences;

  external CSSM_EVIDENCE_PTR Evidence;
}

typedef CSSM_TP_VERIFY_CONTEXT_RESULT = cssm_tp_verify_context_result;
typedef CSSM_TP_VERIFY_CONTEXT_RESULT_PTR
    = ffi.Pointer<cssm_tp_verify_context_result>;

final class cssm_tp_request_set extends ffi.Struct {
  @uint32()
  external int NumberOfRequests;

  external ffi.Pointer<ffi.Void> Requests;
}

typedef CSSM_TP_REQUEST_SET = cssm_tp_request_set;
typedef CSSM_TP_REQUEST_SET_PTR = ffi.Pointer<cssm_tp_request_set>;

final class cssm_tp_result_set extends ffi.Struct {
  @uint32()
  external int NumberOfResults;

  external ffi.Pointer<ffi.Void> Results;
}

typedef CSSM_TP_RESULT_SET = cssm_tp_result_set;
typedef CSSM_TP_RESULT_SET_PTR = ffi.Pointer<cssm_tp_result_set>;
typedef CSSM_TP_CONFIRM_STATUS = uint32;
typedef CSSM_TP_CONFIRM_STATUS_PTR = ffi.Pointer<uint32>;

final class cssm_tp_confirm_response extends ffi.Struct {
  @uint32()
  external int NumberOfResponses;

  external CSSM_TP_CONFIRM_STATUS_PTR Responses;
}

typedef CSSM_TP_CONFIRM_RESPONSE = cssm_tp_confirm_response;
typedef CSSM_TP_CONFIRM_RESPONSE_PTR = ffi.Pointer<cssm_tp_confirm_response>;

final class cssm_tp_certissue_input extends ffi.Struct {
  external CSSM_SUBSERVICE_UID CSPSubserviceUid;

  @CSSM_CL_HANDLE()
  external int CLHandle;

  @uint32()
  external int NumberOfTemplateFields;

  external CSSM_FIELD_PTR SubjectCertFields;

  @CSSM_TP_SERVICES()
  external int MoreServiceRequests;

  @uint32()
  external int NumberOfServiceControls;

  external CSSM_FIELD_PTR ServiceControls;

  external CSSM_ACCESS_CREDENTIALS_PTR UserCredentials;
}

typedef CSSM_TP_CERTISSUE_INPUT = cssm_tp_certissue_input;
typedef CSSM_TP_CERTISSUE_INPUT_PTR = ffi.Pointer<cssm_tp_certissue_input>;
typedef CSSM_TP_CERTISSUE_STATUS = uint32;

final class cssm_tp_certissue_output extends ffi.Struct {
  @CSSM_TP_CERTISSUE_STATUS()
  external int IssueStatus;

  external CSSM_CERTGROUP_PTR CertGroup;

  @CSSM_TP_SERVICES()
  external int PerformedServiceRequests;
}

typedef CSSM_TP_CERTISSUE_OUTPUT = cssm_tp_certissue_output;
typedef CSSM_TP_CERTISSUE_OUTPUT_PTR = ffi.Pointer<cssm_tp_certissue_output>;
typedef CSSM_TP_CERTCHANGE_ACTION = uint32;
typedef CSSM_TP_CERTCHANGE_REASON = uint32;

final class cssm_tp_certchange_input extends ffi.Struct {
  @CSSM_TP_CERTCHANGE_ACTION()
  external int Action;

  @CSSM_TP_CERTCHANGE_REASON()
  external int Reason;

  @CSSM_CL_HANDLE()
  external int CLHandle;

  external CSSM_DATA_PTR Cert;

  external CSSM_FIELD_PTR ChangeInfo;

  external CSSM_TIMESTRING StartTime;

  external CSSM_ACCESS_CREDENTIALS_PTR CallerCredentials;
}

typedef CSSM_TP_CERTCHANGE_INPUT = cssm_tp_certchange_input;
typedef CSSM_TP_CERTCHANGE_INPUT_PTR = ffi.Pointer<cssm_tp_certchange_input>;
typedef CSSM_TP_CERTCHANGE_STATUS = uint32;

final class cssm_tp_certchange_output extends ffi.Struct {
  @CSSM_TP_CERTCHANGE_STATUS()
  external int ActionStatus;

  external CSSM_FIELD RevokeInfo;
}

typedef CSSM_TP_CERTCHANGE_OUTPUT = cssm_tp_certchange_output;
typedef CSSM_TP_CERTCHANGE_OUTPUT_PTR = ffi.Pointer<cssm_tp_certchange_output>;

final class cssm_tp_certverify_input extends ffi.Struct {
  @CSSM_CL_HANDLE()
  external int CLHandle;

  external CSSM_DATA_PTR Cert;

  external CSSM_TP_VERIFY_CONTEXT_PTR VerifyContext;
}

typedef CSSM_TP_CERTVERIFY_INPUT = cssm_tp_certverify_input;
typedef CSSM_TP_CERTVERIFY_INPUT_PTR = ffi.Pointer<cssm_tp_certverify_input>;
typedef CSSM_TP_CERTVERIFY_STATUS = uint32;

final class cssm_tp_certverify_output extends ffi.Struct {
  @CSSM_TP_CERTVERIFY_STATUS()
  external int VerifyStatus;

  @uint32()
  external int NumberOfEvidence;

  external CSSM_EVIDENCE_PTR Evidence;
}

typedef CSSM_TP_CERTVERIFY_OUTPUT = cssm_tp_certverify_output;
typedef CSSM_TP_CERTVERIFY_OUTPUT_PTR = ffi.Pointer<cssm_tp_certverify_output>;

final class cssm_tp_certnotarize_input extends ffi.Struct {
  @CSSM_CL_HANDLE()
  external int CLHandle;

  @uint32()
  external int NumberOfFields;

  external CSSM_FIELD_PTR MoreFields;

  external CSSM_FIELD_PTR SignScope;

  @uint32()
  external int ScopeSize;

  @CSSM_TP_SERVICES()
  external int MoreServiceRequests;

  @uint32()
  external int NumberOfServiceControls;

  external CSSM_FIELD_PTR ServiceControls;

  external CSSM_ACCESS_CREDENTIALS_PTR UserCredentials;
}

typedef CSSM_TP_CERTNOTARIZE_INPUT = cssm_tp_certnotarize_input;
typedef CSSM_TP_CERTNOTARIZE_INPUT_PTR
    = ffi.Pointer<cssm_tp_certnotarize_input>;
typedef CSSM_TP_CERTNOTARIZE_STATUS = uint32;

final class cssm_tp_certnotarize_output extends ffi.Struct {
  @CSSM_TP_CERTNOTARIZE_STATUS()
  external int NotarizeStatus;

  external CSSM_CERTGROUP_PTR NotarizedCertGroup;

  @CSSM_TP_SERVICES()
  external int PerformedServiceRequests;
}

typedef CSSM_TP_CERTNOTARIZE_OUTPUT = cssm_tp_certnotarize_output;
typedef CSSM_TP_CERTNOTARIZE_OUTPUT_PTR
    = ffi.Pointer<cssm_tp_certnotarize_output>;

final class cssm_tp_certreclaim_input extends ffi.Struct {
  @CSSM_CL_HANDLE()
  external int CLHandle;

  @uint32()
  external int NumberOfSelectionFields;

  external CSSM_FIELD_PTR SelectionFields;

  external CSSM_ACCESS_CREDENTIALS_PTR UserCredentials;
}

typedef CSSM_TP_CERTRECLAIM_INPUT = cssm_tp_certreclaim_input;
typedef CSSM_TP_CERTRECLAIM_INPUT_PTR = ffi.Pointer<cssm_tp_certreclaim_input>;
typedef CSSM_TP_CERTRECLAIM_STATUS = uint32;

final class cssm_tp_certreclaim_output extends ffi.Struct {
  @CSSM_TP_CERTRECLAIM_STATUS()
  external int ReclaimStatus;

  external CSSM_CERTGROUP_PTR ReclaimedCertGroup;

  @CSSM_LONG_HANDLE()
  external int KeyCacheHandle;
}

typedef CSSM_TP_CERTRECLAIM_OUTPUT = cssm_tp_certreclaim_output;
typedef CSSM_TP_CERTRECLAIM_OUTPUT_PTR
    = ffi.Pointer<cssm_tp_certreclaim_output>;

final class cssm_tp_crlissue_input extends ffi.Struct {
  @CSSM_CL_HANDLE()
  external int CLHandle;

  @uint32()
  external int CrlIdentifier;

  external CSSM_TIMESTRING CrlThisTime;

  external CSSM_FIELD_PTR PolicyIdentifier;

  external CSSM_ACCESS_CREDENTIALS_PTR CallerCredentials;
}

typedef CSSM_TP_CRLISSUE_INPUT = cssm_tp_crlissue_input;
typedef CSSM_TP_CRLISSUE_INPUT_PTR = ffi.Pointer<cssm_tp_crlissue_input>;
typedef CSSM_TP_CRLISSUE_STATUS = uint32;

final class cssm_tp_crlissue_output extends ffi.Struct {
  @CSSM_TP_CRLISSUE_STATUS()
  external int IssueStatus;

  external CSSM_ENCODED_CRL_PTR Crl;

  external CSSM_TIMESTRING CrlNextTime;
}

typedef CSSM_TP_CRLISSUE_OUTPUT = cssm_tp_crlissue_output;
typedef CSSM_TP_CRLISSUE_OUTPUT_PTR = ffi.Pointer<cssm_tp_crlissue_output>;
typedef CSSM_TP_FORM_TYPE = uint32;
typedef CSSM_CL_TEMPLATE_TYPE = uint32;
typedef CSSM_CERT_BUNDLE_TYPE = uint32;
typedef CSSM_CERT_BUNDLE_ENCODING = uint32;

final class cssm_cert_bundle_header extends ffi.Struct {
  @CSSM_CERT_BUNDLE_TYPE()
  external int BundleType;

  @CSSM_CERT_BUNDLE_ENCODING()
  external int BundleEncoding;
}

typedef CSSM_CERT_BUNDLE_HEADER = cssm_cert_bundle_header;
typedef CSSM_CERT_BUNDLE_HEADER_PTR = ffi.Pointer<cssm_cert_bundle_header>;

final class cssm_cert_bundle extends ffi.Struct {
  external CSSM_CERT_BUNDLE_HEADER BundleHeader;

  external SecAsn1Item Bundle;
}

typedef CSSM_CERT_BUNDLE = cssm_cert_bundle;
typedef CSSM_CERT_BUNDLE_PTR = ffi.Pointer<cssm_cert_bundle>;
typedef CSSM_DB_ATTRIBUTE_NAME_FORMAT = uint32;
typedef CSSM_DB_ATTRIBUTE_NAME_FORMAT_PTR = ffi.Pointer<uint32>;
typedef CSSM_DB_ATTRIBUTE_FORMAT = uint32;
typedef CSSM_DB_ATTRIBUTE_FORMAT_PTR = ffi.Pointer<uint32>;

final class cssm_db_attribute_label extends ffi.Union {
  external ffi.Pointer<ffi.Char> AttributeName;

  external SecAsn1Oid AttributeOID;

  @uint32()
  external int AttributeID;
}

final class cssm_db_attribute_info extends ffi.Struct {
  @CSSM_DB_ATTRIBUTE_NAME_FORMAT()
  external int AttributeNameFormat;

  external cssm_db_attribute_label Label;

  @CSSM_DB_ATTRIBUTE_FORMAT()
  external int AttributeFormat;
}

typedef CSSM_DB_ATTRIBUTE_INFO = cssm_db_attribute_info;
typedef CSSM_DB_ATTRIBUTE_INFO_PTR = ffi.Pointer<cssm_db_attribute_info>;

final class cssm_db_attribute_data extends ffi.Struct {
  external CSSM_DB_ATTRIBUTE_INFO Info;

  @uint32()
  external int NumberOfValues;

  external CSSM_DATA_PTR Value;
}

typedef CSSM_DB_ATTRIBUTE_DATA = cssm_db_attribute_data;
typedef CSSM_DB_ATTRIBUTE_DATA_PTR = ffi.Pointer<cssm_db_attribute_data>;
typedef CSSM_DB_RECORDTYPE = uint32;

final class cssm_db_record_attribute_info extends ffi.Struct {
  @CSSM_DB_RECORDTYPE()
  external int DataRecordType;

  @uint32()
  external int NumberOfAttributes;

  external CSSM_DB_ATTRIBUTE_INFO_PTR AttributeInfo;
}

typedef CSSM_DB_RECORD_ATTRIBUTE_INFO = cssm_db_record_attribute_info;
typedef CSSM_DB_RECORD_ATTRIBUTE_INFO_PTR
    = ffi.Pointer<cssm_db_record_attribute_info>;

final class cssm_db_record_attribute_data extends ffi.Struct {
  @CSSM_DB_RECORDTYPE()
  external int DataRecordType;

  @uint32()
  external int SemanticInformation;

  @uint32()
  external int NumberOfAttributes;

  external CSSM_DB_ATTRIBUTE_DATA_PTR AttributeData;
}

typedef CSSM_DB_RECORD_ATTRIBUTE_DATA = cssm_db_record_attribute_data;
typedef CSSM_DB_RECORD_ATTRIBUTE_DATA_PTR
    = ffi.Pointer<cssm_db_record_attribute_data>;

final class cssm_db_parsing_module_info extends ffi.Struct {
  @CSSM_DB_RECORDTYPE()
  external int RecordType;

  external CSSM_SUBSERVICE_UID ModuleSubserviceUid;
}

typedef CSSM_DB_PARSING_MODULE_INFO = cssm_db_parsing_module_info;
typedef CSSM_DB_PARSING_MODULE_INFO_PTR
    = ffi.Pointer<cssm_db_parsing_module_info>;
typedef CSSM_DB_INDEX_TYPE = uint32;
typedef CSSM_DB_INDEXED_DATA_LOCATION = uint32;

final class cssm_db_index_info extends ffi.Struct {
  @CSSM_DB_INDEX_TYPE()
  external int IndexType;

  @CSSM_DB_INDEXED_DATA_LOCATION()
  external int IndexedDataLocation;

  external CSSM_DB_ATTRIBUTE_INFO Info;
}

typedef CSSM_DB_INDEX_INFO = cssm_db_index_info;
typedef CSSM_DB_INDEX_INFO_PTR = ffi.Pointer<cssm_db_index_info>;

final class cssm_db_unique_record extends ffi.Struct {
  external CSSM_DB_INDEX_INFO RecordLocator;

  external SecAsn1Item RecordIdentifier;
}

typedef CSSM_DB_UNIQUE_RECORD = cssm_db_unique_record;
typedef CSSM_DB_UNIQUE_RECORD_PTR = ffi.Pointer<cssm_db_unique_record>;

final class cssm_db_record_index_info extends ffi.Struct {
  @CSSM_DB_RECORDTYPE()
  external int DataRecordType;

  @uint32()
  external int NumberOfIndexes;

  external CSSM_DB_INDEX_INFO_PTR IndexInfo;
}

typedef CSSM_DB_RECORD_INDEX_INFO = cssm_db_record_index_info;
typedef CSSM_DB_RECORD_INDEX_INFO_PTR = ffi.Pointer<cssm_db_record_index_info>;
typedef CSSM_DB_ACCESS_TYPE = uint32;
typedef CSSM_DB_ACCESS_TYPE_PTR = ffi.Pointer<uint32>;
typedef CSSM_DB_MODIFY_MODE = uint32;

final class cssm_dbinfo extends ffi.Struct {
  @uint32()
  external int NumberOfRecordTypes;

  external CSSM_DB_PARSING_MODULE_INFO_PTR DefaultParsingModules;

  external CSSM_DB_RECORD_ATTRIBUTE_INFO_PTR RecordAttributeNames;

  external CSSM_DB_RECORD_INDEX_INFO_PTR RecordIndexes;

  @CSSM_BOOL()
  external int IsLocal;

  external ffi.Pointer<ffi.Char> AccessPath;

  external ffi.Pointer<ffi.Void> Reserved;
}

typedef CSSM_DBINFO = cssm_dbinfo;
typedef CSSM_DBINFO_PTR = ffi.Pointer<cssm_dbinfo>;
typedef CSSM_DB_OPERATOR = uint32;
typedef CSSM_DB_OPERATOR_PTR = ffi.Pointer<uint32>;
typedef CSSM_DB_CONJUNCTIVE = uint32;
typedef CSSM_DB_CONJUNCTIVE_PTR = ffi.Pointer<uint32>;

final class cssm_selection_predicate extends ffi.Struct {
  @CSSM_DB_OPERATOR()
  external int DbOperator;

  external CSSM_DB_ATTRIBUTE_DATA Attribute;
}

typedef CSSM_SELECTION_PREDICATE = cssm_selection_predicate;
typedef CSSM_SELECTION_PREDICATE_PTR = ffi.Pointer<cssm_selection_predicate>;

final class cssm_query_limits extends ffi.Struct {
  @uint32()
  external int TimeLimit;

  @uint32()
  external int SizeLimit;
}

typedef CSSM_QUERY_LIMITS = cssm_query_limits;
typedef CSSM_QUERY_LIMITS_PTR = ffi.Pointer<cssm_query_limits>;
typedef CSSM_QUERY_FLAGS = uint32;

final class cssm_query extends ffi.Struct {
  @CSSM_DB_RECORDTYPE()
  external int RecordType;

  @CSSM_DB_CONJUNCTIVE()
  external int Conjunctive;

  @uint32()
  external int NumSelectionPredicates;

  external CSSM_SELECTION_PREDICATE_PTR SelectionPredicate;

  external CSSM_QUERY_LIMITS QueryLimits;

  @CSSM_QUERY_FLAGS()
  external int QueryFlags;
}

typedef CSSM_QUERY = cssm_query;
typedef CSSM_QUERY_PTR = ffi.Pointer<cssm_query>;
typedef CSSM_DLTYPE = uint32;
typedef CSSM_DLTYPE_PTR = ffi.Pointer<uint32>;
typedef CSSM_DL_CUSTOM_ATTRIBUTES = ffi.Pointer<ffi.Void>;
typedef CSSM_DL_LDAP_ATTRIBUTES = ffi.Pointer<ffi.Void>;
typedef CSSM_DL_ODBC_ATTRIBUTES = ffi.Pointer<ffi.Void>;
typedef CSSM_DL_FFS_ATTRIBUTES = ffi.Pointer<ffi.Void>;

final class cssm_dl_pkcs11_attributes extends ffi.Struct {
  @uint32()
  external int DeviceAccessFlags;
}

typedef CSSM_DL_PKCS11_ATTRIBUTE = ffi.Pointer<cssm_dl_pkcs11_attributes>;
typedef CSSM_DL_PKCS11_ATTRIBUTE_PTR = ffi.Pointer<cssm_dl_pkcs11_attributes>;

final class cssm_name_list extends ffi.Struct {
  @uint32()
  external int NumStrings;

  external ffi.Pointer<ffi.Pointer<ffi.Char>> String;
}

typedef CSSM_NAME_LIST = cssm_name_list;
typedef CSSM_NAME_LIST_PTR = ffi.Pointer<cssm_name_list>;
typedef CSSM_DB_RETRIEVAL_MODES = uint32;

final class cssm_db_schema_attribute_info extends ffi.Struct {
  @uint32()
  external int AttributeId;

  external ffi.Pointer<ffi.Char> AttributeName;

  external SecAsn1Oid AttributeNameID;

  @CSSM_DB_ATTRIBUTE_FORMAT()
  external int DataType;
}

typedef CSSM_DB_SCHEMA_ATTRIBUTE_INFO = cssm_db_schema_attribute_info;
typedef CSSM_DB_SCHEMA_ATTRIBUTE_INFO_PTR
    = ffi.Pointer<cssm_db_schema_attribute_info>;

final class cssm_db_schema_index_info extends ffi.Struct {
  @uint32()
  external int AttributeId;

  @uint32()
  external int IndexId;

  @CSSM_DB_INDEX_TYPE()
  external int IndexType;

  @CSSM_DB_INDEXED_DATA_LOCATION()
  external int IndexedDataLocation;
}

typedef CSSM_DB_SCHEMA_INDEX_INFO = cssm_db_schema_index_info;
typedef CSSM_DB_SCHEMA_INDEX_INFO_PTR = ffi.Pointer<cssm_db_schema_index_info>;
typedef CSSM_BER_TAG = uint8;
typedef CSSM_X509_ALGORITHM_IDENTIFIER_PTR = ffi.Pointer<SecAsn1AlgId>;

final class cssm_x509_type_value_pair extends ffi.Struct {
  external SecAsn1Oid type;

  @CSSM_BER_TAG()
  external int valueType;

  external SecAsn1Item value;
}

typedef CSSM_X509_TYPE_VALUE_PAIR = cssm_x509_type_value_pair;
typedef CSSM_X509_TYPE_VALUE_PAIR_PTR = ffi.Pointer<cssm_x509_type_value_pair>;

final class cssm_x509_rdn extends ffi.Struct {
  @uint32()
  external int numberOfPairs;

  external CSSM_X509_TYPE_VALUE_PAIR_PTR AttributeTypeAndValue;
}

typedef CSSM_X509_RDN = cssm_x509_rdn;
typedef CSSM_X509_RDN_PTR = ffi.Pointer<cssm_x509_rdn>;

final class cssm_x509_name extends ffi.Struct {
  @uint32()
  external int numberOfRDNs;

  external CSSM_X509_RDN_PTR RelativeDistinguishedName;
}

typedef CSSM_X509_NAME = cssm_x509_name;
typedef CSSM_X509_NAME_PTR = ffi.Pointer<cssm_x509_name>;
typedef CSSM_X509_SUBJECT_PUBLIC_KEY_INFO_PTR = ffi.Pointer<SecAsn1PubKeyInfo>;

final class cssm_x509_time extends ffi.Struct {
  @CSSM_BER_TAG()
  external int timeType;

  external SecAsn1Item time;
}

typedef CSSM_X509_TIME = cssm_x509_time;
typedef CSSM_X509_TIME_PTR = ffi.Pointer<cssm_x509_time>;

final class x509_validity extends ffi.Struct {
  external CSSM_X509_TIME notBefore;

  external CSSM_X509_TIME notAfter;
}

typedef CSSM_X509_VALIDITY = x509_validity;
typedef CSSM_X509_VALIDITY_PTR = ffi.Pointer<x509_validity>;
typedef CSSM_X509_OPTION = CSSM_BOOL;

final class cssm_x509ext_basicConstraints extends ffi.Struct {
  @CSSM_BOOL()
  external int cA;

  @CSSM_X509_OPTION()
  external int pathLenConstraintPresent;

  @uint32()
  external int pathLenConstraint;
}

typedef CSSM_X509EXT_BASICCONSTRAINTS = cssm_x509ext_basicConstraints;
typedef CSSM_X509EXT_BASICCONSTRAINTS_PTR
    = ffi.Pointer<cssm_x509ext_basicConstraints>;

enum extension_data_format {
  CSSM_X509_DATAFORMAT_ENCODED(0),
  CSSM_X509_DATAFORMAT_PARSED(1),
  CSSM_X509_DATAFORMAT_PAIR(2);

  final int value;
  const extension_data_format(this.value);

  static extension_data_format fromValue(int value) => switch (value) {
        0 => CSSM_X509_DATAFORMAT_ENCODED,
        1 => CSSM_X509_DATAFORMAT_PARSED,
        2 => CSSM_X509_DATAFORMAT_PAIR,
        _ => throw ArgumentError(
            "Unknown value for extension_data_format: $value"),
      };
}

final class cssm_x509_extensionTagAndValue extends ffi.Struct {
  @CSSM_BER_TAG()
  external int type;

  external SecAsn1Item value;
}

typedef CSSM_X509EXT_TAGandVALUE = cssm_x509_extensionTagAndValue;
typedef CSSM_X509EXT_TAGandVALUE_PTR
    = ffi.Pointer<cssm_x509_extensionTagAndValue>;

final class cssm_x509ext_pair extends ffi.Struct {
  external CSSM_X509EXT_TAGandVALUE tagAndValue;

  external ffi.Pointer<ffi.Void> parsedValue;
}

typedef CSSM_X509EXT_PAIR = cssm_x509ext_pair;
typedef CSSM_X509EXT_PAIR_PTR = ffi.Pointer<cssm_x509ext_pair>;

final class cssm_x509ext_value extends ffi.Union {
  external ffi.Pointer<CSSM_X509EXT_TAGandVALUE> tagAndValue;

  external ffi.Pointer<ffi.Void> parsedValue;

  external ffi.Pointer<CSSM_X509EXT_PAIR> valuePair;
}

final class cssm_x509_extension extends ffi.Struct {
  external SecAsn1Oid extnId;

  @CSSM_BOOL()
  external int critical;

  @ffi.UnsignedInt()
  external int formatAsInt;

  extension_data_format get format =>
      extension_data_format.fromValue(formatAsInt);

  external cssm_x509ext_value value;

  external SecAsn1Item BERvalue;
}

typedef CSSM_X509_EXTENSION = cssm_x509_extension;
typedef CSSM_X509_EXTENSION_PTR = ffi.Pointer<cssm_x509_extension>;

final class cssm_x509_extensions extends ffi.Struct {
  @uint32()
  external int numberOfExtensions;

  external CSSM_X509_EXTENSION_PTR extensions;
}

typedef CSSM_X509_EXTENSIONS = cssm_x509_extensions;
typedef CSSM_X509_EXTENSIONS_PTR = ffi.Pointer<cssm_x509_extensions>;

final class cssm_x509_tbs_certificate extends ffi.Struct {
  external SecAsn1Item version;

  external SecAsn1Item serialNumber;

  external SecAsn1AlgId signature;

  external CSSM_X509_NAME issuer;

  external CSSM_X509_VALIDITY validity;

  external CSSM_X509_NAME subject;

  external SecAsn1PubKeyInfo subjectPublicKeyInfo;

  external SecAsn1Item issuerUniqueIdentifier;

  external SecAsn1Item subjectUniqueIdentifier;

  external CSSM_X509_EXTENSIONS extensions;
}

typedef CSSM_X509_TBS_CERTIFICATE = cssm_x509_tbs_certificate;
typedef CSSM_X509_TBS_CERTIFICATE_PTR = ffi.Pointer<cssm_x509_tbs_certificate>;

final class cssm_x509_signature extends ffi.Struct {
  external SecAsn1AlgId algorithmIdentifier;

  external SecAsn1Item encrypted;
}

typedef CSSM_X509_SIGNATURE = cssm_x509_signature;
typedef CSSM_X509_SIGNATURE_PTR = ffi.Pointer<cssm_x509_signature>;

final class cssm_x509_signed_certificate extends ffi.Struct {
  external CSSM_X509_TBS_CERTIFICATE certificate;

  external CSSM_X509_SIGNATURE signature;
}

typedef CSSM_X509_SIGNED_CERTIFICATE = cssm_x509_signed_certificate;
typedef CSSM_X509_SIGNED_CERTIFICATE_PTR
    = ffi.Pointer<cssm_x509_signed_certificate>;

final class cssm_x509ext_policyQualifierInfo extends ffi.Struct {
  external SecAsn1Oid policyQualifierId;

  external SecAsn1Item value;
}

typedef CSSM_X509EXT_POLICYQUALIFIERINFO = cssm_x509ext_policyQualifierInfo;
typedef CSSM_X509EXT_POLICYQUALIFIERINFO_PTR
    = ffi.Pointer<cssm_x509ext_policyQualifierInfo>;

final class cssm_x509ext_policyQualifiers extends ffi.Struct {
  @uint32()
  external int numberOfPolicyQualifiers;

  external ffi.Pointer<CSSM_X509EXT_POLICYQUALIFIERINFO> policyQualifier;
}

typedef CSSM_X509EXT_POLICYQUALIFIERS = cssm_x509ext_policyQualifiers;
typedef CSSM_X509EXT_POLICYQUALIFIERS_PTR
    = ffi.Pointer<cssm_x509ext_policyQualifiers>;

final class cssm_x509ext_policyInfo extends ffi.Struct {
  external SecAsn1Oid policyIdentifier;

  external CSSM_X509EXT_POLICYQUALIFIERS policyQualifiers;
}

typedef CSSM_X509EXT_POLICYINFO = cssm_x509ext_policyInfo;
typedef CSSM_X509EXT_POLICYINFO_PTR = ffi.Pointer<cssm_x509ext_policyInfo>;

final class cssm_x509_revoked_cert_entry extends ffi.Struct {
  external SecAsn1Item certificateSerialNumber;

  external CSSM_X509_TIME revocationDate;

  external CSSM_X509_EXTENSIONS extensions;
}

typedef CSSM_X509_REVOKED_CERT_ENTRY = cssm_x509_revoked_cert_entry;
typedef CSSM_X509_REVOKED_CERT_ENTRY_PTR
    = ffi.Pointer<cssm_x509_revoked_cert_entry>;

final class cssm_x509_revoked_cert_list extends ffi.Struct {
  @uint32()
  external int numberOfRevokedCertEntries;

  external CSSM_X509_REVOKED_CERT_ENTRY_PTR revokedCertEntry;
}

typedef CSSM_X509_REVOKED_CERT_LIST = cssm_x509_revoked_cert_list;
typedef CSSM_X509_REVOKED_CERT_LIST_PTR
    = ffi.Pointer<cssm_x509_revoked_cert_list>;

final class cssm_x509_tbs_certlist extends ffi.Struct {
  external SecAsn1Item version;

  external SecAsn1AlgId signature;

  external CSSM_X509_NAME issuer;

  external CSSM_X509_TIME thisUpdate;

  external CSSM_X509_TIME nextUpdate;

  external CSSM_X509_REVOKED_CERT_LIST_PTR revokedCertificates;

  external CSSM_X509_EXTENSIONS extensions;
}

typedef CSSM_X509_TBS_CERTLIST = cssm_x509_tbs_certlist;
typedef CSSM_X509_TBS_CERTLIST_PTR = ffi.Pointer<cssm_x509_tbs_certlist>;

final class cssm_x509_signed_crl extends ffi.Struct {
  external CSSM_X509_TBS_CERTLIST tbsCertList;

  external CSSM_X509_SIGNATURE signature;
}

typedef CSSM_X509_SIGNED_CRL = cssm_x509_signed_crl;
typedef CSSM_X509_SIGNED_CRL_PTR = ffi.Pointer<cssm_x509_signed_crl>;

enum __CE_GeneralNameType {
  GNT_OtherName(0),
  GNT_RFC822Name(1),
  GNT_DNSName(2),
  GNT_X400Address(3),
  GNT_DirectoryName(4),
  GNT_EdiPartyName(5),
  GNT_URI(6),
  GNT_IPAddress(7),
  GNT_RegisteredID(8);

  final int value;
  const __CE_GeneralNameType(this.value);

  static __CE_GeneralNameType fromValue(int value) => switch (value) {
        0 => GNT_OtherName,
        1 => GNT_RFC822Name,
        2 => GNT_DNSName,
        3 => GNT_X400Address,
        4 => GNT_DirectoryName,
        5 => GNT_EdiPartyName,
        6 => GNT_URI,
        7 => GNT_IPAddress,
        8 => GNT_RegisteredID,
        _ =>
          throw ArgumentError("Unknown value for __CE_GeneralNameType: $value"),
      };
}

final class __CE_OtherName extends ffi.Struct {
  external SecAsn1Oid typeId;

  external SecAsn1Item value;
}

typedef CE_OtherName = __CE_OtherName;

final class __CE_GeneralName extends ffi.Struct {
  @ffi.UnsignedInt()
  external int nameTypeAsInt;

  __CE_GeneralNameType get nameType =>
      __CE_GeneralNameType.fromValue(nameTypeAsInt);

  @CSSM_BOOL()
  external int berEncoded;

  external SecAsn1Item name;
}

typedef CE_GeneralName = __CE_GeneralName;

final class __CE_GeneralNames extends ffi.Struct {
  @uint32()
  external int numNames;

  external ffi.Pointer<CE_GeneralName> generalName;
}

typedef CE_GeneralNames = __CE_GeneralNames;

final class __CE_AuthorityKeyID extends ffi.Struct {
  @CSSM_BOOL()
  external int keyIdentifierPresent;

  external SecAsn1Item keyIdentifier;

  @CSSM_BOOL()
  external int generalNamesPresent;

  external ffi.Pointer<CE_GeneralNames> generalNames;

  @CSSM_BOOL()
  external int serialNumberPresent;

  external SecAsn1Item serialNumber;
}

typedef CE_AuthorityKeyID = __CE_AuthorityKeyID;
typedef CE_SubjectKeyID = SecAsn1Item;
typedef CE_KeyUsage = uint16;
typedef CE_CrlReason = uint32;

final class __CE_ExtendedKeyUsage extends ffi.Struct {
  @uint32()
  external int numPurposes;

  external CSSM_OID_PTR purposes;
}

typedef CE_ExtendedKeyUsage = __CE_ExtendedKeyUsage;

final class __CE_BasicConstraints extends ffi.Struct {
  @CSSM_BOOL()
  external int cA;

  @CSSM_BOOL()
  external int pathLenConstraintPresent;

  @uint32()
  external int pathLenConstraint;
}

typedef CE_BasicConstraints = __CE_BasicConstraints;

final class __CE_PolicyQualifierInfo extends ffi.Struct {
  external SecAsn1Oid policyQualifierId;

  external SecAsn1Item qualifier;
}

typedef CE_PolicyQualifierInfo = __CE_PolicyQualifierInfo;

final class __CE_PolicyInformation extends ffi.Struct {
  external SecAsn1Oid certPolicyId;

  @uint32()
  external int numPolicyQualifiers;

  external ffi.Pointer<CE_PolicyQualifierInfo> policyQualifiers;
}

typedef CE_PolicyInformation = __CE_PolicyInformation;

final class __CE_CertPolicies extends ffi.Struct {
  @uint32()
  external int numPolicies;

  external ffi.Pointer<CE_PolicyInformation> policies;
}

typedef CE_CertPolicies = __CE_CertPolicies;
typedef CE_NetscapeCertType = uint16;
typedef CE_CrlDistReasonFlags = uint8;

enum __CE_CrlDistributionPointNameType {
  CE_CDNT_FullName(0),
  CE_CDNT_NameRelativeToCrlIssuer(1);

  final int value;
  const __CE_CrlDistributionPointNameType(this.value);

  static __CE_CrlDistributionPointNameType fromValue(int value) =>
      switch (value) {
        0 => CE_CDNT_FullName,
        1 => CE_CDNT_NameRelativeToCrlIssuer,
        _ => throw ArgumentError(
            "Unknown value for __CE_CrlDistributionPointNameType: $value"),
      };
}

final class UnnamedUnion5 extends ffi.Union {
  external ffi.Pointer<CE_GeneralNames> fullName;

  external CSSM_X509_RDN_PTR rdn;
}

final class __CE_DistributionPointName extends ffi.Struct {
  @ffi.UnsignedInt()
  external int nameTypeAsInt;

  __CE_CrlDistributionPointNameType get nameType =>
      __CE_CrlDistributionPointNameType.fromValue(nameTypeAsInt);

  external UnnamedUnion5 dpn;
}

typedef CE_DistributionPointName = __CE_DistributionPointName;

final class __CE_CRLDistributionPoint extends ffi.Struct {
  external ffi.Pointer<CE_DistributionPointName> distPointName;

  @CSSM_BOOL()
  external int reasonsPresent;

  @CE_CrlDistReasonFlags()
  external int reasons;

  external ffi.Pointer<CE_GeneralNames> crlIssuer;
}

typedef CE_CRLDistributionPoint = __CE_CRLDistributionPoint;

final class __CE_CRLDistPointsSyntax extends ffi.Struct {
  @uint32()
  external int numDistPoints;

  external ffi.Pointer<CE_CRLDistributionPoint> distPoints;
}

typedef CE_CRLDistPointsSyntax = __CE_CRLDistPointsSyntax;

final class __CE_AccessDescription extends ffi.Struct {
  external SecAsn1Oid accessMethod;

  external CE_GeneralName accessLocation;
}

typedef CE_AccessDescription = __CE_AccessDescription;

final class __CE_AuthorityInfoAccess extends ffi.Struct {
  @uint32()
  external int numAccessDescriptions;

  external ffi.Pointer<CE_AccessDescription> accessDescriptions;
}

typedef CE_AuthorityInfoAccess = __CE_AuthorityInfoAccess;
typedef CE_NameRegistrationAuthorities = CE_GeneralNames;

final class __CE_SemanticsInformation extends ffi.Struct {
  external ffi.Pointer<SecAsn1Oid> semanticsIdentifier;

  external ffi.Pointer<CE_NameRegistrationAuthorities>
      nameRegistrationAuthorities;
}

typedef CE_SemanticsInformation = __CE_SemanticsInformation;

final class __CE_QC_Statement extends ffi.Struct {
  external SecAsn1Oid statementId;

  external ffi.Pointer<CE_SemanticsInformation> semanticsInfo;

  external ffi.Pointer<SecAsn1Item> otherInfo;
}

typedef CE_QC_Statement = __CE_QC_Statement;

final class __CE_QC_Statements extends ffi.Struct {
  @uint32()
  external int numQCStatements;

  external ffi.Pointer<CE_QC_Statement> qcStatements;
}

typedef CE_QC_Statements = __CE_QC_Statements;
typedef CE_CrlNumber = uint32;
typedef CE_DeltaCrl = uint32;

final class __CE_IssuingDistributionPoint extends ffi.Struct {
  external ffi.Pointer<CE_DistributionPointName> distPointName;

  @CSSM_BOOL()
  external int onlyUserCertsPresent;

  @CSSM_BOOL()
  external int onlyUserCerts;

  @CSSM_BOOL()
  external int onlyCACertsPresent;

  @CSSM_BOOL()
  external int onlyCACerts;

  @CSSM_BOOL()
  external int onlySomeReasonsPresent;

  @CE_CrlDistReasonFlags()
  external int onlySomeReasons;

  @CSSM_BOOL()
  external int indirectCrlPresent;

  @CSSM_BOOL()
  external int indirectCrl;
}

typedef CE_IssuingDistributionPoint = __CE_IssuingDistributionPoint;

final class __CE_GeneralSubtree extends ffi.Struct {
  external ffi.Pointer<CE_GeneralNames> base;

  @uint32()
  external int minimum;

  @CSSM_BOOL()
  external int maximumPresent;

  @uint32()
  external int maximum;
}

typedef CE_GeneralSubtree = __CE_GeneralSubtree;

final class __CE_GeneralSubtrees extends ffi.Struct {
  @uint32()
  external int numSubtrees;

  external ffi.Pointer<CE_GeneralSubtree> subtrees;
}

typedef CE_GeneralSubtrees = __CE_GeneralSubtrees;

final class __CE_NameConstraints extends ffi.Struct {
  external ffi.Pointer<CE_GeneralSubtrees> permitted;

  external ffi.Pointer<CE_GeneralSubtrees> excluded;
}

typedef CE_NameConstraints = __CE_NameConstraints;

final class __CE_PolicyMapping extends ffi.Struct {
  external SecAsn1Oid issuerDomainPolicy;

  external SecAsn1Oid subjectDomainPolicy;
}

typedef CE_PolicyMapping = __CE_PolicyMapping;

final class __CE_PolicyMappings extends ffi.Struct {
  @uint32()
  external int numPolicyMappings;

  external ffi.Pointer<CE_PolicyMapping> policyMappings;
}

typedef CE_PolicyMappings = __CE_PolicyMappings;

final class __CE_PolicyConstraints extends ffi.Struct {
  @CSSM_BOOL()
  external int requireExplicitPolicyPresent;

  @uint32()
  external int requireExplicitPolicy;

  @CSSM_BOOL()
  external int inhibitPolicyMappingPresent;

  @uint32()
  external int inhibitPolicyMapping;
}

typedef CE_PolicyConstraints = __CE_PolicyConstraints;
typedef CE_InhibitAnyPolicy = uint32;

enum __CE_DataType {
  DT_AuthorityKeyID(0),
  DT_SubjectKeyID(1),
  DT_KeyUsage(2),
  DT_SubjectAltName(3),
  DT_IssuerAltName(4),
  DT_ExtendedKeyUsage(5),
  DT_BasicConstraints(6),
  DT_CertPolicies(7),
  DT_NetscapeCertType(8),
  DT_CrlNumber(9),
  DT_DeltaCrl(10),
  DT_CrlReason(11),
  DT_CrlDistributionPoints(12),
  DT_IssuingDistributionPoint(13),
  DT_AuthorityInfoAccess(14),
  DT_Other(15),
  DT_QC_Statements(16),
  DT_NameConstraints(17),
  DT_PolicyMappings(18),
  DT_PolicyConstraints(19),
  DT_InhibitAnyPolicy(20);

  final int value;
  const __CE_DataType(this.value);

  static __CE_DataType fromValue(int value) => switch (value) {
        0 => DT_AuthorityKeyID,
        1 => DT_SubjectKeyID,
        2 => DT_KeyUsage,
        3 => DT_SubjectAltName,
        4 => DT_IssuerAltName,
        5 => DT_ExtendedKeyUsage,
        6 => DT_BasicConstraints,
        7 => DT_CertPolicies,
        8 => DT_NetscapeCertType,
        9 => DT_CrlNumber,
        10 => DT_DeltaCrl,
        11 => DT_CrlReason,
        12 => DT_CrlDistributionPoints,
        13 => DT_IssuingDistributionPoint,
        14 => DT_AuthorityInfoAccess,
        15 => DT_Other,
        16 => DT_QC_Statements,
        17 => DT_NameConstraints,
        18 => DT_PolicyMappings,
        19 => DT_PolicyConstraints,
        20 => DT_InhibitAnyPolicy,
        _ => throw ArgumentError("Unknown value for __CE_DataType: $value"),
      };
}

final class CE_Data extends ffi.Union {
  external CE_AuthorityKeyID authorityKeyID;

  external CE_SubjectKeyID subjectKeyID;

  @CE_KeyUsage()
  external int keyUsage;

  external CE_GeneralNames subjectAltName;

  external CE_GeneralNames issuerAltName;

  external CE_ExtendedKeyUsage extendedKeyUsage;

  external CE_BasicConstraints basicConstraints;

  external CE_CertPolicies certPolicies;

  @CE_NetscapeCertType()
  external int netscapeCertType;

  @CE_CrlNumber()
  external int crlNumber;

  @CE_DeltaCrl()
  external int deltaCrl;

  @CE_CrlReason()
  external int crlReason;

  external CE_CRLDistPointsSyntax crlDistPoints;

  external CE_IssuingDistributionPoint issuingDistPoint;

  external CE_AuthorityInfoAccess authorityInfoAccess;

  external CE_QC_Statements qualifiedCertStatements;

  external CE_NameConstraints nameConstraints;

  external CE_PolicyMappings policyMappings;

  external CE_PolicyConstraints policyConstraints;

  @CE_InhibitAnyPolicy()
  external int inhibitAnyPolicy;

  external SecAsn1Item rawData;
}

final class __CE_DataAndType extends ffi.Struct {
  @ffi.UnsignedInt()
  external int typeAsInt;

  __CE_DataType get type => __CE_DataType.fromValue(typeAsInt);

  external CE_Data extension1;

  @CSSM_BOOL()
  external int critical;
}

typedef CE_DataAndType = __CE_DataAndType;

final class cssm_acl_process_subject_selector extends ffi.Struct {
  @uint16()
  external int version;

  @uint16()
  external int mask;

  @uint32()
  external int uid;

  @uint32()
  external int gid;
}

typedef CSSM_ACL_PROCESS_SUBJECT_SELECTOR = cssm_acl_process_subject_selector;

final class cssm_acl_keychain_prompt_selector extends ffi.Struct {
  @uint16()
  external int version;

  @uint16()
  external int flags;
}

typedef CSSM_ACL_KEYCHAIN_PROMPT_SELECTOR = cssm_acl_keychain_prompt_selector;
typedef CSSM_ACL_PREAUTH_TRACKING_STATE = uint32;

final class cssm_appledl_open_parameters extends ffi.Struct {
  @uint32()
  external int length;

  @uint32()
  external int version;

  @CSSM_BOOL()
  external int autoCommit;

  @uint32()
  external int mask;

  @mode_t()
  external int mode;
}

typedef CSSM_APPLEDL_OPEN_PARAMETERS = cssm_appledl_open_parameters;
typedef CSSM_APPLEDL_OPEN_PARAMETERS_PTR
    = ffi.Pointer<cssm_appledl_open_parameters>;

final class cssm_applecspdl_db_settings_parameters extends ffi.Struct {
  @uint32()
  external int idleTimeout;

  @uint8()
  external int lockOnSleep;
}

typedef CSSM_APPLECSPDL_DB_SETTINGS_PARAMETERS
    = cssm_applecspdl_db_settings_parameters;
typedef CSSM_APPLECSPDL_DB_SETTINGS_PARAMETERS_PTR
    = ffi.Pointer<cssm_applecspdl_db_settings_parameters>;

final class cssm_applecspdl_db_is_locked_parameters extends ffi.Struct {
  @uint8()
  external int isLocked;
}

typedef CSSM_APPLECSPDL_DB_IS_LOCKED_PARAMETERS
    = cssm_applecspdl_db_is_locked_parameters;
typedef CSSM_APPLECSPDL_DB_IS_LOCKED_PARAMETERS_PTR
    = ffi.Pointer<cssm_applecspdl_db_is_locked_parameters>;

final class cssm_applecspdl_db_change_password_parameters extends ffi.Struct {
  external ffi.Pointer<CSSM_ACCESS_CREDENTIALS> accessCredentials;
}

typedef CSSM_APPLECSPDL_DB_CHANGE_PASSWORD_PARAMETERS
    = cssm_applecspdl_db_change_password_parameters;
typedef CSSM_APPLECSPDL_DB_CHANGE_PASSWORD_PARAMETERS_PTR
    = ffi.Pointer<cssm_applecspdl_db_change_password_parameters>;

final class CSSM_APPLE_TP_NAME_OID extends ffi.Struct {
  external ffi.Pointer<ffi.Char> string;

  external ffi.Pointer<SecAsn1Oid> oid;
}

final class CSSM_APPLE_TP_CERT_REQUEST extends ffi.Struct {
  @CSSM_CSP_HANDLE()
  external int cspHand;

  @CSSM_CL_HANDLE()
  external int clHand;

  @uint32()
  external int serialNumber;

  @uint32()
  external int numSubjectNames;

  external ffi.Pointer<CSSM_APPLE_TP_NAME_OID> subjectNames;

  @uint32()
  external int numIssuerNames;

  external ffi.Pointer<CSSM_APPLE_TP_NAME_OID> issuerNames;

  external CSSM_X509_NAME_PTR issuerNameX509;

  external ffi.Pointer<CSSM_KEY> certPublicKey;

  external ffi.Pointer<CSSM_KEY> issuerPrivateKey;

  @CSSM_ALGORITHMS()
  external int signatureAlg;

  external SecAsn1Oid signatureOid;

  @uint32()
  external int notBefore;

  @uint32()
  external int notAfter;

  @uint32()
  external int numExtensions;

  external ffi.Pointer<CE_DataAndType> extensions;

  external ffi.Pointer<ffi.Char> challengeString;
}

final class CSSM_APPLE_TP_SSL_OPTIONS extends ffi.Struct {
  @uint32()
  external int Version;

  @uint32()
  external int ServerNameLen;

  external ffi.Pointer<ffi.Char> ServerName;

  @uint32()
  external int Flags;
}

typedef CSSM_APPLE_TP_CRL_OPT_FLAGS = uint32;

final class CSSM_APPLE_TP_CRL_OPTIONS extends ffi.Struct {
  @uint32()
  external int Version;

  @CSSM_APPLE_TP_CRL_OPT_FLAGS()
  external int CrlFlags;

  external CSSM_DL_DB_HANDLE_PTR crlStore;
}

final class CSSM_APPLE_TP_SMIME_OPTIONS extends ffi.Struct {
  @uint32()
  external int Version;

  @CE_KeyUsage()
  external int IntendedUsage;

  @uint32()
  external int SenderEmailLen;

  external ffi.Pointer<ffi.Char> SenderEmail;
}

typedef CSSM_APPLE_TP_ACTION_FLAGS = uint32;

final class CSSM_APPLE_TP_ACTION_DATA extends ffi.Struct {
  @uint32()
  external int Version;

  @CSSM_APPLE_TP_ACTION_FLAGS()
  external int ActionFlags;
}

typedef CSSM_TP_APPLE_CERT_STATUS = uint32;

final class CSSM_TP_APPLE_EVIDENCE_INFO extends ffi.Struct {
  @CSSM_TP_APPLE_CERT_STATUS()
  external int StatusBits;

  @uint32()
  external int NumStatusCodes;

  external ffi.Pointer<CSSM_RETURN> StatusCodes;

  @uint32()
  external int Index;

  external CSSM_DL_DB_HANDLE DlDbHandle;

  external CSSM_DB_UNIQUE_RECORD_PTR UniqueRecord;
}

final class CSSM_TP_APPLE_EVIDENCE_HEADER extends ffi.Struct {
  @uint32()
  external int Version;
}

final class CSSM_APPLE_CL_CSR_REQUEST extends ffi.Struct {
  external CSSM_X509_NAME_PTR subjectNameX509;

  @CSSM_ALGORITHMS()
  external int signatureAlg;

  external SecAsn1Oid signatureOid;

  @CSSM_CSP_HANDLE()
  external int cspHand;

  external ffi.Pointer<CSSM_KEY> subjectPublicKey;

  external ffi.Pointer<CSSM_KEY> subjectPrivateKey;

  external ffi.Pointer<ffi.Char> challengeString;
}

enum SecTrustResultType {
  kSecTrustResultInvalid(0),
  kSecTrustResultProceed(1),
  kSecTrustResultConfirm(2),
  kSecTrustResultDeny(3),
  kSecTrustResultUnspecified(4),
  kSecTrustResultRecoverableTrustFailure(5),
  kSecTrustResultFatalTrustFailure(6),
  kSecTrustResultOtherError(7);

  final int value;
  const SecTrustResultType(this.value);

  static SecTrustResultType fromValue(int value) => switch (value) {
        0 => kSecTrustResultInvalid,
        1 => kSecTrustResultProceed,
        2 => kSecTrustResultConfirm,
        3 => kSecTrustResultDeny,
        4 => kSecTrustResultUnspecified,
        5 => kSecTrustResultRecoverableTrustFailure,
        6 => kSecTrustResultFatalTrustFailure,
        7 => kSecTrustResultOtherError,
        _ =>
          throw ArgumentError("Unknown value for SecTrustResultType: $value"),
      };
}

final class __SecTrust extends ffi.Opaque {}

typedef SecTrustRef = ffi.Pointer<__SecTrust>;
void _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, SecTrustRef arg0, int arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(SecTrustRef arg0, ffi.Uint32 arg1)>>()
        .asFunction<void Function(SecTrustRef, int)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, SecTrustRef, ffi.Uint32)>(
            _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, SecTrustRef arg0, int arg1) =>
    (objc.getBlockClosure(block) as void Function(SecTrustRef, int))(
        arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, SecTrustRef, ffi.Uint32)>(
            _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, SecTrustRef arg0, int arg1) {
  (objc.getBlockClosure(block) as void Function(SecTrustRef, int))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, SecTrustRef, ffi.Uint32)>
    _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, SecTrustRef,
                ffi.Uint32)>.listener(
        _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    SecTrustRef arg0,
    int arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(SecTrustRef, int))(
        arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, SecTrustRef, ffi.Uint32)>
    _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, SecTrustRef, ffi.Uint32)>.isolateLocal(
        _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, SecTrustRef, ffi.Uint32)>
    _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, SecTrustRef, ffi.Uint32)>.listener(
        _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)>`.
abstract final class ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<__SecTrust>,
                  ffi.Uint32)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(SecTrustRef arg0, ffi.Uint32 arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)> fromFunction(
          void Function(SecTrustRef, SecTrustResultType) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_closureCallable,
              (SecTrustRef arg0, int arg1) =>
                  fn(arg0, SecTrustResultType.fromValue(arg1))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)>
      listener(void Function(SecTrustRef, SecTrustResultType) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_listenerCallable
            .nativeFunction
            .cast(),
        (SecTrustRef arg0, int arg1) =>
            fn(arg0, SecTrustResultType.fromValue(arg1)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_gwxhxt(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)>
      blocking(void Function(SecTrustRef, SecTrustResultType) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_blockingCallable
            .nativeFunction
            .cast(),
        (SecTrustRef arg0, int arg1) =>
            fn(arg0, SecTrustResultType.fromValue(arg1)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_blockingListenerCallable
            .nativeFunction
            .cast(),
        (SecTrustRef arg0, int arg1) =>
            fn(arg0, SecTrustResultType.fromValue(arg1)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_gwxhxt, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)>`.
extension ObjCBlock_ffiVoid_SecTrustRef_SecTrustResultType_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)> {
  void call(SecTrustRef arg0, SecTrustResultType arg1) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  SecTrustRef arg0, ffi.Uint32 arg1)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>, SecTrustRef,
              int)>()(ref.pointer, arg0, arg1.value);
}

typedef SecTrustCallback = ffi.Pointer<objc.ObjCBlockImpl>;
typedef DartSecTrustCallback
    = objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Uint32)>;
void _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        SecTrustRef arg0,
        bool arg1,
        CFErrorRef arg2) =>
    block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        SecTrustRef arg0, ffi.Bool arg1, CFErrorRef arg2)>>()
            .asFunction<void Function(SecTrustRef, bool, CFErrorRef)>()(
        arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, SecTrustRef,
                    ffi.Bool, CFErrorRef)>(
            _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        SecTrustRef arg0,
        bool arg1,
        CFErrorRef arg2) =>
    (objc.getBlockClosure(block) as void Function(
        SecTrustRef, bool, CFErrorRef))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, SecTrustRef,
                    ffi.Bool, CFErrorRef)>(
            _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    SecTrustRef arg0,
    bool arg1,
    CFErrorRef arg2) {
  (objc.getBlockClosure(block) as void Function(SecTrustRef, bool, CFErrorRef))(
      arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, SecTrustRef, ffi.Bool, CFErrorRef)>
    _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, SecTrustRef,
                ffi.Bool, CFErrorRef)>.listener(
        _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    SecTrustRef arg0,
    bool arg1,
    CFErrorRef arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        SecTrustRef, bool, CFErrorRef))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, SecTrustRef, ffi.Bool, CFErrorRef)>
    _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                SecTrustRef,
                ffi.Bool,
                CFErrorRef)>.isolateLocal(
        _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, SecTrustRef, ffi.Bool, CFErrorRef)>
    _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                SecTrustRef,
                ffi.Bool,
                CFErrorRef)>.listener(
        _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Bool, ffi.Pointer<__CFError>)>`.
abstract final class ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<__SecTrust>, ffi.Bool, ffi.Pointer<__CFError>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Bool,
                      ffi.Pointer<__CFError>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Bool, ffi.Pointer<__CFError>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(SecTrustRef arg0, ffi.Bool arg1, CFErrorRef arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Bool,
                      ffi.Pointer<__CFError>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Bool, ffi.Pointer<__CFError>)>
      fromFunction(void Function(SecTrustRef, bool, CFErrorRef) fn) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Bool,
                      ffi.Pointer<__CFError>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_closureCallable,
                  (SecTrustRef arg0, bool arg1, CFErrorRef arg2) =>
                      fn(arg0, arg1, arg2)),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<__SecTrust>, ffi.Bool, ffi.Pointer<__CFError>)> listener(
      void Function(SecTrustRef, bool, CFErrorRef) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_listenerCallable
            .nativeFunction
            .cast(),
        (SecTrustRef arg0, bool arg1, CFErrorRef arg2) => fn(arg0, arg1, arg2));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_k73ff5(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Bool,
            ffi.Pointer<__CFError>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<__SecTrust>, ffi.Bool, ffi.Pointer<__CFError>)> blocking(
      void Function(SecTrustRef, bool, CFErrorRef) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_blockingCallable
            .nativeFunction
            .cast(),
        (SecTrustRef arg0, bool arg1, CFErrorRef arg2) => fn(arg0, arg1, arg2));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_blockingListenerCallable
            .nativeFunction
            .cast(),
        (SecTrustRef arg0, bool arg1, CFErrorRef arg2) => fn(arg0, arg1, arg2));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_k73ff5, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Bool,
            ffi.Pointer<__CFError>)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<__SecTrust>, ffi.Bool, ffi.Pointer<__CFError>)>`.
extension ObjCBlock_ffiVoid_SecTrustRef_bool_CFErrorRef_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<__SecTrust>, ffi.Bool, ffi.Pointer<__CFError>)> {
  void call(SecTrustRef arg0, bool arg1, CFErrorRef arg2) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      SecTrustRef arg0, ffi.Bool arg1, CFErrorRef arg2)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>, SecTrustRef, bool,
                  CFErrorRef)>()(ref.pointer, arg0, arg1, arg2);
}

typedef SecTrustWithErrorCallback = ffi.Pointer<objc.ObjCBlockImpl>;
typedef DartSecTrustWithErrorCallback = objc.ObjCBlock<
    ffi.Void Function(
        ffi.Pointer<__SecTrust>, ffi.Bool, ffi.Pointer<__CFError>)>;

enum SecTrustOptionFlags {
  kSecTrustOptionAllowExpired(1),
  kSecTrustOptionLeafIsCA(2),
  kSecTrustOptionFetchIssuerFromNet(4),
  kSecTrustOptionAllowExpiredRoot(8),
  kSecTrustOptionRequireRevPerCert(16),
  kSecTrustOptionUseTrustSettings(32),
  kSecTrustOptionImplicitAnchors(64);

  final int value;
  const SecTrustOptionFlags(this.value);

  static SecTrustOptionFlags fromValue(int value) => switch (value) {
        1 => kSecTrustOptionAllowExpired,
        2 => kSecTrustOptionLeafIsCA,
        4 => kSecTrustOptionFetchIssuerFromNet,
        8 => kSecTrustOptionAllowExpiredRoot,
        16 => kSecTrustOptionRequireRevPerCert,
        32 => kSecTrustOptionUseTrustSettings,
        64 => kSecTrustOptionImplicitAnchors,
        _ =>
          throw ArgumentError("Unknown value for SecTrustOptionFlags: $value"),
      };
}

typedef SSLCipherSuite = ffi.Uint16;
typedef DartSSLCipherSuite = int;

enum SSLCiphersuiteGroup {
  kSSLCiphersuiteGroupDefault(0),
  kSSLCiphersuiteGroupCompatibility(1),
  kSSLCiphersuiteGroupLegacy(2),
  kSSLCiphersuiteGroupATS(3),
  kSSLCiphersuiteGroupATSCompatibility(4);

  final int value;
  const SSLCiphersuiteGroup(this.value);

  static SSLCiphersuiteGroup fromValue(int value) => switch (value) {
        0 => kSSLCiphersuiteGroupDefault,
        1 => kSSLCiphersuiteGroupCompatibility,
        2 => kSSLCiphersuiteGroupLegacy,
        3 => kSSLCiphersuiteGroupATS,
        4 => kSSLCiphersuiteGroupATSCompatibility,
        _ =>
          throw ArgumentError("Unknown value for SSLCiphersuiteGroup: $value"),
      };
}

typedef sec_trust_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartsec_trust_t = objc.NSObject;
typedef sec_identity_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartsec_identity_t = objc.NSObject;
typedef sec_certificate_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartsec_certificate_t = objc.NSObject;

enum tls_protocol_version_t {
  tls_protocol_version_TLSv10(769),
  tls_protocol_version_TLSv11(770),
  tls_protocol_version_TLSv12(771),
  tls_protocol_version_TLSv13(772),
  tls_protocol_version_DTLSv10(-257),
  tls_protocol_version_DTLSv12(-259);

  final int value;
  const tls_protocol_version_t(this.value);

  static tls_protocol_version_t fromValue(int value) => switch (value) {
        769 => tls_protocol_version_TLSv10,
        770 => tls_protocol_version_TLSv11,
        771 => tls_protocol_version_TLSv12,
        772 => tls_protocol_version_TLSv13,
        -257 => tls_protocol_version_DTLSv10,
        -259 => tls_protocol_version_DTLSv12,
        _ => throw ArgumentError(
            "Unknown value for tls_protocol_version_t: $value"),
      };
}

enum tls_ciphersuite_t {
  tls_ciphersuite_RSA_WITH_3DES_EDE_CBC_SHA(10),
  tls_ciphersuite_RSA_WITH_AES_128_CBC_SHA(47),
  tls_ciphersuite_RSA_WITH_AES_256_CBC_SHA(53),
  tls_ciphersuite_RSA_WITH_AES_128_GCM_SHA256(156),
  tls_ciphersuite_RSA_WITH_AES_256_GCM_SHA384(157),
  tls_ciphersuite_RSA_WITH_AES_128_CBC_SHA256(60),
  tls_ciphersuite_RSA_WITH_AES_256_CBC_SHA256(61),
  tls_ciphersuite_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA(-16376),
  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_CBC_SHA(-16375),
  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_CBC_SHA(-16374),
  tls_ciphersuite_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA(-16366),
  tls_ciphersuite_ECDHE_RSA_WITH_AES_128_CBC_SHA(-16365),
  tls_ciphersuite_ECDHE_RSA_WITH_AES_256_CBC_SHA(-16364),
  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256(-16349),
  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384(-16348),
  tls_ciphersuite_ECDHE_RSA_WITH_AES_128_CBC_SHA256(-16345),
  tls_ciphersuite_ECDHE_RSA_WITH_AES_256_CBC_SHA384(-16344),
  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256(-16341),
  tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384(-16340),
  tls_ciphersuite_ECDHE_RSA_WITH_AES_128_GCM_SHA256(-16337),
  tls_ciphersuite_ECDHE_RSA_WITH_AES_256_GCM_SHA384(-16336),
  tls_ciphersuite_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256(-13144),
  tls_ciphersuite_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256(-13143),
  tls_ciphersuite_AES_128_GCM_SHA256(4865),
  tls_ciphersuite_AES_256_GCM_SHA384(4866),
  tls_ciphersuite_CHACHA20_POLY1305_SHA256(4867);

  final int value;
  const tls_ciphersuite_t(this.value);

  static tls_ciphersuite_t fromValue(int value) => switch (value) {
        10 => tls_ciphersuite_RSA_WITH_3DES_EDE_CBC_SHA,
        47 => tls_ciphersuite_RSA_WITH_AES_128_CBC_SHA,
        53 => tls_ciphersuite_RSA_WITH_AES_256_CBC_SHA,
        156 => tls_ciphersuite_RSA_WITH_AES_128_GCM_SHA256,
        157 => tls_ciphersuite_RSA_WITH_AES_256_GCM_SHA384,
        60 => tls_ciphersuite_RSA_WITH_AES_128_CBC_SHA256,
        61 => tls_ciphersuite_RSA_WITH_AES_256_CBC_SHA256,
        -16376 => tls_ciphersuite_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,
        -16375 => tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
        -16374 => tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
        -16366 => tls_ciphersuite_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,
        -16365 => tls_ciphersuite_ECDHE_RSA_WITH_AES_128_CBC_SHA,
        -16364 => tls_ciphersuite_ECDHE_RSA_WITH_AES_256_CBC_SHA,
        -16349 => tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
        -16348 => tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
        -16345 => tls_ciphersuite_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
        -16344 => tls_ciphersuite_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
        -16341 => tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
        -16340 => tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
        -16337 => tls_ciphersuite_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        -16336 => tls_ciphersuite_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
        -13144 => tls_ciphersuite_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
        -13143 => tls_ciphersuite_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
        4865 => tls_ciphersuite_AES_128_GCM_SHA256,
        4866 => tls_ciphersuite_AES_256_GCM_SHA384,
        4867 => tls_ciphersuite_CHACHA20_POLY1305_SHA256,
        _ => throw ArgumentError("Unknown value for tls_ciphersuite_t: $value"),
      };
}

enum tls_ciphersuite_group_t {
  tls_ciphersuite_group_default(0),
  tls_ciphersuite_group_compatibility(1),
  tls_ciphersuite_group_legacy(2),
  tls_ciphersuite_group_ats(3),
  tls_ciphersuite_group_ats_compatibility(4);

  final int value;
  const tls_ciphersuite_group_t(this.value);

  static tls_ciphersuite_group_t fromValue(int value) => switch (value) {
        0 => tls_ciphersuite_group_default,
        1 => tls_ciphersuite_group_compatibility,
        2 => tls_ciphersuite_group_legacy,
        3 => tls_ciphersuite_group_ats,
        4 => tls_ciphersuite_group_ats_compatibility,
        _ => throw ArgumentError(
            "Unknown value for tls_ciphersuite_group_t: $value"),
      };
}

enum SSLProtocol {
  kSSLProtocolUnknown(0),
  kTLSProtocol1(4),
  kTLSProtocol11(7),
  kTLSProtocol12(8),
  kDTLSProtocol1(9),
  kTLSProtocol13(10),
  kDTLSProtocol12(11),
  kTLSProtocolMaxSupported(999),
  kSSLProtocol2(1),
  kSSLProtocol3(2),
  kSSLProtocol3Only(3),
  kTLSProtocol1Only(5),
  kSSLProtocolAll(6);

  final int value;
  const SSLProtocol(this.value);

  static SSLProtocol fromValue(int value) => switch (value) {
        0 => kSSLProtocolUnknown,
        4 => kTLSProtocol1,
        7 => kTLSProtocol11,
        8 => kTLSProtocol12,
        9 => kDTLSProtocol1,
        10 => kTLSProtocol13,
        11 => kDTLSProtocol12,
        999 => kTLSProtocolMaxSupported,
        1 => kSSLProtocol2,
        2 => kSSLProtocol3,
        3 => kSSLProtocol3Only,
        5 => kTLSProtocol1Only,
        6 => kSSLProtocolAll,
        _ => throw ArgumentError("Unknown value for SSLProtocol: $value"),
      };
}

void _ObjCBlock_ffiVoid_seccertificatet_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, sec_certificate_t arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(sec_certificate_t arg0)>>()
        .asFunction<void Function(sec_certificate_t)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_seccertificatet_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, sec_certificate_t)>(
            _ObjCBlock_ffiVoid_seccertificatet_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_seccertificatet_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, sec_certificate_t arg0) =>
    (objc.getBlockClosure(block) as void Function(sec_certificate_t))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_seccertificatet_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, sec_certificate_t)>(
            _ObjCBlock_ffiVoid_seccertificatet_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_seccertificatet_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, sec_certificate_t arg0) {
  (objc.getBlockClosure(block) as void Function(sec_certificate_t))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, sec_certificate_t)>
    _ObjCBlock_ffiVoid_seccertificatet_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>, sec_certificate_t)>.listener(
        _ObjCBlock_ffiVoid_seccertificatet_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_seccertificatet_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    sec_certificate_t arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(sec_certificate_t))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, sec_certificate_t)>
    _ObjCBlock_ffiVoid_seccertificatet_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, sec_certificate_t)>.isolateLocal(
        _ObjCBlock_ffiVoid_seccertificatet_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, sec_certificate_t)>
    _ObjCBlock_ffiVoid_seccertificatet_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, sec_certificate_t)>.listener(
        _ObjCBlock_ffiVoid_seccertificatet_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSObject)>`.
abstract final class ObjCBlock_ffiVoid_seccertificatet {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(sec_certificate_t arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_seccertificatet_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject)> fromFunction(
          void Function(Dartsec_certificate_t) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_seccertificatet_closureCallable,
              (sec_certificate_t arg0) => fn(objc.NSObject.castFromPointer(arg0,
                  retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject)> listener(
      void Function(Dartsec_certificate_t) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_seccertificatet_listenerCallable.nativeFunction
            .cast(),
        (sec_certificate_t arg0) => fn(
            objc.NSObject.castFromPointer(arg0, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject)> blocking(
      void Function(Dartsec_certificate_t) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_seccertificatet_blockingCallable.nativeFunction
            .cast(),
        (sec_certificate_t arg0) => fn(
            objc.NSObject.castFromPointer(arg0, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_seccertificatet_blockingListenerCallable
            .nativeFunction
            .cast(),
        (sec_certificate_t arg0) => fn(
            objc.NSObject.castFromPointer(arg0, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSObject)>`.
extension ObjCBlock_ffiVoid_seccertificatet_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSObject)> {
  void call(Dartsec_certificate_t arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  sec_certificate_t arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              sec_certificate_t)>()(ref.pointer, arg0.ref.pointer);
}

typedef sec_protocol_metadata_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartsec_protocol_metadata_t = objc.NSObject;
void _ObjCBlock_ffiVoid_Uint16_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Uint16 arg0)>>()
        .asFunction<void Function(int)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_Uint16_fnPtrCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Uint16)>(_ObjCBlock_ffiVoid_Uint16_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_Uint16_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) =>
    (objc.getBlockClosure(block) as void Function(int))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_Uint16_closureCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Uint16)>(_ObjCBlock_ffiVoid_Uint16_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_Uint16_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) {
  (objc.getBlockClosure(block) as void Function(int))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Uint16)>
    _ObjCBlock_ffiVoid_Uint16_listenerCallable = ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Uint16)>.listener(_ObjCBlock_ffiVoid_Uint16_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_Uint16_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Uint16)>
    _ObjCBlock_ffiVoid_Uint16_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Uint16)>.isolateLocal(
        _ObjCBlock_ffiVoid_Uint16_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Uint16)>
    _ObjCBlock_ffiVoid_Uint16_blockingListenerCallable = ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Uint16)>.listener(_ObjCBlock_ffiVoid_Uint16_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Uint16)>`.
abstract final class ObjCBlock_ffiVoid_Uint16 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Uint16)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Uint16)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Uint16)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Uint16 arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Uint16)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_Uint16_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Uint16)> fromFunction(
          void Function(int) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Uint16)>(
          objc.newClosureBlock(_ObjCBlock_ffiVoid_Uint16_closureCallable,
              (int arg0) => fn(arg0)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Uint16)> listener(
      void Function(int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_Uint16_listenerCallable.nativeFunction.cast(),
        (int arg0) => fn(arg0));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_15f11yh(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Uint16)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Uint16)> blocking(
      void Function(int) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_Uint16_blockingCallable.nativeFunction.cast(),
        (int arg0) => fn(arg0));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_Uint16_blockingListenerCallable.nativeFunction
            .cast(),
        (int arg0) => fn(arg0));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_15f11yh, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Uint16)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Uint16)>`.
extension ObjCBlock_ffiVoid_Uint16_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Uint16)> {
  void call(int arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Uint16 arg0)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
      ref.pointer, arg0);
}

void _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        dispatch_data_t arg0,
        dispatch_data_t arg1) =>
    block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        dispatch_data_t arg0, dispatch_data_t arg1)>>()
            .asFunction<void Function(dispatch_data_t, dispatch_data_t)>()(
        arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    dispatch_data_t, dispatch_data_t)>(
            _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        dispatch_data_t arg0,
        dispatch_data_t arg1) =>
    (objc.getBlockClosure(block) as void Function(
        dispatch_data_t, dispatch_data_t))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    dispatch_data_t, dispatch_data_t)>(
            _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    dispatch_data_t arg0,
    dispatch_data_t arg1) {
  (objc.getBlockClosure(block) as void Function(
      dispatch_data_t, dispatch_data_t))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t, dispatch_data_t)>
    _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t,
                dispatch_data_t)>.listener(
        _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    dispatch_data_t arg0,
    dispatch_data_t arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        dispatch_data_t, dispatch_data_t))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, dispatch_data_t, dispatch_data_t)>
    _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                dispatch_data_t,
                dispatch_data_t)>.isolateLocal(
        _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, dispatch_data_t, dispatch_data_t)>
    _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                dispatch_data_t,
                dispatch_data_t)>.listener(
        _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)>`.
abstract final class ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSObject, objc.NSObject)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(dispatch_data_t arg0, dispatch_data_t arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)> fromFunction(
          void Function(Dartdispatch_data_t, Dartdispatch_data_t) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_closureCallable,
              (dispatch_data_t arg0, dispatch_data_t arg1) => fn(
                  objc.NSObject.castFromPointer(arg0,
                      retain: true, release: true),
                  objc.NSObject.castFromPointer(arg1, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)>
      listener(void Function(Dartdispatch_data_t, Dartdispatch_data_t) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_listenerCallable
            .nativeFunction
            .cast(),
        (dispatch_data_t arg0, dispatch_data_t arg1) => fn(
            objc.NSObject.castFromPointer(arg0, retain: false, release: true),
            objc.NSObject.castFromPointer(arg1, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)>
      blocking(void Function(Dartdispatch_data_t, Dartdispatch_data_t) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_blockingCallable
            .nativeFunction
            .cast(),
        (dispatch_data_t arg0, dispatch_data_t arg1) => fn(
            objc.NSObject.castFromPointer(arg0, retain: false, release: true),
            objc.NSObject.castFromPointer(arg1, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_blockingListenerCallable
            .nativeFunction
            .cast(),
        (dispatch_data_t arg0, dispatch_data_t arg1) => fn(
            objc.NSObject.castFromPointer(arg0, retain: false, release: true),
            objc.NSObject.castFromPointer(arg1, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_pfv6jd, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)>`.
extension ObjCBlock_ffiVoid_dispatchdatat_dispatchdatat_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject)> {
  void call(Dartdispatch_data_t arg0, Dartdispatch_data_t arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                          dispatch_data_t arg0, dispatch_data_t arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                      dispatch_data_t, dispatch_data_t)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

typedef sec_protocol_options_t = ffi.Pointer<objc.ObjCObject>;
typedef Dartsec_protocol_options_t = objc.NSObject;
void _ObjCBlock_ffiVoid_dispatchdatat_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, dispatch_data_t arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(dispatch_data_t arg0)>>()
        .asFunction<void Function(dispatch_data_t)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_dispatchdatat_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t)>(
            _ObjCBlock_ffiVoid_dispatchdatat_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_dispatchdatat_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, dispatch_data_t arg0) =>
    (objc.getBlockClosure(block) as void Function(dispatch_data_t))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_dispatchdatat_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t)>(
            _ObjCBlock_ffiVoid_dispatchdatat_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_dispatchdatat_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, dispatch_data_t arg0) {
  (objc.getBlockClosure(block) as void Function(dispatch_data_t))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t)>
    _ObjCBlock_ffiVoid_dispatchdatat_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t)>.listener(
        _ObjCBlock_ffiVoid_dispatchdatat_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_dispatchdatat_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    dispatch_data_t arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(dispatch_data_t))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, dispatch_data_t)>
    _ObjCBlock_ffiVoid_dispatchdatat_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, dispatch_data_t)>.isolateLocal(
        _ObjCBlock_ffiVoid_dispatchdatat_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, dispatch_data_t)>
    _ObjCBlock_ffiVoid_dispatchdatat_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, dispatch_data_t)>.listener(
        _ObjCBlock_ffiVoid_dispatchdatat_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>`.
abstract final class ObjCBlock_ffiVoid_dispatchdatat {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(dispatch_data_t arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_dispatchdatat_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> fromFunction(
          void Function(Dartdispatch_data_t?) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_dispatchdatat_closureCallable,
              (dispatch_data_t arg0) => fn(arg0.address == 0
                  ? null
                  : objc.NSObject.castFromPointer(arg0,
                      retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> listener(
      void Function(Dartdispatch_data_t?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_listenerCallable.nativeFunction.cast(),
        (dispatch_data_t arg0) => fn(arg0.address == 0
            ? null
            : objc.NSObject.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> blocking(
      void Function(Dartdispatch_data_t?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_blockingCallable.nativeFunction.cast(),
        (dispatch_data_t arg0) => fn(arg0.address == 0
            ? null
            : objc.NSObject.castFromPointer(arg0,
                retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_dispatchdatat_blockingListenerCallable.nativeFunction
            .cast(),
        (dispatch_data_t arg0) => fn(arg0.address == 0
            ? null
            : objc.NSObject.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>`.
extension ObjCBlock_ffiVoid_dispatchdatat_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSObject?)> {
  void call(Dartdispatch_data_t? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      dispatch_data_t arg0)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>, dispatch_data_t)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

typedef sec_protocol_pre_shared_key_selection_complete_t
    = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartsec_protocol_pre_shared_key_selection_complete_t
    = objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>;
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            sec_protocol_metadata_t arg0,
            dispatch_data_t arg1,
            sec_protocol_pre_shared_key_selection_complete_t arg2) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(
                            sec_protocol_metadata_t arg0,
                            dispatch_data_t arg1,
                            sec_protocol_pre_shared_key_selection_complete_t
                                arg2)>>()
                .asFunction<
                    void Function(sec_protocol_metadata_t, dispatch_data_t,
                        sec_protocol_pre_shared_key_selection_complete_t)>()(
            arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    sec_protocol_metadata_t,
                    dispatch_data_t,
                    sec_protocol_pre_shared_key_selection_complete_t)>(
            _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            sec_protocol_metadata_t arg0,
            dispatch_data_t arg1,
            sec_protocol_pre_shared_key_selection_complete_t arg2) =>
        (objc.getBlockClosure(block) as void Function(
                sec_protocol_metadata_t,
                dispatch_data_t,
                sec_protocol_pre_shared_key_selection_complete_t))(
            arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    sec_protocol_metadata_t,
                    dispatch_data_t,
                    sec_protocol_pre_shared_key_selection_complete_t)>(
            _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        sec_protocol_metadata_t arg0,
        dispatch_data_t arg1,
        sec_protocol_pre_shared_key_selection_complete_t arg2) {
  (objc.getBlockClosure(block) as void Function(
      sec_protocol_metadata_t,
      dispatch_data_t,
      sec_protocol_pre_shared_key_selection_complete_t))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            sec_protocol_metadata_t,
            dispatch_data_t,
            sec_protocol_pre_shared_key_selection_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                sec_protocol_metadata_t,
                dispatch_data_t,
                sec_protocol_pre_shared_key_selection_complete_t)>.listener(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        sec_protocol_metadata_t arg0,
        dispatch_data_t arg1,
        sec_protocol_pre_shared_key_selection_complete_t arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        sec_protocol_metadata_t,
        dispatch_data_t,
        sec_protocol_pre_shared_key_selection_complete_t))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            sec_protocol_metadata_t,
            dispatch_data_t,
            sec_protocol_pre_shared_key_selection_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                sec_protocol_metadata_t,
                dispatch_data_t,
                sec_protocol_pre_shared_key_selection_complete_t)>.isolateLocal(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            sec_protocol_metadata_t,
            dispatch_data_t,
            sec_protocol_pre_shared_key_selection_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                sec_protocol_metadata_t,
                dispatch_data_t,
                sec_protocol_pre_shared_key_selection_complete_t)>.listener(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject?, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>`.
abstract final class ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              objc.NSObject, objc.NSObject?, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSObject, objc.NSObject?,
                      objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(objc.NSObject, objc.NSObject?,
              objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sec_protocol_metadata_t arg0, dispatch_data_t arg1, sec_protocol_pre_shared_key_selection_complete_t arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSObject, objc.NSObject?,
                      objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject?, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>
      fromFunction(void Function(Dartsec_protocol_metadata_t, Dartdispatch_data_t?, Dartsec_protocol_pre_shared_key_selection_complete_t) fn) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject?, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_closureCallable,
                  (sec_protocol_metadata_t arg0, dispatch_data_t arg1, sec_protocol_pre_shared_key_selection_complete_t arg2) => fn(
                      objc.NSObject.castFromPointer(arg0, retain: true, release: true),
                      arg1.address == 0 ? null : objc.NSObject.castFromPointer(arg1, retain: true, release: true),
                      ObjCBlock_ffiVoid_dispatchdatat.castFromPointer(arg2, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSObject, objc.NSObject?,
          objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)> listener(
      void Function(Dartsec_protocol_metadata_t, Dartdispatch_data_t?,
              Dartsec_protocol_pre_shared_key_selection_complete_t)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_listenerCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0, dispatch_data_t arg1,
                sec_protocol_pre_shared_key_selection_complete_t arg2) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSObject.castFromPointer(arg1,
                        retain: false, release: true),
                ObjCBlock_ffiVoid_dispatchdatat.castFromPointer(arg2,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_18qun1e(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(objc.NSObject, objc.NSObject?,
                objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSObject, objc.NSObject?,
          objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)> blocking(
      void Function(Dartsec_protocol_metadata_t, Dartdispatch_data_t?,
              Dartsec_protocol_pre_shared_key_selection_complete_t)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_blockingCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0, dispatch_data_t arg1,
                sec_protocol_pre_shared_key_selection_complete_t arg2) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSObject.castFromPointer(arg1,
                        retain: false, release: true),
                ObjCBlock_ffiVoid_dispatchdatat.castFromPointer(arg2,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_blockingListenerCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0, dispatch_data_t arg1,
                sec_protocol_pre_shared_key_selection_complete_t arg2) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSObject.castFromPointer(arg1,
                        retain: false, release: true),
                ObjCBlock_ffiVoid_dispatchdatat.castFromPointer(arg2,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_18qun1e, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(objc.NSObject, objc.NSObject?,
                objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject?, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>`.
extension ObjCBlock_ffiVoid_secprotocolmetadatat_dispatchdatat_secprotocolpresharedkeyselectioncompletet_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(objc.NSObject, objc.NSObject?,
            objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)> {
  void
      call(Dartsec_protocol_metadata_t arg0, Dartdispatch_data_t? arg1,
              Dartsec_protocol_pre_shared_key_selection_complete_t arg2) =>
          ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Void Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              sec_protocol_metadata_t arg0,
                              dispatch_data_t arg1,
                              sec_protocol_pre_shared_key_selection_complete_t
                                  arg2)>>()
                  .asFunction<
                      void Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          sec_protocol_metadata_t,
                          dispatch_data_t,
                          sec_protocol_pre_shared_key_selection_complete_t)>()(
              ref.pointer,
              arg0.ref.pointer,
              arg1?.ref.pointer ?? ffi.nullptr,
              arg2.ref.pointer);
}

typedef sec_protocol_pre_shared_key_selection_t
    = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartsec_protocol_pre_shared_key_selection_t = objc.ObjCBlock<
    ffi.Void Function(objc.NSObject, objc.NSObject?,
        objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>;
typedef sec_protocol_key_update_complete_t = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartsec_protocol_key_update_complete_t
    = objc.ObjCBlock<ffi.Void Function()>;
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            sec_protocol_metadata_t arg0,
            sec_protocol_key_update_complete_t arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(sec_protocol_metadata_t arg0,
                        sec_protocol_key_update_complete_t arg1)>>()
            .asFunction<
                void Function(sec_protocol_metadata_t,
                    sec_protocol_key_update_complete_t)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    sec_protocol_metadata_t,
                    sec_protocol_key_update_complete_t)>(
            _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            sec_protocol_metadata_t arg0,
            sec_protocol_key_update_complete_t arg1) =>
        (objc.getBlockClosure(block) as void Function(sec_protocol_metadata_t,
            sec_protocol_key_update_complete_t))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    sec_protocol_metadata_t,
                    sec_protocol_key_update_complete_t)>(
            _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        sec_protocol_metadata_t arg0,
        sec_protocol_key_update_complete_t arg1) {
  (objc.getBlockClosure(block) as void Function(
      sec_protocol_metadata_t, sec_protocol_key_update_complete_t))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            sec_protocol_metadata_t, sec_protocol_key_update_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                sec_protocol_metadata_t,
                sec_protocol_key_update_complete_t)>.listener(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        sec_protocol_metadata_t arg0,
        sec_protocol_key_update_complete_t arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(sec_protocol_metadata_t,
        sec_protocol_key_update_complete_t))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            sec_protocol_metadata_t,
            sec_protocol_key_update_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                sec_protocol_metadata_t,
                sec_protocol_key_update_complete_t)>.isolateLocal(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            sec_protocol_metadata_t,
            sec_protocol_key_update_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                sec_protocol_metadata_t,
                sec_protocol_key_update_complete_t)>.listener(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>`.
abstract final class ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(sec_protocol_metadata_t arg0,
                          sec_protocol_key_update_complete_t arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>
      fromFunction(void Function(Dartsec_protocol_metadata_t, Dartsec_protocol_key_update_complete_t) fn) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_closureCallable,
                  (sec_protocol_metadata_t arg0,
                          sec_protocol_key_update_complete_t arg1) =>
                      fn(objc.NSObject.castFromPointer(arg0, retain: true, release: true),
                          ObjCBlock_ffiVoid.castFromPointer(arg1, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
          ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>
      listener(
          void Function(Dartsec_protocol_metadata_t,
                  Dartsec_protocol_key_update_complete_t)
              fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_listenerCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0,
                sec_protocol_key_update_complete_t arg1) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                ObjCBlock_ffiVoid.castFromPointer(arg1,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_o762yo(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>
      blocking(
          void Function(Dartsec_protocol_metadata_t,
                  Dartsec_protocol_key_update_complete_t)
              fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_blockingCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0,
                sec_protocol_key_update_complete_t arg1) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                ObjCBlock_ffiVoid.castFromPointer(arg1,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_blockingListenerCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0,
                sec_protocol_key_update_complete_t arg1) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                ObjCBlock_ffiVoid.castFromPointer(arg1,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_o762yo, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>`.
extension ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolkeyupdatecompletet_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)> {
  void call(Dartsec_protocol_metadata_t arg0,
          Dartsec_protocol_key_update_complete_t arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          sec_protocol_metadata_t arg0,
                          sec_protocol_key_update_complete_t arg1)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      sec_protocol_metadata_t,
                      sec_protocol_key_update_complete_t)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

typedef sec_protocol_key_update_t = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartsec_protocol_key_update_t = objc.ObjCBlock<
    ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function()>)>;
typedef sec_protocol_challenge_complete_t = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartsec_protocol_challenge_complete_t
    = objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>;
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            sec_protocol_metadata_t arg0,
            sec_protocol_challenge_complete_t arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(sec_protocol_metadata_t arg0,
                        sec_protocol_challenge_complete_t arg1)>>()
            .asFunction<
                void Function(sec_protocol_metadata_t,
                    sec_protocol_challenge_complete_t)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    sec_protocol_metadata_t,
                    sec_protocol_challenge_complete_t)>(
            _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            sec_protocol_metadata_t arg0,
            sec_protocol_challenge_complete_t arg1) =>
        (objc.getBlockClosure(block) as void Function(sec_protocol_metadata_t,
            sec_protocol_challenge_complete_t))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    sec_protocol_metadata_t,
                    sec_protocol_challenge_complete_t)>(
            _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        sec_protocol_metadata_t arg0,
        sec_protocol_challenge_complete_t arg1) {
  (objc.getBlockClosure(block) as void Function(
      sec_protocol_metadata_t, sec_protocol_challenge_complete_t))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            sec_protocol_metadata_t, sec_protocol_challenge_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                sec_protocol_metadata_t,
                sec_protocol_challenge_complete_t)>.listener(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        sec_protocol_metadata_t arg0,
        sec_protocol_challenge_complete_t arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(sec_protocol_metadata_t,
        sec_protocol_challenge_complete_t))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            sec_protocol_metadata_t,
            sec_protocol_challenge_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                sec_protocol_metadata_t,
                sec_protocol_challenge_complete_t)>.isolateLocal(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            sec_protocol_metadata_t,
            sec_protocol_challenge_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                sec_protocol_metadata_t,
                sec_protocol_challenge_complete_t)>.listener(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>`.
abstract final class ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              objc.NSObject, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSObject,
                      objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sec_protocol_metadata_t arg0, sec_protocol_challenge_complete_t arg1)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSObject,
                      objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>
      fromFunction(void Function(Dartsec_protocol_metadata_t, Dartsec_protocol_challenge_complete_t) fn) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_closureCallable,
                  (sec_protocol_metadata_t arg0, sec_protocol_challenge_complete_t arg1) => fn(
                      objc.NSObject.castFromPointer(arg0, retain: true, release: true),
                      ObjCBlock_ffiVoid_dispatchdatat.castFromPointer(arg1, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
          ffi.Void Function(
              objc.NSObject, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>
      listener(
          void Function(Dartsec_protocol_metadata_t,
                  Dartsec_protocol_challenge_complete_t)
              fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_listenerCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0,
                sec_protocol_challenge_complete_t arg1) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_dispatchdatat.castFromPointer(arg1,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_o762yo(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(objc.NSObject,
                objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(
              objc.NSObject, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>
      blocking(
          void Function(Dartsec_protocol_metadata_t,
                  Dartsec_protocol_challenge_complete_t)
              fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_blockingCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0,
                sec_protocol_challenge_complete_t arg1) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_dispatchdatat.castFromPointer(arg1,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_blockingListenerCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0,
                sec_protocol_challenge_complete_t arg1) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_dispatchdatat.castFromPointer(arg1,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_o762yo, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(objc.NSObject,
                objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>`.
extension ObjCBlock_ffiVoid_secprotocolmetadatat_secprotocolchallengecompletet_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            objc.NSObject, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)> {
  void call(Dartsec_protocol_metadata_t arg0,
          Dartsec_protocol_challenge_complete_t arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          sec_protocol_metadata_t arg0,
                          sec_protocol_challenge_complete_t arg1)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      sec_protocol_metadata_t,
                      sec_protocol_challenge_complete_t)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

typedef sec_protocol_challenge_t = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartsec_protocol_challenge_t = objc.ObjCBlock<
    ffi.Void Function(
        objc.NSObject, objc.ObjCBlock<ffi.Void Function(objc.NSObject?)>)>;
void _ObjCBlock_ffiVoid_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>()
        .asFunction<void Function(bool)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Bool)>(_ObjCBlock_ffiVoid_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) =>
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_bool_closureCallable =
    ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Bool)>(_ObjCBlock_ffiVoid_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) {
  (objc.getBlockClosure(block) as void Function(bool))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)>
    _ObjCBlock_ffiVoid_bool_listenerCallable = ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Bool)>.listener(_ObjCBlock_ffiVoid_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    bool arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
    _ObjCBlock_ffiVoid_bool_blockingCallable = ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool)>.isolateLocal(_ObjCBlock_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
    _ObjCBlock_ffiVoid_bool_blockingListenerCallable = ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Bool)>.listener(_ObjCBlock_ffiVoid_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_bool_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunction(
          void Function(bool) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_bool_closureCallable, (bool arg0) => fn(arg0)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> listener(
      void Function(bool) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_listenerCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1s56lr9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> blocking(
      void Function(bool) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_blockingCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_bool_blockingListenerCallable.nativeFunction.cast(),
        (bool arg0) => fn(arg0));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1s56lr9, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
extension ObjCBlock_ffiVoid_bool_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Bool)> {
  void call(bool arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Bool arg0)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, bool)>()(
      ref.pointer, arg0);
}

typedef sec_protocol_verify_complete_t = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartsec_protocol_verify_complete_t
    = objc.ObjCBlock<ffi.Void Function(ffi.Bool)>;
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            sec_protocol_metadata_t arg0,
            sec_trust_t arg1,
            sec_protocol_verify_complete_t arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        sec_protocol_metadata_t arg0,
                        sec_trust_t arg1,
                        sec_protocol_verify_complete_t arg2)>>()
            .asFunction<
                void Function(sec_protocol_metadata_t, sec_trust_t,
                    sec_protocol_verify_complete_t)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    sec_protocol_metadata_t,
                    sec_trust_t,
                    sec_protocol_verify_complete_t)>(
            _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            sec_protocol_metadata_t arg0,
            sec_trust_t arg1,
            sec_protocol_verify_complete_t arg2) =>
        (objc.getBlockClosure(block) as void Function(sec_protocol_metadata_t,
            sec_trust_t, sec_protocol_verify_complete_t))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    sec_protocol_metadata_t,
                    sec_trust_t,
                    sec_protocol_verify_complete_t)>(
            _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        sec_protocol_metadata_t arg0,
        sec_trust_t arg1,
        sec_protocol_verify_complete_t arg2) {
  (objc.getBlockClosure(block) as void Function(sec_protocol_metadata_t,
      sec_trust_t, sec_protocol_verify_complete_t))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            sec_protocol_metadata_t,
            sec_trust_t,
            sec_protocol_verify_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                sec_protocol_metadata_t,
                sec_trust_t,
                sec_protocol_verify_complete_t)>.listener(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        sec_protocol_metadata_t arg0,
        sec_trust_t arg1,
        sec_protocol_verify_complete_t arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(sec_protocol_metadata_t,
        sec_trust_t, sec_protocol_verify_complete_t))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            sec_protocol_metadata_t,
            sec_trust_t,
            sec_protocol_verify_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                sec_protocol_metadata_t,
                sec_trust_t,
                sec_protocol_verify_complete_t)>.isolateLocal(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            sec_protocol_metadata_t,
            sec_trust_t,
            sec_protocol_verify_complete_t)>
    _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                sec_protocol_metadata_t,
                sec_trust_t,
                sec_protocol_verify_complete_t)>.listener(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>`.
abstract final class ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(objc.NSObject, objc.NSObject,
              objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSObject, objc.NSObject,
                      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(objc.NSObject, objc.NSObject,
              objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sec_protocol_metadata_t arg0, sec_trust_t arg1, sec_protocol_verify_complete_t arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSObject, objc.NSObject,
                      objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>
      fromFunction(void Function(Dartsec_protocol_metadata_t, Dartsec_trust_t, Dartsec_protocol_verify_complete_t) fn) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_closureCallable,
                  (sec_protocol_metadata_t arg0, sec_trust_t arg1, sec_protocol_verify_complete_t arg2) => fn(
                      objc.NSObject.castFromPointer(arg0, retain: true, release: true),
                      objc.NSObject.castFromPointer(arg1, retain: true, release: true),
                      ObjCBlock_ffiVoid_bool.castFromPointer(arg2, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSObject, objc.NSObject,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)> listener(
      void Function(Dartsec_protocol_metadata_t, Dartsec_trust_t,
              Dartsec_protocol_verify_complete_t)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_listenerCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0, sec_trust_t arg1,
                sec_protocol_verify_complete_t arg2) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                objc.NSObject.castFromPointer(arg1,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_bool.castFromPointer(arg2,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_18qun1e(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(objc.NSObject, objc.NSObject,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSObject, objc.NSObject,
          objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)> blocking(
      void Function(Dartsec_protocol_metadata_t, Dartsec_trust_t,
              Dartsec_protocol_verify_complete_t)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_blockingCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0, sec_trust_t arg1,
                sec_protocol_verify_complete_t arg2) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                objc.NSObject.castFromPointer(arg1,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_bool.castFromPointer(arg2,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_blockingListenerCallable
            .nativeFunction
            .cast(),
        (sec_protocol_metadata_t arg0, sec_trust_t arg1,
                sec_protocol_verify_complete_t arg2) =>
            fn(
                objc.NSObject.castFromPointer(arg0,
                    retain: false, release: true),
                objc.NSObject.castFromPointer(arg1,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_bool.castFromPointer(arg2,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_18qun1e, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(objc.NSObject, objc.NSObject,
                objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSObject, objc.NSObject, objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>`.
extension ObjCBlock_ffiVoid_secprotocolmetadatat_sectrustt_secprotocolverifycompletet_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(objc.NSObject, objc.NSObject,
            objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)> {
  void call(Dartsec_protocol_metadata_t arg0, Dartsec_trust_t arg1,
          Dartsec_protocol_verify_complete_t arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          sec_protocol_metadata_t arg0,
                          sec_trust_t arg1,
                          sec_protocol_verify_complete_t arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      sec_protocol_metadata_t,
                      sec_trust_t,
                      sec_protocol_verify_complete_t)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2.ref.pointer);
}

typedef sec_protocol_verify_t = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartsec_protocol_verify_t = objc.ObjCBlock<
    ffi.Void Function(objc.NSObject, objc.NSObject,
        objc.ObjCBlock<ffi.Void Function(ffi.Bool)>)>;

final class SSLContext extends ffi.Opaque {}

typedef SSLContextRef = ffi.Pointer<SSLContext>;
typedef SSLConnectionRef = ffi.Pointer<ffi.Void>;

enum SSLSessionOption {
  kSSLSessionOptionBreakOnServerAuth(0),
  kSSLSessionOptionBreakOnCertRequested(1),
  kSSLSessionOptionBreakOnClientAuth(2),
  kSSLSessionOptionFalseStart(3),
  kSSLSessionOptionSendOneByteRecord(4),
  kSSLSessionOptionAllowServerIdentityChange(5),
  kSSLSessionOptionFallback(6),
  kSSLSessionOptionBreakOnClientHello(7),
  kSSLSessionOptionAllowRenegotiation(8),
  kSSLSessionOptionEnableSessionTickets(9);

  final int value;
  const SSLSessionOption(this.value);

  static SSLSessionOption fromValue(int value) => switch (value) {
        0 => kSSLSessionOptionBreakOnServerAuth,
        1 => kSSLSessionOptionBreakOnCertRequested,
        2 => kSSLSessionOptionBreakOnClientAuth,
        3 => kSSLSessionOptionFalseStart,
        4 => kSSLSessionOptionSendOneByteRecord,
        5 => kSSLSessionOptionAllowServerIdentityChange,
        6 => kSSLSessionOptionFallback,
        7 => kSSLSessionOptionBreakOnClientHello,
        8 => kSSLSessionOptionAllowRenegotiation,
        9 => kSSLSessionOptionEnableSessionTickets,
        _ => throw ArgumentError("Unknown value for SSLSessionOption: $value"),
      };
}

enum SSLSessionState {
  kSSLIdle(0),
  kSSLHandshake(1),
  kSSLConnected(2),
  kSSLClosed(3),
  kSSLAborted(4);

  final int value;
  const SSLSessionState(this.value);

  static SSLSessionState fromValue(int value) => switch (value) {
        0 => kSSLIdle,
        1 => kSSLHandshake,
        2 => kSSLConnected,
        3 => kSSLClosed,
        4 => kSSLAborted,
        _ => throw ArgumentError("Unknown value for SSLSessionState: $value"),
      };
}

enum SSLClientCertificateState {
  kSSLClientCertNone(0),
  kSSLClientCertRequested(1),
  kSSLClientCertSent(2),
  kSSLClientCertRejected(3);

  final int value;
  const SSLClientCertificateState(this.value);

  static SSLClientCertificateState fromValue(int value) => switch (value) {
        0 => kSSLClientCertNone,
        1 => kSSLClientCertRequested,
        2 => kSSLClientCertSent,
        3 => kSSLClientCertRejected,
        _ => throw ArgumentError(
            "Unknown value for SSLClientCertificateState: $value"),
      };
}

typedef SSLReadFuncFunction = OSStatus Function(SSLConnectionRef connection,
    ffi.Pointer<ffi.Void> data, ffi.Pointer<ffi.Size> dataLength);
typedef DartSSLReadFuncFunction = DartSInt32 Function(
    SSLConnectionRef connection,
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.Size> dataLength);
typedef SSLReadFunc = ffi.Pointer<ffi.NativeFunction<SSLReadFuncFunction>>;
typedef SSLWriteFuncFunction = OSStatus Function(SSLConnectionRef connection,
    ffi.Pointer<ffi.Void> data, ffi.Pointer<ffi.Size> dataLength);
typedef DartSSLWriteFuncFunction = DartSInt32 Function(
    SSLConnectionRef connection,
    ffi.Pointer<ffi.Void> data,
    ffi.Pointer<ffi.Size> dataLength);
typedef SSLWriteFunc = ffi.Pointer<ffi.NativeFunction<SSLWriteFuncFunction>>;

enum SSLProtocolSide {
  kSSLServerSide(0),
  kSSLClientSide(1);

  final int value;
  const SSLProtocolSide(this.value);

  static SSLProtocolSide fromValue(int value) => switch (value) {
        0 => kSSLServerSide,
        1 => kSSLClientSide,
        _ => throw ArgumentError("Unknown value for SSLProtocolSide: $value"),
      };
}

enum SSLConnectionType {
  kSSLStreamType(0),
  kSSLDatagramType(1);

  final int value;
  const SSLConnectionType(this.value);

  static SSLConnectionType fromValue(int value) => switch (value) {
        0 => kSSLStreamType,
        1 => kSSLDatagramType,
        _ => throw ArgumentError("Unknown value for SSLConnectionType: $value"),
      };
}

enum SSLAuthenticate {
  kNeverAuthenticate(0),
  kAlwaysAuthenticate(1),
  kTryAuthenticate(2);

  final int value;
  const SSLAuthenticate(this.value);

  static SSLAuthenticate fromValue(int value) => switch (value) {
        0 => kNeverAuthenticate,
        1 => kAlwaysAuthenticate,
        2 => kTryAuthenticate,
        _ => throw ArgumentError("Unknown value for SSLAuthenticate: $value"),
      };
}

late final _class_NSURLSession = objc.getClass("NSURLSession");
void _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(objc.NSData?, NSURLResponse?,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)> fromFunction(
          void Function(objc.NSData?, NSURLResponse?, objc.NSError?) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2) =>
                  fn(
                      arg0.address == 0 ? null : objc.NSData.castFromPointer(arg0, retain: true, release: true),
                      arg1.address == 0 ? null : NSURLResponse.castFromPointer(arg1, retain: true, release: true),
                      arg2.address == 0 ? null : objc.NSError.castFromPointer(arg2, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>
      listener(void Function(objc.NSData?, NSURLResponse?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : NSURLResponse.castFromPointer(arg1,
                        retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_r8gdi7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSData?, NSURLResponse?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>
      blocking(void Function(objc.NSData?, NSURLResponse?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : NSURLResponse.castFromPointer(arg1,
                        retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : NSURLResponse.castFromPointer(arg1,
                        retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_r8gdi7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSData?, NSURLResponse?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSURLResponse_NSError_CallExtension on objc
    .ObjCBlock<ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)> {
  void call(objc.NSData? arg0, NSURLResponse? arg1, objc.NSError? arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer,
          arg0?.ref.pointer ?? ffi.nullptr,
          arg1?.ref.pointer ?? ffi.nullptr,
          arg2?.ref.pointer ?? ffi.nullptr);
}

late final _sel_dataTaskWithRequest_completionHandler_ =
    objc.registerName("dataTaskWithRequest:completionHandler:");
final _objc_msgSend_r0bo0s = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_dataTaskWithURL_completionHandler_ =
    objc.registerName("dataTaskWithURL:completionHandler:");

/// WARNING: NSURLSessionUploadTask is a stub. To generate bindings for this class, include
/// NSURLSessionUploadTask in your config's objc-interfaces list.
///
/// An NSURLSessionUploadTask does not currently provide any additional
/// functionality over an NSURLSessionDataTask.  All delegate messages
/// that may be sent referencing an NSURLSessionDataTask equally apply
/// to NSURLSessionUploadTasks.
class NSURLSessionUploadTask extends NSURLSessionDataTask {
  NSURLSessionUploadTask._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLSessionUploadTask] that points to the same underlying object as [other].
  NSURLSessionUploadTask.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLSessionUploadTask] that wraps the given raw object pointer.
  NSURLSessionUploadTask.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_uploadTaskWithRequest_fromFile_completionHandler_ =
    objc.registerName("uploadTaskWithRequest:fromFile:completionHandler:");
final _objc_msgSend_2wiv66 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_uploadTaskWithRequest_fromData_completionHandler_ =
    objc.registerName("uploadTaskWithRequest:fromData:completionHandler:");
late final _sel_uploadTaskWithResumeData_completionHandler_ =
    objc.registerName("uploadTaskWithResumeData:completionHandler:");
late final _class_NSURLSessionDownloadTask =
    objc.getClass("NSURLSessionDownloadTask");
void _ObjCBlock_ffiVoid_NSData_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSData_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSData_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?)>`.
abstract final class ObjCBlock_ffiVoid_NSData {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSData_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?)> fromFunction(
          void Function(objc.NSData?) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSData_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                  ? null
                  : objc.NSData.castFromPointer(arg0,
                      retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?)> listener(
      void Function(objc.NSData?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSData.castFromPointer(arg0, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?)> blocking(
      void Function(objc.NSData?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSData.castFromPointer(arg0, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSData.castFromPointer(arg0, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?)>`.
extension ObjCBlock_ffiVoid_NSData_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?)> {
  void call(objc.NSData? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_cancelByProducingResumeData_ =
    objc.registerName("cancelByProducingResumeData:");

/// NSURLSessionDownloadTask is a task that represents a download to
/// local storage.
class NSURLSessionDownloadTask extends NSURLSessionTask {
  NSURLSessionDownloadTask._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLSessionDownloadTask] that points to the same underlying object as [other].
  NSURLSessionDownloadTask.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLSessionDownloadTask] that wraps the given raw object pointer.
  NSURLSessionDownloadTask.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLSessionDownloadTask].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSURLSessionDownloadTask);
  }

  /// Cancel the download (and calls the superclass -cancel).  If
  /// conditions will allow for resuming the download in the future, the
  /// callback will be called with an opaque data blob, which may be used
  /// with -downloadTaskWithResumeData: to attempt to resume the download.
  /// If resume data cannot be created, the completion handler will be
  /// called with nil resumeData.
  void cancelByProducingResumeData_(
      objc.ObjCBlock<ffi.Void Function(objc.NSData?)> completionHandler) {
    _objc_msgSend_f167m6(this.ref.pointer, _sel_cancelByProducingResumeData_,
        completionHandler.ref.pointer);
  }

  /// init
  NSURLSessionDownloadTask init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static NSURLSessionDownloadTask new1() {
    final _ret =
        _objc_msgSend_151sglz(_class_NSURLSessionDownloadTask, _sel_new);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLSessionDownloadTask allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_NSURLSessionDownloadTask, _sel_allocWithZone_, zone);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static NSURLSessionDownloadTask alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_NSURLSessionDownloadTask, _sel_alloc);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  NSURLSessionDownloadTask self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  NSURLSessionDownloadTask retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  NSURLSessionDownloadTask autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: true, release: true);
  }
}

void _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(objc.NSURL?, NSURLResponse?,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)> fromFunction(
          void Function(objc.NSURL?, NSURLResponse?, objc.NSError?) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2) =>
                  fn(
                      arg0.address == 0 ? null : objc.NSURL.castFromPointer(arg0, retain: true, release: true),
                      arg1.address == 0 ? null : NSURLResponse.castFromPointer(arg1, retain: true, release: true),
                      arg2.address == 0 ? null : objc.NSError.castFromPointer(arg2, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>
      listener(void Function(objc.NSURL?, NSURLResponse?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL
                        .castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : NSURLResponse.castFromPointer(arg1,
                        retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_r8gdi7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSURL?, NSURLResponse?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>
      blocking(void Function(objc.NSURL?, NSURLResponse?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL
                        .castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : NSURLResponse.castFromPointer(arg1,
                        retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSURL
                        .castFromPointer(arg0, retain: false, release: true),
                arg1.address == 0
                    ? null
                    : NSURLResponse.castFromPointer(arg1,
                        retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_r8gdi7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSURL?, NSURLResponse?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSURL_NSURLResponse_NSError_CallExtension on objc
    .ObjCBlock<ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)> {
  void call(objc.NSURL? arg0, NSURLResponse? arg1, objc.NSError? arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer,
          arg0?.ref.pointer ?? ffi.nullptr,
          arg1?.ref.pointer ?? ffi.nullptr,
          arg2?.ref.pointer ?? ffi.nullptr);
}

late final _sel_downloadTaskWithRequest_completionHandler_ =
    objc.registerName("downloadTaskWithRequest:completionHandler:");
late final _sel_downloadTaskWithURL_completionHandler_ =
    objc.registerName("downloadTaskWithURL:completionHandler:");
late final _sel_downloadTaskWithResumeData_completionHandler_ =
    objc.registerName("downloadTaskWithResumeData:completionHandler:");

/// NSURLSession convenience routines deliver results to
/// a completion handler block.  These convenience routines
/// are not available to NSURLSessions that are configured
/// as background sessions.
///
/// Task objects are always created in a suspended state and
/// must be sent the -resume message before they will execute.
extension NSURLSessionAsynchronousConvenience on NSURLSession {
  /// data task convenience methods.  These methods create tasks that
  /// bypass the normal delegate calls for response and data delivery,
  /// and provide a simple cancelable asynchronous interface to receiving
  /// data.  Errors will be returned in the NSURLErrorDomain,
  /// see <Foundation/NSURLError.h>.  The delegate, if any, will still be
  /// called for authentication challenges.
  NSURLSessionDataTask dataTaskWithRequest_completionHandler_(
      NSURLRequest request,
      objc.ObjCBlock<
              ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_dataTaskWithRequest_completionHandler_,
        request.ref.pointer,
        completionHandler.ref.pointer);
    return NSURLSessionDataTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// dataTaskWithURL:completionHandler:
  NSURLSessionDataTask dataTaskWithURL_completionHandler_(
      objc.NSURL url,
      objc.ObjCBlock<
              ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_dataTaskWithURL_completionHandler_,
        url.ref.pointer,
        completionHandler.ref.pointer);
    return NSURLSessionDataTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// upload convenience method.
  NSURLSessionUploadTask uploadTaskWithRequest_fromFile_completionHandler_(
      NSURLRequest request,
      objc.NSURL fileURL,
      objc.ObjCBlock<
              ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_2wiv66(
        this.ref.pointer,
        _sel_uploadTaskWithRequest_fromFile_completionHandler_,
        request.ref.pointer,
        fileURL.ref.pointer,
        completionHandler.ref.pointer);
    return NSURLSessionUploadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// uploadTaskWithRequest:fromData:completionHandler:
  NSURLSessionUploadTask uploadTaskWithRequest_fromData_completionHandler_(
      NSURLRequest request,
      objc.NSData? bodyData,
      objc.ObjCBlock<
              ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_2wiv66(
        this.ref.pointer,
        _sel_uploadTaskWithRequest_fromData_completionHandler_,
        request.ref.pointer,
        bodyData?.ref.pointer ?? ffi.nullptr,
        completionHandler.ref.pointer);
    return NSURLSessionUploadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a URLSessionUploadTask from a resume data blob. If resuming from an upload
  /// file, the file must still exist and be unmodified.
  ///
  /// - Parameter resumeData: Resume data blob from an incomplete upload, such as data returned by the cancelByProducingResumeData: method.
  /// - Parameter completionHandler: The completion handler to call when the load request is complete.
  /// - Returns: A new session upload task, or nil if the resumeData is invalid.
  NSURLSessionUploadTask uploadTaskWithResumeData_completionHandler_(
      objc.NSData resumeData,
      objc.ObjCBlock<
              ffi.Void Function(objc.NSData?, NSURLResponse?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_uploadTaskWithResumeData_completionHandler_,
        resumeData.ref.pointer,
        completionHandler.ref.pointer);
    return NSURLSessionUploadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// download task convenience methods.  When a download successfully
  /// completes, the NSURL will point to a file that must be read or
  /// copied during the invocation of the completion routine.  The file
  /// will be removed automatically.
  NSURLSessionDownloadTask downloadTaskWithRequest_completionHandler_(
      NSURLRequest request,
      objc.ObjCBlock<
              ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_downloadTaskWithRequest_completionHandler_,
        request.ref.pointer,
        completionHandler.ref.pointer);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// downloadTaskWithURL:completionHandler:
  NSURLSessionDownloadTask downloadTaskWithURL_completionHandler_(
      objc.NSURL url,
      objc.ObjCBlock<
              ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_downloadTaskWithURL_completionHandler_,
        url.ref.pointer,
        completionHandler.ref.pointer);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// downloadTaskWithResumeData:completionHandler:
  NSURLSessionDownloadTask downloadTaskWithResumeData_completionHandler_(
      objc.NSData resumeData,
      objc.ObjCBlock<
              ffi.Void Function(objc.NSURL?, NSURLResponse?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_downloadTaskWithResumeData_completionHandler_,
        resumeData.ref.pointer,
        completionHandler.ref.pointer);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_sharedSession = objc.registerName("sharedSession");
late final _class_NSURLSessionConfiguration =
    objc.getClass("NSURLSessionConfiguration");
late final _sel_backgroundSessionConfiguration_ =
    objc.registerName("backgroundSessionConfiguration:");

/// NSURLSessionDeprecated
extension NSURLSessionDeprecated on NSURLSessionConfiguration {
  /// backgroundSessionConfiguration:
  static NSURLSessionConfiguration backgroundSessionConfiguration_(
      objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(_class_NSURLSessionConfiguration,
        _sel_backgroundSessionConfiguration_, identifier.ref.pointer);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_defaultSessionConfiguration =
    objc.registerName("defaultSessionConfiguration");
late final _sel_ephemeralSessionConfiguration =
    objc.registerName("ephemeralSessionConfiguration");
late final _sel_backgroundSessionConfigurationWithIdentifier_ =
    objc.registerName("backgroundSessionConfigurationWithIdentifier:");
late final _sel_identifier = objc.registerName("identifier");
late final _sel_requestCachePolicy = objc.registerName("requestCachePolicy");
late final _sel_setRequestCachePolicy_ =
    objc.registerName("setRequestCachePolicy:");
late final _sel_timeoutIntervalForRequest =
    objc.registerName("timeoutIntervalForRequest");
late final _sel_setTimeoutIntervalForRequest_ =
    objc.registerName("setTimeoutIntervalForRequest:");
late final _sel_timeoutIntervalForResource =
    objc.registerName("timeoutIntervalForResource");
late final _sel_setTimeoutIntervalForResource_ =
    objc.registerName("setTimeoutIntervalForResource:");
late final _sel_waitsForConnectivity =
    objc.registerName("waitsForConnectivity");
late final _sel_setWaitsForConnectivity_ =
    objc.registerName("setWaitsForConnectivity:");
late final _sel_isDiscretionary = objc.registerName("isDiscretionary");
late final _sel_setDiscretionary_ = objc.registerName("setDiscretionary:");
late final _sel_sharedContainerIdentifier =
    objc.registerName("sharedContainerIdentifier");
late final _sel_setSharedContainerIdentifier_ =
    objc.registerName("setSharedContainerIdentifier:");
late final _sel_sessionSendsLaunchEvents =
    objc.registerName("sessionSendsLaunchEvents");
late final _sel_setSessionSendsLaunchEvents_ =
    objc.registerName("setSessionSendsLaunchEvents:");
late final _sel_connectionProxyDictionary =
    objc.registerName("connectionProxyDictionary");
late final _sel_setConnectionProxyDictionary_ =
    objc.registerName("setConnectionProxyDictionary:");
late final _sel_TLSMinimumSupportedProtocol =
    objc.registerName("TLSMinimumSupportedProtocol");
final _objc_msgSend_cbopi9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedInt Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTLSMinimumSupportedProtocol_ =
    objc.registerName("setTLSMinimumSupportedProtocol:");
final _objc_msgSend_268k8x = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedInt)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_TLSMaximumSupportedProtocol =
    objc.registerName("TLSMaximumSupportedProtocol");
late final _sel_setTLSMaximumSupportedProtocol_ =
    objc.registerName("setTLSMaximumSupportedProtocol:");
late final _sel_TLSMinimumSupportedProtocolVersion =
    objc.registerName("TLSMinimumSupportedProtocolVersion");
final _objc_msgSend_9jpwfb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Uint16 Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTLSMinimumSupportedProtocolVersion_ =
    objc.registerName("setTLSMinimumSupportedProtocolVersion:");
final _objc_msgSend_1mvuct7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Uint16)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_TLSMaximumSupportedProtocolVersion =
    objc.registerName("TLSMaximumSupportedProtocolVersion");
late final _sel_setTLSMaximumSupportedProtocolVersion_ =
    objc.registerName("setTLSMaximumSupportedProtocolVersion:");
late final _sel_HTTPShouldSetCookies =
    objc.registerName("HTTPShouldSetCookies");
late final _sel_setHTTPShouldSetCookies_ =
    objc.registerName("setHTTPShouldSetCookies:");
late final _sel_HTTPCookieAcceptPolicy =
    objc.registerName("HTTPCookieAcceptPolicy");
final _objc_msgSend_104dkoq = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSUInteger Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setHTTPCookieAcceptPolicy_ =
    objc.registerName("setHTTPCookieAcceptPolicy:");
final _objc_msgSend_3q55ys = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, NSUInteger)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_HTTPAdditionalHeaders =
    objc.registerName("HTTPAdditionalHeaders");
late final _sel_setHTTPAdditionalHeaders_ =
    objc.registerName("setHTTPAdditionalHeaders:");
late final _sel_HTTPMaximumConnectionsPerHost =
    objc.registerName("HTTPMaximumConnectionsPerHost");
late final _sel_setHTTPMaximumConnectionsPerHost_ =
    objc.registerName("setHTTPMaximumConnectionsPerHost:");
late final _sel_HTTPCookieStorage = objc.registerName("HTTPCookieStorage");
late final _sel_setHTTPCookieStorage_ =
    objc.registerName("setHTTPCookieStorage:");

/// WARNING: NSURLCredentialStorage is a stub. To generate bindings for this class, include
/// NSURLCredentialStorage in your config's objc-interfaces list.
///
/// NSURLCredentialStorage
class NSURLCredentialStorage extends objc.ObjCObjectBase {
  NSURLCredentialStorage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSURLCredentialStorage] that points to the same underlying object as [other].
  NSURLCredentialStorage.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLCredentialStorage] that wraps the given raw object pointer.
  NSURLCredentialStorage.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_URLCredentialStorage =
    objc.registerName("URLCredentialStorage");
late final _sel_setURLCredentialStorage_ =
    objc.registerName("setURLCredentialStorage:");
late final _sel_URLCache = objc.registerName("URLCache");
late final _sel_setURLCache_ = objc.registerName("setURLCache:");
late final _sel_shouldUseExtendedBackgroundIdleMode =
    objc.registerName("shouldUseExtendedBackgroundIdleMode");
late final _sel_setShouldUseExtendedBackgroundIdleMode_ =
    objc.registerName("setShouldUseExtendedBackgroundIdleMode:");
late final _sel_protocolClasses = objc.registerName("protocolClasses");
late final _sel_setProtocolClasses_ = objc.registerName("setProtocolClasses:");

/// !
/// @enum NSURLSessionMultipathServiceType
///
/// @discussion The NSURLSessionMultipathServiceType enum defines constants that
/// can be used to specify the multipath service type to associate an NSURLSession.  The
/// multipath service type determines whether multipath TCP should be attempted and the conditions
/// for creating and switching between subflows.  Using these service types requires the appropriate entitlement.  Any connection attempt will fail if the process does not have the required entitlement.
/// A primary interface is a generally less expensive interface in terms of both cost and power (such as WiFi or ethernet).  A secondary interface is more expensive (such as 3G or LTE).
///
/// @constant NSURLSessionMultipathServiceTypeNone Specifies that multipath tcp should not be used.  Connections will use a single flow.
/// This is the default value.  No entitlement is required to set this value.
///
/// @constant NSURLSessionMultipathServiceTypeHandover Specifies that a secondary subflow should only be used
/// when the primary subflow is not performing adequately.   Requires the com.apple.developer.networking.multipath entitlement.
///
/// @constant NSURLSessionMultipathServiceTypeInteractive Specifies that a secondary subflow should be used if the
/// primary subflow is not performing adequately (packet loss, high round trip times, bandwidth issues).  The secondary
/// subflow will be created more aggressively than with NSURLSessionMultipathServiceTypeHandover.  Requires the com.apple.developer.networking.multipath entitlement.
///
/// @constant NSURLSessionMultipathServiceTypeAggregate Specifies that multiple subflows across multiple interfaces should be
/// used for better bandwidth.  This mode is only available for experimentation on devices configured for development use.
/// It can be enabled in the Developer section of the Settings app.
enum NSURLSessionMultipathServiceType {
  /// None - no multipath (default)
  NSURLSessionMultipathServiceTypeNone(0),

  /// Handover - secondary flows brought up when primary flow is not performing adequately.
  NSURLSessionMultipathServiceTypeHandover(1),

  /// Interactive - secondary flows created more aggressively.
  NSURLSessionMultipathServiceTypeInteractive(2),

  /// Aggregate - multiple subflows used for greater bandwidth.
  NSURLSessionMultipathServiceTypeAggregate(3);

  final int value;
  const NSURLSessionMultipathServiceType(this.value);

  static NSURLSessionMultipathServiceType fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionMultipathServiceTypeNone,
        1 => NSURLSessionMultipathServiceTypeHandover,
        2 => NSURLSessionMultipathServiceTypeInteractive,
        3 => NSURLSessionMultipathServiceTypeAggregate,
        _ => throw ArgumentError(
            "Unknown value for NSURLSessionMultipathServiceType: $value"),
      };
}

late final _sel_multipathServiceType =
    objc.registerName("multipathServiceType");
final _objc_msgSend_1wxwnc0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setMultipathServiceType_ =
    objc.registerName("setMultipathServiceType:");
final _objc_msgSend_1hx005a = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, NSInteger)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// Configuration options for an NSURLSession.  When a session is
/// created, a copy of the configuration object is made - you cannot
/// modify the configuration of a session after it has been created.
///
/// The shared session uses the global credential, cache and cookie
/// storage objects.
///
/// An ephemeral session has no persistent disk storage for cookies,
/// cache or credentials.
///
/// A background session can be used to perform networking operations
/// on behalf of a suspended application, within certain constraints.
class NSURLSessionConfiguration extends objc.NSObject {
  NSURLSessionConfiguration._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLSessionConfiguration] that points to the same underlying object as [other].
  NSURLSessionConfiguration.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLSessionConfiguration] that wraps the given raw object pointer.
  NSURLSessionConfiguration.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLSessionConfiguration].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSURLSessionConfiguration);
  }

  /// defaultSessionConfiguration
  static NSURLSessionConfiguration getDefaultSessionConfiguration() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSURLSessionConfiguration, _sel_defaultSessionConfiguration);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// ephemeralSessionConfiguration
  static NSURLSessionConfiguration getEphemeralSessionConfiguration() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSURLSessionConfiguration, _sel_ephemeralSessionConfiguration);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// backgroundSessionConfigurationWithIdentifier:
  static NSURLSessionConfiguration
      backgroundSessionConfigurationWithIdentifier_(objc.NSString identifier) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSURLSessionConfiguration,
        _sel_backgroundSessionConfigurationWithIdentifier_,
        identifier.ref.pointer);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// identifier for the background session configuration
  objc.NSString? get identifier {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// default cache policy for requests
  NSURLRequestCachePolicy get requestCachePolicy {
    final _ret =
        _objc_msgSend_8jm3uo(this.ref.pointer, _sel_requestCachePolicy);
    return NSURLRequestCachePolicy.fromValue(_ret);
  }

  /// default cache policy for requests
  set requestCachePolicy(NSURLRequestCachePolicy value) {
    _objc_msgSend_1yjxuv2(
        this.ref.pointer, _sel_setRequestCachePolicy_, value.value);
  }

  /// default timeout for requests.  This will cause a timeout if no data is transmitted for the given timeout value, and is reset whenever data is transmitted.
  DartNSTimeInterval get timeoutIntervalForRequest {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            this.ref.pointer, _sel_timeoutIntervalForRequest)
        : _objc_msgSend_1ukqyt8(
            this.ref.pointer, _sel_timeoutIntervalForRequest);
  }

  /// default timeout for requests.  This will cause a timeout if no data is transmitted for the given timeout value, and is reset whenever data is transmitted.
  set timeoutIntervalForRequest(DartNSTimeInterval value) {
    _objc_msgSend_hwm8nu(
        this.ref.pointer, _sel_setTimeoutIntervalForRequest_, value);
  }

  /// default timeout for requests.  This will cause a timeout if a resource is not able to be retrieved within a given timeout.
  DartNSTimeInterval get timeoutIntervalForResource {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(
            this.ref.pointer, _sel_timeoutIntervalForResource)
        : _objc_msgSend_1ukqyt8(
            this.ref.pointer, _sel_timeoutIntervalForResource);
  }

  /// default timeout for requests.  This will cause a timeout if a resource is not able to be retrieved within a given timeout.
  set timeoutIntervalForResource(DartNSTimeInterval value) {
    _objc_msgSend_hwm8nu(
        this.ref.pointer, _sel_setTimeoutIntervalForResource_, value);
  }

  /// type of service for requests.
  NSURLRequestNetworkServiceType get networkServiceType {
    final _ret =
        _objc_msgSend_t4uaw1(this.ref.pointer, _sel_networkServiceType);
    return NSURLRequestNetworkServiceType.fromValue(_ret);
  }

  /// type of service for requests.
  set networkServiceType(NSURLRequestNetworkServiceType value) {
    _objc_msgSend_1mse4s1(
        this.ref.pointer, _sel_setNetworkServiceType_, value.value);
  }

  /// allow request to route over cellular.
  bool get allowsCellularAccess {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_allowsCellularAccess);
  }

  /// allow request to route over cellular.
  set allowsCellularAccess(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAllowsCellularAccess_, value);
  }

  /// allow request to route over expensive networks.  Defaults to YES.
  bool get allowsExpensiveNetworkAccess {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_allowsExpensiveNetworkAccess);
  }

  /// allow request to route over expensive networks.  Defaults to YES.
  set allowsExpensiveNetworkAccess(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAllowsExpensiveNetworkAccess_, value);
  }

  /// allow request to route over networks in constrained mode. Defaults to YES.
  bool get allowsConstrainedNetworkAccess {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_allowsConstrainedNetworkAccess);
  }

  /// allow request to route over networks in constrained mode. Defaults to YES.
  set allowsConstrainedNetworkAccess(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setAllowsConstrainedNetworkAccess_, value);
  }

  /// requires requests from the session to be made with DNSSEC validation enabled. Defaults to NO.
  bool get requiresDNSSECValidation {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_requiresDNSSECValidation);
  }

  /// requires requests from the session to be made with DNSSEC validation enabled. Defaults to NO.
  set requiresDNSSECValidation(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setRequiresDNSSECValidation_, value);
  }

  /// Causes tasks to wait for network connectivity to become available, rather
  /// than immediately failing with an error (such as NSURLErrorNotConnectedToInternet)
  /// when it is not. When waiting for connectivity, the timeoutIntervalForRequest
  /// property does not apply, but the timeoutIntervalForResource property does.
  ///
  /// Unsatisfactory connectivity (that requires waiting) includes cases where the
  /// device has limited or insufficient connectivity for a task (e.g., only has a
  /// cellular connection but the allowsCellularAccess property is NO, or requires
  /// a VPN connection in order to reach the desired host).
  ///
  /// Default value is NO. Ignored by background sessions, as background sessions
  /// always wait for connectivity.
  bool get waitsForConnectivity {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_waitsForConnectivity);
  }

  /// Causes tasks to wait for network connectivity to become available, rather
  /// than immediately failing with an error (such as NSURLErrorNotConnectedToInternet)
  /// when it is not. When waiting for connectivity, the timeoutIntervalForRequest
  /// property does not apply, but the timeoutIntervalForResource property does.
  ///
  /// Unsatisfactory connectivity (that requires waiting) includes cases where the
  /// device has limited or insufficient connectivity for a task (e.g., only has a
  /// cellular connection but the allowsCellularAccess property is NO, or requires
  /// a VPN connection in order to reach the desired host).
  ///
  /// Default value is NO. Ignored by background sessions, as background sessions
  /// always wait for connectivity.
  set waitsForConnectivity(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setWaitsForConnectivity_, value);
  }

  /// allows background tasks to be scheduled at the discretion of the system for optimal performance.
  bool get discretionary {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDiscretionary);
  }

  /// allows background tasks to be scheduled at the discretion of the system for optimal performance.
  set discretionary(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDiscretionary_, value);
  }

  /// The identifier of the shared data container into which files in background sessions should be downloaded.
  /// App extensions wishing to use background sessions *must* set this property to a valid container identifier, or
  /// all transfers in that session will fail with NSURLErrorBackgroundSessionRequiresSharedContainer.
  objc.NSString? get sharedContainerIdentifier {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_sharedContainerIdentifier);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The identifier of the shared data container into which files in background sessions should be downloaded.
  /// App extensions wishing to use background sessions *must* set this property to a valid container identifier, or
  /// all transfers in that session will fail with NSURLErrorBackgroundSessionRequiresSharedContainer.
  set sharedContainerIdentifier(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSharedContainerIdentifier_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// Allows the app to be resumed or launched in the background when tasks in background sessions complete
  /// or when auth is required. This only applies to configurations created with +backgroundSessionConfigurationWithIdentifier:
  /// and the default value is YES.
  ///
  /// NOTE: macOS apps based on AppKit do not support background launch.
  bool get sessionSendsLaunchEvents {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_sessionSendsLaunchEvents);
  }

  /// Allows the app to be resumed or launched in the background when tasks in background sessions complete
  /// or when auth is required. This only applies to configurations created with +backgroundSessionConfigurationWithIdentifier:
  /// and the default value is YES.
  ///
  /// NOTE: macOS apps based on AppKit do not support background launch.
  set sessionSendsLaunchEvents(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setSessionSendsLaunchEvents_, value);
  }

  /// The proxy dictionary, as described by <CFNetwork/CFHTTPStream.h>
  objc.NSDictionary? get connectionProxyDictionary {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_connectionProxyDictionary);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// The proxy dictionary, as described by <CFNetwork/CFHTTPStream.h>
  set connectionProxyDictionary(objc.NSDictionary? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setConnectionProxyDictionary_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  SSLProtocol get TLSMinimumSupportedProtocol {
    final _ret = _objc_msgSend_cbopi9(
        this.ref.pointer, _sel_TLSMinimumSupportedProtocol);
    return SSLProtocol.fromValue(_ret);
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  set TLSMinimumSupportedProtocol(SSLProtocol value) {
    _objc_msgSend_268k8x(
        this.ref.pointer, _sel_setTLSMinimumSupportedProtocol_, value.value);
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  SSLProtocol get TLSMaximumSupportedProtocol {
    final _ret = _objc_msgSend_cbopi9(
        this.ref.pointer, _sel_TLSMaximumSupportedProtocol);
    return SSLProtocol.fromValue(_ret);
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecureTransport.h>
  set TLSMaximumSupportedProtocol(SSLProtocol value) {
    _objc_msgSend_268k8x(
        this.ref.pointer, _sel_setTLSMaximumSupportedProtocol_, value.value);
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  tls_protocol_version_t get TLSMinimumSupportedProtocolVersion {
    final _ret = _objc_msgSend_9jpwfb(
        this.ref.pointer, _sel_TLSMinimumSupportedProtocolVersion);
    return tls_protocol_version_t.fromValue(_ret);
  }

  /// The minimum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  set TLSMinimumSupportedProtocolVersion(tls_protocol_version_t value) {
    _objc_msgSend_1mvuct7(this.ref.pointer,
        _sel_setTLSMinimumSupportedProtocolVersion_, value.value);
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  tls_protocol_version_t get TLSMaximumSupportedProtocolVersion {
    final _ret = _objc_msgSend_9jpwfb(
        this.ref.pointer, _sel_TLSMaximumSupportedProtocolVersion);
    return tls_protocol_version_t.fromValue(_ret);
  }

  /// The maximum allowable versions of the TLS protocol, from <Security/SecProtocolTypes.h>
  set TLSMaximumSupportedProtocolVersion(tls_protocol_version_t value) {
    _objc_msgSend_1mvuct7(this.ref.pointer,
        _sel_setTLSMaximumSupportedProtocolVersion_, value.value);
  }

  /// Allow the use of HTTP pipelining
  bool get HTTPShouldUsePipelining {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_HTTPShouldUsePipelining);
  }

  /// Allow the use of HTTP pipelining
  set HTTPShouldUsePipelining(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setHTTPShouldUsePipelining_, value);
  }

  /// Allow the session to set cookies on requests
  bool get HTTPShouldSetCookies {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_HTTPShouldSetCookies);
  }

  /// Allow the session to set cookies on requests
  set HTTPShouldSetCookies(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setHTTPShouldSetCookies_, value);
  }

  /// Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage.
  NSHTTPCookieAcceptPolicy get HTTPCookieAcceptPolicy {
    final _ret =
        _objc_msgSend_104dkoq(this.ref.pointer, _sel_HTTPCookieAcceptPolicy);
    return NSHTTPCookieAcceptPolicy.fromValue(_ret);
  }

  /// Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage.
  set HTTPCookieAcceptPolicy(NSHTTPCookieAcceptPolicy value) {
    _objc_msgSend_3q55ys(
        this.ref.pointer, _sel_setHTTPCookieAcceptPolicy_, value.value);
  }

  /// Specifies additional headers which will be set on outgoing requests.
  /// Note that these headers are added to the request only if not already present.
  objc.NSDictionary? get HTTPAdditionalHeaders {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_HTTPAdditionalHeaders);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// Specifies additional headers which will be set on outgoing requests.
  /// Note that these headers are added to the request only if not already present.
  set HTTPAdditionalHeaders(objc.NSDictionary? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setHTTPAdditionalHeaders_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// The maximum number of simultaneous persistent connections per host
  DartNSInteger get HTTPMaximumConnectionsPerHost {
    return _objc_msgSend_1hz7y9r(
        this.ref.pointer, _sel_HTTPMaximumConnectionsPerHost);
  }

  /// The maximum number of simultaneous persistent connections per host
  set HTTPMaximumConnectionsPerHost(DartNSInteger value) {
    _objc_msgSend_4sp4xj(
        this.ref.pointer, _sel_setHTTPMaximumConnectionsPerHost_, value);
  }

  /// The cookie storage object to use, or nil to indicate that no cookies should be handled
  NSHTTPCookieStorage? get HTTPCookieStorage {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_HTTPCookieStorage);
    return _ret.address == 0
        ? null
        : NSHTTPCookieStorage.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// The cookie storage object to use, or nil to indicate that no cookies should be handled
  set HTTPCookieStorage(NSHTTPCookieStorage? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setHTTPCookieStorage_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// The credential storage object, or nil to indicate that no credential storage is to be used
  NSURLCredentialStorage? get URLCredentialStorage {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_URLCredentialStorage);
    return _ret.address == 0
        ? null
        : NSURLCredentialStorage.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// The credential storage object, or nil to indicate that no credential storage is to be used
  set URLCredentialStorage(NSURLCredentialStorage? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setURLCredentialStorage_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// The URL resource cache, or nil to indicate that no caching is to be performed
  NSURLCache? get URLCache {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_URLCache);
    return _ret.address == 0
        ? null
        : NSURLCache.castFromPointer(_ret, retain: true, release: true);
  }

  /// The URL resource cache, or nil to indicate that no caching is to be performed
  set URLCache(NSURLCache? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setURLCache_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Enable extended background idle mode for any tcp sockets created.    Enabling this mode asks the system to keep the socket open
  /// and delay reclaiming it when the process moves to the background (see https://developer.apple.com/library/ios/technotes/tn2277/_index.html)
  bool get shouldUseExtendedBackgroundIdleMode {
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_shouldUseExtendedBackgroundIdleMode);
  }

  /// Enable extended background idle mode for any tcp sockets created.    Enabling this mode asks the system to keep the socket open
  /// and delay reclaiming it when the process moves to the background (see https://developer.apple.com/library/ios/technotes/tn2277/_index.html)
  set shouldUseExtendedBackgroundIdleMode(bool value) {
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setShouldUseExtendedBackgroundIdleMode_, value);
  }

  /// An optional array of Class objects which subclass NSURLProtocol.
  /// The Class will be sent +canInitWithRequest: when determining if
  /// an instance of the class can be used for a given URL scheme.
  /// You should not use +[NSURLProtocol registerClass:], as that
  /// method will register your class with the default session rather
  /// than with an instance of NSURLSession.
  /// Custom NSURLProtocol subclasses are not available to background
  /// sessions.
  objc.ObjCObjectBase? get protocolClasses {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_protocolClasses);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// An optional array of Class objects which subclass NSURLProtocol.
  /// The Class will be sent +canInitWithRequest: when determining if
  /// an instance of the class can be used for a given URL scheme.
  /// You should not use +[NSURLProtocol registerClass:], as that
  /// method will register your class with the default session rather
  /// than with an instance of NSURLSession.
  /// Custom NSURLProtocol subclasses are not available to background
  /// sessions.
  set protocolClasses(objc.ObjCObjectBase? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setProtocolClasses_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// multipath service type to use for connections.  The default is NSURLSessionMultipathServiceTypeNone
  NSURLSessionMultipathServiceType get multipathServiceType {
    final _ret =
        _objc_msgSend_1wxwnc0(this.ref.pointer, _sel_multipathServiceType);
    return NSURLSessionMultipathServiceType.fromValue(_ret);
  }

  /// multipath service type to use for connections.  The default is NSURLSessionMultipathServiceTypeNone
  set multipathServiceType(NSURLSessionMultipathServiceType value) {
    _objc_msgSend_1hx005a(
        this.ref.pointer, _sel_setMultipathServiceType_, value.value);
  }

  /// init
  NSURLSessionConfiguration init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static NSURLSessionConfiguration new1() {
    final _ret =
        _objc_msgSend_151sglz(_class_NSURLSessionConfiguration, _sel_new);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLSessionConfiguration allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_NSURLSessionConfiguration, _sel_allocWithZone_, zone);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static NSURLSessionConfiguration alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_NSURLSessionConfiguration, _sel_alloc);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  NSURLSessionConfiguration self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  NSURLSessionConfiguration retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  NSURLSessionConfiguration autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_sessionWithConfiguration_ =
    objc.registerName("sessionWithConfiguration:");
late final _class_NSOperationQueue = objc.getClass("NSOperationQueue");
late final _sel_operations = objc.registerName("operations");
late final _sel_operationCount = objc.registerName("operationCount");

/// NSDeprecated
extension NSDeprecated1 on NSOperationQueue {
  /// These two functions are inherently a race condition and should be avoided if possible
  objc.NSArray get operations {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_operations);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// operationCount
  DartNSUInteger get operationCount {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_operationCount);
  }
}

/// WARNING: NSOperation is a stub. To generate bindings for this class, include
/// NSOperation in your config's objc-interfaces list.
///
/// NSOperation
class NSOperation extends objc.NSObject {
  NSOperation._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSOperation] that points to the same underlying object as [other].
  NSOperation.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSOperation] that wraps the given raw object pointer.
  NSOperation.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_addOperation_ = objc.registerName("addOperation:");
late final _sel_addOperations_waitUntilFinished_ =
    objc.registerName("addOperations:waitUntilFinished:");
final _objc_msgSend_6p7ndb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool)>();
late final _sel_addOperationWithBlock_ =
    objc.registerName("addOperationWithBlock:");
late final _sel_addBarrierBlock_ = objc.registerName("addBarrierBlock:");
late final _sel_maxConcurrentOperationCount =
    objc.registerName("maxConcurrentOperationCount");
late final _sel_setMaxConcurrentOperationCount_ =
    objc.registerName("setMaxConcurrentOperationCount:");
late final _sel_isSuspended = objc.registerName("isSuspended");
late final _sel_setSuspended_ = objc.registerName("setSuspended:");
late final _sel_name = objc.registerName("name");
late final _sel_setName_ = objc.registerName("setName:");
late final _sel_qualityOfService = objc.registerName("qualityOfService");
final _objc_msgSend_oi8iq9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setQualityOfService_ =
    objc.registerName("setQualityOfService:");
final _objc_msgSend_n2da1l = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, NSInteger)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// !
/// @typedef dispatch_queue_t
///
/// @abstract
/// Dispatch queues invoke workitems submitted to them.
///
/// @discussion
/// Dispatch queues come in many flavors, the most common one being the dispatch
/// serial queue (See dispatch_queue_serial_t).
///
/// The system manages a pool of threads which process dispatch queues and invoke
/// workitems submitted to them.
///
/// Conceptually a dispatch queue may have its own thread of execution, and
/// interaction between queues is highly asynchronous.
///
/// Dispatch queues are reference counted via calls to dispatch_retain() and
/// dispatch_release(). Pending workitems submitted to a queue also hold a
/// reference to the queue until they have finished. Once all references to a
/// queue have been released, the queue will be deallocated by the system.
typedef dispatch_queue_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_t1 = objc.NSObject;
late final _sel_underlyingQueue = objc.registerName("underlyingQueue");
late final _sel_setUnderlyingQueue_ = objc.registerName("setUnderlyingQueue:");
late final _sel_cancelAllOperations = objc.registerName("cancelAllOperations");
late final _sel_waitUntilAllOperationsAreFinished =
    objc.registerName("waitUntilAllOperationsAreFinished");
late final _sel_currentQueue = objc.registerName("currentQueue");
late final _sel_mainQueue = objc.registerName("mainQueue");

/// NSOperationQueue
class NSOperationQueue extends objc.NSObject {
  NSOperationQueue._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSOperationQueue] that points to the same underlying object as [other].
  NSOperationQueue.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSOperationQueue] that wraps the given raw object pointer.
  NSOperationQueue.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSOperationQueue].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSOperationQueue);
  }

  /// progress
  NSProgress get progress {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_progress);
    return NSProgress.castFromPointer(_ret, retain: true, release: true);
  }

  /// addOperation:
  void addOperation_(NSOperation op) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addOperation_, op.ref.pointer);
  }

  /// addOperations:waitUntilFinished:
  void addOperations_waitUntilFinished_(objc.NSArray ops, bool wait) {
    _objc_msgSend_6p7ndb(this.ref.pointer,
        _sel_addOperations_waitUntilFinished_, ops.ref.pointer, wait);
  }

  /// addOperationWithBlock:
  void addOperationWithBlock_(objc.ObjCBlock<ffi.Void Function()> block) {
    _objc_msgSend_f167m6(
        this.ref.pointer, _sel_addOperationWithBlock_, block.ref.pointer);
  }

  /// @method addBarrierBlock:
  /// @param barrier      A block to execute
  /// @discussion         The `addBarrierBlock:` method executes the block when the NSOperationQueue has finished all enqueued operations and
  /// prevents any subsequent operations to be executed until the barrier has been completed. This acts similarly to the
  /// `dispatch_barrier_async` function.
  void addBarrierBlock_(objc.ObjCBlock<ffi.Void Function()> barrier) {
    _objc_msgSend_f167m6(
        this.ref.pointer, _sel_addBarrierBlock_, barrier.ref.pointer);
  }

  /// maxConcurrentOperationCount
  DartNSInteger get maxConcurrentOperationCount {
    return _objc_msgSend_1hz7y9r(
        this.ref.pointer, _sel_maxConcurrentOperationCount);
  }

  /// setMaxConcurrentOperationCount:
  set maxConcurrentOperationCount(DartNSInteger value) {
    _objc_msgSend_4sp4xj(
        this.ref.pointer, _sel_setMaxConcurrentOperationCount_, value);
  }

  /// isSuspended
  bool get suspended {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isSuspended);
  }

  /// setSuspended:
  set suspended(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setSuspended_, value);
  }

  /// name
  objc.NSString? get name {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setName:
  set name(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setName_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// qualityOfService
  NSQualityOfService get qualityOfService {
    final _ret = _objc_msgSend_oi8iq9(this.ref.pointer, _sel_qualityOfService);
    return NSQualityOfService.fromValue(_ret);
  }

  /// setQualityOfService:
  set qualityOfService(NSQualityOfService value) {
    _objc_msgSend_n2da1l(
        this.ref.pointer, _sel_setQualityOfService_, value.value);
  }

  /// actually retain
  Dartdispatch_queue_t1? get underlyingQueue {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_underlyingQueue);
    return _ret.address == 0
        ? null
        : objc.NSObject.castFromPointer(_ret, retain: true, release: true);
  }

  /// actually retain
  set underlyingQueue(Dartdispatch_queue_t1? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setUnderlyingQueue_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// cancelAllOperations
  void cancelAllOperations() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_cancelAllOperations);
  }

  /// waitUntilAllOperationsAreFinished
  void waitUntilAllOperationsAreFinished() {
    _objc_msgSend_1pl9qdv(
        this.ref.pointer, _sel_waitUntilAllOperationsAreFinished);
  }

  /// currentQueue
  static NSOperationQueue? getCurrentQueue() {
    final _ret =
        _objc_msgSend_151sglz(_class_NSOperationQueue, _sel_currentQueue);
    return _ret.address == 0
        ? null
        : NSOperationQueue.castFromPointer(_ret, retain: true, release: true);
  }

  /// mainQueue
  static NSOperationQueue getMainQueue() {
    final _ret = _objc_msgSend_151sglz(_class_NSOperationQueue, _sel_mainQueue);
    return NSOperationQueue.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSOperationQueue init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSOperationQueue.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSOperationQueue new1() {
    final _ret = _objc_msgSend_151sglz(_class_NSOperationQueue, _sel_new);
    return NSOperationQueue.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSOperationQueue allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_NSOperationQueue, _sel_allocWithZone_, zone);
    return NSOperationQueue.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSOperationQueue alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSOperationQueue, _sel_alloc);
    return NSOperationQueue.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  NSOperationQueue self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSOperationQueue.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSOperationQueue retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSOperationQueue.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSOperationQueue autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSOperationQueue.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_sessionWithConfiguration_delegate_delegateQueue_ =
    objc.registerName("sessionWithConfiguration:delegate:delegateQueue:");
late final _sel_delegateQueue = objc.registerName("delegateQueue");
late final _sel_configuration = objc.registerName("configuration");
late final _sel_sessionDescription = objc.registerName("sessionDescription");
late final _sel_setSessionDescription_ =
    objc.registerName("setSessionDescription:");
late final _sel_finishTasksAndInvalidate =
    objc.registerName("finishTasksAndInvalidate");
late final _sel_invalidateAndCancel = objc.registerName("invalidateAndCancel");
late final _sel_resetWithCompletionHandler_ =
    objc.registerName("resetWithCompletionHandler:");
late final _sel_flushWithCompletionHandler_ =
    objc.registerName("flushWithCompletionHandler:");
void
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
      fromFunction(void Function(objc.ObjCObjectBase, objc.ObjCObjectBase, objc.ObjCObjectBase) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      objc.ObjCObjectBase(arg0, retain: true, release: true),
                      objc.ObjCObjectBase(arg1, retain: true, release: true),
                      objc.ObjCObjectBase(arg2, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)> listener(
      void Function(
              objc.ObjCObjectBase, objc.ObjCObjectBase, objc.ObjCObjectBase)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                objc.ObjCObjectBase(arg0, retain: false, release: true),
                objc.ObjCObjectBase(arg1, retain: false, release: true),
                objc.ObjCObjectBase(arg2, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_r8gdi7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)> blocking(
      void Function(
              objc.ObjCObjectBase, objc.ObjCObjectBase, objc.ObjCObjectBase)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                objc.ObjCObjectBase(arg0, retain: false, release: true),
                objc.ObjCObjectBase(arg1, retain: false, release: true),
                objc.ObjCObjectBase(arg2, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                objc.ObjCObjectBase(arg0, retain: false, release: true),
                objc.ObjCObjectBase(arg1, retain: false, release: true),
                objc.ObjCObjectBase(arg2, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_r8gdi7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_objcObjCObject_objcObjCObject_objcObjCObject_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)> {
  void call(objc.ObjCObjectBase arg0, objc.ObjCObjectBase arg1,
          objc.ObjCObjectBase arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_getTasksWithCompletionHandler_ =
    objc.registerName("getTasksWithCompletionHandler:");
void _ObjCBlock_ffiVoid_objcObjCObject1_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_objcObjCObject1_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_objcObjCObject1_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject1_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_objcObjCObject1_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_objcObjCObject1_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject1_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject1_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject1_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_objcObjCObject1_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject1_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_objcObjCObject1_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject1_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject1_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObject1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_objcObjCObject1_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>
      fromFunction(void Function(objc.ObjCObjectBase) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_objcObjCObject1_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0) => fn(
                      objc.ObjCObjectBase(arg0, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>
      listener(void Function(objc.ObjCObjectBase) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject1_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(objc.ObjCObjectBase(arg0, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>
      blocking(void Function(objc.ObjCObjectBase) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject1_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(objc.ObjCObjectBase(arg0, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject1_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) =>
            fn(objc.ObjCObjectBase(arg0, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_objcObjCObject1_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)> {
  void call(objc.ObjCObjectBase arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0.ref.pointer);
}

late final _sel_getAllTasksWithCompletionHandler_ =
    objc.registerName("getAllTasksWithCompletionHandler:");
late final _sel_dataTaskWithRequest_ =
    objc.registerName("dataTaskWithRequest:");
late final _sel_dataTaskWithURL_ = objc.registerName("dataTaskWithURL:");
late final _sel_uploadTaskWithRequest_fromFile_ =
    objc.registerName("uploadTaskWithRequest:fromFile:");
late final _sel_uploadTaskWithRequest_fromData_ =
    objc.registerName("uploadTaskWithRequest:fromData:");
late final _sel_uploadTaskWithResumeData_ =
    objc.registerName("uploadTaskWithResumeData:");
late final _sel_uploadTaskWithStreamedRequest_ =
    objc.registerName("uploadTaskWithStreamedRequest:");
late final _sel_downloadTaskWithRequest_ =
    objc.registerName("downloadTaskWithRequest:");
late final _sel_downloadTaskWithURL_ =
    objc.registerName("downloadTaskWithURL:");
late final _sel_downloadTaskWithResumeData_ =
    objc.registerName("downloadTaskWithResumeData:");

/// WARNING: NSURLSessionStreamTask is a stub. To generate bindings for this class, include
/// NSURLSessionStreamTask in your config's objc-interfaces list.
///
/// An NSURLSessionStreamTask provides an interface to perform reads
/// and writes to a TCP/IP stream created via NSURLSession.  This task
/// may be explicitly created from an NSURLSession, or created as a
/// result of the appropriate disposition response to a
/// -URLSession:dataTask:didReceiveResponse: delegate message.
///
/// NSURLSessionStreamTask can be used to perform asynchronous reads
/// and writes.  Reads and writes are enqueued and executed serially,
/// with the completion handler being invoked on the sessions delegate
/// queue.  If an error occurs, or the task is canceled, all
/// outstanding read and write calls will have their completion
/// handlers invoked with an appropriate error.
///
/// It is also possible to create NSInputStream and NSOutputStream
/// instances from an NSURLSessionTask by sending
/// -captureStreams to the task.  All outstanding reads and writes are
/// completed before the streams are created.  Once the streams are
/// delivered to the session delegate, the task is considered complete
/// and will receive no more messages.  These streams are
/// disassociated from the underlying session.
class NSURLSessionStreamTask extends NSURLSessionTask {
  NSURLSessionStreamTask._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLSessionStreamTask] that points to the same underlying object as [other].
  NSURLSessionStreamTask.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLSessionStreamTask] that wraps the given raw object pointer.
  NSURLSessionStreamTask.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_streamTaskWithHostName_port_ =
    objc.registerName("streamTaskWithHostName:port:");
final _objc_msgSend_9slupp = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();

/// WARNING: NSNetService is a stub. To generate bindings for this class, include
/// NSNetService in your config's objc-interfaces list.
///
/// NSNetService
class NSNetService extends objc.ObjCObjectBase {
  NSNetService._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSNetService] that points to the same underlying object as [other].
  NSNetService.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSNetService] that wraps the given raw object pointer.
  NSNetService.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_streamTaskWithNetService_ =
    objc.registerName("streamTaskWithNetService:");
late final _class_NSURLSessionWebSocketTask =
    objc.getClass("NSURLSessionWebSocketTask");
late final _class_NSURLSessionWebSocketMessage =
    objc.getClass("NSURLSessionWebSocketMessage");
late final _sel_initWithData_ = objc.registerName("initWithData:");
late final _sel_initWithString_ = objc.registerName("initWithString:");

enum NSURLSessionWebSocketMessageType {
  NSURLSessionWebSocketMessageTypeData(0),
  NSURLSessionWebSocketMessageTypeString(1);

  final int value;
  const NSURLSessionWebSocketMessageType(this.value);

  static NSURLSessionWebSocketMessageType fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionWebSocketMessageTypeData,
        1 => NSURLSessionWebSocketMessageTypeString,
        _ => throw ArgumentError(
            "Unknown value for NSURLSessionWebSocketMessageType: $value"),
      };
}

late final _sel_type = objc.registerName("type");
final _objc_msgSend_1qouven = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_data = objc.registerName("data");
late final _sel_string = objc.registerName("string");

/// The client can create a WebSocket message object that will be passed to the send calls
/// and will be delivered from the receive calls. The message can be initialized with data or string.
/// If initialized with data, the string property will be nil and vice versa.
class NSURLSessionWebSocketMessage extends objc.NSObject {
  NSURLSessionWebSocketMessage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLSessionWebSocketMessage] that points to the same underlying object as [other].
  NSURLSessionWebSocketMessage.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLSessionWebSocketMessage] that wraps the given raw object pointer.
  NSURLSessionWebSocketMessage.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLSessionWebSocketMessage].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_,
        _class_NSURLSessionWebSocketMessage);
  }

  /// Create a message with data type
  NSURLSessionWebSocketMessage initWithData_(objc.NSData data) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithData_, data.ref.pointer);
    return NSURLSessionWebSocketMessage.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// Create a message with string type
  NSURLSessionWebSocketMessage initWithString_(objc.NSString string) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithString_, string.ref.pointer);
    return NSURLSessionWebSocketMessage.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// type
  NSURLSessionWebSocketMessageType get type {
    final _ret = _objc_msgSend_1qouven(this.ref.pointer, _sel_type);
    return NSURLSessionWebSocketMessageType.fromValue(_ret);
  }

  /// data
  objc.NSData? get data {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_data);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// string
  objc.NSString? get string {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_string);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSURLSessionWebSocketMessage init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSURLSessionWebSocketMessage.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static NSURLSessionWebSocketMessage new1() {
    final _ret =
        _objc_msgSend_151sglz(_class_NSURLSessionWebSocketMessage, _sel_new);
    return NSURLSessionWebSocketMessage.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLSessionWebSocketMessage allocWithZone_(
      ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_NSURLSessionWebSocketMessage, _sel_allocWithZone_, zone);
    return NSURLSessionWebSocketMessage.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static NSURLSessionWebSocketMessage alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_NSURLSessionWebSocketMessage, _sel_alloc);
    return NSURLSessionWebSocketMessage.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  NSURLSessionWebSocketMessage self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSURLSessionWebSocketMessage.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  NSURLSessionWebSocketMessage retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSURLSessionWebSocketMessage.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  NSURLSessionWebSocketMessage autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSURLSessionWebSocketMessage.castFromPointer(_ret,
        retain: true, release: true);
  }
}

void _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSError_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunction(
          void Function(objc.NSError?) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                  ? null
                  : objc.NSError.castFromPointer(arg0,
                      retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> listener(
      void Function(objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> blocking(
      void Function(objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0,
                retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSError_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSError.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSError?)> {
  void call(objc.NSError? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_sendMessage_completionHandler_ =
    objc.registerName("sendMessage:completionHandler:");
void _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(NSURLSessionWebSocketMessage?,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)> fromFunction(
          void Function(NSURLSessionWebSocketMessage?, objc.NSError?) fn) =>
      objc.ObjCBlock<ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : NSURLSessionWebSocketMessage.castFromPointer(arg0, retain: true, release: true),
                  arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
          ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)>
      listener(void Function(NSURLSessionWebSocketMessage?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : NSURLSessionWebSocketMessage.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(NSURLSessionWebSocketMessage?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)>
      blocking(void Function(NSURLSessionWebSocketMessage?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : NSURLSessionWebSocketMessage.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : NSURLSessionWebSocketMessage.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_pfv6jd, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(NSURLSessionWebSocketMessage?,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSURLSessionWebSocketMessage_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)> {
  void call(NSURLSessionWebSocketMessage? arg0, objc.NSError? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer,
          arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_receiveMessageWithCompletionHandler_ =
    objc.registerName("receiveMessageWithCompletionHandler:");
late final _sel_sendPingWithPongReceiveHandler_ =
    objc.registerName("sendPingWithPongReceiveHandler:");

/// The WebSocket close codes follow the close codes given in the RFC
sealed class NSURLSessionWebSocketCloseCode {
  static const NSURLSessionWebSocketCloseCodeInvalid = 0;
  static const NSURLSessionWebSocketCloseCodeNormalClosure = 1000;
  static const NSURLSessionWebSocketCloseCodeGoingAway = 1001;
  static const NSURLSessionWebSocketCloseCodeProtocolError = 1002;
  static const NSURLSessionWebSocketCloseCodeUnsupportedData = 1003;
  static const NSURLSessionWebSocketCloseCodeNoStatusReceived = 1005;
  static const NSURLSessionWebSocketCloseCodeAbnormalClosure = 1006;
  static const NSURLSessionWebSocketCloseCodeInvalidFramePayloadData = 1007;
  static const NSURLSessionWebSocketCloseCodePolicyViolation = 1008;
  static const NSURLSessionWebSocketCloseCodeMessageTooBig = 1009;
  static const NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing = 1010;
  static const NSURLSessionWebSocketCloseCodeInternalServerError = 1011;
  static const NSURLSessionWebSocketCloseCodeTLSHandshakeFailure = 1015;
}

late final _sel_cancelWithCloseCode_reason_ =
    objc.registerName("cancelWithCloseCode:reason:");
final _objc_msgSend_tqzk0b = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                NSInteger,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_maximumMessageSize = objc.registerName("maximumMessageSize");
late final _sel_setMaximumMessageSize_ =
    objc.registerName("setMaximumMessageSize:");
late final _sel_closeCode = objc.registerName("closeCode");
final _objc_msgSend_1rhk8uh = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_closeReason = objc.registerName("closeReason");

/// A WebSocket task can be created with a ws or wss url. A client can also provide
/// a list of protocols it wishes to advertise during the WebSocket handshake phase.
/// Once the handshake is successfully completed the client will be notified through an optional delegate.
/// All reads and writes enqueued before the completion of the handshake will be queued up and
/// executed once the handshake succeeds. Before the handshake completes, the client can be called to handle
/// redirection or authentication using the same delegates as NSURLSessionTask. WebSocket task will also provide
/// support for cookies and will store cookies to the cookie storage on the session and will attach cookies to
/// outgoing HTTP handshake requests.
class NSURLSessionWebSocketTask extends NSURLSessionTask {
  NSURLSessionWebSocketTask._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLSessionWebSocketTask] that points to the same underlying object as [other].
  NSURLSessionWebSocketTask.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLSessionWebSocketTask] that wraps the given raw object pointer.
  NSURLSessionWebSocketTask.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLSessionWebSocketTask].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSURLSessionWebSocketTask);
  }

  /// Sends a WebSocket message. If an error occurs, any outstanding work will also fail.
  /// Note that invocation of the completion handler does not
  /// guarantee that the remote side has received all the bytes, only
  /// that they have been written to the kernel.
  void sendMessage_completionHandler_(NSURLSessionWebSocketMessage message,
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)> completionHandler) {
    _objc_msgSend_o762yo(this.ref.pointer, _sel_sendMessage_completionHandler_,
        message.ref.pointer, completionHandler.ref.pointer);
  }

  /// Reads a WebSocket message once all the frames of the message are available.
  /// If the maximumMessage size is hit while buffering the frames, the receiveMessage call will error out
  /// and all outstanding work will also fail resulting in the end of the task.
  void receiveMessageWithCompletionHandler_(
      objc.ObjCBlock<
              ffi.Void Function(NSURLSessionWebSocketMessage?, objc.NSError?)>
          completionHandler) {
    _objc_msgSend_f167m6(
        this.ref.pointer,
        _sel_receiveMessageWithCompletionHandler_,
        completionHandler.ref.pointer);
  }

  /// Sends a ping frame from the client side. The pongReceiveHandler is invoked when the client
  /// receives a pong from the server endpoint. If a connection is lost or an error occurs before receiving
  /// the pong from the endpoint, the pongReceiveHandler block will be invoked with an error.
  /// Note - the pongReceiveHandler will always be called in the order in which the pings were sent.
  void sendPingWithPongReceiveHandler_(
      objc.ObjCBlock<ffi.Void Function(objc.NSError?)> pongReceiveHandler) {
    _objc_msgSend_f167m6(this.ref.pointer, _sel_sendPingWithPongReceiveHandler_,
        pongReceiveHandler.ref.pointer);
  }

  /// Sends a close frame with the given closeCode. An optional reason can be provided while sending the close frame.
  /// Simply calling cancel on the task will result in a cancellation frame being sent without any reason.
  void cancelWithCloseCode_reason_(
      DartNSInteger closeCode, objc.NSData? reason) {
    _objc_msgSend_tqzk0b(this.ref.pointer, _sel_cancelWithCloseCode_reason_,
        closeCode, reason?.ref.pointer ?? ffi.nullptr);
  }

  /// The maximum number of bytes to be buffered before erroring out. This includes the sum of all bytes from continuation frames. Receive calls will error out if this value is reached
  DartNSInteger get maximumMessageSize {
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_maximumMessageSize);
  }

  /// The maximum number of bytes to be buffered before erroring out. This includes the sum of all bytes from continuation frames. Receive calls will error out if this value is reached
  set maximumMessageSize(DartNSInteger value) {
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setMaximumMessageSize_, value);
  }

  /// A task can be queried for it's close code at any point. When the task is not closed, it will be set to NSURLSessionWebSocketCloseCodeInvalid
  DartNSInteger get closeCode {
    return _objc_msgSend_1rhk8uh(this.ref.pointer, _sel_closeCode);
  }

  /// A task can be queried for it's close reason at any point. A nil value indicates no closeReason or that the task is still running
  objc.NSData? get closeReason {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_closeReason);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  NSURLSessionWebSocketTask init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSURLSessionWebSocketTask.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static NSURLSessionWebSocketTask new1() {
    final _ret =
        _objc_msgSend_151sglz(_class_NSURLSessionWebSocketTask, _sel_new);
    return NSURLSessionWebSocketTask.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLSessionWebSocketTask allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_NSURLSessionWebSocketTask, _sel_allocWithZone_, zone);
    return NSURLSessionWebSocketTask.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static NSURLSessionWebSocketTask alloc() {
    final _ret =
        _objc_msgSend_151sglz(_class_NSURLSessionWebSocketTask, _sel_alloc);
    return NSURLSessionWebSocketTask.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  NSURLSessionWebSocketTask self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSURLSessionWebSocketTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  NSURLSessionWebSocketTask retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSURLSessionWebSocketTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  NSURLSessionWebSocketTask autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSURLSessionWebSocketTask.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_webSocketTaskWithURL_ =
    objc.registerName("webSocketTaskWithURL:");
late final _sel_webSocketTaskWithURL_protocols_ =
    objc.registerName("webSocketTaskWithURL:protocols:");
late final _sel_webSocketTaskWithRequest_ =
    objc.registerName("webSocketTaskWithRequest:");

/// NSURLSession is a replacement API for NSURLConnection.  It provides
/// options that affect the policy of, and various aspects of the
/// mechanism by which NSURLRequest objects are retrieved from the
/// network.
///
/// An NSURLSession may be bound to a delegate object.  The delegate is
/// invoked for certain events during the lifetime of a session, such as
/// server authentication or determining whether a resource to be loaded
/// should be converted into a download.
///
/// NSURLSession instances are thread-safe.
///
/// The default NSURLSession uses a system provided delegate and is
/// appropriate to use in place of existing code that uses
/// +[NSURLConnection sendAsynchronousRequest:queue:completionHandler:]
///
/// An NSURLSession creates NSURLSessionTask objects which represent the
/// action of a resource being loaded.  These are analogous to
/// NSURLConnection objects but provide for more control and a unified
/// delegate model.
///
/// NSURLSessionTask objects are always created in a suspended state and
/// must be sent the -resume message before they will execute.
///
/// Subclasses of NSURLSessionTask are used to syntactically
/// differentiate between data and file downloads.
///
/// An NSURLSessionDataTask receives the resource as a series of calls to
/// the URLSession:dataTask:didReceiveData: delegate method.  This is type of
/// task most commonly associated with retrieving objects for immediate parsing
/// by the consumer.
///
/// An NSURLSessionUploadTask differs from an NSURLSessionDataTask
/// in how its instance is constructed.  Upload tasks are explicitly created
/// by referencing a file or data object to upload, or by utilizing the
/// -URLSession:task:needNewBodyStream: delegate message to supply an upload
/// body.
///
/// An NSURLSessionDownloadTask will directly write the response data to
/// a temporary file.  When completed, the delegate is sent
/// URLSession:downloadTask:didFinishDownloadingToURL: and given an opportunity
/// to move this file to a permanent location in its sandboxed container, or to
/// otherwise read the file. If canceled, an NSURLSessionDownloadTask can
/// produce a data blob that can be used to resume a download at a later
/// time.
///
/// Beginning with iOS 9 and Mac OS X 10.11, NSURLSessionStream is
/// available as a task type.  This allows for direct TCP/IP connection
/// to a given host and port with optional secure handshaking and
/// navigation of proxies.  Data tasks may also be upgraded to a
/// NSURLSessionStream task via the HTTP Upgrade: header and appropriate
/// use of the pipelining option of NSURLSessionConfiguration.  See RFC
/// 2817 and RFC 6455 for information about the Upgrade: header, and
/// comments below on turning data tasks into stream tasks.
///
/// An NSURLSessionWebSocketTask is a task that allows clients to connect to servers supporting
/// WebSocket. The task will perform the HTTP handshake to upgrade the connection
/// and once the WebSocket handshake is successful, the client can read and write
/// messages that will be framed using the WebSocket protocol by the framework.
class NSURLSession extends objc.NSObject {
  NSURLSession._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLSession] that points to the same underlying object as [other].
  NSURLSession.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLSession] that wraps the given raw object pointer.
  NSURLSession.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSURLSession].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSURLSession);
  }

  /// The shared session uses the currently set global NSURLCache,
  /// NSHTTPCookieStorage and NSURLCredentialStorage objects.
  static NSURLSession getSharedSession() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLSession, _sel_sharedSession);
    return NSURLSession.castFromPointer(_ret, retain: true, release: true);
  }

  /// Customization of NSURLSession occurs during creation of a new session.
  /// If you only need to use the convenience routines with custom
  /// configuration options it is not necessary to specify a delegate.
  /// If you do specify a delegate, the delegate will be retained until after
  /// the delegate has been sent the URLSession:didBecomeInvalidWithError: message.
  static NSURLSession sessionWithConfiguration_(
      NSURLSessionConfiguration configuration) {
    final _ret = _objc_msgSend_1sotr3r(_class_NSURLSession,
        _sel_sessionWithConfiguration_, configuration.ref.pointer);
    return NSURLSession.castFromPointer(_ret, retain: true, release: true);
  }

  /// sessionWithConfiguration:delegate:delegateQueue:
  static NSURLSession sessionWithConfiguration_delegate_delegateQueue_(
      NSURLSessionConfiguration configuration,
      objc.ObjCObjectBase? delegate,
      NSOperationQueue? queue) {
    final _ret = _objc_msgSend_11spmsz(
        _class_NSURLSession,
        _sel_sessionWithConfiguration_delegate_delegateQueue_,
        configuration.ref.pointer,
        delegate?.ref.pointer ?? ffi.nullptr,
        queue?.ref.pointer ?? ffi.nullptr);
    return NSURLSession.castFromPointer(_ret, retain: true, release: true);
  }

  /// delegateQueue
  NSOperationQueue get delegateQueue {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegateQueue);
    return NSOperationQueue.castFromPointer(_ret, retain: true, release: true);
  }

  /// delegate
  objc.ObjCObjectBase? get delegate {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// configuration
  NSURLSessionConfiguration get configuration {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_configuration);
    return NSURLSessionConfiguration.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// The sessionDescription property is available for the developer to
  /// provide a descriptive label for the session.
  objc.NSString? get sessionDescription {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_sessionDescription);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// The sessionDescription property is available for the developer to
  /// provide a descriptive label for the session.
  set sessionDescription(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSessionDescription_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// -finishTasksAndInvalidate returns immediately and existing tasks will be allowed
  /// to run to completion.  New tasks may not be created.  The session
  /// will continue to make delegate callbacks until URLSession:didBecomeInvalidWithError:
  /// has been issued.
  ///
  /// -finishTasksAndInvalidate and -invalidateAndCancel do not
  /// have any effect on the shared session instance.
  ///
  /// When invalidating a background session, it is not safe to create another background
  /// session with the same identifier until URLSession:didBecomeInvalidWithError: has
  /// been issued.
  void finishTasksAndInvalidate() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_finishTasksAndInvalidate);
  }

  /// -invalidateAndCancel acts as -finishTasksAndInvalidate, but issues
  /// -cancel to all outstanding tasks for this session.  Note task
  /// cancellation is subject to the state of the task, and some tasks may
  /// have already have completed at the time they are sent -cancel.
  void invalidateAndCancel() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_invalidateAndCancel);
  }

  /// empty all cookies, cache and credential stores, removes disk files, issues -flushWithCompletionHandler:. Invokes completionHandler() on the delegate queue.
  void resetWithCompletionHandler_(
      objc.ObjCBlock<ffi.Void Function()> completionHandler) {
    _objc_msgSend_f167m6(this.ref.pointer, _sel_resetWithCompletionHandler_,
        completionHandler.ref.pointer);
  }

  /// flush storage to disk and clear transient network caches.  Invokes completionHandler() on the delegate queue.
  void flushWithCompletionHandler_(
      objc.ObjCBlock<ffi.Void Function()> completionHandler) {
    _objc_msgSend_f167m6(this.ref.pointer, _sel_flushWithCompletionHandler_,
        completionHandler.ref.pointer);
  }

  /// invokes completionHandler with outstanding data, upload and download tasks.
  void getTasksWithCompletionHandler_(
      objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
          completionHandler) {
    _objc_msgSend_f167m6(this.ref.pointer, _sel_getTasksWithCompletionHandler_,
        completionHandler.ref.pointer);
  }

  /// invokes completionHandler with all outstanding tasks.
  void getAllTasksWithCompletionHandler_(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>)>
          completionHandler) {
    _objc_msgSend_f167m6(this.ref.pointer,
        _sel_getAllTasksWithCompletionHandler_, completionHandler.ref.pointer);
  }

  /// Creates a data task with the given request.  The request may have a body stream.
  NSURLSessionDataTask dataTaskWithRequest_(NSURLRequest request) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_dataTaskWithRequest_, request.ref.pointer);
    return NSURLSessionDataTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a data task to retrieve the contents of the given URL.
  NSURLSessionDataTask dataTaskWithURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_dataTaskWithURL_, url.ref.pointer);
    return NSURLSessionDataTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates an upload task with the given request.  The body of the request will be created from the file referenced by fileURL
  NSURLSessionUploadTask uploadTaskWithRequest_fromFile_(
      NSURLRequest request, objc.NSURL fileURL) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_uploadTaskWithRequest_fromFile_,
        request.ref.pointer,
        fileURL.ref.pointer);
    return NSURLSessionUploadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates an upload task with the given request.  The body of the request is provided from the bodyData.
  NSURLSessionUploadTask uploadTaskWithRequest_fromData_(
      NSURLRequest request, objc.NSData bodyData) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_uploadTaskWithRequest_fromData_,
        request.ref.pointer,
        bodyData.ref.pointer);
    return NSURLSessionUploadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates an upload task from a resume data blob. Requires the server to support the latest resumable uploads
  /// Internet-Draft from the HTTP Working Group, found at
  /// https://datatracker.ietf.org/doc/draft-ietf-httpbis-resumable-upload/
  /// If resuming from an upload file, the file must still exist and be unmodified. If the upload cannot be successfully
  /// resumed, URLSession:task:didCompleteWithError: will be called.
  ///
  /// - Parameter resumeData: Resume data blob from an incomplete upload, such as data returned by the cancelByProducingResumeData: method.
  /// - Returns: A new session upload task, or nil if the resumeData is invalid.
  NSURLSessionUploadTask uploadTaskWithResumeData_(objc.NSData resumeData) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_uploadTaskWithResumeData_, resumeData.ref.pointer);
    return NSURLSessionUploadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates an upload task with the given request.  The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required.
  NSURLSessionUploadTask uploadTaskWithStreamedRequest_(NSURLRequest request) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_uploadTaskWithStreamedRequest_, request.ref.pointer);
    return NSURLSessionUploadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a download task with the given request.
  NSURLSessionDownloadTask downloadTaskWithRequest_(NSURLRequest request) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_downloadTaskWithRequest_, request.ref.pointer);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a download task to download the contents of the given URL.
  NSURLSessionDownloadTask downloadTaskWithURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_downloadTaskWithURL_, url.ref.pointer);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a download task with the resume data.  If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called.
  NSURLSessionDownloadTask downloadTaskWithResumeData_(objc.NSData resumeData) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_downloadTaskWithResumeData_, resumeData.ref.pointer);
    return NSURLSessionDownloadTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a bidirectional stream task to a given host and port.
  NSURLSessionStreamTask streamTaskWithHostName_port_(
      objc.NSString hostname, DartNSInteger port) {
    final _ret = _objc_msgSend_9slupp(this.ref.pointer,
        _sel_streamTaskWithHostName_port_, hostname.ref.pointer, port);
    return NSURLSessionStreamTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a bidirectional stream task with an NSNetService to identify the endpoint.
  /// The NSNetService will be resolved before any IO completes.
  NSURLSessionStreamTask streamTaskWithNetService_(NSNetService service) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_streamTaskWithNetService_, service.ref.pointer);
    return NSURLSessionStreamTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a WebSocket task given the url. The given url must have a ws or wss scheme.
  NSURLSessionWebSocketTask webSocketTaskWithURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_webSocketTaskWithURL_, url.ref.pointer);
    return NSURLSessionWebSocketTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a WebSocket task given the url and an array of protocols. The protocols will be used in the WebSocket handshake to
  /// negotiate a preferred protocol with the server
  /// Note - The protocol will not affect the WebSocket framing. More details on the protocol can be found by reading the WebSocket RFC
  NSURLSessionWebSocketTask webSocketTaskWithURL_protocols_(
      objc.NSURL url, objc.ObjCObjectBase protocols) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_webSocketTaskWithURL_protocols_,
        url.ref.pointer,
        protocols.ref.pointer);
    return NSURLSessionWebSocketTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Creates a WebSocket task given the request. The request properties can be modified and will be used by the task during the HTTP handshake phase.
  /// Clients who want to add custom protocols can do so by directly adding headers with the key Sec-WebSocket-Protocol
  /// and a comma separated list of protocols they wish to negotiate with the server. The custom HTTP headers provided by the client will remain unchanged for the handshake with the server.
  NSURLSessionWebSocketTask webSocketTaskWithRequest_(NSURLRequest request) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_webSocketTaskWithRequest_, request.ref.pointer);
    return NSURLSessionWebSocketTask.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// init
  NSURLSession init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSURLSession.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSURLSession new1() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLSession, _sel_new);
    return NSURLSession.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSURLSession allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_NSURLSession, _sel_allocWithZone_, zone);
    return NSURLSession.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSURLSession alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSURLSession, _sel_alloc);
    return NSURLSession.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  NSURLSession self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSURLSession.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSURLSession retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSURLSession.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSURLSession autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSURLSession.castFromPointer(_ret, retain: true, release: true);
  }
}

/// Disposition options for various delegate messages
enum NSURLSessionDelayedRequestDisposition {
  /// Use the original request provided when the task was created; the request parameter is ignored.
  NSURLSessionDelayedRequestContinueLoading(0),

  /// Use the specified request, which may not be nil.
  NSURLSessionDelayedRequestUseNewRequest(1),

  /// Cancel the task; the request parameter is ignored.
  NSURLSessionDelayedRequestCancel(2);

  final int value;
  const NSURLSessionDelayedRequestDisposition(this.value);

  static NSURLSessionDelayedRequestDisposition fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionDelayedRequestContinueLoading,
        1 => NSURLSessionDelayedRequestUseNewRequest,
        2 => NSURLSessionDelayedRequestCancel,
        _ => throw ArgumentError(
            "Unknown value for NSURLSessionDelayedRequestDisposition: $value"),
      };
}

enum NSURLSessionAuthChallengeDisposition {
  /// Use the specified credential, which may be nil
  NSURLSessionAuthChallengeUseCredential(0),

  /// Default handling for the challenge - as if this delegate were not implemented; the credential parameter is ignored.
  NSURLSessionAuthChallengePerformDefaultHandling(1),

  /// The entire request will be canceled; the credential parameter is ignored.
  NSURLSessionAuthChallengeCancelAuthenticationChallenge(2),

  /// This challenge is rejected and the next authentication protection space should be tried; the credential parameter is ignored.
  NSURLSessionAuthChallengeRejectProtectionSpace(3);

  final int value;
  const NSURLSessionAuthChallengeDisposition(this.value);

  static NSURLSessionAuthChallengeDisposition fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionAuthChallengeUseCredential,
        1 => NSURLSessionAuthChallengePerformDefaultHandling,
        2 => NSURLSessionAuthChallengeCancelAuthenticationChallenge,
        3 => NSURLSessionAuthChallengeRejectProtectionSpace,
        _ => throw ArgumentError(
            "Unknown value for NSURLSessionAuthChallengeDisposition: $value"),
      };
}

enum NSURLSessionResponseDisposition {
  /// Cancel the load, this is the same as -[task cancel]
  NSURLSessionResponseCancel(0),

  /// Allow the load to continue
  NSURLSessionResponseAllow(1),

  /// Turn this request into a download
  NSURLSessionResponseBecomeDownload(2),

  /// Turn this task into a stream task
  NSURLSessionResponseBecomeStream(3);

  final int value;
  const NSURLSessionResponseDisposition(this.value);

  static NSURLSessionResponseDisposition fromValue(int value) =>
      switch (value) {
        0 => NSURLSessionResponseCancel,
        1 => NSURLSessionResponseAllow,
        2 => NSURLSessionResponseBecomeDownload,
        3 => NSURLSessionResponseBecomeStream,
        _ => throw ArgumentError(
            "Unknown value for NSURLSessionResponseDisposition: $value"),
      };
}

late final _protocol_NSURLSessionDataDelegate =
    objc.getProtocol("NSURLSessionDataDelegate");
void _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Void Function(NSInteger arg0)>>()
        .asFunction<void Function(int)>()(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger)>(
            _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) =>
    (objc.getBlockClosure(block) as void Function(int))(arg0);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger)>(
            _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, int arg0) {
  (objc.getBlockClosure(block) as void Function(int))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger)>
    _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>, NSInteger)>.listener(
        _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    int arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(int))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, NSInteger)>
    _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, NSInteger)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, NSInteger)>
    _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, NSInteger)>.listener(
        _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSInteger)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionResponseDisposition {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSInteger)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(NSInteger)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSInteger)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(NSInteger arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(NSInteger)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSInteger)> fromFunction(
          void Function(NSURLSessionResponseDisposition) fn) =>
      objc.ObjCBlock<ffi.Void Function(NSInteger)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_closureCallable,
              (int arg0) =>
                  fn(NSURLSessionResponseDisposition.fromValue(arg0))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(NSInteger)> listener(
      void Function(NSURLSessionResponseDisposition) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_listenerCallable
            .nativeFunction
            .cast(),
        (int arg0) => fn(NSURLSessionResponseDisposition.fromValue(arg0)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_16sve1d(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSInteger)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSInteger)> blocking(
      void Function(NSURLSessionResponseDisposition) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_blockingCallable
            .nativeFunction
            .cast(),
        (int arg0) => fn(NSURLSessionResponseDisposition.fromValue(arg0)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_blockingListenerCallable
            .nativeFunction
            .cast(),
        (int arg0) => fn(NSURLSessionResponseDisposition.fromValue(arg0)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_16sve1d, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSInteger)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSInteger)>`.
extension ObjCBlock_ffiVoid_NSURLSessionResponseDisposition_CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSInteger)> {
  void call(NSURLSessionResponseDisposition arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block, NSInteger arg0)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, int)>()(
      ref.pointer, arg0.value);
}

late final _sel_URLSession_dataTask_didReceiveResponse_completionHandler_ = objc
    .registerName("URLSession:dataTask:didReceiveResponse:completionHandler:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Pointer<objc.ObjCObject> arg3,
                            ffi.Pointer<objc.ObjCBlockImpl> arg4)>>()
                .asFunction<
                    void Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCBlockImpl>)>()(
            arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionDataTask,
              NSURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSInteger)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionDataTask,
                  NSURLResponse,
                  objc.ObjCBlock<ffi.Void Function(NSInteger)>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLResponse,
          objc.ObjCBlock<ffi.Void Function(NSInteger)>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCBlockImpl> arg4)>> ptr) =>
      objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionDataTask,
                  NSURLResponse,
                  objc.ObjCBlock<ffi.Void Function(NSInteger)>)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCBlockImpl> arg4) => fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionDataTask.castFromPointer(arg2, retain: true, release: true),
                      NSURLResponse.castFromPointer(arg3, retain: true, release: true),
                      ObjCBlock_ffiVoid_NSURLSessionResponseDisposition.castFromPointer(arg4, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLResponse,
          objc.ObjCBlock<ffi.Void Function(NSInteger)>)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask,
              NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLResponse.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionResponseDisposition
                    .castFromPointer(arg4, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xx612k(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionDataTask,
                NSURLResponse,
                objc.ObjCBlock<ffi.Void Function(NSInteger)>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSURLResponse,
          objc.ObjCBlock<ffi.Void Function(NSInteger)>)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask,
              NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLResponse.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionResponseDisposition
                    .castFromPointer(arg4, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLResponse.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionResponseDisposition
                    .castFromPointer(arg4, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xx612k, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionDataTask,
                NSURLResponse,
                objc.ObjCBlock<ffi.Void Function(NSInteger)>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            NSURLResponse,
            objc.ObjCBlock<ffi.Void Function(NSInteger)>)> {
  void call(
          ffi.Pointer<ffi.Void> arg0,
          NSURLSession arg1,
          NSURLSessionDataTask arg2,
          NSURLResponse arg3,
          objc.ObjCBlock<ffi.Void Function(NSInteger)> arg4) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3,
                          ffi.Pointer<objc.ObjCBlockImpl> arg4)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(
          ref.pointer,
          arg0,
          arg1.ref.pointer,
          arg2.ref.pointer,
          arg3.ref.pointer,
          arg4.ref.pointer);
}

late final _sel_URLSession_dataTask_didBecomeDownloadTask_ =
    objc.registerName("URLSession:dataTask:didBecomeDownloadTask:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDataTask, NSURLSessionDownloadTask)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionDataTask, NSURLSessionDownloadTask)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDataTask, NSURLSessionDownloadTask)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionDataTask, NSURLSessionDownloadTask)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionDataTask.castFromPointer(arg2, retain: true, release: true),
                      NSURLSessionDownloadTask.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDataTask, NSURLSessionDownloadTask)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask,
              NSURLSessionDownloadTask)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionDownloadTask)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDataTask, NSURLSessionDownloadTask)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask,
              NSURLSessionDownloadTask)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg3,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionDownloadTask)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            NSURLSessionDataTask, NSURLSessionDownloadTask)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionDataTask arg2, NSURLSessionDownloadTask arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer);
}

late final _sel_URLSession_dataTask_didBecomeStreamTask_ =
    objc.registerName("URLSession:dataTask:didBecomeStreamTask:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDataTask, NSURLSessionStreamTask)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionDataTask, NSURLSessionStreamTask)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDataTask, NSURLSessionStreamTask)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionDataTask, NSURLSessionStreamTask)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionDataTask.castFromPointer(arg2, retain: true, release: true),
                      NSURLSessionStreamTask.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDataTask, NSURLSessionStreamTask)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask,
              NSURLSessionStreamTask)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLSessionStreamTask.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionStreamTask)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDataTask, NSURLSessionStreamTask)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask,
              NSURLSessionStreamTask)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLSessionStreamTask.castFromPointer(arg3,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLSessionStreamTask.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            NSURLSessionStreamTask)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            NSURLSessionDataTask, NSURLSessionStreamTask)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionDataTask arg2, NSURLSessionStreamTask arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer);
}

late final _sel_URLSession_dataTask_didReceiveData_ =
    objc.registerName("URLSession:dataTask:didReceiveData:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, objc.NSData)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDataTask, objc.NSData)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionDataTask,
                  objc.NSData)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDataTask, objc.NSData)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionDataTask, objc.NSData)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, objc.NSData)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, objc.NSData) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, objc.NSData)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionDataTask.castFromPointer(arg2, retain: true, release: true),
                      objc.NSData.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDataTask, objc.NSData)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask,
              objc.NSData)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSData.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            objc.NSData)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDataTask, objc.NSData)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask,
              objc.NSData)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSData.castFromPointer(arg3,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSData.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            objc.NSData)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, objc.NSData)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            NSURLSessionDataTask, objc.NSData)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionDataTask arg2, objc.NSData arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer);
}

late final _sel_URLSession_dataTask_willCacheResponse_completionHandler_ = objc
    .registerName("URLSession:dataTask:willCacheResponse:completionHandler:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Pointer<objc.ObjCObject> arg3,
                            ffi.Pointer<objc.ObjCBlockImpl> arg4)>>()
                .asFunction<
                    void Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCBlockImpl>)>()(
            arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSCachedURLResponse, objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionDataTask,
              NSCachedURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionDataTask,
                  NSCachedURLResponse,
                  objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSCachedURLResponse,
          objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCBlockImpl> arg4)>> ptr) =>
      objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionDataTask,
                  NSCachedURLResponse,
                  objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSCachedURLResponse, objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSCachedURLResponse, objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSCachedURLResponse, objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCBlockImpl> arg4) => fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionDataTask.castFromPointer(arg2, retain: true, release: true),
                      NSCachedURLResponse.castFromPointer(arg3, retain: true, release: true),
                      ObjCBlock_ffiVoid_NSCachedURLResponse.castFromPointer(arg4, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSCachedURLResponse,
          objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)> listener(
      void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionDataTask,
              NSCachedURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSCachedURLResponse.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSCachedURLResponse.castFromPointer(arg4,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xx612k(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionDataTask,
                NSCachedURLResponse,
                objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDataTask,
          NSCachedURLResponse,
          objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)> blocking(
      void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionDataTask,
              NSCachedURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSCachedURLResponse.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSCachedURLResponse.castFromPointer(arg4,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDataTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSCachedURLResponse.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSCachedURLResponse.castFromPointer(arg4,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xx612k, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionDataTask,
                NSCachedURLResponse,
                objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDataTask, NSCachedURLResponse, objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDataTask,
            NSCachedURLResponse,
            objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)> {
  void call(
          ffi.Pointer<ffi.Void> arg0,
          NSURLSession arg1,
          NSURLSessionDataTask arg2,
          NSCachedURLResponse arg3,
          objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)> arg4) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3,
                          ffi.Pointer<objc.ObjCBlockImpl> arg4)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(
          ref.pointer,
          arg0,
          arg1.ref.pointer,
          arg2.ref.pointer,
          arg3.ref.pointer,
          arg4.ref.pointer);
}

late final _sel_URLSession_didCreateTask_ =
    objc.registerName("URLSession:didCreateTask:");
void _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                  NSURLSessionTask)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(
                          arg0,
                          NSURLSession.castFromPointer(arg1, retain: true, release: true),
                          NSURLSessionTask.castFromPointer(arg2, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            NSURLSessionTask)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_fjrv01, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            NSURLSessionTask)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionTask arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

void
    _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            int arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(NSInteger arg0,
                            ffi.Pointer<objc.ObjCObject> arg1)>>()
                .asFunction<void Function(int, ffi.Pointer<objc.ObjCObject>)>()(
            arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            int arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as void Function(
            int, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        int arg0,
        ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      int, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        int arg0,
        ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        int, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, NSInteger, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                NSInteger,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, NSInteger, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                NSInteger,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(NSInteger, NSURLRequest?)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(NSInteger arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
      fromFunction(void Function(NSURLSessionDelayedRequestDisposition, NSURLRequest?) fn) =>
          objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_closureCallable,
                  (int arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                      NSURLSessionDelayedRequestDisposition.fromValue(arg0),
                      arg1.address == 0
                          ? null
                          : NSURLRequest.castFromPointer(arg1, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)> listener(
      void Function(NSURLSessionDelayedRequestDisposition, NSURLRequest?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_listenerCallable
            .nativeFunction
            .cast(),
        (int arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            NSURLSessionDelayedRequestDisposition.fromValue(arg0),
            arg1.address == 0
                ? null
                : NSURLRequest.castFromPointer(arg1,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1otpo83(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)> blocking(
      void Function(NSURLSessionDelayedRequestDisposition, NSURLRequest?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_blockingCallable
            .nativeFunction
            .cast(),
        (int arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            NSURLSessionDelayedRequestDisposition.fromValue(arg0),
            arg1.address == 0
                ? null
                : NSURLRequest.castFromPointer(arg1,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_blockingListenerCallable
            .nativeFunction
            .cast(),
        (int arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            NSURLSessionDelayedRequestDisposition.fromValue(arg0),
            arg1.address == 0
                ? null
                : NSURLRequest.castFromPointer(arg1,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1otpo83, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>`.
extension ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest_CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)> {
  void call(NSURLSessionDelayedRequestDisposition arg0, NSURLRequest? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                          NSInteger arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>, int,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0.value, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_URLSession_task_willBeginDelayedRequest_completionHandler_ =
    objc.registerName(
        "URLSession:task:willBeginDelayedRequest:completionHandler:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Pointer<objc.ObjCObject> arg3,
                            ffi.Pointer<objc.ObjCBlockImpl> arg4)>>()
                .asFunction<
                    void Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCBlockImpl>)>()(
            arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  NSURLRequest,
                  objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCBlockImpl> arg4)>> ptr) =>
      objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  NSURLRequest,
                  objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCBlockImpl> arg4) => fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionTask.castFromPointer(arg2, retain: true, release: true),
                      NSURLRequest.castFromPointer(arg3, retain: true, release: true),
                      ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest.castFromPointer(arg4, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>
      listener(
          void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  NSURLRequest,
                  objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
              fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLRequest.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest
                    .castFromPointer(arg4, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xx612k(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionTask,
                NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>
      blocking(
          void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  NSURLRequest,
                  objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
              fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLRequest.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest
                    .castFromPointer(arg4, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLRequest.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionDelayedRequestDisposition_NSURLRequest
                    .castFromPointer(arg4, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xx612k, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionTask,
                NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)> {
  void call(
          ffi.Pointer<ffi.Void> arg0,
          NSURLSession arg1,
          NSURLSessionTask arg2,
          NSURLRequest arg3,
          objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)> arg4) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3,
                          ffi.Pointer<objc.ObjCBlockImpl> arg4)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(
          ref.pointer,
          arg0,
          arg1.ref.pointer,
          arg2.ref.pointer,
          arg3.ref.pointer,
          arg4.ref.pointer);
}

late final _sel_URLSession_taskIsWaitingForConnectivity_ =
    objc.registerName("URLSession:taskIsWaitingForConnectivity:");
late final _class_NSHTTPURLResponse = objc.getClass("NSHTTPURLResponse");
late final _sel_initWithURL_statusCode_HTTPVersion_headerFields_ =
    objc.registerName("initWithURL:statusCode:HTTPVersion:headerFields:");
final _objc_msgSend_xw7l5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Long,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_statusCode = objc.registerName("statusCode");
late final _sel_allHeaderFields = objc.registerName("allHeaderFields");
late final _sel_localizedStringForStatusCode_ =
    objc.registerName("localizedStringForStatusCode:");
final _objc_msgSend_qugqlf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Long)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();

/// NSHTTPURLResponse
class NSHTTPURLResponse extends NSURLResponse {
  NSHTTPURLResponse._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSHTTPURLResponse] that points to the same underlying object as [other].
  NSHTTPURLResponse.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSHTTPURLResponse] that wraps the given raw object pointer.
  NSHTTPURLResponse.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSHTTPURLResponse].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSHTTPURLResponse);
  }

  /// !
  /// @method	initWithURL:statusCode:HTTPVersion:headerFields:
  /// @abstract initializer for NSHTTPURLResponse objects.
  /// @param 	url the URL from which the response was generated.
  /// @param	statusCode an HTTP status code.
  /// @param	HTTPVersion The version of the HTTP response as represented by the server.  This is typically represented as "HTTP/1.1".
  /// @param 	headerFields A dictionary representing the header keys and values of the server response.
  /// @result 	the instance of the object, or NULL if an error occurred during initialization.
  /// @discussion This API was introduced in Mac OS X 10.7.2 and iOS 5.0 and is not available prior to those releases.
  NSHTTPURLResponse? initWithURL_statusCode_HTTPVersion_headerFields_(
      objc.NSURL url,
      DartNSInteger statusCode,
      objc.NSString? HTTPVersion,
      objc.NSDictionary? headerFields) {
    final _ret = _objc_msgSend_xw7l5(
        this.ref.retainAndReturnPointer(),
        _sel_initWithURL_statusCode_HTTPVersion_headerFields_,
        url.ref.pointer,
        statusCode,
        HTTPVersion?.ref.pointer ?? ffi.nullptr,
        headerFields?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : NSHTTPURLResponse.castFromPointer(_ret, retain: false, release: true);
  }

  /// !
  /// @abstract Returns the HTTP status code of the receiver.
  /// @result The HTTP status code of the receiver.
  DartNSInteger get statusCode {
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_statusCode);
  }

  /// !
  /// @abstract Returns a dictionary containing all the HTTP header fields
  /// of the receiver.
  /// @discussion By examining this header dictionary, clients can see
  /// the "raw" header information which was reported to the protocol
  /// implementation by the HTTP server. This may be of use to
  /// sophisticated or special-purpose HTTP clients.
  /// @result A dictionary containing all the HTTP header fields of the
  /// receiver.
  objc.NSDictionary get allHeaderFields {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_allHeaderFields);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @method valueForHTTPHeaderField:
  /// @abstract Returns the value which corresponds to the given header
  /// field. Note that, in keeping with the HTTP RFC, HTTP header field
  /// names are case-insensitive.
  /// @param field the header field name to use for the lookup
  /// (case-insensitive).
  /// @result the value associated with the given header field, or nil if
  /// there is no value associated with the given header field.
  objc.NSString? valueForHTTPHeaderField_(objc.NSString field) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_valueForHTTPHeaderField_, field.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @method localizedStringForStatusCode:
  /// @abstract Convenience method which returns a localized string
  /// corresponding to the status code for this response.
  /// @param statusCode the status code to use to produce a localized string.
  /// @result A localized string corresponding to the given status code.
  static objc.NSString localizedStringForStatusCode_(DartNSInteger statusCode) {
    final _ret = _objc_msgSend_qugqlf(_class_NSHTTPURLResponse,
        _sel_localizedStringForStatusCode_, statusCode);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// !
  /// @method initWithURL:MIMEType:expectedContentLength:textEncodingName:
  /// @abstract Initialize an NSURLResponse with the provided values.
  /// @param URL the URL
  /// @param MIMEType the MIME content type of the response
  /// @param length the expected content length of the associated data
  /// @param name the name of the text encoding for the associated data, if applicable, else nil
  /// @result The initialized NSURLResponse.
  /// @discussion This is the designated initializer for NSURLResponse.
  NSHTTPURLResponse
      initWithURL_MIMEType_expectedContentLength_textEncodingName_(
          objc.NSURL URL,
          objc.NSString? MIMEType,
          DartNSInteger length,
          objc.NSString? name) {
    final _ret = _objc_msgSend_l9ppnx(
        this.ref.retainAndReturnPointer(),
        _sel_initWithURL_MIMEType_expectedContentLength_textEncodingName_,
        URL.ref.pointer,
        MIMEType?.ref.pointer ?? ffi.nullptr,
        length,
        name?.ref.pointer ?? ffi.nullptr);
    return NSHTTPURLResponse.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// init
  NSHTTPURLResponse init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSHTTPURLResponse.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static NSHTTPURLResponse new1() {
    final _ret = _objc_msgSend_151sglz(_class_NSHTTPURLResponse, _sel_new);
    return NSHTTPURLResponse.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static NSHTTPURLResponse allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_NSHTTPURLResponse, _sel_allocWithZone_, zone);
    return NSHTTPURLResponse.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static NSHTTPURLResponse alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSHTTPURLResponse, _sel_alloc);
    return NSHTTPURLResponse.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  NSHTTPURLResponse self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSHTTPURLResponse.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSHTTPURLResponse retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSHTTPURLResponse.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSHTTPURLResponse autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSHTTPURLResponse.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(
        _class_NSHTTPURLResponse, _sel_supportsSecureCoding);
  }

  /// initWithCoder:
  NSHTTPURLResponse? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : NSHTTPURLResponse.castFromPointer(_ret, retain: false, release: true);
  }
}

void _ObjCBlock_ffiVoid_NSURLRequest_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSURLRequest_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURLRequest_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURLRequest_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSURLRequest_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURLRequest_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSURLRequest_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLRequest_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURLRequest_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSURLRequest_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLRequest_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSURLRequest_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLRequest_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURLRequest_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSURLRequest_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> fromFunction(
          void Function(NSURLRequest?) fn) =>
      objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSURLRequest_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                  ? null
                  : NSURLRequest.castFromPointer(arg0,
                      retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> listener(
      void Function(NSURLRequest?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLRequest_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : NSURLRequest.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> blocking(
      void Function(NSURLRequest?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLRequest_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : NSURLRequest.castFromPointer(arg0,
                retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLRequest_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : NSURLRequest.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>`.
extension ObjCBlock_ffiVoid_NSURLRequest_CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> {
  void call(NSURLRequest? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_ =
    objc.registerName(
        "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCObject> arg4,
            ffi.Pointer<objc.ObjCBlockImpl> arg5) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Pointer<objc.ObjCObject> arg3,
                            ffi.Pointer<objc.ObjCObject> arg4,
                            ffi.Pointer<objc.ObjCBlockImpl> arg5)>>()
                .asFunction<
                    void Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCBlockImpl>)>()(
            arg0, arg1, arg2, arg3, arg4, arg5);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCObject> arg4,
            ffi.Pointer<objc.ObjCBlockImpl> arg5) =>
        (objc.getBlockClosure(block) as void Function(
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>))(
            arg0, arg1, arg2, arg3, arg4, arg5);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCObject> arg4,
        ffi.Pointer<objc.ObjCBlockImpl> arg5) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4, arg5);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCObject> arg4,
        ffi.Pointer<objc.ObjCBlockImpl> arg5) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              NSHTTPURLResponse,
              NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  NSHTTPURLResponse,
                  NSURLRequest,
                  objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCObject> arg4, ffi.Pointer<objc.ObjCBlockImpl> arg5)>> ptr) =>
      objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  NSHTTPURLResponse,
                  NSURLRequest,
                  objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCObject> arg4, ffi.Pointer<objc.ObjCBlockImpl> arg5) => fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionTask.castFromPointer(arg2, retain: true, release: true),
                      NSHTTPURLResponse.castFromPointer(arg3, retain: true, release: true),
                      NSURLRequest.castFromPointer(arg4, retain: true, release: true),
                      ObjCBlock_ffiVoid_NSURLRequest.castFromPointer(arg5, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)> listener(
      void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              NSHTTPURLResponse,
              NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCObject> arg4,
                ffi.Pointer<objc.ObjCBlockImpl> arg5) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSHTTPURLResponse.castFromPointer(arg3,
                    retain: false, release: true),
                NSURLRequest.castFromPointer(arg4,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLRequest.castFromPointer(arg5,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_l2g8ke(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionTask,
                NSHTTPURLResponse,
                NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSHTTPURLResponse,
          NSURLRequest,
          objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)> blocking(
      void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              NSHTTPURLResponse,
              NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCObject> arg4,
                ffi.Pointer<objc.ObjCBlockImpl> arg5) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSHTTPURLResponse.castFromPointer(arg3,
                    retain: false, release: true),
                NSURLRequest.castFromPointer(arg4,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLRequest.castFromPointer(arg5,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCObject> arg4,
                ffi.Pointer<objc.ObjCBlockImpl> arg5) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSHTTPURLResponse.castFromPointer(arg3,
                    retain: false, release: true),
                NSURLRequest.castFromPointer(arg4,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLRequest.castFromPointer(arg5,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_l2g8ke, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionTask,
                NSHTTPURLResponse,
                NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            NSHTTPURLResponse,
            NSURLRequest,
            objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)> {
  void call(
          ffi.Pointer<ffi.Void> arg0,
          NSURLSession arg1,
          NSURLSessionTask arg2,
          NSHTTPURLResponse arg3,
          NSURLRequest arg4,
          objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3,
                          ffi.Pointer<objc.ObjCObject> arg4,
                          ffi.Pointer<objc.ObjCBlockImpl> arg5)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(
          ref.pointer,
          arg0,
          arg1.ref.pointer,
          arg2.ref.pointer,
          arg3.ref.pointer,
          arg4.ref.pointer,
          arg5.ref.pointer);
}

/// WARNING: NSURLAuthenticationChallenge is a stub. To generate bindings for this class, include
/// NSURLAuthenticationChallenge in your config's objc-interfaces list.
///
/// NSURLAuthenticationChallenge
class NSURLAuthenticationChallenge extends objc.ObjCObjectBase {
  NSURLAuthenticationChallenge._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSURLAuthenticationChallenge] that points to the same underlying object as [other].
  NSURLAuthenticationChallenge.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLAuthenticationChallenge] that wraps the given raw object pointer.
  NSURLAuthenticationChallenge.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);
}

/// WARNING: NSURLCredential is a stub. To generate bindings for this class, include
/// NSURLCredential in your config's objc-interfaces list.
///
/// NSURLCredential
class NSURLCredential extends objc.ObjCObjectBase {
  NSURLCredential._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [NSURLCredential] that points to the same underlying object as [other].
  NSURLCredential.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLCredential] that wraps the given raw object pointer.
  NSURLCredential.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

void
    _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            int arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(NSInteger arg0,
                            ffi.Pointer<objc.ObjCObject> arg1)>>()
                .asFunction<void Function(int, ffi.Pointer<objc.ObjCObject>)>()(
            arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            int arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as void Function(
            int, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        int arg0,
        ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      int, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, NSInteger,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        int arg0,
        ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        int, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, NSInteger, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                NSInteger,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, NSInteger, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                NSInteger,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>`.
abstract final class ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(NSInteger, NSURLCredential?)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(NSInteger arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_fnPtrCallable,
              ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>
      fromFunction(void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?) fn) =>
          objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_closureCallable,
                  (int arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                      NSURLSessionAuthChallengeDisposition.fromValue(arg0),
                      arg1.address == 0
                          ? null
                          : NSURLCredential.castFromPointer(arg1, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>
      listener(
          void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?)
              fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_listenerCallable
            .nativeFunction
            .cast(),
        (int arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            NSURLSessionAuthChallengeDisposition.fromValue(arg0),
            arg1.address == 0
                ? null
                : NSURLCredential.castFromPointer(arg1,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_n8yd09(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>
      blocking(
          void Function(NSURLSessionAuthChallengeDisposition, NSURLCredential?)
              fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_blockingCallable
            .nativeFunction
            .cast(),
        (int arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            NSURLSessionAuthChallengeDisposition.fromValue(arg0),
            arg1.address == 0
                ? null
                : NSURLCredential.castFromPointer(arg1,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_blockingListenerCallable
            .nativeFunction
            .cast(),
        (int arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            NSURLSessionAuthChallengeDisposition.fromValue(arg0),
            arg1.address == 0
                ? null
                : NSURLCredential.castFromPointer(arg1,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_n8yd09, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>`.
extension ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential_CallExtension
    on objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)> {
  void call(NSURLSessionAuthChallengeDisposition arg0, NSURLCredential? arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                          NSInteger arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(ffi.Pointer<objc.ObjCBlockImpl>, int,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0.value, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_URLSession_task_didReceiveChallenge_completionHandler_ =
    objc.registerName("URLSession:task:didReceiveChallenge:completionHandler:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Pointer<objc.ObjCObject> arg3,
                            ffi.Pointer<objc.ObjCBlockImpl> arg4)>>()
                .asFunction<
                    void Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCBlockImpl>)>()(
            arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  NSURLAuthenticationChallenge,
                  objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCBlockImpl> arg4)>> ptr) =>
      objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  NSURLAuthenticationChallenge,
                  objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3, ffi.Pointer<objc.ObjCBlockImpl> arg4) => fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionTask.castFromPointer(arg2, retain: true, release: true),
                      NSURLAuthenticationChallenge.castFromPointer(arg3, retain: true, release: true),
                      ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.castFromPointer(arg4, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<
              ffi.Void Function(NSInteger, NSURLCredential?)>)> listener(
      void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLAuthenticationChallenge.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential
                    .castFromPointer(arg4, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xx612k(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionTask,
                NSURLAuthenticationChallenge,
                objc.ObjCBlock<
                    ffi.Void Function(NSInteger, NSURLCredential?)>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<
              ffi.Void Function(NSInteger, NSURLCredential?)>)> blocking(
      void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLAuthenticationChallenge.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential
                    .castFromPointer(arg4, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLAuthenticationChallenge.castFromPointer(arg3,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential
                    .castFromPointer(arg4, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xx612k, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionTask,
                NSURLAuthenticationChallenge,
                objc.ObjCBlock<
                    ffi.Void Function(NSInteger, NSURLCredential?)>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)> {
  void call(
          ffi.Pointer<ffi.Void> arg0,
          NSURLSession arg1,
          NSURLSessionTask arg2,
          NSURLAuthenticationChallenge arg3,
          objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>
              arg4) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3,
                          ffi.Pointer<objc.ObjCBlockImpl> arg4)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer, arg4.ref.pointer);
}

void _ObjCBlock_ffiVoid_NSInputStream_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
        .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSInputStream_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSInputStream_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSInputStream_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSInputStream_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSInputStream_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSInputStream_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSInputStream_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSInputStream_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSInputStream_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSInputStream_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSInputStream_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSInputStream_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSInputStream_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>`.
abstract final class ObjCBlock_ffiVoid_NSInputStream {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_NSInputStream_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> fromFunction(
          void Function(objc.NSInputStream?) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSInputStream_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
                  ? null
                  : objc.NSInputStream.castFromPointer(arg0,
                      retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> listener(
      void Function(objc.NSInputStream?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSInputStream_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSInputStream.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> blocking(
      void Function(objc.NSInputStream?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSInputStream_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSInputStream.castFromPointer(arg0,
                retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSInputStream_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0) => fn(arg0.address == 0
            ? null
            : objc.NSInputStream.castFromPointer(arg0,
                retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_xtuoz7, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>`.
extension ObjCBlock_ffiVoid_NSInputStream_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> {
  void call(objc.NSInputStream? arg0) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_URLSession_task_needNewBodyStream_ =
    objc.registerName("URLSession:task:needNewBodyStream:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCBlockImpl> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      NSURLSession,
                      NSURLSessionTask,
                      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCBlockImpl> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      NSURLSession,
                      NSURLSessionTask,
                      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionTask.castFromPointer(arg2, retain: true, release: true),
                      ObjCBlock_ffiVoid_NSInputStream.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSInputStream.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSInputStream.castFromPointer(arg3,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSInputStream.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_bklti2, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)> {
  void call(
          ffi.Pointer<ffi.Void> arg0,
          NSURLSession arg1,
          NSURLSessionTask arg2,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCBlockImpl> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer);
}

late final _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_ =
    objc.registerName(
        "URLSession:task:needNewBodyStreamFromOffset:completionHandler:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            int arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Int64 arg3,
                            ffi.Pointer<objc.ObjCBlockImpl> arg4)>>()
                .asFunction<
                    void Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        int,
                        ffi.Pointer<objc.ObjCBlockImpl>)>()(
            arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Int64,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            int arg3,
            ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Int64,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        int arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      int,
      ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        int arg3,
        ffi.Pointer<objc.ObjCBlockImpl> arg4) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3, arg4);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Pointer<objc.ObjCBlockImpl>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLSessionTask,
              ffi.Int64,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  ffi.Int64,
                  objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Int64 arg3, ffi.Pointer<objc.ObjCBlockImpl> arg4)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      NSURLSession,
                      NSURLSessionTask,
                      ffi.Int64,
                      objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, int arg3, ffi.Pointer<objc.ObjCBlockImpl> arg4) => fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionTask.castFromPointer(arg2, retain: true, release: true),
                      arg3,
                      ObjCBlock_ffiVoid_NSInputStream.castFromPointer(arg4, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          ffi.Int64,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, int,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                ObjCBlock_ffiVoid_NSInputStream.castFromPointer(arg4,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_jyim80(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionTask,
                ffi.Int64,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          ffi.Int64,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, int,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                ObjCBlock_ffiVoid_NSInputStream.castFromPointer(arg4,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                ffi.Pointer<objc.ObjCBlockImpl> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                ObjCBlock_ffiVoid_NSInputStream.castFromPointer(arg4,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_jyim80, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLSessionTask,
                ffi.Int64,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            ffi.Int64,
            objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)> {
  void call(
          ffi.Pointer<ffi.Void> arg0,
          NSURLSession arg1,
          NSURLSessionTask arg2,
          int arg3,
          objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)> arg4) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Int64 arg3,
                          ffi.Pointer<objc.ObjCBlockImpl> arg4)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      int,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3, arg4.ref.pointer);
}

late final _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_ =
    objc.registerName(
        "URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            int arg3,
            int arg4,
            int arg5) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Int64 arg3,
                        ffi.Int64 arg4,
                        ffi.Int64 arg5)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    int,
                    int,
                    int)>()(arg0, arg1, arg2, arg3, arg4, arg5);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Int64,
                    ffi.Int64,
                    ffi.Int64)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            int arg3,
            int arg4,
            int arg5) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int,
            int))(arg0, arg1, arg2, arg3, arg4, arg5);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Int64,
                    ffi.Int64,
                    ffi.Int64)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        int arg3,
        int arg4,
        int arg5) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      int,
      int,
      int))(arg0, arg1, arg2, arg3, arg4, arg5);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Int64,
                ffi.Int64)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        int arg3,
        int arg4,
        int arg5) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int,
        int))(arg0, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Int64,
                ffi.Int64)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Int64,
                ffi.Int64)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, ffi.Int64, ffi.Int64)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionTask, ffi.Int64, ffi.Int64, ffi.Int64)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionTask,
          ffi.Int64,
          ffi.Int64,
          ffi.Int64)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Int64 arg3, ffi.Int64 arg4, ffi.Int64 arg5)>> ptr) =>
      objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                  NSURLSessionTask, ffi.Int64, ffi.Int64, ffi.Int64)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, ffi.Int64, ffi.Int64)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, int, int, int) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, ffi.Int64, ffi.Int64)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      int arg3,
                      int arg4,
                      int arg5) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionTask.castFromPointer(arg2, retain: true, release: true),
                      arg3,
                      arg4,
                      arg5)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
          ffi.Int64, ffi.Int64, ffi.Int64)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, int,
              int, int)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                int arg4,
                int arg5) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4,
                arg5));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_h68abb(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
          ffi.Int64, ffi.Int64, ffi.Int64)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, int,
              int, int)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                int arg4,
                int arg5) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4,
                arg5));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                int arg4,
                int arg5) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4,
                arg5));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_h68abb, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionTask,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, ffi.Int64, ffi.Int64, ffi.Int64)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            ffi.Int64, ffi.Int64, ffi.Int64)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionTask arg2, int arg3, int arg4, int arg5) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Int64 arg3,
                          ffi.Int64 arg4,
                          ffi.Int64 arg5)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      int,
                      int,
                      int)>()(ref.pointer, arg0, arg1.ref.pointer,
          arg2.ref.pointer, arg3, arg4, arg5);
}

late final _sel_URLSession_task_didReceiveInformationalResponse_ =
    objc.registerName("URLSession:task:didReceiveInformationalResponse:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionTask, NSHTTPURLResponse)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionTask, NSHTTPURLResponse)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionTask, NSHTTPURLResponse)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionTask.castFromPointer(arg2, retain: true, release: true),
                      NSHTTPURLResponse.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
          NSHTTPURLResponse)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
              NSHTTPURLResponse)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSHTTPURLResponse.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            NSHTTPURLResponse)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
          NSHTTPURLResponse)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
              NSHTTPURLResponse)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSHTTPURLResponse.castFromPointer(arg3,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSHTTPURLResponse.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            NSHTTPURLResponse)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSHTTPURLResponse)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            NSHTTPURLResponse)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionTask arg2, NSHTTPURLResponse arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer);
}

/// WARNING: NSURLSessionTaskMetrics is a stub. To generate bindings for this class, include
/// NSURLSessionTaskMetrics in your config's objc-interfaces list.
///
/// NSURLSessionTaskMetrics
class NSURLSessionTaskMetrics extends objc.NSObject {
  NSURLSessionTaskMetrics._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSURLSessionTaskMetrics] that points to the same underlying object as [other].
  NSURLSessionTaskMetrics.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSURLSessionTaskMetrics] that wraps the given raw object pointer.
  NSURLSessionTaskMetrics.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _sel_URLSession_task_didFinishCollectingMetrics_ =
    objc.registerName("URLSession:task:didFinishCollectingMetrics:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionTask, NSURLSessionTaskMetrics)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionTask, NSURLSessionTaskMetrics)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionTask, NSURLSessionTaskMetrics)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionTask, NSURLSessionTaskMetrics)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionTask.castFromPointer(arg2, retain: true, release: true),
                      NSURLSessionTaskMetrics.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
          NSURLSessionTaskMetrics)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
              NSURLSessionTaskMetrics)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLSessionTaskMetrics.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            NSURLSessionTaskMetrics)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
          NSURLSessionTaskMetrics)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
              NSURLSessionTaskMetrics)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLSessionTaskMetrics.castFromPointer(arg3,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                NSURLSessionTaskMetrics.castFromPointer(arg3,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            NSURLSessionTaskMetrics)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            NSURLSessionTaskMetrics)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionTask arg2, NSURLSessionTaskMetrics arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer);
}

late final _sel_URLSession_task_didCompleteWithError_ =
    objc.registerName("URLSession:task:didCompleteWithError:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionTask, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionTask,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionTask, objc.NSError?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionTask, objc.NSError?)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.NSError?)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.NSError?) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionTask.castFromPointer(arg2, retain: true, release: true),
                      arg3.address == 0 ? null : objc.NSError.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
          objc.NSError?)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
              objc.NSError?)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
          objc.NSError?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
              objc.NSError?)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg3,
                        retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionTask,
            objc.NSError?)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionTask arg2, objc.NSError? arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3?.ref.pointer ?? ffi.nullptr);
}

late final _sel_URLSession_didBecomeInvalidWithError_ =
    objc.registerName("URLSession:didBecomeInvalidWithError:");
void _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                  objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)>
      fromFunctionPointer(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      arg2.address == 0 ? null : objc.NSError.castFromPointer(arg2, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                arg2.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg2,
                        retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_fjrv01, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            objc.NSError?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, objc.NSError?)> {
  void call(
          ffi.Pointer<ffi.Void> arg0, NSURLSession arg1, objc.NSError? arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2?.ref.pointer ?? ffi.nullptr);
}

late final _sel_URLSession_didReceiveChallenge_completionHandler_ =
    objc.registerName("URLSession:didReceiveChallenge:completionHandler:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCBlockImpl> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCBlockImpl> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(
                      ffi.Pointer<ffi.Void>,
                      NSURLSession,
                      NSURLAuthenticationChallenge,
                      objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCBlockImpl> arg3)>> ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLAuthenticationChallenge.castFromPointer(arg2, retain: true, release: true),
                      ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<
              ffi.Void Function(NSInteger, NSURLCredential?)>)> listener(
      void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLAuthenticationChallenge.castFromPointer(arg2,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential
                    .castFromPointer(arg3, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_bklti2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLAuthenticationChallenge,
                objc.ObjCBlock<
                    ffi.Void Function(NSInteger, NSURLCredential?)>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLAuthenticationChallenge,
          objc.ObjCBlock<
              ffi.Void Function(NSInteger, NSURLCredential?)>)> blocking(
      void Function(
              ffi.Pointer<ffi.Void>,
              NSURLSession,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLAuthenticationChallenge.castFromPointer(arg2,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential
                    .castFromPointer(arg3, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCBlockImpl> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLAuthenticationChallenge.castFromPointer(arg2,
                    retain: false, release: true),
                ObjCBlock_ffiVoid_NSURLSessionAuthChallengeDisposition_NSURLCredential
                    .castFromPointer(arg3, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_bklti2, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(
                ffi.Pointer<ffi.Void>,
                NSURLSession,
                NSURLAuthenticationChallenge,
                objc.ObjCBlock<
                    ffi.Void Function(NSInteger, NSURLCredential?)>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLAuthenticationChallenge,
            objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)> {
  void call(
          ffi.Pointer<ffi.Void> arg0,
          NSURLSession arg1,
          NSURLAuthenticationChallenge arg2,
          objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>
              arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCBlockImpl> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCBlockImpl>)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer);
}

late final _sel_URLSessionDidFinishEventsForBackgroundURLSession_ =
    objc.registerName("URLSessionDidFinishEventsForBackgroundURLSession:");
void _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  NSURLSession)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(
                          arg0,
                          NSURLSession.castFromPointer(arg1,
                              retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>
      listener(void Function(ffi.Pointer<ffi.Void>, NSURLSession) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            NSURLSession.castFromPointer(arg1, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>
      blocking(void Function(ffi.Pointer<ffi.Void>, NSURLSession) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            NSURLSession.castFromPointer(arg1, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            NSURLSession.castFromPointer(arg1, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_18v1jvf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1) => ref
          .pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1.ref.pointer);
}

/// Messages related to the operation of a task that delivers data
/// directly to the delegate.
abstract final class NSURLSessionDataDelegate {
  /// Builds an object that implements the NSURLSessionDataDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  static objc.ObjCObjectBase implement(
      {void Function(NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)?
          URLSession_dataTask_didReceiveResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
          URLSession_dataTask_didBecomeDownloadTask_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
          URLSession_dataTask_didBecomeStreamTask_,
      void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
          URLSession_dataTask_didReceiveData_,
      void Function(NSURLSession, NSURLSessionDataTask, NSCachedURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)?
          URLSession_dataTask_willCacheResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSURLSessionDataDelegate
            .URLSession_dataTask_didReceiveResponse_completionHandler_
        .implement(
            builder, URLSession_dataTask_didReceiveResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeDownloadTask_
        .implement(builder, URLSession_dataTask_didBecomeDownloadTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeStreamTask_.implement(
        builder, URLSession_dataTask_didBecomeStreamTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didReceiveData_.implement(
        builder, URLSession_dataTask_didReceiveData_);
    NSURLSessionDataDelegate
            .URLSession_dataTask_willCacheResponse_completionHandler_
        .implement(
            builder, URLSession_dataTask_willCacheResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_didCreateTask_.implement(
        builder, URLSession_didCreateTask_);
    NSURLSessionDataDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implement(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDataDelegate.URLSession_taskIsWaitingForConnectivity_.implement(
        builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDataDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implement(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implement(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSession_task_needNewBodyStream_.implement(
        builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDataDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implement(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implement(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDataDelegate.URLSession_task_didReceiveInformationalResponse_
        .implement(builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDataDelegate.URLSession_task_didFinishCollectingMetrics_
        .implement(builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDataDelegate.URLSession_task_didCompleteWithError_.implement(
        builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDataDelegate.URLSession_didBecomeInvalidWithError_.implement(
        builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDataDelegate.URLSession_didReceiveChallenge_completionHandler_
        .implement(builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSessionDidFinishEventsForBackgroundURLSession_
        .implement(builder, URLSessionDidFinishEventsForBackgroundURLSession_);
    return builder.build();
  }

  /// Adds the implementation of the NSURLSessionDataDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {void Function(NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)?
          URLSession_dataTask_didReceiveResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
          URLSession_dataTask_didBecomeDownloadTask_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
          URLSession_dataTask_didBecomeStreamTask_,
      void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
          URLSession_dataTask_didReceiveData_,
      void Function(NSURLSession, NSURLSessionDataTask, NSCachedURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)?
          URLSession_dataTask_willCacheResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    NSURLSessionDataDelegate
            .URLSession_dataTask_didReceiveResponse_completionHandler_
        .implement(
            builder, URLSession_dataTask_didReceiveResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeDownloadTask_
        .implement(builder, URLSession_dataTask_didBecomeDownloadTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeStreamTask_.implement(
        builder, URLSession_dataTask_didBecomeStreamTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didReceiveData_.implement(
        builder, URLSession_dataTask_didReceiveData_);
    NSURLSessionDataDelegate
            .URLSession_dataTask_willCacheResponse_completionHandler_
        .implement(
            builder, URLSession_dataTask_willCacheResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_didCreateTask_.implement(
        builder, URLSession_didCreateTask_);
    NSURLSessionDataDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implement(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDataDelegate.URLSession_taskIsWaitingForConnectivity_.implement(
        builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDataDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implement(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implement(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSession_task_needNewBodyStream_.implement(
        builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDataDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implement(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implement(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDataDelegate.URLSession_task_didReceiveInformationalResponse_
        .implement(builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDataDelegate.URLSession_task_didFinishCollectingMetrics_
        .implement(builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDataDelegate.URLSession_task_didCompleteWithError_.implement(
        builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDataDelegate.URLSession_didBecomeInvalidWithError_.implement(
        builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDataDelegate.URLSession_didReceiveChallenge_completionHandler_
        .implement(builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSessionDidFinishEventsForBackgroundURLSession_
        .implement(builder, URLSessionDidFinishEventsForBackgroundURLSession_);
  }

  /// Builds an object that implements the NSURLSessionDataDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  static objc.ObjCObjectBase implementAsListener(
      {void Function(NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)?
          URLSession_dataTask_didReceiveResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
          URLSession_dataTask_didBecomeDownloadTask_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
          URLSession_dataTask_didBecomeStreamTask_,
      void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
          URLSession_dataTask_didReceiveData_,
      void Function(NSURLSession, NSURLSessionDataTask, NSCachedURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)?
          URLSession_dataTask_willCacheResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSURLSessionDataDelegate
            .URLSession_dataTask_didReceiveResponse_completionHandler_
        .implementAsListener(
            builder, URLSession_dataTask_didReceiveResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeDownloadTask_
        .implementAsListener(
            builder, URLSession_dataTask_didBecomeDownloadTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeStreamTask_
        .implementAsListener(builder, URLSession_dataTask_didBecomeStreamTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didReceiveData_
        .implementAsListener(builder, URLSession_dataTask_didReceiveData_);
    NSURLSessionDataDelegate
            .URLSession_dataTask_willCacheResponse_completionHandler_
        .implementAsListener(
            builder, URLSession_dataTask_willCacheResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_didCreateTask_.implementAsListener(
        builder, URLSession_didCreateTask_);
    NSURLSessionDataDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDataDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsListener(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDataDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSession_task_needNewBodyStream_
        .implementAsListener(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDataDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsListener(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsListener(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDataDelegate.URLSession_task_didReceiveInformationalResponse_
        .implementAsListener(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDataDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsListener(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDataDelegate.URLSession_task_didCompleteWithError_
        .implementAsListener(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDataDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsListener(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDataDelegate.URLSession_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsListener(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
    return builder.build();
  }

  /// Adds the implementation of the NSURLSessionDataDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {void Function(NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)?
          URLSession_dataTask_didReceiveResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
          URLSession_dataTask_didBecomeDownloadTask_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
          URLSession_dataTask_didBecomeStreamTask_,
      void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
          URLSession_dataTask_didReceiveData_,
      void Function(NSURLSession, NSURLSessionDataTask, NSCachedURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)?
          URLSession_dataTask_willCacheResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    NSURLSessionDataDelegate
            .URLSession_dataTask_didReceiveResponse_completionHandler_
        .implementAsListener(
            builder, URLSession_dataTask_didReceiveResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeDownloadTask_
        .implementAsListener(
            builder, URLSession_dataTask_didBecomeDownloadTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeStreamTask_
        .implementAsListener(builder, URLSession_dataTask_didBecomeStreamTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didReceiveData_
        .implementAsListener(builder, URLSession_dataTask_didReceiveData_);
    NSURLSessionDataDelegate
            .URLSession_dataTask_willCacheResponse_completionHandler_
        .implementAsListener(
            builder, URLSession_dataTask_willCacheResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_didCreateTask_.implementAsListener(
        builder, URLSession_didCreateTask_);
    NSURLSessionDataDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDataDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsListener(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDataDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSession_task_needNewBodyStream_
        .implementAsListener(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDataDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsListener(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsListener(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDataDelegate.URLSession_task_didReceiveInformationalResponse_
        .implementAsListener(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDataDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsListener(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDataDelegate.URLSession_task_didCompleteWithError_
        .implementAsListener(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDataDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsListener(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDataDelegate.URLSession_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsListener(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
  }

  /// Builds an object that implements the NSURLSessionDataDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  static objc.ObjCObjectBase implementAsBlocking(
      {void Function(NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)?
          URLSession_dataTask_didReceiveResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
          URLSession_dataTask_didBecomeDownloadTask_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
          URLSession_dataTask_didBecomeStreamTask_,
      void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
          URLSession_dataTask_didReceiveData_,
      void Function(NSURLSession, NSURLSessionDataTask, NSCachedURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)?
          URLSession_dataTask_willCacheResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSURLSessionDataDelegate
            .URLSession_dataTask_didReceiveResponse_completionHandler_
        .implementAsBlocking(
            builder, URLSession_dataTask_didReceiveResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeDownloadTask_
        .implementAsBlocking(
            builder, URLSession_dataTask_didBecomeDownloadTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeStreamTask_
        .implementAsBlocking(builder, URLSession_dataTask_didBecomeStreamTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didReceiveData_
        .implementAsBlocking(builder, URLSession_dataTask_didReceiveData_);
    NSURLSessionDataDelegate
            .URLSession_dataTask_willCacheResponse_completionHandler_
        .implementAsBlocking(
            builder, URLSession_dataTask_willCacheResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_didCreateTask_.implementAsBlocking(
        builder, URLSession_didCreateTask_);
    NSURLSessionDataDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDataDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsBlocking(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDataDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSession_task_needNewBodyStream_
        .implementAsBlocking(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDataDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsBlocking(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDataDelegate.URLSession_task_didReceiveInformationalResponse_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDataDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsBlocking(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDataDelegate.URLSession_task_didCompleteWithError_
        .implementAsBlocking(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDataDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsBlocking(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDataDelegate.URLSession_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsBlocking(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
    return builder.build();
  }

  /// Adds the implementation of the NSURLSessionDataDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {void Function(NSURLSession, NSURLSessionDataTask, NSURLResponse, objc.ObjCBlock<ffi.Void Function(NSInteger)>)?
          URLSession_dataTask_didReceiveResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)?
          URLSession_dataTask_didBecomeDownloadTask_,
      void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)?
          URLSession_dataTask_didBecomeStreamTask_,
      void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)?
          URLSession_dataTask_didReceiveData_,
      void Function(NSURLSession, NSURLSessionDataTask, NSCachedURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)?
          URLSession_dataTask_willCacheResponse_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    NSURLSessionDataDelegate
            .URLSession_dataTask_didReceiveResponse_completionHandler_
        .implementAsBlocking(
            builder, URLSession_dataTask_didReceiveResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeDownloadTask_
        .implementAsBlocking(
            builder, URLSession_dataTask_didBecomeDownloadTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didBecomeStreamTask_
        .implementAsBlocking(builder, URLSession_dataTask_didBecomeStreamTask_);
    NSURLSessionDataDelegate.URLSession_dataTask_didReceiveData_
        .implementAsBlocking(builder, URLSession_dataTask_didReceiveData_);
    NSURLSessionDataDelegate
            .URLSession_dataTask_willCacheResponse_completionHandler_
        .implementAsBlocking(
            builder, URLSession_dataTask_willCacheResponse_completionHandler_);
    NSURLSessionDataDelegate.URLSession_didCreateTask_.implementAsBlocking(
        builder, URLSession_didCreateTask_);
    NSURLSessionDataDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDataDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsBlocking(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDataDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSession_task_needNewBodyStream_
        .implementAsBlocking(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDataDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDataDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsBlocking(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDataDelegate.URLSession_task_didReceiveInformationalResponse_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDataDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsBlocking(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDataDelegate.URLSession_task_didCompleteWithError_
        .implementAsBlocking(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDataDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsBlocking(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDataDelegate.URLSession_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDataDelegate.URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsBlocking(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
  }

  /// The task has received a response and no further messages will be
  /// received until the completion block is called. The disposition
  /// allows you to cancel a request or to turn a data task into a
  /// download task. This delegate message is optional - if you do not
  /// implement it, you can get the response as a property of the task.
  ///
  /// This method will not be called for background upload tasks (which cannot be converted to download tasks).
  static final URLSession_dataTask_didReceiveResponse_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionDataTask, NSURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSInteger)>)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_dataTask_didReceiveResponse_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_dataTask_didReceiveResponse_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionDataTask, NSURLResponse,
                objc.ObjCBlock<ffi.Void Function(NSInteger)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionDataTask arg2,
                    NSURLResponse arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger)> arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionDataTask, NSURLResponse,
                objc.ObjCBlock<ffi.Void Function(NSInteger)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionDataTask arg2,
                    NSURLResponse arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger)> arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionDataTask, NSURLResponse,
                objc.ObjCBlock<ffi.Void Function(NSInteger)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLResponse_ffiVoidNSURLSessionResponseDisposition
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionDataTask arg2,
                    NSURLResponse arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger)> arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Notification that a data task has become a download task.  No
  /// future messages will be sent to the data task.
  static final URLSession_dataTask_didBecomeDownloadTask_ =
      objc.ObjCProtocolListenableMethod<
          void Function(
              NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_dataTask_didBecomeDownloadTask_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_dataTask_didBecomeDownloadTask_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDataTask arg2, NSURLSessionDownloadTask arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDataTask arg2, NSURLSessionDownloadTask arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionDownloadTask
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDataTask arg2, NSURLSessionDownloadTask arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Notification that a data task has become a bidirectional stream
  /// task.  No future messages will be sent to the data task.  The newly
  /// created streamTask will carry the original request and response as
  /// properties.
  ///
  /// For requests that were pipelined, the stream object will only allow
  /// reading, and the object will immediately issue a
  /// -URLSession:writeClosedForStream:.  Pipelining can be disabled for
  /// all requests in a session, or by the NSURLRequest
  /// HTTPShouldUsePipelining property.
  ///
  /// The underlying connection is no longer considered part of the HTTP
  /// connection cache and won't count against the total number of
  /// connections per host.
  static final URLSession_dataTask_didBecomeStreamTask_ =
      objc.ObjCProtocolListenableMethod<
          void Function(
              NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_dataTask_didBecomeStreamTask_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_dataTask_didBecomeStreamTask_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDataTask arg2, NSURLSessionStreamTask arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDataTask arg2, NSURLSessionStreamTask arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionDataTask, NSURLSessionStreamTask)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSURLSessionStreamTask
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDataTask arg2, NSURLSessionStreamTask arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Sent when data is available for the delegate to consume.  As the
  /// data may be discontiguous, you should use
  /// [NSData enumerateByteRangesUsingBlock:] to access it.
  static final URLSession_dataTask_didReceiveData_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionDataTask, objc.NSData)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_dataTask_didReceiveData_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_dataTask_didReceiveData_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionDataTask, objc.NSData) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDataTask arg2, objc.NSData arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionDataTask, objc.NSData) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDataTask arg2, objc.NSData arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionDataTask, objc.NSData) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSData
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDataTask arg2, objc.NSData arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Invoke the completion routine with a valid NSCachedURLResponse to
  /// allow the resulting data to be cached, or pass nil to prevent
  /// caching. Note that there is no guarantee that caching will be
  /// attempted for a given resource, and you should not rely on this
  /// message to receive the resource data.
  static final URLSession_dataTask_willCacheResponse_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionDataTask, NSCachedURLResponse,
              objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_dataTask_willCacheResponse_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_dataTask_willCacheResponse_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionDataTask, NSCachedURLResponse,
                objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionDataTask arg2,
                    NSCachedURLResponse arg3,
                    objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionDataTask, NSCachedURLResponse,
                objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionDataTask arg2,
                    NSCachedURLResponse arg3,
                    objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionDataTask, NSCachedURLResponse,
                objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDataTask_NSCachedURLResponse_ffiVoidNSCachedURLResponse
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionDataTask arg2,
                    NSCachedURLResponse arg3,
                    objc.ObjCBlock<ffi.Void Function(NSCachedURLResponse?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Notification that a task has been created.  This method is the first message
  /// a task sends, providing a place to configure the task before it is resumed.
  ///
  /// This delegate callback is *NOT* dispatched to the delegate queue.  It is
  /// invoked synchronously before the task creation method returns.
  static final URLSession_didCreateTask_ = objc.ObjCProtocolListenableMethod<
      void Function(NSURLSession, NSURLSessionTask)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_didCreateTask_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_didCreateTask_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
  );

  /// Sent when the system is ready to begin work for a task with a delayed start
  /// time set (using the earliestBeginDate property). The completionHandler must
  /// be invoked in order for loading to proceed. The disposition provided to the
  /// completion handler continues the load with the original request provided to
  /// the task, replaces the request with the specified task, or cancels the task.
  /// If this delegate is not implemented, loading will proceed with the original
  /// request.
  ///
  /// Recommendation: only implement this delegate if tasks that have the
  /// earliestBeginDate property set may become stale and require alteration prior
  /// to starting the network load.
  ///
  /// If a new request is specified, the allowsExpensiveNetworkAccess,
  /// allowsConstrainedNetworkAccess, and allowsCellularAccess properties
  /// from the new request will not be used; the properties from the
  /// original request will continue to be used.
  ///
  /// Canceling the task is equivalent to calling the task's cancel method; the
  /// URLSession:task:didCompleteWithError: task delegate will be called with error
  /// NSURLErrorCancelled.
  static final URLSession_task_willBeginDelayedRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLRequest arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLRequest arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLRequest arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Sent when a task cannot start the network loading process because the current
  /// network connectivity is not available or sufficient for the task's request.
  ///
  /// This delegate will be called at most one time per task, and is only called if
  /// the waitsForConnectivity property in the NSURLSessionConfiguration has been
  /// set to YES.
  ///
  /// This delegate callback will never be called for background sessions, because
  /// the waitForConnectivity property is ignored by those sessions.
  static final URLSession_taskIsWaitingForConnectivity_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_taskIsWaitingForConnectivity_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_taskIsWaitingForConnectivity_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
  );

  /// An HTTP request is attempting to perform a redirection to a different
  /// URL. You must invoke the completion routine to allow the
  /// redirection, allow the redirection with a modified request, or
  /// pass nil to the completionHandler to cause the body of the redirection
  /// response to be delivered as the payload of this request. The default
  /// is to follow redirections.
  ///
  /// For tasks in background sessions, redirections will always be followed and this method will not be called.
  static final URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
                NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSHTTPURLResponse arg3,
                    NSURLRequest arg4,
                    objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
                NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSHTTPURLResponse arg3,
                    NSURLRequest arg4,
                    objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
                NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSHTTPURLResponse arg3,
                    NSURLRequest arg4,
                    objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
  );

  /// The task has received a request specific authentication challenge.
  /// If this delegate is not implemented, the session specific authentication challenge
  /// will *NOT* be called and the behavior will be the same as using the default handling
  /// disposition.
  static final URLSession_task_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_task_didReceiveChallenge_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_task_didReceiveChallenge_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLAuthenticationChallenge arg3,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLAuthenticationChallenge arg3,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLAuthenticationChallenge arg3,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Sent if a task requires a new, unopened body stream.  This may be
  /// necessary when authentication has failed for any request that
  /// involves a body stream.
  static final URLSession_task_needNewBodyStream_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_task_needNewBodyStream_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_task_needNewBodyStream_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Tells the delegate if a task requires a new body stream starting from the given offset. This may be
  /// necessary when resuming a failed upload task.
  ///
  /// - Parameter session: The session containing the task that needs a new body stream from the given offset.
  /// - Parameter task: The task that needs a new body stream.
  /// - Parameter offset: The starting offset required for the body stream.
  /// - Parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
  static final URLSession_task_needNewBodyStreamFromOffset_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, int,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, int,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    int arg3,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, int,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    int arg3,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, int,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    int arg3,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Sent periodically to notify the delegate of upload progress.  This
  /// information is also available as properties of the task.
  static final URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, int, int, int)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, int arg3, int arg4, int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, int arg3, int arg4, int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, int arg3, int arg4, int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
  );

  /// Sent for each informational response received except 101 switching protocols.
  static final URLSession_task_didReceiveInformationalResponse_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_task_didReceiveInformationalResponse_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_task_didReceiveInformationalResponse_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSHTTPURLResponse arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSHTTPURLResponse arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSHTTPURLResponse arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Sent when complete statistics information has been collected for the task.
  static final URLSession_task_didFinishCollectingMetrics_ =
      objc.ObjCProtocolListenableMethod<
          void Function(
              NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_task_didFinishCollectingMetrics_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_task_didFinishCollectingMetrics_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSURLSessionTaskMetrics arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSURLSessionTaskMetrics arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSURLSessionTaskMetrics arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Sent as the last message related to a specific task.  Error may be
  /// nil, which implies that no error occurred and this task is complete.
  static final URLSession_task_didCompleteWithError_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, objc.NSError?)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_task_didCompleteWithError_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_task_didCompleteWithError_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// The last message a session receives.  A session will only become
  /// invalid because of a systemic error or when it has been
  /// explicitly invalidated, in which case the error parameter will be nil.
  static final URLSession_didBecomeInvalidWithError_ = objc
      .ObjCProtocolListenableMethod<void Function(NSURLSession, objc.NSError?)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_didBecomeInvalidWithError_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_didBecomeInvalidWithError_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
  );

  /// If implemented, when a connection level authentication challenge
  /// has occurred, this delegate will be given the opportunity to
  /// provide authentication credentials to the underlying
  /// connection. Some types of authentication will apply to more than
  /// one request on a given connection to a server (SSL Server Trust
  /// challenges).  If this delegate message is not implemented, the
  /// behavior will be to use the default handling, which may involve user
  /// interaction.
  static final URLSession_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSession_didReceiveChallenge_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSession_didReceiveChallenge_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLAuthenticationChallenge arg2,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLAuthenticationChallenge arg2,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLAuthenticationChallenge arg2,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// If an application has received an
  /// -application:handleEventsForBackgroundURLSession:completionHandler:
  /// message, the session delegate will receive this message to indicate
  /// that all messages previously enqueued for this session have been
  /// delivered.  At this time it is safe to invoke the previously stored
  /// completion handler, or to begin any internal updates that will
  /// result in invoking the completion handler.
  static final URLSessionDidFinishEventsForBackgroundURLSession_ =
      objc.ObjCProtocolListenableMethod<void Function(NSURLSession)>(
    _protocol_NSURLSessionDataDelegate,
    _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDataDelegate,
      _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1)),
    (void Function(NSURLSession) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1)),
    (void Function(NSURLSession) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1)),
  );
}

late final _protocol_NSURLSessionDownloadDelegate =
    objc.getProtocol("NSURLSessionDownloadDelegate");
late final _sel_URLSession_downloadTask_didFinishDownloadingToURL_ =
    objc.registerName("URLSession:downloadTask:didFinishDownloadingToURL:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, objc.NSURL)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionDownloadTask,
                  objc.NSURL)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, objc.NSURL)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionDownloadTask, objc.NSURL)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, objc.NSURL) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionDownloadTask.castFromPointer(arg2, retain: true, release: true),
                      objc.NSURL.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDownloadTask, objc.NSURL)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, objc.NSURL)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSURL
                    .castFromPointer(arg3, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDownloadTask,
            objc.NSURL)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDownloadTask, objc.NSURL)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, objc.NSURL)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSURL
                    .castFromPointer(arg3, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSURL
                    .castFromPointer(arg3, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDownloadTask,
            objc.NSURL)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            NSURLSessionDownloadTask, objc.NSURL)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionDownloadTask arg2, objc.NSURL arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3.ref.pointer);
}

late final _sel_URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_ =
    objc.registerName(
        "URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            int arg3,
            int arg4,
            int arg5) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Int64 arg3,
                        ffi.Int64 arg4,
                        ffi.Int64 arg5)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    int,
                    int,
                    int)>()(arg0, arg1, arg2, arg3, arg4, arg5);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Int64,
                    ffi.Int64,
                    ffi.Int64)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            int arg3,
            int arg4,
            int arg5) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int,
            int))(arg0, arg1, arg2, arg3, arg4, arg5);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Int64,
                    ffi.Int64,
                    ffi.Int64)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        int arg3,
        int arg4,
        int arg5) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      int,
      int,
      int))(arg0, arg1, arg2, arg3, arg4, arg5);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Int64,
                ffi.Int64)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        int arg3,
        int arg4,
        int arg5) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int,
        int))(arg0, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Int64,
                ffi.Int64)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Int64,
                ffi.Int64)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionDownloadTask,
                  ffi.Int64,
                  ffi.Int64,
                  ffi.Int64)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(
          ffi.Pointer<ffi.Void>,
          NSURLSession,
          NSURLSessionDownloadTask,
          ffi.Int64,
          ffi.Int64,
          ffi.Int64)> fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Int64 arg3, ffi.Int64 arg4, ffi.Int64 arg5)>> ptr) =>
      objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                  NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, int, int, int) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      int arg3,
                      int arg4,
                      int arg5) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionDownloadTask.castFromPointer(arg2, retain: true, release: true),
                      arg3,
                      arg4,
                      arg5)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, int, int, int)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                int arg4,
                int arg5) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4,
                arg5));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_h68abb(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDownloadTask,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, int, int, int)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                int arg4,
                int arg5) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4,
                arg5));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                int arg4,
                int arg5) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4,
                arg5));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_h68abb, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDownloadTask,
            ffi.Int64,
            ffi.Int64,
            ffi.Int64)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            NSURLSessionDownloadTask, ffi.Int64, ffi.Int64, ffi.Int64)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionDownloadTask arg2, int arg3, int arg4, int arg5) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Int64 arg3,
                          ffi.Int64 arg4,
                          ffi.Int64 arg5)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      int,
                      int,
                      int)>()(ref.pointer, arg0, arg1.ref.pointer,
          arg2.ref.pointer, arg3, arg4, arg5);
}

late final _sel_URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_ =
    objc.registerName(
        "URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            int arg3,
            int arg4) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Int64 arg3,
                        ffi.Int64 arg4)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    int,
                    int)>()(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Int64,
                    ffi.Int64)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            int arg3,
            int arg4) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int))(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Int64,
                    ffi.Int64)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        int arg3,
        int arg4) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      int,
      int))(arg0, arg1, arg2, arg3, arg4);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Int64)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Int64)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        int arg3,
        int arg4) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int))(arg0, arg1, arg2, arg3, arg4);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Int64)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Int64)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Int64,
            ffi.Int64)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int64,
                ffi.Int64)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionDownloadTask,
                  ffi.Int64,
                  ffi.Int64)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Int64 arg3, ffi.Int64 arg4)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, int, int) fn) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, int arg3, int arg4) => fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionDownloadTask.castFromPointer(arg2, retain: true, release: true),
                      arg3,
                      arg4)),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, int, int)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2, int arg3, int arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_ly2579(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDownloadTask,
            ffi.Int64,
            ffi.Int64)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionDownloadTask, int, int)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2, int arg3, int arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2, int arg3, int arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_ly2579, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionDownloadTask,
            ffi.Int64,
            ffi.Int64)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            NSURLSessionDownloadTask, ffi.Int64, ffi.Int64)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionDownloadTask arg2, int arg3, int arg4) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Int64 arg3,
                          ffi.Int64 arg4)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      int,
                      int)>()(
          ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3, arg4);
}

/// Messages related to the operation of a task that writes data to a
/// file and notifies the delegate upon completion.
abstract final class NSURLSessionDownloadDelegate {
  /// Builds an object that implements the NSURLSessionDownloadDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  static objc.ObjCObjectBase implement(
      {required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          URLSession_downloadTask_didFinishDownloadingToURL_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
          URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
          URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didFinishDownloadingToURL_
        .implement(builder, URLSession_downloadTask_didFinishDownloadingToURL_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_
        .implement(builder,
            URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_
        .implement(builder,
            URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_);
    NSURLSessionDownloadDelegate.URLSession_didCreateTask_.implement(
        builder, URLSession_didCreateTask_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implement(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_taskIsWaitingForConnectivity_
        .implement(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implement(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implement(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_task_needNewBodyStream_.implement(
        builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDownloadDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implement(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implement(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implement(builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDownloadDelegate.URLSession_task_didFinishCollectingMetrics_
        .implement(builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDownloadDelegate.URLSession_task_didCompleteWithError_
        .implement(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDownloadDelegate.URLSession_didBecomeInvalidWithError_
        .implement(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDownloadDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implement(builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implement(builder, URLSessionDidFinishEventsForBackgroundURLSession_);
    return builder.build();
  }

  /// Adds the implementation of the NSURLSessionDownloadDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          URLSession_downloadTask_didFinishDownloadingToURL_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
          URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
          URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didFinishDownloadingToURL_
        .implement(builder, URLSession_downloadTask_didFinishDownloadingToURL_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_
        .implement(builder,
            URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_
        .implement(builder,
            URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_);
    NSURLSessionDownloadDelegate.URLSession_didCreateTask_.implement(
        builder, URLSession_didCreateTask_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implement(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_taskIsWaitingForConnectivity_
        .implement(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implement(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implement(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_task_needNewBodyStream_.implement(
        builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDownloadDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implement(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implement(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implement(builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDownloadDelegate.URLSession_task_didFinishCollectingMetrics_
        .implement(builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDownloadDelegate.URLSession_task_didCompleteWithError_
        .implement(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDownloadDelegate.URLSession_didBecomeInvalidWithError_
        .implement(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDownloadDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implement(builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implement(builder, URLSessionDidFinishEventsForBackgroundURLSession_);
  }

  /// Builds an object that implements the NSURLSessionDownloadDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  static objc.ObjCObjectBase implementAsListener(
      {required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          URLSession_downloadTask_didFinishDownloadingToURL_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
          URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
          URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didFinishDownloadingToURL_
        .implementAsListener(
            builder, URLSession_downloadTask_didFinishDownloadingToURL_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_
        .implementAsListener(builder,
            URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_
        .implementAsListener(builder,
            URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_);
    NSURLSessionDownloadDelegate.URLSession_didCreateTask_.implementAsListener(
        builder, URLSession_didCreateTask_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsListener(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_task_needNewBodyStream_
        .implementAsListener(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDownloadDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsListener(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsListener(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implementAsListener(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDownloadDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsListener(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDownloadDelegate.URLSession_task_didCompleteWithError_
        .implementAsListener(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDownloadDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsListener(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDownloadDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsListener(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
    return builder.build();
  }

  /// Adds the implementation of the NSURLSessionDownloadDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          URLSession_downloadTask_didFinishDownloadingToURL_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
          URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
          URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didFinishDownloadingToURL_
        .implementAsListener(
            builder, URLSession_downloadTask_didFinishDownloadingToURL_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_
        .implementAsListener(builder,
            URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_
        .implementAsListener(builder,
            URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_);
    NSURLSessionDownloadDelegate.URLSession_didCreateTask_.implementAsListener(
        builder, URLSession_didCreateTask_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsListener(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_task_needNewBodyStream_
        .implementAsListener(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDownloadDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsListener(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsListener(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implementAsListener(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDownloadDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsListener(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDownloadDelegate.URLSession_task_didCompleteWithError_
        .implementAsListener(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDownloadDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsListener(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDownloadDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsListener(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
  }

  /// Builds an object that implements the NSURLSessionDownloadDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  static objc.ObjCObjectBase implementAsBlocking(
      {required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          URLSession_downloadTask_didFinishDownloadingToURL_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
          URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
          URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didFinishDownloadingToURL_
        .implementAsBlocking(
            builder, URLSession_downloadTask_didFinishDownloadingToURL_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_
        .implementAsBlocking(builder,
            URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_
        .implementAsBlocking(builder,
            URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_);
    NSURLSessionDownloadDelegate.URLSession_didCreateTask_.implementAsBlocking(
        builder, URLSession_didCreateTask_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsBlocking(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_task_needNewBodyStream_
        .implementAsBlocking(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDownloadDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsBlocking(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDownloadDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsBlocking(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDownloadDelegate.URLSession_task_didCompleteWithError_
        .implementAsBlocking(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDownloadDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsBlocking(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDownloadDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsBlocking(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
    return builder.build();
  }

  /// Adds the implementation of the NSURLSessionDownloadDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {required void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          URLSession_downloadTask_didFinishDownloadingToURL_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)?
          URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
      void Function(NSURLSession, NSURLSessionDownloadTask, int, int)?
          URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didFinishDownloadingToURL_
        .implementAsBlocking(
            builder, URLSession_downloadTask_didFinishDownloadingToURL_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_
        .implementAsBlocking(builder,
            URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_);
    NSURLSessionDownloadDelegate
            .URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_
        .implementAsBlocking(builder,
            URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_);
    NSURLSessionDownloadDelegate.URLSession_didCreateTask_.implementAsBlocking(
        builder, URLSession_didCreateTask_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsBlocking(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionDownloadDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate.URLSession_task_needNewBodyStream_
        .implementAsBlocking(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionDownloadDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsBlocking(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionDownloadDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionDownloadDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsBlocking(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionDownloadDelegate.URLSession_task_didCompleteWithError_
        .implementAsBlocking(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionDownloadDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsBlocking(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionDownloadDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionDownloadDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsBlocking(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
  }

  /// Sent when a download task that has completed a download.  The delegate should
  /// copy or move the file at the given location to a new location as it will be
  /// removed when the delegate message returns. URLSession:task:didCompleteWithError: will
  /// still be called.
  static final URLSession_downloadTask_didFinishDownloadingToURL_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_downloadTask_didFinishDownloadingToURL_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_downloadTask_didFinishDownloadingToURL_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDownloadTask arg2, objc.NSURL arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDownloadTask arg2, objc.NSURL arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionDownloadTask, objc.NSURL) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_NSURL
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDownloadTask arg2, objc.NSURL arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Sent periodically to notify the delegate of download progress.
  static final URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionDownloadTask arg2,
                    int arg3,
                    int arg4,
                    int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionDownloadTask arg2,
                    int arg3,
                    int arg4,
                    int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionDownloadTask, int, int, int)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64_Int64
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionDownloadTask arg2,
                    int arg3,
                    int arg4,
                    int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
  );

  /// Sent when a download has been resumed. If a download failed with an
  /// error, the -userInfo dictionary of the error will contain an
  /// NSURLSessionDownloadTaskResumeData key, whose value is the resume
  /// data.
  static final URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionDownloadTask, int, int)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionDownloadTask, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDownloadTask arg2, int arg3, int arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionDownloadTask, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDownloadTask arg2, int arg3, int arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionDownloadTask, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionDownloadTask_Int64_Int64
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionDownloadTask arg2, int arg3, int arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Notification that a task has been created.  This method is the first message
  /// a task sends, providing a place to configure the task before it is resumed.
  ///
  /// This delegate callback is *NOT* dispatched to the delegate queue.  It is
  /// invoked synchronously before the task creation method returns.
  static final URLSession_didCreateTask_ = objc.ObjCProtocolListenableMethod<
      void Function(NSURLSession, NSURLSessionTask)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_didCreateTask_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_didCreateTask_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
  );

  /// Sent when the system is ready to begin work for a task with a delayed start
  /// time set (using the earliestBeginDate property). The completionHandler must
  /// be invoked in order for loading to proceed. The disposition provided to the
  /// completion handler continues the load with the original request provided to
  /// the task, replaces the request with the specified task, or cancels the task.
  /// If this delegate is not implemented, loading will proceed with the original
  /// request.
  ///
  /// Recommendation: only implement this delegate if tasks that have the
  /// earliestBeginDate property set may become stale and require alteration prior
  /// to starting the network load.
  ///
  /// If a new request is specified, the allowsExpensiveNetworkAccess,
  /// allowsConstrainedNetworkAccess, and allowsCellularAccess properties
  /// from the new request will not be used; the properties from the
  /// original request will continue to be used.
  ///
  /// Canceling the task is equivalent to calling the task's cancel method; the
  /// URLSession:task:didCompleteWithError: task delegate will be called with error
  /// NSURLErrorCancelled.
  static final URLSession_task_willBeginDelayedRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLRequest arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLRequest arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLRequest arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Sent when a task cannot start the network loading process because the current
  /// network connectivity is not available or sufficient for the task's request.
  ///
  /// This delegate will be called at most one time per task, and is only called if
  /// the waitsForConnectivity property in the NSURLSessionConfiguration has been
  /// set to YES.
  ///
  /// This delegate callback will never be called for background sessions, because
  /// the waitForConnectivity property is ignored by those sessions.
  static final URLSession_taskIsWaitingForConnectivity_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_taskIsWaitingForConnectivity_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_taskIsWaitingForConnectivity_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
  );

  /// An HTTP request is attempting to perform a redirection to a different
  /// URL. You must invoke the completion routine to allow the
  /// redirection, allow the redirection with a modified request, or
  /// pass nil to the completionHandler to cause the body of the redirection
  /// response to be delivered as the payload of this request. The default
  /// is to follow redirections.
  ///
  /// For tasks in background sessions, redirections will always be followed and this method will not be called.
  static final URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
                NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSHTTPURLResponse arg3,
                    NSURLRequest arg4,
                    objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
                NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSHTTPURLResponse arg3,
                    NSURLRequest arg4,
                    objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
                NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSHTTPURLResponse arg3,
                    NSURLRequest arg4,
                    objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
  );

  /// The task has received a request specific authentication challenge.
  /// If this delegate is not implemented, the session specific authentication challenge
  /// will *NOT* be called and the behavior will be the same as using the default handling
  /// disposition.
  static final URLSession_task_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_task_didReceiveChallenge_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_task_didReceiveChallenge_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLAuthenticationChallenge arg3,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLAuthenticationChallenge arg3,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLAuthenticationChallenge arg3,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Sent if a task requires a new, unopened body stream.  This may be
  /// necessary when authentication has failed for any request that
  /// involves a body stream.
  static final URLSession_task_needNewBodyStream_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_task_needNewBodyStream_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_task_needNewBodyStream_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Tells the delegate if a task requires a new body stream starting from the given offset. This may be
  /// necessary when resuming a failed upload task.
  ///
  /// - Parameter session: The session containing the task that needs a new body stream from the given offset.
  /// - Parameter task: The task that needs a new body stream.
  /// - Parameter offset: The starting offset required for the body stream.
  /// - Parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
  static final URLSession_task_needNewBodyStreamFromOffset_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, int,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, int,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    int arg3,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, int,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    int arg3,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, int,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    int arg3,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Sent periodically to notify the delegate of upload progress.  This
  /// information is also available as properties of the task.
  static final URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, int, int, int)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, int arg3, int arg4, int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, int arg3, int arg4, int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, int arg3, int arg4, int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
  );

  /// Sent for each informational response received except 101 switching protocols.
  static final URLSession_task_didReceiveInformationalResponse_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_task_didReceiveInformationalResponse_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_task_didReceiveInformationalResponse_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSHTTPURLResponse arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSHTTPURLResponse arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSHTTPURLResponse arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Sent when complete statistics information has been collected for the task.
  static final URLSession_task_didFinishCollectingMetrics_ =
      objc.ObjCProtocolListenableMethod<
          void Function(
              NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_task_didFinishCollectingMetrics_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_task_didFinishCollectingMetrics_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSURLSessionTaskMetrics arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSURLSessionTaskMetrics arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSURLSessionTaskMetrics arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Sent as the last message related to a specific task.  Error may be
  /// nil, which implies that no error occurred and this task is complete.
  static final URLSession_task_didCompleteWithError_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, objc.NSError?)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_task_didCompleteWithError_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_task_didCompleteWithError_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// The last message a session receives.  A session will only become
  /// invalid because of a systemic error or when it has been
  /// explicitly invalidated, in which case the error parameter will be nil.
  static final URLSession_didBecomeInvalidWithError_ = objc
      .ObjCProtocolListenableMethod<void Function(NSURLSession, objc.NSError?)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_didBecomeInvalidWithError_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_didBecomeInvalidWithError_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
  );

  /// If implemented, when a connection level authentication challenge
  /// has occurred, this delegate will be given the opportunity to
  /// provide authentication credentials to the underlying
  /// connection. Some types of authentication will apply to more than
  /// one request on a given connection to a server (SSL Server Trust
  /// challenges).  If this delegate message is not implemented, the
  /// behavior will be to use the default handling, which may involve user
  /// interaction.
  static final URLSession_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSession_didReceiveChallenge_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSession_didReceiveChallenge_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLAuthenticationChallenge arg2,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLAuthenticationChallenge arg2,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLAuthenticationChallenge arg2,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// If an application has received an
  /// -application:handleEventsForBackgroundURLSession:completionHandler:
  /// message, the session delegate will receive this message to indicate
  /// that all messages previously enqueued for this session have been
  /// delivered.  At this time it is safe to invoke the previously stored
  /// completion handler, or to begin any internal updates that will
  /// result in invoking the completion handler.
  static final URLSessionDidFinishEventsForBackgroundURLSession_ =
      objc.ObjCProtocolListenableMethod<void Function(NSURLSession)>(
    _protocol_NSURLSessionDownloadDelegate,
    _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionDownloadDelegate,
      _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1)),
    (void Function(NSURLSession) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1)),
    (void Function(NSURLSession) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1)),
  );
}

late final _protocol_NSURLSessionWebSocketDelegate =
    objc.getProtocol("NSURLSessionWebSocketDelegate");
late final _sel_URLSession_webSocketTask_didOpenWithProtocol_ =
    objc.registerName("URLSession:webSocketTask:didOpenWithProtocol:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionWebSocketTask, objc.NSString?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionWebSocketTask,
                  objc.NSString?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionWebSocketTask, objc.NSString?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionWebSocketTask, objc.NSString?)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, objc.NSString?) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionWebSocketTask.castFromPointer(arg2, retain: true, release: true),
                      arg3.address == 0 ? null : objc.NSString.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionWebSocketTask, objc.NSString?)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionWebSocketTask, objc.NSString?)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionWebSocketTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg3,
                        retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1tz5yf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionWebSocketTask,
            objc.NSString?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionWebSocketTask, objc.NSString?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionWebSocketTask, objc.NSString?)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionWebSocketTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg3,
                        retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionWebSocketTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg3,
                        retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1tz5yf, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionWebSocketTask,
            objc.NSString?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            NSURLSessionWebSocketTask, objc.NSString?)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSURLSession arg1,
          NSURLSessionWebSocketTask arg2, objc.NSString? arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0,
          arg1.ref.pointer, arg2.ref.pointer, arg3?.ref.pointer ?? ffi.nullptr);
}

late final _sel_URLSession_webSocketTask_didCloseWithCode_reason_ =
    objc.registerName("URLSession:webSocketTask:didCloseWithCode:reason:");
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            int arg3,
            ffi.Pointer<objc.ObjCObject> arg4) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        ffi.Void Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            NSInteger arg3,
                            ffi.Pointer<objc.ObjCObject> arg4)>>()
                .asFunction<
                    void Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        int,
                        ffi.Pointer<objc.ObjCObject>)>()(
            arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    NSInteger,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            int arg3,
            ffi.Pointer<objc.ObjCObject> arg4) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3, arg4);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    NSInteger,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        int arg3,
        ffi.Pointer<objc.ObjCObject> arg4) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      int,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3, arg4);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            NSInteger,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                NSInteger,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        int arg3,
        ffi.Pointer<objc.ObjCObject> arg4) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3, arg4);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            NSInteger,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                NSInteger,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            NSInteger,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                NSInteger,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, NSInteger, objc.NSData?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionWebSocketTask, NSInteger, objc.NSData?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void>,
                  NSURLSession,
                  NSURLSessionWebSocketTask,
                  NSInteger,
                  objc.NSData?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionWebSocketTask, NSInteger, objc.NSData?)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, NSInteger arg3, ffi.Pointer<objc.ObjCObject> arg4)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
                      NSURLSessionWebSocketTask, NSInteger, objc.NSData?)>(
              objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, NSInteger, objc.NSData?)> fromFunction(void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, DartNSInteger, objc.NSData?) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, NSInteger, objc.NSData?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_closureCallable,
              (ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      int arg3,
                      ffi.Pointer<objc.ObjCObject> arg4) =>
                  fn(
                      arg0,
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionWebSocketTask.castFromPointer(arg2, retain: true, release: true),
                      arg3,
                      arg4.address == 0 ? null : objc.NSData.castFromPointer(arg4, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionWebSocketTask, NSInteger, objc.NSData?)> listener(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionWebSocketTask, DartNSInteger, objc.NSData?)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                ffi.Pointer<objc.ObjCObject> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionWebSocketTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg4,
                        retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1lx650f(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionWebSocketTask,
            NSInteger,
            objc.NSData?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
          NSURLSessionWebSocketTask, NSInteger, objc.NSData?)> blocking(
      void Function(ffi.Pointer<ffi.Void>, NSURLSession,
              NSURLSessionWebSocketTask, DartNSInteger, objc.NSData?)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                ffi.Pointer<objc.ObjCObject> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionWebSocketTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg4,
                        retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                int arg3,
                ffi.Pointer<objc.ObjCObject> arg4) =>
            fn(
                arg0,
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionWebSocketTask.castFromPointer(arg2,
                    retain: false, release: true),
                arg3,
                arg4.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg4,
                        retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1lx650f, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            ffi.Pointer<ffi.Void>,
            NSURLSession,
            NSURLSessionWebSocketTask,
            NSInteger,
            objc.NSData?)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession, NSURLSessionWebSocketTask, NSInteger, objc.NSData?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
            NSURLSessionWebSocketTask, NSInteger, objc.NSData?)> {
  void call(
          ffi.Pointer<ffi.Void> arg0,
          NSURLSession arg1,
          NSURLSessionWebSocketTask arg2,
          DartNSInteger arg3,
          objc.NSData? arg4) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          NSInteger arg3,
                          ffi.Pointer<objc.ObjCObject> arg4)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      int,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer,
          arg0,
          arg1.ref.pointer,
          arg2.ref.pointer,
          arg3,
          arg4?.ref.pointer ?? ffi.nullptr);
}

/// NSURLSessionWebSocketDelegate
abstract final class NSURLSessionWebSocketDelegate {
  /// Builds an object that implements the NSURLSessionWebSocketDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  static objc.ObjCObjectBase implement(
      {void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
          URLSession_webSocketTask_didOpenWithProtocol_,
      void Function(NSURLSession, NSURLSessionWebSocketTask, DartNSInteger, objc.NSData?)?
          URLSession_webSocketTask_didCloseWithCode_reason_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(
              NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSURLSessionWebSocketDelegate.URLSession_webSocketTask_didOpenWithProtocol_
        .implement(builder, URLSession_webSocketTask_didOpenWithProtocol_);
    NSURLSessionWebSocketDelegate
            .URLSession_webSocketTask_didCloseWithCode_reason_
        .implement(builder, URLSession_webSocketTask_didCloseWithCode_reason_);
    NSURLSessionWebSocketDelegate.URLSession_didCreateTask_.implement(
        builder, URLSession_didCreateTask_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implement(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_taskIsWaitingForConnectivity_
        .implement(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implement(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implement(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_task_needNewBodyStream_.implement(
        builder, URLSession_task_needNewBodyStream_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implement(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implement(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implement(builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionWebSocketDelegate.URLSession_task_didFinishCollectingMetrics_
        .implement(builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionWebSocketDelegate.URLSession_task_didCompleteWithError_
        .implement(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionWebSocketDelegate.URLSession_didBecomeInvalidWithError_
        .implement(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionWebSocketDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implement(builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implement(builder, URLSessionDidFinishEventsForBackgroundURLSession_);
    return builder.build();
  }

  /// Adds the implementation of the NSURLSessionWebSocketDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
          URLSession_webSocketTask_didOpenWithProtocol_,
      void Function(NSURLSession, NSURLSessionWebSocketTask, DartNSInteger, objc.NSData?)?
          URLSession_webSocketTask_didCloseWithCode_reason_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(
              NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    NSURLSessionWebSocketDelegate.URLSession_webSocketTask_didOpenWithProtocol_
        .implement(builder, URLSession_webSocketTask_didOpenWithProtocol_);
    NSURLSessionWebSocketDelegate
            .URLSession_webSocketTask_didCloseWithCode_reason_
        .implement(builder, URLSession_webSocketTask_didCloseWithCode_reason_);
    NSURLSessionWebSocketDelegate.URLSession_didCreateTask_.implement(
        builder, URLSession_didCreateTask_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implement(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_taskIsWaitingForConnectivity_
        .implement(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implement(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implement(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_task_needNewBodyStream_.implement(
        builder, URLSession_task_needNewBodyStream_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implement(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implement(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implement(builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionWebSocketDelegate.URLSession_task_didFinishCollectingMetrics_
        .implement(builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionWebSocketDelegate.URLSession_task_didCompleteWithError_
        .implement(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionWebSocketDelegate.URLSession_didBecomeInvalidWithError_
        .implement(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionWebSocketDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implement(builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implement(builder, URLSessionDidFinishEventsForBackgroundURLSession_);
  }

  /// Builds an object that implements the NSURLSessionWebSocketDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  static objc.ObjCObjectBase implementAsListener(
      {void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
          URLSession_webSocketTask_didOpenWithProtocol_,
      void Function(NSURLSession, NSURLSessionWebSocketTask, DartNSInteger, objc.NSData?)?
          URLSession_webSocketTask_didCloseWithCode_reason_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(
              NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSURLSessionWebSocketDelegate.URLSession_webSocketTask_didOpenWithProtocol_
        .implementAsListener(
            builder, URLSession_webSocketTask_didOpenWithProtocol_);
    NSURLSessionWebSocketDelegate
            .URLSession_webSocketTask_didCloseWithCode_reason_
        .implementAsListener(
            builder, URLSession_webSocketTask_didCloseWithCode_reason_);
    NSURLSessionWebSocketDelegate.URLSession_didCreateTask_.implementAsListener(
        builder, URLSession_didCreateTask_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsListener(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_task_needNewBodyStream_
        .implementAsListener(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsListener(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsListener(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implementAsListener(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionWebSocketDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsListener(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionWebSocketDelegate.URLSession_task_didCompleteWithError_
        .implementAsListener(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionWebSocketDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsListener(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionWebSocketDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsListener(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
    return builder.build();
  }

  /// Adds the implementation of the NSURLSessionWebSocketDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  static void addToBuilderAsListener(objc.ObjCProtocolBuilder builder,
      {void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
          URLSession_webSocketTask_didOpenWithProtocol_,
      void Function(NSURLSession, NSURLSessionWebSocketTask, DartNSInteger, objc.NSData?)?
          URLSession_webSocketTask_didCloseWithCode_reason_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(
              NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    NSURLSessionWebSocketDelegate.URLSession_webSocketTask_didOpenWithProtocol_
        .implementAsListener(
            builder, URLSession_webSocketTask_didOpenWithProtocol_);
    NSURLSessionWebSocketDelegate
            .URLSession_webSocketTask_didCloseWithCode_reason_
        .implementAsListener(
            builder, URLSession_webSocketTask_didCloseWithCode_reason_);
    NSURLSessionWebSocketDelegate.URLSession_didCreateTask_.implementAsListener(
        builder, URLSession_didCreateTask_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsListener(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsListener(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_task_needNewBodyStream_
        .implementAsListener(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsListener(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsListener(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implementAsListener(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionWebSocketDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsListener(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionWebSocketDelegate.URLSession_task_didCompleteWithError_
        .implementAsListener(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionWebSocketDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsListener(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionWebSocketDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implementAsListener(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsListener(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
  }

  /// Builds an object that implements the NSURLSessionWebSocketDelegate protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  static objc.ObjCObjectBase implementAsBlocking(
      {void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
          URLSession_webSocketTask_didOpenWithProtocol_,
      void Function(NSURLSession, NSURLSessionWebSocketTask, DartNSInteger, objc.NSData?)?
          URLSession_webSocketTask_didCloseWithCode_reason_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(
              NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    final builder = objc.ObjCProtocolBuilder();
    NSURLSessionWebSocketDelegate.URLSession_webSocketTask_didOpenWithProtocol_
        .implementAsBlocking(
            builder, URLSession_webSocketTask_didOpenWithProtocol_);
    NSURLSessionWebSocketDelegate
            .URLSession_webSocketTask_didCloseWithCode_reason_
        .implementAsBlocking(
            builder, URLSession_webSocketTask_didCloseWithCode_reason_);
    NSURLSessionWebSocketDelegate.URLSession_didCreateTask_.implementAsBlocking(
        builder, URLSession_didCreateTask_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsBlocking(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_task_needNewBodyStream_
        .implementAsBlocking(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsBlocking(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionWebSocketDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsBlocking(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionWebSocketDelegate.URLSession_task_didCompleteWithError_
        .implementAsBlocking(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionWebSocketDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsBlocking(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionWebSocketDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsBlocking(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
    return builder.build();
  }

  /// Adds the implementation of the NSURLSessionWebSocketDelegate protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  static void addToBuilderAsBlocking(objc.ObjCProtocolBuilder builder,
      {void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)?
          URLSession_webSocketTask_didOpenWithProtocol_,
      void Function(NSURLSession, NSURLSessionWebSocketTask, DartNSInteger, objc.NSData?)?
          URLSession_webSocketTask_didCloseWithCode_reason_,
      void Function(NSURLSession, NSURLSessionTask)? URLSession_didCreateTask_,
      void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)?
          URLSession_task_willBeginDelayedRequest_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask)?
          URLSession_taskIsWaitingForConnectivity_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)?
          URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)?
          URLSession_task_didReceiveChallenge_completionHandler_,
      void Function(
              NSURLSession, NSURLSessionTask, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)?
          URLSession_task_needNewBodyStream_,
      void Function(NSURLSession, NSURLSessionTask, int, objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)? URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      void Function(NSURLSession, NSURLSessionTask, int, int, int)? URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)? URLSession_task_didReceiveInformationalResponse_,
      void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)? URLSession_task_didFinishCollectingMetrics_,
      void Function(NSURLSession, NSURLSessionTask, objc.NSError?)? URLSession_task_didCompleteWithError_,
      void Function(NSURLSession, objc.NSError?)? URLSession_didBecomeInvalidWithError_,
      void Function(NSURLSession, NSURLAuthenticationChallenge, objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)? URLSession_didReceiveChallenge_completionHandler_,
      void Function(NSURLSession)? URLSessionDidFinishEventsForBackgroundURLSession_}) {
    NSURLSessionWebSocketDelegate.URLSession_webSocketTask_didOpenWithProtocol_
        .implementAsBlocking(
            builder, URLSession_webSocketTask_didOpenWithProtocol_);
    NSURLSessionWebSocketDelegate
            .URLSession_webSocketTask_didCloseWithCode_reason_
        .implementAsBlocking(
            builder, URLSession_webSocketTask_didCloseWithCode_reason_);
    NSURLSessionWebSocketDelegate.URLSession_didCreateTask_.implementAsBlocking(
        builder, URLSession_didCreateTask_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willBeginDelayedRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willBeginDelayedRequest_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_taskIsWaitingForConnectivity_
        .implementAsBlocking(builder, URLSession_taskIsWaitingForConnectivity_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate.URLSession_task_needNewBodyStream_
        .implementAsBlocking(builder, URLSession_task_needNewBodyStream_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_needNewBodyStreamFromOffset_completionHandler_
        .implementAsBlocking(builder,
            URLSession_task_needNewBodyStreamFromOffset_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_
        .implementAsBlocking(builder,
            URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_);
    NSURLSessionWebSocketDelegate
            .URLSession_task_didReceiveInformationalResponse_
        .implementAsBlocking(
            builder, URLSession_task_didReceiveInformationalResponse_);
    NSURLSessionWebSocketDelegate.URLSession_task_didFinishCollectingMetrics_
        .implementAsBlocking(
            builder, URLSession_task_didFinishCollectingMetrics_);
    NSURLSessionWebSocketDelegate.URLSession_task_didCompleteWithError_
        .implementAsBlocking(builder, URLSession_task_didCompleteWithError_);
    NSURLSessionWebSocketDelegate.URLSession_didBecomeInvalidWithError_
        .implementAsBlocking(builder, URLSession_didBecomeInvalidWithError_);
    NSURLSessionWebSocketDelegate
            .URLSession_didReceiveChallenge_completionHandler_
        .implementAsBlocking(
            builder, URLSession_didReceiveChallenge_completionHandler_);
    NSURLSessionWebSocketDelegate
            .URLSessionDidFinishEventsForBackgroundURLSession_
        .implementAsBlocking(
            builder, URLSessionDidFinishEventsForBackgroundURLSession_);
  }

  /// Indicates that the WebSocket handshake was successful and the connection has been upgraded to webSockets.
  /// It will also provide the protocol that is picked in the handshake. If the handshake fails, this delegate will not be invoked.
  static final URLSession_webSocketTask_didOpenWithProtocol_ =
      objc.ObjCProtocolListenableMethod<
          void Function(
              NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_webSocketTask_didOpenWithProtocol_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_webSocketTask_didOpenWithProtocol_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionWebSocketTask arg2, objc.NSString? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionWebSocketTask arg2, objc.NSString? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionWebSocketTask, objc.NSString?)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSString
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionWebSocketTask arg2, objc.NSString? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Indicates that the WebSocket has received a close frame from the server endpoint.
  /// The close code and the close reason may be provided by the delegate if the server elects to send
  /// this information in the close frame
  static final URLSession_webSocketTask_didCloseWithCode_reason_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionWebSocketTask, DartNSInteger,
              objc.NSData?)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_webSocketTask_didCloseWithCode_reason_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_webSocketTask_didCloseWithCode_reason_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionWebSocketTask, DartNSInteger,
                objc.NSData?)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionWebSocketTask arg2,
                    DartNSInteger arg3,
                    objc.NSData? arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionWebSocketTask, DartNSInteger,
                objc.NSData?)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionWebSocketTask arg2,
                    DartNSInteger arg3,
                    objc.NSData? arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionWebSocketTask, DartNSInteger,
                objc.NSData?)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionWebSocketTask_NSURLSessionWebSocketCloseCode_NSData
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionWebSocketTask arg2,
                    DartNSInteger arg3,
                    objc.NSData? arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Notification that a task has been created.  This method is the first message
  /// a task sends, providing a place to configure the task before it is resumed.
  ///
  /// This delegate callback is *NOT* dispatched to the delegate queue.  It is
  /// invoked synchronously before the task creation method returns.
  static final URLSession_didCreateTask_ = objc.ObjCProtocolListenableMethod<
      void Function(NSURLSession, NSURLSessionTask)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_didCreateTask_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_didCreateTask_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
  );

  /// Sent when the system is ready to begin work for a task with a delayed start
  /// time set (using the earliestBeginDate property). The completionHandler must
  /// be invoked in order for loading to proceed. The disposition provided to the
  /// completion handler continues the load with the original request provided to
  /// the task, replaces the request with the specified task, or cancels the task.
  /// If this delegate is not implemented, loading will proceed with the original
  /// request.
  ///
  /// Recommendation: only implement this delegate if tasks that have the
  /// earliestBeginDate property set may become stale and require alteration prior
  /// to starting the network load.
  ///
  /// If a new request is specified, the allowsExpensiveNetworkAccess,
  /// allowsConstrainedNetworkAccess, and allowsCellularAccess properties
  /// from the new request will not be used; the properties from the
  /// original request will continue to be used.
  ///
  /// Canceling the task is equivalent to calling the task's cancel method; the
  /// URLSession:task:didCompleteWithError: task delegate will be called with error
  /// NSURLErrorCancelled.
  static final URLSession_task_willBeginDelayedRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_task_willBeginDelayedRequest_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLRequest arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLRequest arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLRequest,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLRequest_ffiVoidNSURLSessionDelayedRequestDispositionNSURLRequest
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLRequest arg3,
                    objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLRequest?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Sent when a task cannot start the network loading process because the current
  /// network connectivity is not available or sufficient for the task's request.
  ///
  /// This delegate will be called at most one time per task, and is only called if
  /// the waitsForConnectivity property in the NSURLSessionConfiguration has been
  /// set to YES.
  ///
  /// This delegate callback will never be called for background sessions, because
  /// the waitForConnectivity property is ignored by those sessions.
  static final URLSession_taskIsWaitingForConnectivity_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_taskIsWaitingForConnectivity_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_taskIsWaitingForConnectivity_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, NSURLSessionTask) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2) =>
                func(arg1, arg2)),
  );

  /// An HTTP request is attempting to perform a redirection to a different
  /// URL. You must invoke the completion routine to allow the
  /// redirection, allow the redirection with a modified request, or
  /// pass nil to the completionHandler to cause the body of the redirection
  /// response to be delivered as the payload of this request. The default
  /// is to follow redirections.
  ///
  /// For tasks in background sessions, redirections will always be followed and this method will not be called.
  static final URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
              NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
                NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSHTTPURLResponse arg3,
                    NSURLRequest arg4,
                    objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
                NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSHTTPURLResponse arg3,
                    NSURLRequest arg4,
                    objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse,
                NSURLRequest, objc.ObjCBlock<ffi.Void Function(NSURLRequest?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse_NSURLRequest_ffiVoidNSURLRequest
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSHTTPURLResponse arg3,
                    NSURLRequest arg4,
                    objc.ObjCBlock<ffi.Void Function(NSURLRequest?)> arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
  );

  /// The task has received a request specific authentication challenge.
  /// If this delegate is not implemented, the session specific authentication challenge
  /// will *NOT* be called and the behavior will be the same as using the default handling
  /// disposition.
  static final URLSession_task_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(
              NSURLSession,
              NSURLSessionTask,
              NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_task_didReceiveChallenge_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_task_didReceiveChallenge_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLAuthenticationChallenge arg3,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLAuthenticationChallenge arg3,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    NSURLAuthenticationChallenge arg3,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Sent if a task requires a new, unopened body stream.  This may be
  /// necessary when authentication has failed for any request that
  /// involves a body stream.
  static final URLSession_task_needNewBodyStream_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_task_needNewBodyStream_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_task_needNewBodyStream_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_ffiVoidNSInputStream
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Tells the delegate if a task requires a new body stream starting from the given offset. This may be
  /// necessary when resuming a failed upload task.
  ///
  /// - Parameter session: The session containing the task that needs a new body stream from the given offset.
  /// - Parameter task: The task that needs a new body stream.
  /// - Parameter offset: The starting offset required for the body stream.
  /// - Parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
  static final URLSession_task_needNewBodyStreamFromOffset_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, int,
              objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_task_needNewBodyStreamFromOffset_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, int,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    int arg3,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, int,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    int arg3,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
    (void Function(NSURLSession, NSURLSessionTask, int,
                objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_ffiVoidNSInputStream
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLSessionTask arg2,
                    int arg3,
                    objc.ObjCBlock<ffi.Void Function(objc.NSInputStream?)>
                        arg4) =>
                func(arg1, arg2, arg3, arg4)),
  );

  /// Sent periodically to notify the delegate of upload progress.  This
  /// information is also available as properties of the task.
  static final URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, int, int, int)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, int arg3, int arg4, int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, int arg3, int arg4, int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
    (void Function(NSURLSession, NSURLSessionTask, int, int, int) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_Int64_Int64_Int64
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, int arg3, int arg4, int arg5) =>
                func(arg1, arg2, arg3, arg4, arg5)),
  );

  /// Sent for each informational response received except 101 switching protocols.
  static final URLSession_task_didReceiveInformationalResponse_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_task_didReceiveInformationalResponse_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_task_didReceiveInformationalResponse_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSHTTPURLResponse arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSHTTPURLResponse arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSHTTPURLResponse) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSHTTPURLResponse
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSHTTPURLResponse arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Sent when complete statistics information has been collected for the task.
  static final URLSession_task_didFinishCollectingMetrics_ =
      objc.ObjCProtocolListenableMethod<
          void Function(
              NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_task_didFinishCollectingMetrics_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_task_didFinishCollectingMetrics_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSURLSessionTaskMetrics arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSURLSessionTaskMetrics arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, NSURLSessionTaskMetrics)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSURLSessionTaskMetrics
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, NSURLSessionTaskMetrics arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// Sent as the last message related to a specific task.  Error may be
  /// nil, which implies that no error occurred and this task is complete.
  static final URLSession_task_didCompleteWithError_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLSessionTask, objc.NSError?)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_task_didCompleteWithError_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_task_didCompleteWithError_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError
            .fromFunction((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError
            .listener((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLSessionTask, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLSessionTask_NSError
            .blocking((ffi.Pointer<ffi.Void> _, NSURLSession arg1,
                    NSURLSessionTask arg2, objc.NSError? arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// The last message a session receives.  A session will only become
  /// invalid because of a systemic error or when it has been
  /// explicitly invalidated, in which case the error parameter will be nil.
  static final URLSession_didBecomeInvalidWithError_ = objc
      .ObjCProtocolListenableMethod<void Function(NSURLSession, objc.NSError?)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_didBecomeInvalidWithError_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_didBecomeInvalidWithError_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
    (void Function(NSURLSession, objc.NSError?) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSError.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1, objc.NSError? arg2) =>
                func(arg1, arg2)),
  );

  /// If implemented, when a connection level authentication challenge
  /// has occurred, this delegate will be given the opportunity to
  /// provide authentication credentials to the underlying
  /// connection. Some types of authentication will apply to more than
  /// one request on a given connection to a server (SSL Server Trust
  /// challenges).  If this delegate message is not implemented, the
  /// behavior will be to use the default handling, which may involve user
  /// interaction.
  static final URLSession_didReceiveChallenge_completionHandler_ =
      objc.ObjCProtocolListenableMethod<
          void Function(NSURLSession, NSURLAuthenticationChallenge,
              objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSession_didReceiveChallenge_completionHandler_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSession_didReceiveChallenge_completionHandler_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .fromFunction((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLAuthenticationChallenge arg2,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .listener((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLAuthenticationChallenge arg2,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
    (void Function(NSURLSession, NSURLAuthenticationChallenge,
                objc.ObjCBlock<ffi.Void Function(NSInteger, NSURLCredential?)>)
            func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession_NSURLAuthenticationChallenge_ffiVoidNSURLSessionAuthChallengeDispositionNSURLCredential
            .blocking((ffi.Pointer<ffi.Void> _,
                    NSURLSession arg1,
                    NSURLAuthenticationChallenge arg2,
                    objc.ObjCBlock<
                            ffi.Void Function(NSInteger, NSURLCredential?)>
                        arg3) =>
                func(arg1, arg2, arg3)),
  );

  /// If an application has received an
  /// -application:handleEventsForBackgroundURLSession:completionHandler:
  /// message, the session delegate will receive this message to indicate
  /// that all messages previously enqueued for this session have been
  /// delivered.  At this time it is safe to invoke the previously stored
  /// completion handler, or to begin any internal updates that will
  /// result in invoking the completion handler.
  static final URLSessionDidFinishEventsForBackgroundURLSession_ =
      objc.ObjCProtocolListenableMethod<void Function(NSURLSession)>(
    _protocol_NSURLSessionWebSocketDelegate,
    _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
    objc.getProtocolMethodSignature(
      _protocol_NSURLSessionWebSocketDelegate,
      _sel_URLSessionDidFinishEventsForBackgroundURLSession_,
      isRequired: false,
      isInstanceMethod: true,
    ),
    (void Function(NSURLSession) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession.fromFunction(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1)),
    (void Function(NSURLSession) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession.listener(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1)),
    (void Function(NSURLSession) func) =>
        ObjCBlock_ffiVoid_ffiVoid_NSURLSession.blocking(
            (ffi.Pointer<ffi.Void> _, NSURLSession arg1) => func(arg1)),
  );
}

typedef unichar = ffi.UnsignedShort;
typedef Dartunichar = int;
late final _class_NSValue = objc.getClass("NSValue");
late final _sel_valueWithBytes_objCType_ =
    objc.registerName("valueWithBytes:objCType:");
final _objc_msgSend_e9mncn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Char>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Char>)>();
late final _sel_value_withObjCType_ = objc.registerName("value:withObjCType:");

/// NSValueCreation
extension NSValueCreation on objc.NSValue {
  /// valueWithBytes:objCType:
  static objc.NSValue valueWithBytes_objCType_(
      ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Char> type) {
    final _ret = _objc_msgSend_e9mncn(
        _class_NSValue, _sel_valueWithBytes_objCType_, value, type);
    return objc.NSValue.castFromPointer(_ret, retain: true, release: true);
  }

  /// value:withObjCType:
  static objc.NSValue value_withObjCType_(
      ffi.Pointer<ffi.Void> value, ffi.Pointer<ffi.Char> type) {
    final _ret = _objc_msgSend_e9mncn(
        _class_NSValue, _sel_value_withObjCType_, value, type);
    return objc.NSValue.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_valueWithNonretainedObject_ =
    objc.registerName("valueWithNonretainedObject:");
late final _sel_nonretainedObjectValue =
    objc.registerName("nonretainedObjectValue");
late final _sel_valueWithPointer_ = objc.registerName("valueWithPointer:");
final _objc_msgSend_1mbt9g9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)>();
late final _sel_pointerValue = objc.registerName("pointerValue");
final _objc_msgSend_6ex6p5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isEqualToValue_ = objc.registerName("isEqualToValue:");

/// NSValueExtensionMethods
extension NSValueExtensionMethods on objc.NSValue {
  /// valueWithNonretainedObject:
  static objc.NSValue valueWithNonretainedObject_(
      objc.ObjCObjectBase? anObject) {
    final _ret = _objc_msgSend_1sotr3r(_class_NSValue,
        _sel_valueWithNonretainedObject_, anObject?.ref.pointer ?? ffi.nullptr);
    return objc.NSValue.castFromPointer(_ret, retain: true, release: true);
  }

  /// nonretainedObjectValue
  objc.ObjCObjectBase? get nonretainedObjectValue {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_nonretainedObjectValue);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// valueWithPointer:
  static objc.NSValue valueWithPointer_(ffi.Pointer<ffi.Void> pointer) {
    final _ret =
        _objc_msgSend_1mbt9g9(_class_NSValue, _sel_valueWithPointer_, pointer);
    return objc.NSValue.castFromPointer(_ret, retain: true, release: true);
  }

  /// pointerValue
  ffi.Pointer<ffi.Void> get pointerValue {
    return _objc_msgSend_6ex6p5(this.ref.pointer, _sel_pointerValue);
  }

  /// isEqualToValue:
  bool isEqualToValue_(objc.NSValue value) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isEqualToValue_, value.ref.pointer);
  }
}

late final _class_NSNumber = objc.getClass("NSNumber");
late final _sel_numberWithChar_ = objc.registerName("numberWithChar:");
final _objc_msgSend_13mclwd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Char)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_numberWithUnsignedChar_ =
    objc.registerName("numberWithUnsignedChar:");
final _objc_msgSend_7uautw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedChar)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_numberWithShort_ = objc.registerName("numberWithShort:");
final _objc_msgSend_68x6r1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Short)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_numberWithUnsignedShort_ =
    objc.registerName("numberWithUnsignedShort:");
final _objc_msgSend_1njucl2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedShort)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_numberWithInt_ = objc.registerName("numberWithInt:");
final _objc_msgSend_14hvw5k = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_numberWithUnsignedInt_ =
    objc.registerName("numberWithUnsignedInt:");
final _objc_msgSend_degb40 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedInt)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_numberWithLong_ = objc.registerName("numberWithLong:");
late final _sel_numberWithUnsignedLong_ =
    objc.registerName("numberWithUnsignedLong:");
late final _sel_numberWithLongLong_ = objc.registerName("numberWithLongLong:");
final _objc_msgSend_16f0drb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.LongLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_numberWithUnsignedLongLong_ =
    objc.registerName("numberWithUnsignedLongLong:");
final _objc_msgSend_1x2hskc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLongLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_numberWithFloat_ = objc.registerName("numberWithFloat:");
final _objc_msgSend_et8cuh = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Float)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_numberWithDouble_ = objc.registerName("numberWithDouble:");
late final _sel_numberWithBool_ = objc.registerName("numberWithBool:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_numberWithInteger_ = objc.registerName("numberWithInteger:");
late final _sel_numberWithUnsignedInteger_ =
    objc.registerName("numberWithUnsignedInteger:");

/// NSNumberCreation
extension NSNumberCreation on objc.NSNumber {
  /// numberWithChar:
  static objc.NSNumber numberWithChar_(int value) {
    final _ret =
        _objc_msgSend_13mclwd(_class_NSNumber, _sel_numberWithChar_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithUnsignedChar:
  static objc.NSNumber numberWithUnsignedChar_(int value) {
    final _ret = _objc_msgSend_7uautw(
        _class_NSNumber, _sel_numberWithUnsignedChar_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithShort:
  static objc.NSNumber numberWithShort_(int value) {
    final _ret =
        _objc_msgSend_68x6r1(_class_NSNumber, _sel_numberWithShort_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithUnsignedShort:
  static objc.NSNumber numberWithUnsignedShort_(int value) {
    final _ret = _objc_msgSend_1njucl2(
        _class_NSNumber, _sel_numberWithUnsignedShort_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithInt:
  static objc.NSNumber numberWithInt_(int value) {
    final _ret =
        _objc_msgSend_14hvw5k(_class_NSNumber, _sel_numberWithInt_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithUnsignedInt:
  static objc.NSNumber numberWithUnsignedInt_(int value) {
    final _ret = _objc_msgSend_degb40(
        _class_NSNumber, _sel_numberWithUnsignedInt_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithLong:
  static objc.NSNumber numberWithLong_(int value) {
    final _ret =
        _objc_msgSend_qugqlf(_class_NSNumber, _sel_numberWithLong_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithUnsignedLong:
  static objc.NSNumber numberWithUnsignedLong_(int value) {
    final _ret = _objc_msgSend_14hpxwa(
        _class_NSNumber, _sel_numberWithUnsignedLong_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithLongLong:
  static objc.NSNumber numberWithLongLong_(int value) {
    final _ret =
        _objc_msgSend_16f0drb(_class_NSNumber, _sel_numberWithLongLong_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithUnsignedLongLong:
  static objc.NSNumber numberWithUnsignedLongLong_(int value) {
    final _ret = _objc_msgSend_1x2hskc(
        _class_NSNumber, _sel_numberWithUnsignedLongLong_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithFloat:
  static objc.NSNumber numberWithFloat_(double value) {
    final _ret =
        _objc_msgSend_et8cuh(_class_NSNumber, _sel_numberWithFloat_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithDouble:
  static objc.NSNumber numberWithDouble_(double value) {
    final _ret =
        _objc_msgSend_oa8mke(_class_NSNumber, _sel_numberWithDouble_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithBool:
  static objc.NSNumber numberWithBool_(bool value) {
    final _ret =
        _objc_msgSend_1t6aok9(_class_NSNumber, _sel_numberWithBool_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithInteger:
  static objc.NSNumber numberWithInteger_(DartNSInteger value) {
    final _ret =
        _objc_msgSend_qugqlf(_class_NSNumber, _sel_numberWithInteger_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }

  /// numberWithUnsignedInteger:
  static objc.NSNumber numberWithUnsignedInteger_(DartNSUInteger value) {
    final _ret = _objc_msgSend_14hpxwa(
        _class_NSNumber, _sel_numberWithUnsignedInteger_, value);
    return objc.NSNumber.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_getValue_ = objc.registerName("getValue:");
final _objc_msgSend_ovsamd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)>();

/// NSDeprecated
extension NSDeprecated2 on objc.NSValue {
  /// getValue:
  void getValue_(ffi.Pointer<ffi.Void> value) {
    _objc_msgSend_ovsamd(this.ref.pointer, _sel_getValue_, value);
  }
}

typedef NSRange = objc.NSRange;
typedef NSRangePointer = ffi.Pointer<NSRange>;
late final _sel_valueWithRange_ = objc.registerName("valueWithRange:");
final _objc_msgSend_1k1o1s7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>();
late final _sel_rangeValue = objc.registerName("rangeValue");
final _objc_msgSend_1u11dbb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.NSRange Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        objc.NSRange Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1u11dbbStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.NSRange>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.NSRange>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();

/// NSValueRangeExtensions
extension NSValueRangeExtensions on objc.NSValue {
  /// valueWithRange:
  static objc.NSValue valueWithRange_(NSRange range) {
    final _ret =
        _objc_msgSend_1k1o1s7(_class_NSValue, _sel_valueWithRange_, range);
    return objc.NSValue.castFromPointer(_ret, retain: true, release: true);
  }

  /// rangeValue
  NSRange get rangeValue {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1u11dbbStret(_ptr, this.ref.pointer, _sel_rangeValue)
        : _ptr.ref = _objc_msgSend_1u11dbb(this.ref.pointer, _sel_rangeValue);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }
}

late final _class_NSArray = objc.getClass("NSArray");
late final _sel_arrayByAddingObject_ =
    objc.registerName("arrayByAddingObject:");
late final _sel_arrayByAddingObjectsFromArray_ =
    objc.registerName("arrayByAddingObjectsFromArray:");
late final _sel_componentsJoinedByString_ =
    objc.registerName("componentsJoinedByString:");
late final _sel_containsObject_ = objc.registerName("containsObject:");
late final _sel_firstObjectCommonWithArray_ =
    objc.registerName("firstObjectCommonWithArray:");
late final _sel_getObjects_range_ = objc.registerName("getObjects:range:");
final _objc_msgSend_o16d3k = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                objc.NSRange)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            objc.NSRange)>();
late final _sel_indexOfObject_ = objc.registerName("indexOfObject:");
final _objc_msgSend_1vd1c5m = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_indexOfObject_inRange_ =
    objc.registerName("indexOfObject:inRange:");
final _objc_msgSend_zug4wi = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange)>();
late final _sel_indexOfObjectIdenticalTo_ =
    objc.registerName("indexOfObjectIdenticalTo:");
late final _sel_indexOfObjectIdenticalTo_inRange_ =
    objc.registerName("indexOfObjectIdenticalTo:inRange:");
late final _sel_isEqualToArray_ = objc.registerName("isEqualToArray:");
late final _sel_firstObject = objc.registerName("firstObject");
late final _sel_lastObject = objc.registerName("lastObject");
late final _sel_reverseObjectEnumerator =
    objc.registerName("reverseObjectEnumerator");
late final _sel_sortedArrayHint = objc.registerName("sortedArrayHint");
late final _sel_sortedArrayUsingFunction_context_ =
    objc.registerName("sortedArrayUsingFunction:context:");
final _objc_msgSend_1ffoev1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<
                    ffi.NativeFunction<
                        NSInteger Function(
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<ffi.Void>)>>,
                ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<
                ffi.NativeFunction<
                    NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>,
            ffi.Pointer<ffi.Void>)>();
late final _sel_sortedArrayUsingFunction_context_hint_ =
    objc.registerName("sortedArrayUsingFunction:context:hint:");
final _objc_msgSend_1i2r70j = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<
                    ffi.NativeFunction<
                        NSInteger Function(
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<ffi.Void>)>>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<
                ffi.NativeFunction<
                    NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_sortedArrayUsingSelector_ =
    objc.registerName("sortedArrayUsingSelector:");
late final _sel_subarrayWithRange_ = objc.registerName("subarrayWithRange:");
late final _sel_makeObjectsPerformSelector_ =
    objc.registerName("makeObjectsPerformSelector:");
final _objc_msgSend_1d9e4oe = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_makeObjectsPerformSelector_withObject_ =
    objc.registerName("makeObjectsPerformSelector:withObject:");
final _objc_msgSend_1qv0eq4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_objectsAtIndexes_ = objc.registerName("objectsAtIndexes:");
late final _sel_objectAtIndexedSubscript_ =
    objc.registerName("objectAtIndexedSubscript:");
void _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        int arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    NSUInteger arg1, ffi.Pointer<ffi.Bool> arg2)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>, int,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    NSUInteger,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        int arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        int, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    NSUInteger,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    int arg1,
    ffi.Pointer<ffi.Bool> arg2) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
      int, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, NSUInteger, ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    int arg1,
    ffi.Pointer<ffi.Bool> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        int, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            NSUInteger,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                ffi.Pointer<ffi.Bool>)>.isolateLocal(
        _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            NSUInteger,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, NSUInteger arg1, ffi.Pointer<ffi.Bool> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>
      fromFunction(void Function(objc.ObjCObjectBase, DartNSUInteger, ffi.Pointer<ffi.Bool>) fn) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, int arg1, ffi.Pointer<ffi.Bool> arg2) =>
                      fn(objc.ObjCObjectBase(arg0, retain: true, release: true), arg1, arg2)),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>)> listener(
      void Function(objc.ObjCObjectBase, DartNSUInteger, ffi.Pointer<ffi.Bool>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, int arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(objc.ObjCObjectBase(arg0, retain: false, release: true), arg1,
                arg2));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1p9ui4q(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>)> blocking(
      void Function(objc.ObjCObjectBase, DartNSUInteger, ffi.Pointer<ffi.Bool>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, int arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(objc.ObjCObjectBase(arg0, retain: false, release: true), arg1,
                arg2));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, int arg1,
                ffi.Pointer<ffi.Bool> arg2) =>
            fn(objc.ObjCObjectBase(arg0, retain: false, release: true), arg1,
                arg2));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1p9ui4q, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_objcObjCObject_NSUInteger_bool_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>)> {
  void call(objc.ObjCObjectBase arg0, DartNSUInteger arg1,
          ffi.Pointer<ffi.Bool> arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          NSUInteger arg1,
                          ffi.Pointer<ffi.Bool> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      int,
                      ffi.Pointer<ffi.Bool>)>()(
          ref.pointer, arg0.ref.pointer, arg1, arg2);
}

late final _sel_enumerateObjectsUsingBlock_ =
    objc.registerName("enumerateObjectsUsingBlock:");
late final _sel_enumerateObjectsWithOptions_usingBlock_ =
    objc.registerName("enumerateObjectsWithOptions:usingBlock:");
late final _sel_enumerateObjectsAtIndexes_options_usingBlock_ =
    objc.registerName("enumerateObjectsAtIndexes:options:usingBlock:");
final _objc_msgSend_a3wp08 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
bool _ObjCBlock_bool_objcObjCObject_NSUInteger_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        int arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCObject> arg0,
                    NSUInteger arg1, ffi.Pointer<ffi.Bool> arg2)>>()
        .asFunction<
            bool Function(ffi.Pointer<objc.ObjCObject>, int,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_objcObjCObject_NSUInteger_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    NSUInteger,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_bool_objcObjCObject_NSUInteger_bool_fnPtrTrampoline,
            false)
        .cast();
bool _ObjCBlock_bool_objcObjCObject_NSUInteger_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        int arg1,
        ffi.Pointer<ffi.Bool> arg2) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<objc.ObjCObject>,
        int, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_objcObjCObject_NSUInteger_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    NSUInteger,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_bool_objcObjCObject_NSUInteger_bool_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_bool_objcObjCObject_NSUInteger_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject> arg0, NSUInteger arg1, ffi.Pointer<ffi.Bool> arg2)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>(
              objc.newPointerBlock(
                  _ObjCBlock_bool_objcObjCObject_NSUInteger_bool_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>
      fromFunction(bool Function(objc.ObjCObjectBase, DartNSUInteger, ffi.Pointer<ffi.Bool>) fn) =>
          objc.ObjCBlock<
                  ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>(
              objc.newClosureBlock(
                  _ObjCBlock_bool_objcObjCObject_NSUInteger_bool_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, int arg1, ffi.Pointer<ffi.Bool> arg2) =>
                      fn(objc.ObjCObjectBase(arg0, retain: true, release: true), arg1, arg2)),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_bool_objcObjCObject_NSUInteger_bool_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>)> {
  bool call(objc.ObjCObjectBase arg0, DartNSUInteger arg1,
          ffi.Pointer<ffi.Bool> arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          NSUInteger arg1,
                          ffi.Pointer<ffi.Bool> arg2)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      int,
                      ffi.Pointer<ffi.Bool>)>()(
          ref.pointer, arg0.ref.pointer, arg1, arg2);
}

late final _sel_indexOfObjectPassingTest_ =
    objc.registerName("indexOfObjectPassingTest:");
final _objc_msgSend_10mlopr = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_indexOfObjectWithOptions_passingTest_ =
    objc.registerName("indexOfObjectWithOptions:passingTest:");
final _objc_msgSend_1698hqz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_indexOfObjectAtIndexes_options_passingTest_ =
    objc.registerName("indexOfObjectAtIndexes:options:passingTest:");
final _objc_msgSend_k1x6mt = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_indexesOfObjectsPassingTest_ =
    objc.registerName("indexesOfObjectsPassingTest:");
late final _sel_indexesOfObjectsWithOptions_passingTest_ =
    objc.registerName("indexesOfObjectsWithOptions:passingTest:");
late final _sel_indexesOfObjectsAtIndexes_options_passingTest_ =
    objc.registerName("indexesOfObjectsAtIndexes:options:passingTest:");
final _objc_msgSend_1i9v144 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_sortedArrayUsingComparator_ =
    objc.registerName("sortedArrayUsingComparator:");
late final _sel_sortedArrayWithOptions_usingComparator_ =
    objc.registerName("sortedArrayWithOptions:usingComparator:");
late final _sel_indexOfObject_inSortedRange_options_usingComparator_ =
    objc.registerName("indexOfObject:inSortedRange:options:usingComparator:");
final _objc_msgSend_kshx9d = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

/// NSExtendedArray
extension NSExtendedArray on objc.NSArray {
  /// arrayByAddingObject:
  objc.NSArray arrayByAddingObject_(objc.ObjCObjectBase anObject) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_arrayByAddingObject_, anObject.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// arrayByAddingObjectsFromArray:
  objc.NSArray arrayByAddingObjectsFromArray_(objc.NSArray otherArray) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_arrayByAddingObjectsFromArray_, otherArray.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// componentsJoinedByString:
  objc.NSString componentsJoinedByString_(objc.NSString separator) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_componentsJoinedByString_, separator.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// containsObject:
  bool containsObject_(objc.ObjCObjectBase anObject) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_containsObject_, anObject.ref.pointer);
  }

  /// description
  objc.NSString get description {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_description);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// descriptionWithLocale:
  objc.NSString descriptionWithLocale_(objc.ObjCObjectBase? locale) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_descriptionWithLocale_, locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// descriptionWithLocale:indent:
  objc.NSString descriptionWithLocale_indent_(
      objc.ObjCObjectBase? locale, DartNSUInteger level) {
    final _ret = _objc_msgSend_1k4kd9s(
        this.ref.pointer,
        _sel_descriptionWithLocale_indent_,
        locale?.ref.pointer ?? ffi.nullptr,
        level);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// firstObjectCommonWithArray:
  objc.ObjCObjectBase? firstObjectCommonWithArray_(objc.NSArray otherArray) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_firstObjectCommonWithArray_, otherArray.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// getObjects:range:
  void getObjects_range_(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, NSRange range) {
    _objc_msgSend_o16d3k(
        this.ref.pointer, _sel_getObjects_range_, objects, range);
  }

  /// indexOfObject:
  DartNSUInteger indexOfObject_(objc.ObjCObjectBase anObject) {
    return _objc_msgSend_1vd1c5m(
        this.ref.pointer, _sel_indexOfObject_, anObject.ref.pointer);
  }

  /// indexOfObject:inRange:
  DartNSUInteger indexOfObject_inRange_(
      objc.ObjCObjectBase anObject, NSRange range) {
    return _objc_msgSend_zug4wi(this.ref.pointer, _sel_indexOfObject_inRange_,
        anObject.ref.pointer, range);
  }

  /// indexOfObjectIdenticalTo:
  DartNSUInteger indexOfObjectIdenticalTo_(objc.ObjCObjectBase anObject) {
    return _objc_msgSend_1vd1c5m(
        this.ref.pointer, _sel_indexOfObjectIdenticalTo_, anObject.ref.pointer);
  }

  /// indexOfObjectIdenticalTo:inRange:
  DartNSUInteger indexOfObjectIdenticalTo_inRange_(
      objc.ObjCObjectBase anObject, NSRange range) {
    return _objc_msgSend_zug4wi(this.ref.pointer,
        _sel_indexOfObjectIdenticalTo_inRange_, anObject.ref.pointer, range);
  }

  /// isEqualToArray:
  bool isEqualToArray_(objc.NSArray otherArray) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isEqualToArray_, otherArray.ref.pointer);
  }

  /// firstObject
  objc.ObjCObjectBase? get firstObject {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_firstObject);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// lastObject
  objc.ObjCObjectBase? get lastObject {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lastObject);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// objectEnumerator
  objc.NSEnumerator objectEnumerator() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_objectEnumerator);
    return objc.NSEnumerator.castFromPointer(_ret, retain: true, release: true);
  }

  /// reverseObjectEnumerator
  objc.NSEnumerator reverseObjectEnumerator() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_reverseObjectEnumerator);
    return objc.NSEnumerator.castFromPointer(_ret, retain: true, release: true);
  }

  /// sortedArrayHint
  objc.NSData get sortedArrayHint {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sortedArrayHint);
    return objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// sortedArrayUsingFunction:context:
  objc.NSArray sortedArrayUsingFunction_context_(
      ffi.Pointer<
              ffi.NativeFunction<
                  NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>
          comparator,
      ffi.Pointer<ffi.Void> context) {
    final _ret = _objc_msgSend_1ffoev1(this.ref.pointer,
        _sel_sortedArrayUsingFunction_context_, comparator, context);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// sortedArrayUsingFunction:context:hint:
  objc.NSArray sortedArrayUsingFunction_context_hint_(
      ffi.Pointer<
              ffi.NativeFunction<
                  NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>
          comparator,
      ffi.Pointer<ffi.Void> context,
      objc.NSData? hint) {
    final _ret = _objc_msgSend_1i2r70j(
        this.ref.pointer,
        _sel_sortedArrayUsingFunction_context_hint_,
        comparator,
        context,
        hint?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// sortedArrayUsingSelector:
  objc.NSArray sortedArrayUsingSelector_(
      ffi.Pointer<objc.ObjCSelector> comparator) {
    final _ret = _objc_msgSend_3ctkt6(
        this.ref.pointer, _sel_sortedArrayUsingSelector_, comparator);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// subarrayWithRange:
  objc.NSArray subarrayWithRange_(NSRange range) {
    final _ret =
        _objc_msgSend_1k1o1s7(this.ref.pointer, _sel_subarrayWithRange_, range);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writeToURL:error:
  bool writeToURL_error_(
      objc.NSURL url, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    return _objc_msgSend_l9p60w(
        this.ref.pointer, _sel_writeToURL_error_, url.ref.pointer, error);
  }

  /// makeObjectsPerformSelector:
  void makeObjectsPerformSelector_(ffi.Pointer<objc.ObjCSelector> aSelector) {
    _objc_msgSend_1d9e4oe(
        this.ref.pointer, _sel_makeObjectsPerformSelector_, aSelector);
  }

  /// makeObjectsPerformSelector:withObject:
  void makeObjectsPerformSelector_withObject_(
      ffi.Pointer<objc.ObjCSelector> aSelector, objc.ObjCObjectBase? argument) {
    _objc_msgSend_1qv0eq4(
        this.ref.pointer,
        _sel_makeObjectsPerformSelector_withObject_,
        aSelector,
        argument?.ref.pointer ?? ffi.nullptr);
  }

  /// objectsAtIndexes:
  objc.NSArray objectsAtIndexes_(objc.NSIndexSet indexes) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_objectsAtIndexes_, indexes.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// objectAtIndexedSubscript:
  objc.ObjCObjectBase objectAtIndexedSubscript_(DartNSUInteger idx) {
    final _ret = _objc_msgSend_14hpxwa(
        this.ref.pointer, _sel_objectAtIndexedSubscript_, idx);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// enumerateObjectsUsingBlock:
  void enumerateObjectsUsingBlock_(
      objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
                  ffi.Pointer<ffi.Bool>)>
          block) {
    _objc_msgSend_f167m6(
        this.ref.pointer, _sel_enumerateObjectsUsingBlock_, block.ref.pointer);
  }

  /// enumerateObjectsWithOptions:usingBlock:
  void enumerateObjectsWithOptions_usingBlock_(
      objc.NSEnumerationOptions opts,
      objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
                  ffi.Pointer<ffi.Bool>)>
          block) {
    _objc_msgSend_yx8yc6(
        this.ref.pointer,
        _sel_enumerateObjectsWithOptions_usingBlock_,
        opts.value,
        block.ref.pointer);
  }

  /// enumerateObjectsAtIndexes:options:usingBlock:
  void enumerateObjectsAtIndexes_options_usingBlock_(
      objc.NSIndexSet s,
      objc.NSEnumerationOptions opts,
      objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
                  ffi.Pointer<ffi.Bool>)>
          block) {
    _objc_msgSend_a3wp08(
        this.ref.pointer,
        _sel_enumerateObjectsAtIndexes_options_usingBlock_,
        s.ref.pointer,
        opts.value,
        block.ref.pointer);
  }

  /// indexOfObjectPassingTest:
  DartNSUInteger indexOfObjectPassingTest_(
      objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
                  ffi.Pointer<ffi.Bool>)>
          predicate) {
    return _objc_msgSend_10mlopr(this.ref.pointer,
        _sel_indexOfObjectPassingTest_, predicate.ref.pointer);
  }

  /// indexOfObjectWithOptions:passingTest:
  DartNSUInteger indexOfObjectWithOptions_passingTest_(
      objc.NSEnumerationOptions opts,
      objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
                  ffi.Pointer<ffi.Bool>)>
          predicate) {
    return _objc_msgSend_1698hqz(
        this.ref.pointer,
        _sel_indexOfObjectWithOptions_passingTest_,
        opts.value,
        predicate.ref.pointer);
  }

  /// indexOfObjectAtIndexes:options:passingTest:
  DartNSUInteger indexOfObjectAtIndexes_options_passingTest_(
      objc.NSIndexSet s,
      objc.NSEnumerationOptions opts,
      objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
                  ffi.Pointer<ffi.Bool>)>
          predicate) {
    return _objc_msgSend_k1x6mt(
        this.ref.pointer,
        _sel_indexOfObjectAtIndexes_options_passingTest_,
        s.ref.pointer,
        opts.value,
        predicate.ref.pointer);
  }

  /// indexesOfObjectsPassingTest:
  objc.NSIndexSet indexesOfObjectsPassingTest_(
      objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
                  ffi.Pointer<ffi.Bool>)>
          predicate) {
    final _ret = _objc_msgSend_nnxkei(this.ref.pointer,
        _sel_indexesOfObjectsPassingTest_, predicate.ref.pointer);
    return objc.NSIndexSet.castFromPointer(_ret, retain: true, release: true);
  }

  /// indexesOfObjectsWithOptions:passingTest:
  objc.NSIndexSet indexesOfObjectsWithOptions_passingTest_(
      objc.NSEnumerationOptions opts,
      objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
                  ffi.Pointer<ffi.Bool>)>
          predicate) {
    final _ret = _objc_msgSend_13x5boi(
        this.ref.pointer,
        _sel_indexesOfObjectsWithOptions_passingTest_,
        opts.value,
        predicate.ref.pointer);
    return objc.NSIndexSet.castFromPointer(_ret, retain: true, release: true);
  }

  /// indexesOfObjectsAtIndexes:options:passingTest:
  objc.NSIndexSet indexesOfObjectsAtIndexes_options_passingTest_(
      objc.NSIndexSet s,
      objc.NSEnumerationOptions opts,
      objc.ObjCBlock<
              ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.UnsignedLong,
                  ffi.Pointer<ffi.Bool>)>
          predicate) {
    final _ret = _objc_msgSend_1i9v144(
        this.ref.pointer,
        _sel_indexesOfObjectsAtIndexes_options_passingTest_,
        s.ref.pointer,
        opts.value,
        predicate.ref.pointer);
    return objc.NSIndexSet.castFromPointer(_ret, retain: true, release: true);
  }

  /// sortedArrayUsingComparator:
  objc.NSArray sortedArrayUsingComparator_(DartNSComparator cmptr) {
    final _ret = _objc_msgSend_nnxkei(
        this.ref.pointer, _sel_sortedArrayUsingComparator_, cmptr.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// sortedArrayWithOptions:usingComparator:
  objc.NSArray sortedArrayWithOptions_usingComparator_(
      objc.NSSortOptions opts, DartNSComparator cmptr) {
    final _ret = _objc_msgSend_1x5ew3h(
        this.ref.pointer,
        _sel_sortedArrayWithOptions_usingComparator_,
        opts.value,
        cmptr.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// indexOfObject:inSortedRange:options:usingComparator:
  DartNSUInteger indexOfObject_inSortedRange_options_usingComparator_(
      objc.ObjCObjectBase obj,
      NSRange r,
      objc.NSBinarySearchingOptions opts,
      DartNSComparator cmp) {
    return _objc_msgSend_kshx9d(
        this.ref.pointer,
        _sel_indexOfObject_inSortedRange_options_usingComparator_,
        obj.ref.pointer,
        r,
        opts.value,
        cmp.ref.pointer);
  }
}

late final _sel_array = objc.registerName("array");
late final _sel_arrayWithObject_ = objc.registerName("arrayWithObject:");
late final _sel_arrayWithObjects_count_ =
    objc.registerName("arrayWithObjects:count:");
final _objc_msgSend_zmbtbd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            int)>();
late final _sel_arrayWithObjects_ = objc.registerName("arrayWithObjects:");
late final _sel_arrayWithArray_ = objc.registerName("arrayWithArray:");
late final _sel_initWithObjects_ = objc.registerName("initWithObjects:");
late final _sel_initWithArray_ = objc.registerName("initWithArray:");
late final _sel_initWithArray_copyItems_ =
    objc.registerName("initWithArray:copyItems:");
late final _sel_arrayWithContentsOfURL_error_ =
    objc.registerName("arrayWithContentsOfURL:error:");

/// NSArrayCreation
extension NSArrayCreation on objc.NSArray {
  /// array
  static objc.NSArray array() {
    final _ret = _objc_msgSend_151sglz(_class_NSArray, _sel_array);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// arrayWithObject:
  static objc.NSArray arrayWithObject_(objc.ObjCObjectBase anObject) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSArray, _sel_arrayWithObject_, anObject.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// arrayWithObjects:count:
  static objc.NSArray arrayWithObjects_count_(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects, DartNSUInteger cnt) {
    final _ret = _objc_msgSend_zmbtbd(
        _class_NSArray, _sel_arrayWithObjects_count_, objects, cnt);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// arrayWithObjects:
  static objc.NSArray arrayWithObjects_(objc.ObjCObjectBase firstObj) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSArray, _sel_arrayWithObjects_, firstObj.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// arrayWithArray:
  static objc.NSArray arrayWithArray_(objc.NSArray array) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSArray, _sel_arrayWithArray_, array.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithObjects:
  objc.NSArray initWithObjects_(objc.ObjCObjectBase firstObj) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithObjects_, firstObj.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithArray:
  objc.NSArray initWithArray_(objc.NSArray array) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithArray_, array.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithArray:copyItems:
  objc.NSArray initWithArray_copyItems_(objc.NSArray array, bool flag) {
    final _ret = _objc_msgSend_17amj0z(this.ref.retainAndReturnPointer(),
        _sel_initWithArray_copyItems_, array.ref.pointer, flag);
    return objc.NSArray.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:error:
  objc.NSArray? initWithContentsOfURL_error_(
      objc.NSURL url, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1lhpu4m(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_error_, url.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: false, release: true);
  }

  /// arrayWithContentsOfURL:error:
  static objc.NSArray? arrayWithContentsOfURL_error_(
      objc.NSURL url, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1lhpu4m(_class_NSArray,
        _sel_arrayWithContentsOfURL_error_, url.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

bool _ObjCBlock_bool_objcObjCObject_objcObjCObject_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Bool Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_objcObjCObject_objcObjCObject_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_objcObjCObject_objcObjCObject_fnPtrTrampoline,
            false)
        .cast();
bool _ObjCBlock_bool_objcObjCObject_objcObjCObject_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_bool_objcObjCObject_objcObjCObject_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_bool_objcObjCObject_objcObjCObject_closureTrampoline,
            false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_bool_objcObjCObject_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Bool Function(
              ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>(
              objc.newPointerBlock(
                  _ObjCBlock_bool_objcObjCObject_objcObjCObject_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
      fromFunction(bool Function(objc.ObjCObjectBase, objc.ObjCObjectBase) fn) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>(
              objc.newClosureBlock(
                  _ObjCBlock_bool_objcObjCObject_objcObjCObject_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                      objc.ObjCObjectBase(arg0, retain: true, release: true),
                      objc.ObjCObjectBase(arg1, retain: true, release: true))),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_bool_objcObjCObject_objcObjCObject_CallExtension
    on objc.ObjCBlock<
        ffi.Bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)> {
  bool call(objc.ObjCObjectBase arg0, objc.ObjCObjectBase arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Bool Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  bool Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

late final _sel_differenceFromArray_withOptions_usingEquivalenceTest_ =
    objc.registerName("differenceFromArray:withOptions:usingEquivalenceTest:");
final _objc_msgSend_1415lvo = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_differenceFromArray_withOptions_ =
    objc.registerName("differenceFromArray:withOptions:");
final _objc_msgSend_1wtpmu7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_differenceFromArray_ =
    objc.registerName("differenceFromArray:");
late final _sel_arrayByApplyingDifference_ =
    objc.registerName("arrayByApplyingDifference:");

/// NSArrayDiffing
extension NSArrayDiffing on objc.NSArray {
  /// differenceFromArray:withOptions:usingEquivalenceTest:
  objc.NSOrderedCollectionDifference
      differenceFromArray_withOptions_usingEquivalenceTest_(
          objc.NSArray other,
          objc.NSOrderedCollectionDifferenceCalculationOptions options,
          objc.ObjCBlock<
                  ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>
              block) {
    final _ret = _objc_msgSend_1415lvo(
        this.ref.pointer,
        _sel_differenceFromArray_withOptions_usingEquivalenceTest_,
        other.ref.pointer,
        options.value,
        block.ref.pointer);
    return objc.NSOrderedCollectionDifference.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// differenceFromArray:withOptions:
  objc.NSOrderedCollectionDifference differenceFromArray_withOptions_(
      objc.NSArray other,
      objc.NSOrderedCollectionDifferenceCalculationOptions options) {
    final _ret = _objc_msgSend_1wtpmu7(
        this.ref.pointer,
        _sel_differenceFromArray_withOptions_,
        other.ref.pointer,
        options.value);
    return objc.NSOrderedCollectionDifference.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// differenceFromArray:
  objc.NSOrderedCollectionDifference differenceFromArray_(objc.NSArray other) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_differenceFromArray_, other.ref.pointer);
    return objc.NSOrderedCollectionDifference.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// arrayByApplyingDifference:
  objc.NSArray? arrayByApplyingDifference_(
      objc.NSOrderedCollectionDifference difference) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_arrayByApplyingDifference_, difference.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_getObjects_ = objc.registerName("getObjects:");
final _objc_msgSend_1dau4w = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_arrayWithContentsOfFile_ =
    objc.registerName("arrayWithContentsOfFile:");
late final _sel_arrayWithContentsOfURL_ =
    objc.registerName("arrayWithContentsOfURL:");

/// NSDeprecated
extension NSDeprecated3 on objc.NSArray {
  /// getObjects:
  void getObjects_(ffi.Pointer<ffi.Pointer<objc.ObjCObject>> objects) {
    _objc_msgSend_1dau4w(this.ref.pointer, _sel_getObjects_, objects);
  }

  /// arrayWithContentsOfFile:
  static objc.NSArray? arrayWithContentsOfFile_(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSArray, _sel_arrayWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// arrayWithContentsOfURL:
  static objc.NSArray? arrayWithContentsOfURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSArray, _sel_arrayWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithContentsOfFile:
  objc.NSArray? initWithContentsOfFile_(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  objc.NSArray? initWithContentsOfURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: false, release: true);
  }

  /// writeToFile:atomically:
  bool writeToFile_atomically_(objc.NSString path, bool useAuxiliaryFile) {
    return _objc_msgSend_1iyq28l(this.ref.pointer, _sel_writeToFile_atomically_,
        path.ref.pointer, useAuxiliaryFile);
  }

  /// writeToURL:atomically:
  bool writeToURL_atomically_(objc.NSURL url, bool atomically) {
    return _objc_msgSend_1iyq28l(this.ref.pointer, _sel_writeToURL_atomically_,
        url.ref.pointer, atomically);
  }
}

late final _class_NSMutableArray = objc.getClass("NSMutableArray");
late final _sel_addObjectsFromArray_ =
    objc.registerName("addObjectsFromArray:");
late final _sel_exchangeObjectAtIndex_withObjectAtIndex_ =
    objc.registerName("exchangeObjectAtIndex:withObjectAtIndex:");
final _objc_msgSend_bfp043 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_removeObject_inRange_ =
    objc.registerName("removeObject:inRange:");
final _objc_msgSend_1oteutl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange)>();
late final _sel_removeObject_ = objc.registerName("removeObject:");
late final _sel_removeObjectIdenticalTo_inRange_ =
    objc.registerName("removeObjectIdenticalTo:inRange:");
late final _sel_removeObjectIdenticalTo_ =
    objc.registerName("removeObjectIdenticalTo:");
late final _sel_removeObjectsFromIndices_numIndices_ =
    objc.registerName("removeObjectsFromIndices:numIndices:");
final _objc_msgSend_swohtd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.UnsignedLong>,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.UnsignedLong>,
            int)>();
late final _sel_removeObjectsInArray_ =
    objc.registerName("removeObjectsInArray:");
late final _sel_removeObjectsInRange_ =
    objc.registerName("removeObjectsInRange:");
final _objc_msgSend_1e3pm0z = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>();
late final _sel_replaceObjectsInRange_withObjectsFromArray_range_ =
    objc.registerName("replaceObjectsInRange:withObjectsFromArray:range:");
final _objc_msgSend_15bolr3 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange,
                ffi.Pointer<objc.ObjCObject>,
                objc.NSRange)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSRange)>();
late final _sel_replaceObjectsInRange_withObjectsFromArray_ =
    objc.registerName("replaceObjectsInRange:withObjectsFromArray:");
final _objc_msgSend_1tv4uax = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_setArray_ = objc.registerName("setArray:");
late final _sel_sortUsingFunction_context_ =
    objc.registerName("sortUsingFunction:context:");
final _objc_msgSend_1bvics1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<
                    ffi.NativeFunction<
                        NSInteger Function(
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<objc.ObjCObject>,
                            ffi.Pointer<ffi.Void>)>>,
                ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<
                ffi.NativeFunction<
                    NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>,
            ffi.Pointer<ffi.Void>)>();
late final _sel_sortUsingSelector_ = objc.registerName("sortUsingSelector:");
late final _sel_insertObjects_atIndexes_ =
    objc.registerName("insertObjects:atIndexes:");
late final _sel_removeObjectsAtIndexes_ =
    objc.registerName("removeObjectsAtIndexes:");
late final _sel_replaceObjectsAtIndexes_withObjects_ =
    objc.registerName("replaceObjectsAtIndexes:withObjects:");
late final _sel_setObject_atIndexedSubscript_ =
    objc.registerName("setObject:atIndexedSubscript:");
final _objc_msgSend_djsa9o = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_sortUsingComparator_ =
    objc.registerName("sortUsingComparator:");
late final _sel_sortWithOptions_usingComparator_ =
    objc.registerName("sortWithOptions:usingComparator:");
final _objc_msgSend_jjgvjt = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();

/// NSExtendedMutableArray
extension NSExtendedMutableArray on objc.NSMutableArray {
  /// addObjectsFromArray:
  void addObjectsFromArray_(objc.NSArray otherArray) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_addObjectsFromArray_, otherArray.ref.pointer);
  }

  /// exchangeObjectAtIndex:withObjectAtIndex:
  void exchangeObjectAtIndex_withObjectAtIndex_(
      DartNSUInteger idx1, DartNSUInteger idx2) {
    _objc_msgSend_bfp043(this.ref.pointer,
        _sel_exchangeObjectAtIndex_withObjectAtIndex_, idx1, idx2);
  }

  /// removeAllObjects
  void removeAllObjects() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeAllObjects);
  }

  /// removeObject:inRange:
  void removeObject_inRange_(objc.ObjCObjectBase anObject, NSRange range) {
    _objc_msgSend_1oteutl(this.ref.pointer, _sel_removeObject_inRange_,
        anObject.ref.pointer, range);
  }

  /// removeObject:
  void removeObject_(objc.ObjCObjectBase anObject) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeObject_, anObject.ref.pointer);
  }

  /// removeObjectIdenticalTo:inRange:
  void removeObjectIdenticalTo_inRange_(
      objc.ObjCObjectBase anObject, NSRange range) {
    _objc_msgSend_1oteutl(this.ref.pointer,
        _sel_removeObjectIdenticalTo_inRange_, anObject.ref.pointer, range);
  }

  /// removeObjectIdenticalTo:
  void removeObjectIdenticalTo_(objc.ObjCObjectBase anObject) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeObjectIdenticalTo_, anObject.ref.pointer);
  }

  /// removeObjectsFromIndices:numIndices:
  void removeObjectsFromIndices_numIndices_(
      ffi.Pointer<NSUInteger> indices, DartNSUInteger cnt) {
    _objc_msgSend_swohtd(this.ref.pointer,
        _sel_removeObjectsFromIndices_numIndices_, indices, cnt);
  }

  /// removeObjectsInArray:
  void removeObjectsInArray_(objc.NSArray otherArray) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeObjectsInArray_, otherArray.ref.pointer);
  }

  /// removeObjectsInRange:
  void removeObjectsInRange_(NSRange range) {
    _objc_msgSend_1e3pm0z(this.ref.pointer, _sel_removeObjectsInRange_, range);
  }

  /// replaceObjectsInRange:withObjectsFromArray:range:
  void replaceObjectsInRange_withObjectsFromArray_range_(
      NSRange range, objc.NSArray otherArray, NSRange otherRange) {
    _objc_msgSend_15bolr3(
        this.ref.pointer,
        _sel_replaceObjectsInRange_withObjectsFromArray_range_,
        range,
        otherArray.ref.pointer,
        otherRange);
  }

  /// replaceObjectsInRange:withObjectsFromArray:
  void replaceObjectsInRange_withObjectsFromArray_(
      NSRange range, objc.NSArray otherArray) {
    _objc_msgSend_1tv4uax(
        this.ref.pointer,
        _sel_replaceObjectsInRange_withObjectsFromArray_,
        range,
        otherArray.ref.pointer);
  }

  /// setArray:
  void setArray_(objc.NSArray otherArray) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setArray_, otherArray.ref.pointer);
  }

  /// sortUsingFunction:context:
  void sortUsingFunction_context_(
      ffi.Pointer<
              ffi.NativeFunction<
                  NSInteger Function(ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>
          compare,
      ffi.Pointer<ffi.Void> context) {
    _objc_msgSend_1bvics1(
        this.ref.pointer, _sel_sortUsingFunction_context_, compare, context);
  }

  /// sortUsingSelector:
  void sortUsingSelector_(ffi.Pointer<objc.ObjCSelector> comparator) {
    _objc_msgSend_1d9e4oe(
        this.ref.pointer, _sel_sortUsingSelector_, comparator);
  }

  /// insertObjects:atIndexes:
  void insertObjects_atIndexes_(objc.NSArray objects, objc.NSIndexSet indexes) {
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_insertObjects_atIndexes_,
        objects.ref.pointer, indexes.ref.pointer);
  }

  /// removeObjectsAtIndexes:
  void removeObjectsAtIndexes_(objc.NSIndexSet indexes) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeObjectsAtIndexes_, indexes.ref.pointer);
  }

  /// replaceObjectsAtIndexes:withObjects:
  void replaceObjectsAtIndexes_withObjects_(
      objc.NSIndexSet indexes, objc.NSArray objects) {
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_replaceObjectsAtIndexes_withObjects_,
        indexes.ref.pointer,
        objects.ref.pointer);
  }

  /// setObject:atIndexedSubscript:
  void setObject_atIndexedSubscript_(
      objc.ObjCObjectBase obj, DartNSUInteger idx) {
    _objc_msgSend_djsa9o(this.ref.pointer, _sel_setObject_atIndexedSubscript_,
        obj.ref.pointer, idx);
  }

  /// sortUsingComparator:
  void sortUsingComparator_(DartNSComparator cmptr) {
    _objc_msgSend_f167m6(
        this.ref.pointer, _sel_sortUsingComparator_, cmptr.ref.pointer);
  }

  /// sortWithOptions:usingComparator:
  void sortWithOptions_usingComparator_(
      objc.NSSortOptions opts, DartNSComparator cmptr) {
    _objc_msgSend_jjgvjt(this.ref.pointer,
        _sel_sortWithOptions_usingComparator_, opts.value, cmptr.ref.pointer);
  }
}

late final _sel_arrayWithCapacity_ = objc.registerName("arrayWithCapacity:");

/// NSMutableArrayCreation
extension NSMutableArrayCreation on objc.NSMutableArray {
  /// arrayWithCapacity:
  static objc.NSMutableArray arrayWithCapacity_(DartNSUInteger numItems) {
    final _ret = _objc_msgSend_14hpxwa(
        _class_NSMutableArray, _sel_arrayWithCapacity_, numItems);
    return objc.NSMutableArray.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// arrayWithContentsOfFile:
  static objc.NSMutableArray? arrayWithContentsOfFile_(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSMutableArray, _sel_arrayWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableArray.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// arrayWithContentsOfURL:
  static objc.NSMutableArray? arrayWithContentsOfURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSMutableArray, _sel_arrayWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableArray.castFromPointer(_ret,
            retain: true, release: true);
  }

  /// initWithContentsOfFile:
  objc.NSMutableArray? initWithContentsOfFile_(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableArray.castFromPointer(_ret,
            retain: false, release: true);
  }

  /// initWithContentsOfURL:
  objc.NSMutableArray? initWithContentsOfURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSMutableArray.castFromPointer(_ret,
            retain: false, release: true);
  }
}

late final _sel_applyDifference_ = objc.registerName("applyDifference:");

/// NSMutableArrayDiffing
extension NSMutableArrayDiffing on objc.NSMutableArray {
  /// applyDifference:
  void applyDifference_(objc.NSOrderedCollectionDifference difference) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_applyDifference_, difference.ref.pointer);
  }
}

void _ObjCBlock_ffiVoid_objcObjCObject_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_objcObjCObject_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_objcObjCObject_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_objcObjCObject_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_objcObjCObject_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject_NSError_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_objcObjCObject_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject_NSError_blockingCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_objcObjCObject_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_objcObjCObject_NSError_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_objcObjCObject_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>`.
abstract final class ObjCBlock_ffiVoid_objcObjCObject_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>?,
                  objc.NSError)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_objcObjCObject_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)> fromFunction(
          void Function(objc.ObjCObjectBase?, objc.NSError) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_objcObjCObject_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : objc.ObjCObjectBase(arg0, retain: true, release: true),
                  objc.NSError.castFromPointer(arg1, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>
      listener(void Function(objc.ObjCObjectBase?, objc.NSError) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_NSError_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg0, retain: false, release: true),
                objc.NSError.castFromPointer(arg1,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?,
            objc.NSError)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>
      blocking(void Function(objc.ObjCObjectBase?, objc.NSError) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_NSError_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg0, retain: false, release: true),
                objc.NSError.castFromPointer(arg1,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_objcObjCObject_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.ObjCObjectBase(arg0, retain: false, release: true),
                objc.NSError.castFromPointer(arg1,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_pfv6jd, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>?,
            objc.NSError)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>`.
extension ObjCBlock_ffiVoid_objcObjCObject_NSError_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)> {
  void call(objc.ObjCObjectBase? arg0, objc.NSError arg1) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1.ref.pointer);
}

typedef NSItemProviderCompletionHandler = ffi.Pointer<objc.ObjCBlockImpl>;
typedef DartNSItemProviderCompletionHandler = objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>;
void
    _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            NSItemProviderCompletionHandler arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        NSItemProviderCompletionHandler arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2)>>()
            .asFunction<
                void Function(
                    NSItemProviderCompletionHandler,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    NSItemProviderCompletionHandler,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            NSItemProviderCompletionHandler arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2) =>
        (objc.getBlockClosure(block) as void Function(
            NSItemProviderCompletionHandler,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    NSItemProviderCompletionHandler,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        NSItemProviderCompletionHandler arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  (objc.getBlockClosure(block) as void Function(
      NSItemProviderCompletionHandler,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            NSItemProviderCompletionHandler,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                NSItemProviderCompletionHandler,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        NSItemProviderCompletionHandler arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2) {
  try {
    (objc.getBlockClosure(block) as void Function(
        NSItemProviderCompletionHandler,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            NSItemProviderCompletionHandler,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                NSItemProviderCompletionHandler,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            NSItemProviderCompletionHandler,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                NSItemProviderCompletionHandler,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>, ffi.Pointer<objc.ObjCObject>, objc.NSDictionary)>`.
abstract final class ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>,
              ffi.Pointer<objc.ObjCObject>,
              objc.NSDictionary)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>,
                  ffi.Pointer<objc.ObjCObject>,
                  objc.NSDictionary)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Void Function(
              objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>,
              ffi.Pointer<objc.ObjCObject>,
              objc.NSDictionary)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(NSItemProviderCompletionHandler arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2)>> ptr) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>,
                  ffi.Pointer<objc.ObjCObject>,
                  objc.NSDictionary)>(objc.newPointerBlock(_ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_fnPtrCallable, ptr.cast()), retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>, ffi.Pointer<objc.ObjCObject>, objc.NSDictionary)>
      fromFunction(void Function(DartNSItemProviderCompletionHandler, objc.ObjCObjectBase, objc.NSDictionary) fn) =>
          objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>, ffi.Pointer<objc.ObjCObject>, objc.NSDictionary)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_closureCallable,
                  (NSItemProviderCompletionHandler arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2) =>
                      fn(
                          ObjCBlock_ffiVoid_objcObjCObject_NSError.castFromPointer(arg0, retain: true, release: true),
                          objc.ObjCObjectBase(arg1, retain: true, release: true),
                          objc.NSDictionary.castFromPointer(arg2, retain: true, release: true))),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>,
          ffi.Pointer<objc.ObjCObject>,
          objc.NSDictionary)> listener(
      void Function(DartNSItemProviderCompletionHandler, objc.ObjCObjectBase,
              objc.NSDictionary)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_listenerCallable
            .nativeFunction
            .cast(),
        (NSItemProviderCompletionHandler arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                ObjCBlock_ffiVoid_objcObjCObject_NSError.castFromPointer(arg0,
                    retain: false, release: true),
                objc.ObjCObjectBase(arg1, retain: false, release: true),
                objc.NSDictionary.castFromPointer(arg2,
                    retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_1b3bb6a(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            objc.ObjCBlock<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSDictionary)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>,
          ffi.Pointer<objc.ObjCObject>,
          objc.NSDictionary)> blocking(
      void Function(DartNSItemProviderCompletionHandler, objc.ObjCObjectBase,
              objc.NSDictionary)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_blockingCallable
            .nativeFunction
            .cast(),
        (NSItemProviderCompletionHandler arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                ObjCBlock_ffiVoid_objcObjCObject_NSError.castFromPointer(arg0,
                    retain: false, release: true),
                objc.ObjCObjectBase(arg1, retain: false, release: true),
                objc.NSDictionary.castFromPointer(arg2,
                    retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_blockingListenerCallable
            .nativeFunction
            .cast(),
        (NSItemProviderCompletionHandler arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2) =>
            fn(
                ObjCBlock_ffiVoid_objcObjCObject_NSError.castFromPointer(arg0,
                    retain: false, release: true),
                objc.ObjCObjectBase(arg1, retain: false, release: true),
                objc.NSDictionary.castFromPointer(arg2,
                    retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_1b3bb6a, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(
            objc.ObjCBlock<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSDictionary)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>, ffi.Pointer<objc.ObjCObject>, objc.NSDictionary)>`.
extension ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            objc.ObjCBlock<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>,
            ffi.Pointer<objc.ObjCObject>,
            objc.NSDictionary)> {
  void call(DartNSItemProviderCompletionHandler arg0, objc.ObjCObjectBase arg1,
          objc.NSDictionary arg2) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          NSItemProviderCompletionHandler arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      NSItemProviderCompletionHandler,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2.ref.pointer);
}

typedef NSItemProviderLoadHandler = ffi.Pointer<objc.ObjCBlockImpl>;
typedef DartNSItemProviderLoadHandler = objc.ObjCBlock<
    ffi.Void Function(
        objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>?, objc.NSError)>,
        ffi.Pointer<objc.ObjCObject>,
        objc.NSDictionary)>;
late final _class_NSItemProvider = objc.getClass("NSItemProvider");
late final _sel_previewImageHandler = objc.registerName("previewImageHandler");
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCBlockImpl> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPreviewImageHandler_ =
    objc.registerName("setPreviewImageHandler:");
late final _sel_loadPreviewImageWithOptions_completionHandler_ =
    objc.registerName("loadPreviewImageWithOptions:completionHandler:");

/// NSPreviewSupport
extension NSPreviewSupport on objc.NSItemProvider {
  /// previewImageHandler
  DartNSItemProviderLoadHandler? get previewImageHandler {
    final _ret =
        _objc_msgSend_uwvaik(this.ref.pointer, _sel_previewImageHandler);
    return _ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObject_NSDictionary
            .castFromPointer(_ret, retain: true, release: true);
  }

  /// setPreviewImageHandler:
  set previewImageHandler(DartNSItemProviderLoadHandler? value) {
    _objc_msgSend_f167m6(this.ref.pointer, _sel_setPreviewImageHandler_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// loadPreviewImageWithOptions:completionHandler:
  void loadPreviewImageWithOptions_completionHandler_(objc.NSDictionary options,
      DartNSItemProviderCompletionHandler completionHandler) {
    _objc_msgSend_o762yo(
        this.ref.pointer,
        _sel_loadPreviewImageWithOptions_completionHandler_,
        options.ref.pointer,
        completionHandler.ref.pointer);
  }
}

typedef NSStringEncoding = NSUInteger;
late final _class_NSString = objc.getClass("NSString");
late final _sel_substringFromIndex_ = objc.registerName("substringFromIndex:");
late final _sel_substringToIndex_ = objc.registerName("substringToIndex:");
late final _sel_substringWithRange_ = objc.registerName("substringWithRange:");
late final _sel_getCharacters_range_ =
    objc.registerName("getCharacters:range:");
final _objc_msgSend_898fog = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.UnsignedShort>,
                objc.NSRange)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.UnsignedShort>,
            objc.NSRange)>();
late final _sel_compare_options_ = objc.registerName("compare:options:");
final _objc_msgSend_pg1fnv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSInteger Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_compare_options_range_ =
    objc.registerName("compare:options:range:");
final _objc_msgSend_xrqic1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSInteger Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                objc.NSRange)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            objc.NSRange)>();
late final _sel_compare_options_range_locale_ =
    objc.registerName("compare:options:range:locale:");
final _objc_msgSend_1895u4n = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSInteger Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                objc.NSRange,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_caseInsensitiveCompare_ =
    objc.registerName("caseInsensitiveCompare:");
late final _sel_localizedCompare_ = objc.registerName("localizedCompare:");
late final _sel_localizedCaseInsensitiveCompare_ =
    objc.registerName("localizedCaseInsensitiveCompare:");
late final _sel_localizedStandardCompare_ =
    objc.registerName("localizedStandardCompare:");
late final _sel_isEqualToString_ = objc.registerName("isEqualToString:");
late final _sel_hasPrefix_ = objc.registerName("hasPrefix:");
late final _sel_hasSuffix_ = objc.registerName("hasSuffix:");
late final _sel_commonPrefixWithString_options_ =
    objc.registerName("commonPrefixWithString:options:");
final _objc_msgSend_diypgk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_containsString_ = objc.registerName("containsString:");
late final _sel_localizedCaseInsensitiveContainsString_ =
    objc.registerName("localizedCaseInsensitiveContainsString:");
late final _sel_localizedStandardContainsString_ =
    objc.registerName("localizedStandardContainsString:");
late final _sel_localizedStandardRangeOfString_ =
    objc.registerName("localizedStandardRangeOfString:");
final _objc_msgSend_182fzon = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.NSRange Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.NSRange Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_182fzonStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.NSRange>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.NSRange>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_rangeOfString_ = objc.registerName("rangeOfString:");
late final _sel_rangeOfString_options_ =
    objc.registerName("rangeOfString:options:");
final _objc_msgSend_102xxo4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.NSRange Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger)>>()
    .asFunction<
        objc.NSRange Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
final _objc_msgSend_102xxo4Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.NSRange>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.NSRange>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_rangeOfString_options_range_ =
    objc.registerName("rangeOfString:options:range:");
final _objc_msgSend_1nmlvqc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.NSRange Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                objc.NSRange)>>()
    .asFunction<
        objc.NSRange Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            objc.NSRange)>();
final _objc_msgSend_1nmlvqcStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.NSRange>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                objc.NSRange)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.NSRange>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            objc.NSRange)>();
late final _sel_rangeOfString_options_range_locale_ =
    objc.registerName("rangeOfString:options:range:locale:");
final _objc_msgSend_gg0462 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.NSRange Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                objc.NSRange,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        objc.NSRange Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObject>)>();
final _objc_msgSend_gg0462Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.NSRange>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                objc.NSRange,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.NSRange>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_rangeOfCharacterFromSet_ =
    objc.registerName("rangeOfCharacterFromSet:");
late final _sel_rangeOfCharacterFromSet_options_ =
    objc.registerName("rangeOfCharacterFromSet:options:");
late final _sel_rangeOfCharacterFromSet_options_range_ =
    objc.registerName("rangeOfCharacterFromSet:options:range:");
late final _sel_rangeOfComposedCharacterSequenceAtIndex_ =
    objc.registerName("rangeOfComposedCharacterSequenceAtIndex:");
final _objc_msgSend_d3i1uy = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.NSRange Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        objc.NSRange Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_d3i1uyStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.NSRange>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.NSRange>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_rangeOfComposedCharacterSequencesForRange_ =
    objc.registerName("rangeOfComposedCharacterSequencesForRange:");
final _objc_msgSend_uimyc7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            objc.NSRange Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>>()
    .asFunction<
        objc.NSRange Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>();
final _objc_msgSend_uimyc7Stret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.NSRange>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.NSRange>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>();
late final _sel_stringByAppendingString_ =
    objc.registerName("stringByAppendingString:");
late final _sel_stringByAppendingFormat_ =
    objc.registerName("stringByAppendingFormat:");
late final _sel_doubleValue = objc.registerName("doubleValue");
late final _sel_floatValue = objc.registerName("floatValue");
late final _sel_intValue = objc.registerName("intValue");
final _objc_msgSend_13yqbb6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Int Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_integerValue = objc.registerName("integerValue");
late final _sel_longLongValue = objc.registerName("longLongValue");
late final _sel_boolValue = objc.registerName("boolValue");
late final _sel_uppercaseString = objc.registerName("uppercaseString");
late final _sel_lowercaseString = objc.registerName("lowercaseString");
late final _sel_capitalizedString = objc.registerName("capitalizedString");
late final _sel_localizedUppercaseString =
    objc.registerName("localizedUppercaseString");
late final _sel_localizedLowercaseString =
    objc.registerName("localizedLowercaseString");
late final _sel_localizedCapitalizedString =
    objc.registerName("localizedCapitalizedString");
late final _sel_uppercaseStringWithLocale_ =
    objc.registerName("uppercaseStringWithLocale:");
late final _sel_lowercaseStringWithLocale_ =
    objc.registerName("lowercaseStringWithLocale:");
late final _sel_capitalizedStringWithLocale_ =
    objc.registerName("capitalizedStringWithLocale:");
late final _sel_getLineStart_end_contentsEnd_forRange_ =
    objc.registerName("getLineStart:end:contentsEnd:forRange:");
final _objc_msgSend_ourvf2 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.UnsignedLong>,
                ffi.Pointer<ffi.UnsignedLong>,
                ffi.Pointer<ffi.UnsignedLong>,
                objc.NSRange)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.UnsignedLong>,
            ffi.Pointer<ffi.UnsignedLong>,
            ffi.Pointer<ffi.UnsignedLong>,
            objc.NSRange)>();
late final _sel_lineRangeForRange_ = objc.registerName("lineRangeForRange:");
late final _sel_getParagraphStart_end_contentsEnd_forRange_ =
    objc.registerName("getParagraphStart:end:contentsEnd:forRange:");
late final _sel_paragraphRangeForRange_ =
    objc.registerName("paragraphRangeForRange:");
void _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        NSRange arg1,
        NSRange arg2,
        ffi.Pointer<ffi.Bool> arg3) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    NSRange arg1, NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>, NSRange, NSRange,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    NSRange,
                    NSRange,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        NSRange arg1,
        NSRange arg2,
        ffi.Pointer<ffi.Bool> arg3) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        NSRange, NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    NSRange,
                    NSRange,
                    ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    NSRange arg1,
    NSRange arg2,
    ffi.Pointer<ffi.Bool> arg3) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
      NSRange, NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            NSRange,
            NSRange,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_listenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                NSRange,
                NSRange,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    NSRange arg1,
    NSRange arg2,
    ffi.Pointer<ffi.Bool> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        NSRange, NSRange, ffi.Pointer<ffi.Bool>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            NSRange,
            NSRange,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                NSRange,
                NSRange,
                ffi.Pointer<ffi.Bool>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            NSRange,
            NSRange,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                NSRange,
                NSRange,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
                      ffi.Pointer<ffi.Bool>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, NSRange arg1, NSRange arg2, ffi.Pointer<ffi.Bool> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
                      ffi.Pointer<ffi.Bool>)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)> fromFunction(
          void Function(objc.NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
              fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, NSRange arg1, NSRange arg2,
                      ffi.Pointer<ffi.Bool> arg3) =>
                  fn(arg0.address == 0 ? null : objc.NSString.castFromPointer(arg0, retain: true, release: true), arg1, arg2, arg3)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
          ffi.Pointer<ffi.Bool>)> listener(
      void Function(objc.NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, NSRange arg1, NSRange arg2,
                ffi.Pointer<ffi.Bool> arg3) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg0,
                        retain: false, release: true),
                arg1,
                arg2,
                arg3));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_lmc3p5(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
          ffi.Pointer<ffi.Bool>)> blocking(
      void Function(objc.NSString?, NSRange, NSRange, ffi.Pointer<ffi.Bool>)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, NSRange arg1, NSRange arg2,
                ffi.Pointer<ffi.Bool> arg3) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg0,
                        retain: false, release: true),
                arg1,
                arg2,
                arg3));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, NSRange arg1, NSRange arg2,
                ffi.Pointer<ffi.Bool> arg3) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSString.castFromPointer(arg0,
                        retain: false, release: true),
                arg1,
                arg2,
                arg3));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_lmc3p5, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
            ffi.Pointer<ffi.Bool>)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSString_NSRange_NSRange_bool_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
            ffi.Pointer<ffi.Bool>)> {
  void call(objc.NSString? arg0, NSRange arg1, NSRange arg2,
          ffi.Pointer<ffi.Bool> arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          NSRange arg1,
                          NSRange arg2,
                          ffi.Pointer<ffi.Bool> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      NSRange,
                      NSRange,
                      ffi.Pointer<ffi.Bool>)>()(
          ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1, arg2, arg3);
}

late final _sel_enumerateSubstringsInRange_options_usingBlock_ =
    objc.registerName("enumerateSubstringsInRange:options:usingBlock:");
final _objc_msgSend_14ew8zr = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange,
                NSUInteger,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.NSRange,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
void _ObjCBlock_ffiVoid_NSString_bool_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<ffi.Bool> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<ffi.Bool> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSString_bool_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_NSString_bool_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSString_bool_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<ffi.Bool> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSString_bool_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>(
            _ObjCBlock_ffiVoid_NSString_bool_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSString_bool_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSString_bool_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_NSString_bool_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSString_bool_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<ffi.Bool> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Bool>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSString_bool_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSString_bool_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Bool>)>
    _ObjCBlock_ffiVoid_NSString_bool_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Bool>)>.listener(
        _ObjCBlock_ffiVoid_NSString_bool_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_NSString_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<ffi.Bool> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSString_bool_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>
      fromFunction(void Function(objc.NSString, ffi.Pointer<ffi.Bool>) fn) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_NSString_bool_closureCallable,
                  (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
                      objc.NSString.castFromPointer(arg0,
                          retain: true, release: true),
                      arg1)),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>
      listener(void Function(objc.NSString, ffi.Pointer<ffi.Bool>) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSString_bool_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
            objc.NSString.castFromPointer(arg0, retain: false, release: true),
            arg1));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_t8l8el(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>
      blocking(void Function(objc.NSString, ffi.Pointer<ffi.Bool>) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSString_bool_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
            objc.NSString.castFromPointer(arg0, retain: false, release: true),
            arg1));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSString_bool_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<ffi.Bool> arg1) => fn(
            objc.NSString.castFromPointer(arg0, retain: false, release: true),
            arg1));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_t8l8el, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_NSString_bool_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)> {
  void call(objc.NSString arg0, ffi.Pointer<ffi.Bool> arg1) => ref
      .pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<objc.ObjCObject> arg0,
                  ffi.Pointer<ffi.Bool> arg1)>>()
      .asFunction<
          void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Bool>)>()(ref.pointer, arg0.ref.pointer, arg1);
}

late final _sel_enumerateLinesUsingBlock_ =
    objc.registerName("enumerateLinesUsingBlock:");
late final _sel_UTF8String = objc.registerName("UTF8String");
final _objc_msgSend_1fuqfwb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<ffi.Char> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_fastestEncoding = objc.registerName("fastestEncoding");
late final _sel_smallestEncoding = objc.registerName("smallestEncoding");
late final _sel_dataUsingEncoding_allowLossyConversion_ =
    objc.registerName("dataUsingEncoding:allowLossyConversion:");
final _objc_msgSend_hiwitm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong, ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, bool)>();
late final _sel_dataUsingEncoding_ = objc.registerName("dataUsingEncoding:");
late final _sel_canBeConvertedToEncoding_ =
    objc.registerName("canBeConvertedToEncoding:");
final _objc_msgSend_6peh6o = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_cStringUsingEncoding_ =
    objc.registerName("cStringUsingEncoding:");
final _objc_msgSend_1jtxufi = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_getCString_maxLength_encoding_ =
    objc.registerName("getCString:maxLength:encoding:");
final _objc_msgSend_1lv8yz3 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>, int, int)>();
late final _sel_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_ =
    objc.registerName(
        "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:");
final _objc_msgSend_i30zh3 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Void>,
                ffi.UnsignedLong,
                ffi.Pointer<ffi.UnsignedLong>,
                ffi.UnsignedLong,
                NSUInteger,
                objc.NSRange,
                ffi.Pointer<objc.NSRange>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Void>,
            int,
            ffi.Pointer<ffi.UnsignedLong>,
            int,
            int,
            objc.NSRange,
            ffi.Pointer<objc.NSRange>)>();
late final _sel_maximumLengthOfBytesUsingEncoding_ =
    objc.registerName("maximumLengthOfBytesUsingEncoding:");
final _objc_msgSend_12py2ux = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_lengthOfBytesUsingEncoding_ =
    objc.registerName("lengthOfBytesUsingEncoding:");
late final _sel_availableStringEncodings =
    objc.registerName("availableStringEncodings");
final _objc_msgSend_1h2q612 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.UnsignedLong> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<ffi.UnsignedLong> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_localizedNameOfStringEncoding_ =
    objc.registerName("localizedNameOfStringEncoding:");
late final _sel_defaultCStringEncoding =
    objc.registerName("defaultCStringEncoding");
late final _sel_decomposedStringWithCanonicalMapping =
    objc.registerName("decomposedStringWithCanonicalMapping");
late final _sel_precomposedStringWithCanonicalMapping =
    objc.registerName("precomposedStringWithCanonicalMapping");
late final _sel_decomposedStringWithCompatibilityMapping =
    objc.registerName("decomposedStringWithCompatibilityMapping");
late final _sel_precomposedStringWithCompatibilityMapping =
    objc.registerName("precomposedStringWithCompatibilityMapping");
late final _sel_componentsSeparatedByString_ =
    objc.registerName("componentsSeparatedByString:");
late final _sel_componentsSeparatedByCharactersInSet_ =
    objc.registerName("componentsSeparatedByCharactersInSet:");
late final _sel_stringByTrimmingCharactersInSet_ =
    objc.registerName("stringByTrimmingCharactersInSet:");
late final _sel_stringByPaddingToLength_withString_startingAtIndex_ =
    objc.registerName("stringByPaddingToLength:withString:startingAtIndex:");
final _objc_msgSend_1tfztp = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            int)>();
late final _sel_stringByFoldingWithOptions_locale_ =
    objc.registerName("stringByFoldingWithOptions:locale:");
final _objc_msgSend_11cbyu0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                NSUInteger,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_stringByReplacingOccurrencesOfString_withString_options_range_ =
    objc.registerName(
        "stringByReplacingOccurrencesOfString:withString:options:range:");
final _objc_msgSend_2u4jm6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                objc.NSRange)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            objc.NSRange)>();
late final _sel_stringByReplacingOccurrencesOfString_withString_ =
    objc.registerName("stringByReplacingOccurrencesOfString:withString:");
late final _sel_stringByReplacingCharactersInRange_withString_ =
    objc.registerName("stringByReplacingCharactersInRange:withString:");
final _objc_msgSend_bstjp9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                objc.NSRange,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            objc.NSRange,
            ffi.Pointer<objc.ObjCObject>)>();
typedef NSStringTransform = ffi.Pointer<objc.ObjCObject>;
typedef DartNSStringTransform = objc.NSString;
late final _sel_stringByApplyingTransform_reverse_ =
    objc.registerName("stringByApplyingTransform:reverse:");
late final _sel_writeToURL_atomically_encoding_error_ =
    objc.registerName("writeToURL:atomically:encoding:error:");
final _objc_msgSend_dv3z6r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                ffi.UnsignedLong,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            int,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_writeToFile_atomically_encoding_error_ =
    objc.registerName("writeToFile:atomically:encoding:error:");
late final _sel_hash = objc.registerName("hash");
late final _sel_initWithCharactersNoCopy_length_freeWhenDone_ =
    objc.registerName("initWithCharactersNoCopy:length:freeWhenDone:");
final _objc_msgSend_lh0jh5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.UnsignedShort>,
                ffi.UnsignedLong,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.UnsignedShort>,
            int,
            bool)>();
void _ObjCBlock_ffiVoid_unichar_NSUInteger_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<unichar> arg0,
        int arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<unichar> arg0, NSUInteger arg1)>>()
        .asFunction<void Function(ffi.Pointer<unichar>, int)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_unichar_NSUInteger_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<unichar>, NSUInteger)>(
            _ObjCBlock_ffiVoid_unichar_NSUInteger_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_unichar_NSUInteger_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<unichar> arg0,
        int arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<unichar>, int))(
        arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_unichar_NSUInteger_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<unichar>, NSUInteger)>(
            _ObjCBlock_ffiVoid_unichar_NSUInteger_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_unichar_NSUInteger_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<unichar> arg0,
    int arg1) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<unichar>, int))(
      arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<unichar>, NSUInteger)>
    _ObjCBlock_ffiVoid_unichar_NSUInteger_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<unichar>, NSUInteger)>.listener(
        _ObjCBlock_ffiVoid_unichar_NSUInteger_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_unichar_NSUInteger_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<unichar> arg0,
    int arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<unichar>, int))(
        arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<unichar>, NSUInteger)>
    _ObjCBlock_ffiVoid_unichar_NSUInteger_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<unichar>,
                NSUInteger)>.isolateLocal(
        _ObjCBlock_ffiVoid_unichar_NSUInteger_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<unichar>, NSUInteger)>
    _ObjCBlock_ffiVoid_unichar_NSUInteger_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<unichar>,
                NSUInteger)>.listener(
        _ObjCBlock_ffiVoid_unichar_NSUInteger_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_ffiVoid_unichar_NSUInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<unichar>,
                  ffi.UnsignedLong)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<unichar> arg0, NSUInteger arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_unichar_NSUInteger_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)> fromFunction(
          void Function(ffi.Pointer<unichar>, DartNSUInteger) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_unichar_NSUInteger_closureCallable,
              (ffi.Pointer<unichar> arg0, int arg1) => fn(arg0, arg1)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)>
      listener(void Function(ffi.Pointer<unichar>, DartNSUInteger) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_unichar_NSUInteger_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<unichar> arg0, int arg1) => fn(arg0, arg1));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_vhbh5h(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)>
      blocking(void Function(ffi.Pointer<unichar>, DartNSUInteger) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_unichar_NSUInteger_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<unichar> arg0, int arg1) => fn(arg0, arg1));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_unichar_NSUInteger_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<unichar> arg0, int arg1) => fn(arg0, arg1));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_vhbh5h, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)>`.
extension ObjCBlock_ffiVoid_unichar_NSUInteger_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)> {
  void call(ffi.Pointer<unichar> arg0, DartNSUInteger arg1) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<unichar> arg0, NSUInteger arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<unichar>, int)>()(ref.pointer, arg0, arg1);
}

late final _sel_initWithCharactersNoCopy_length_deallocator_ =
    objc.registerName("initWithCharactersNoCopy:length:deallocator:");
final _objc_msgSend_talwei = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.UnsignedShort>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.UnsignedShort>,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_initWithCharacters_length_ =
    objc.registerName("initWithCharacters:length:");
final _objc_msgSend_9x4k8x = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.UnsignedShort>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.UnsignedShort>,
            int)>();
late final _sel_initWithUTF8String_ = objc.registerName("initWithUTF8String:");
final _objc_msgSend_56zxyn = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>)>();
late final _sel_initWithFormat_ = objc.registerName("initWithFormat:");
late final _sel_initWithFormat_locale_ =
    objc.registerName("initWithFormat:locale:");
late final _sel_initWithValidatedFormat_validFormatSpecifiers_error_ =
    objc.registerName("initWithValidatedFormat:validFormatSpecifiers:error:");
final _objc_msgSend_1pnyuds = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_initWithValidatedFormat_validFormatSpecifiers_locale_error_ =
    objc.registerName(
        "initWithValidatedFormat:validFormatSpecifiers:locale:error:");
final _objc_msgSend_1k0ezzm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_initWithData_encoding_ =
    objc.registerName("initWithData:encoding:");
late final _sel_initWithBytes_length_encoding_ =
    objc.registerName("initWithBytes:length:encoding:");
final _objc_msgSend_9b3h4v = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Void>,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>, int, int)>();
late final _sel_initWithBytesNoCopy_length_encoding_freeWhenDone_ =
    objc.registerName("initWithBytesNoCopy:length:encoding:freeWhenDone:");
final _objc_msgSend_k4j8m3 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Void>,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Void>,
            int,
            int,
            bool)>();
void _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        int arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> arg0, NSUInteger arg1)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, NSUInteger)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        int arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
        arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, NSUInteger)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    int arg1) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
      arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, NSUInteger)>
    _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, NSUInteger)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    int arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, int))(
        arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, NSUInteger)>
    _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                NSUInteger)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, NSUInteger)>
    _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                NSUInteger)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSUInteger {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  ffi.UnsignedLong)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> fromFunctionPointer(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, NSUInteger arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>
      fromFunction(void Function(ffi.Pointer<ffi.Void>, DartNSUInteger) fn) =>
          objc.ObjCBlock<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(
              objc.newClosureBlock(
                  _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1)),
              retain: false,
              release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>
      listener(void Function(ffi.Pointer<ffi.Void>, DartNSUInteger) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_zuf90e(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc
      .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>
      blocking(void Function(ffi.Pointer<ffi.Void>, DartNSUInteger) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSUInteger_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, int arg1) => fn(arg0, arg1));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_zuf90e, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSUInteger_CallExtension on objc
    .ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)> {
  void call(ffi.Pointer<ffi.Void> arg0, DartNSUInteger arg1) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0, NSUInteger arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, int)>()(ref.pointer, arg0, arg1);
}

late final _sel_initWithBytesNoCopy_length_encoding_deallocator_ =
    objc.registerName("initWithBytesNoCopy:length:encoding:deallocator:");
final _objc_msgSend_1lbgrac = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Void>,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Void>,
            int,
            int,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_stringWithString_ = objc.registerName("stringWithString:");
late final _sel_stringWithCharacters_length_ =
    objc.registerName("stringWithCharacters:length:");
late final _sel_stringWithUTF8String_ =
    objc.registerName("stringWithUTF8String:");
late final _sel_stringWithFormat_ = objc.registerName("stringWithFormat:");
late final _sel_localizedStringWithFormat_ =
    objc.registerName("localizedStringWithFormat:");
late final _sel_stringWithValidatedFormat_validFormatSpecifiers_error_ =
    objc.registerName("stringWithValidatedFormat:validFormatSpecifiers:error:");
late final _sel_localizedStringWithValidatedFormat_validFormatSpecifiers_error_ =
    objc.registerName(
        "localizedStringWithValidatedFormat:validFormatSpecifiers:error:");
late final _sel_initWithCString_encoding_ =
    objc.registerName("initWithCString:encoding:");
final _objc_msgSend_erqryg = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>, int)>();
late final _sel_stringWithCString_encoding_ =
    objc.registerName("stringWithCString:encoding:");
late final _sel_initWithContentsOfURL_encoding_error_ =
    objc.registerName("initWithContentsOfURL:encoding:error:");
final _objc_msgSend_1nomli1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_initWithContentsOfFile_encoding_error_ =
    objc.registerName("initWithContentsOfFile:encoding:error:");
late final _sel_stringWithContentsOfURL_encoding_error_ =
    objc.registerName("stringWithContentsOfURL:encoding:error:");
late final _sel_stringWithContentsOfFile_encoding_error_ =
    objc.registerName("stringWithContentsOfFile:encoding:error:");
late final _sel_initWithContentsOfURL_usedEncoding_error_ =
    objc.registerName("initWithContentsOfURL:usedEncoding:error:");
final _objc_msgSend_1alewu7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.UnsignedLong>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.UnsignedLong>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_initWithContentsOfFile_usedEncoding_error_ =
    objc.registerName("initWithContentsOfFile:usedEncoding:error:");
late final _sel_stringWithContentsOfURL_usedEncoding_error_ =
    objc.registerName("stringWithContentsOfURL:usedEncoding:error:");
late final _sel_stringWithContentsOfFile_usedEncoding_error_ =
    objc.registerName("stringWithContentsOfFile:usedEncoding:error:");

/// NSStringExtensionMethods
extension NSStringExtensionMethods on objc.NSString {
  /// substringFromIndex:
  objc.NSString substringFromIndex_(DartNSUInteger from) {
    final _ret =
        _objc_msgSend_14hpxwa(this.ref.pointer, _sel_substringFromIndex_, from);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// substringToIndex:
  objc.NSString substringToIndex_(DartNSUInteger to) {
    final _ret =
        _objc_msgSend_14hpxwa(this.ref.pointer, _sel_substringToIndex_, to);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// substringWithRange:
  objc.NSString substringWithRange_(NSRange range) {
    final _ret = _objc_msgSend_1k1o1s7(
        this.ref.pointer, _sel_substringWithRange_, range);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// getCharacters:range:
  void getCharacters_range_(ffi.Pointer<unichar> buffer, NSRange range) {
    _objc_msgSend_898fog(
        this.ref.pointer, _sel_getCharacters_range_, buffer, range);
  }

  /// compare:
  objc.NSComparisonResult compare_(objc.NSString string) {
    final _ret = _objc_msgSend_1ym6zyw(
        this.ref.pointer, _sel_compare_, string.ref.pointer);
    return objc.NSComparisonResult.fromValue(_ret);
  }

  /// compare:options:
  objc.NSComparisonResult compare_options_(
      objc.NSString string, objc.NSStringCompareOptions mask) {
    final _ret = _objc_msgSend_pg1fnv(this.ref.pointer, _sel_compare_options_,
        string.ref.pointer, mask.value);
    return objc.NSComparisonResult.fromValue(_ret);
  }

  /// compare:options:range:
  objc.NSComparisonResult compare_options_range_(objc.NSString string,
      objc.NSStringCompareOptions mask, NSRange rangeOfReceiverToCompare) {
    final _ret = _objc_msgSend_xrqic1(
        this.ref.pointer,
        _sel_compare_options_range_,
        string.ref.pointer,
        mask.value,
        rangeOfReceiverToCompare);
    return objc.NSComparisonResult.fromValue(_ret);
  }

  /// compare:options:range:locale:
  objc.NSComparisonResult compare_options_range_locale_(
      objc.NSString string,
      objc.NSStringCompareOptions mask,
      NSRange rangeOfReceiverToCompare,
      objc.ObjCObjectBase? locale) {
    final _ret = _objc_msgSend_1895u4n(
        this.ref.pointer,
        _sel_compare_options_range_locale_,
        string.ref.pointer,
        mask.value,
        rangeOfReceiverToCompare,
        locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSComparisonResult.fromValue(_ret);
  }

  /// caseInsensitiveCompare:
  objc.NSComparisonResult caseInsensitiveCompare_(objc.NSString string) {
    final _ret = _objc_msgSend_1ym6zyw(
        this.ref.pointer, _sel_caseInsensitiveCompare_, string.ref.pointer);
    return objc.NSComparisonResult.fromValue(_ret);
  }

  /// localizedCompare:
  objc.NSComparisonResult localizedCompare_(objc.NSString string) {
    final _ret = _objc_msgSend_1ym6zyw(
        this.ref.pointer, _sel_localizedCompare_, string.ref.pointer);
    return objc.NSComparisonResult.fromValue(_ret);
  }

  /// localizedCaseInsensitiveCompare:
  objc.NSComparisonResult localizedCaseInsensitiveCompare_(
      objc.NSString string) {
    final _ret = _objc_msgSend_1ym6zyw(this.ref.pointer,
        _sel_localizedCaseInsensitiveCompare_, string.ref.pointer);
    return objc.NSComparisonResult.fromValue(_ret);
  }

  /// localizedStandardCompare:
  objc.NSComparisonResult localizedStandardCompare_(objc.NSString string) {
    final _ret = _objc_msgSend_1ym6zyw(
        this.ref.pointer, _sel_localizedStandardCompare_, string.ref.pointer);
    return objc.NSComparisonResult.fromValue(_ret);
  }

  /// isEqualToString:
  bool isEqualToString_(objc.NSString aString) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_isEqualToString_, aString.ref.pointer);
  }

  /// hasPrefix:
  bool hasPrefix_(objc.NSString str) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_hasPrefix_, str.ref.pointer);
  }

  /// hasSuffix:
  bool hasSuffix_(objc.NSString str) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_hasSuffix_, str.ref.pointer);
  }

  /// commonPrefixWithString:options:
  objc.NSString commonPrefixWithString_options_(
      objc.NSString str, objc.NSStringCompareOptions mask) {
    final _ret = _objc_msgSend_diypgk(this.ref.pointer,
        _sel_commonPrefixWithString_options_, str.ref.pointer, mask.value);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// containsString:
  bool containsString_(objc.NSString str) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_containsString_, str.ref.pointer);
  }

  /// localizedCaseInsensitiveContainsString:
  bool localizedCaseInsensitiveContainsString_(objc.NSString str) {
    return _objc_msgSend_19nvye5(this.ref.pointer,
        _sel_localizedCaseInsensitiveContainsString_, str.ref.pointer);
  }

  /// localizedStandardContainsString:
  bool localizedStandardContainsString_(objc.NSString str) {
    return _objc_msgSend_19nvye5(this.ref.pointer,
        _sel_localizedStandardContainsString_, str.ref.pointer);
  }

  /// localizedStandardRangeOfString:
  NSRange localizedStandardRangeOfString_(objc.NSString str) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_182fzonStret(_ptr, this.ref.pointer,
            _sel_localizedStandardRangeOfString_, str.ref.pointer)
        : _ptr.ref = _objc_msgSend_182fzon(this.ref.pointer,
            _sel_localizedStandardRangeOfString_, str.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// rangeOfString:
  NSRange rangeOfString_(objc.NSString searchString) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_182fzonStret(_ptr, this.ref.pointer,
            _sel_rangeOfString_, searchString.ref.pointer)
        : _ptr.ref = _objc_msgSend_182fzon(
            this.ref.pointer, _sel_rangeOfString_, searchString.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// rangeOfString:options:
  NSRange rangeOfString_options_(
      objc.NSString searchString, objc.NSStringCompareOptions mask) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_102xxo4Stret(_ptr, this.ref.pointer,
            _sel_rangeOfString_options_, searchString.ref.pointer, mask.value)
        : _ptr.ref = _objc_msgSend_102xxo4(this.ref.pointer,
            _sel_rangeOfString_options_, searchString.ref.pointer, mask.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// rangeOfString:options:range:
  NSRange rangeOfString_options_range_(objc.NSString searchString,
      objc.NSStringCompareOptions mask, NSRange rangeOfReceiverToSearch) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1nmlvqcStret(
            _ptr,
            this.ref.pointer,
            _sel_rangeOfString_options_range_,
            searchString.ref.pointer,
            mask.value,
            rangeOfReceiverToSearch)
        : _ptr.ref = _objc_msgSend_1nmlvqc(
            this.ref.pointer,
            _sel_rangeOfString_options_range_,
            searchString.ref.pointer,
            mask.value,
            rangeOfReceiverToSearch);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// rangeOfString:options:range:locale:
  NSRange rangeOfString_options_range_locale_(
      objc.NSString searchString,
      objc.NSStringCompareOptions mask,
      NSRange rangeOfReceiverToSearch,
      objc.NSLocale? locale) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_gg0462Stret(
            _ptr,
            this.ref.pointer,
            _sel_rangeOfString_options_range_locale_,
            searchString.ref.pointer,
            mask.value,
            rangeOfReceiverToSearch,
            locale?.ref.pointer ?? ffi.nullptr)
        : _ptr.ref = _objc_msgSend_gg0462(
            this.ref.pointer,
            _sel_rangeOfString_options_range_locale_,
            searchString.ref.pointer,
            mask.value,
            rangeOfReceiverToSearch,
            locale?.ref.pointer ?? ffi.nullptr);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// rangeOfCharacterFromSet:
  NSRange rangeOfCharacterFromSet_(objc.NSCharacterSet searchSet) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_182fzonStret(_ptr, this.ref.pointer,
            _sel_rangeOfCharacterFromSet_, searchSet.ref.pointer)
        : _ptr.ref = _objc_msgSend_182fzon(this.ref.pointer,
            _sel_rangeOfCharacterFromSet_, searchSet.ref.pointer);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// rangeOfCharacterFromSet:options:
  NSRange rangeOfCharacterFromSet_options_(
      objc.NSCharacterSet searchSet, objc.NSStringCompareOptions mask) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_102xxo4Stret(
            _ptr,
            this.ref.pointer,
            _sel_rangeOfCharacterFromSet_options_,
            searchSet.ref.pointer,
            mask.value)
        : _ptr.ref = _objc_msgSend_102xxo4(
            this.ref.pointer,
            _sel_rangeOfCharacterFromSet_options_,
            searchSet.ref.pointer,
            mask.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// rangeOfCharacterFromSet:options:range:
  NSRange rangeOfCharacterFromSet_options_range_(objc.NSCharacterSet searchSet,
      objc.NSStringCompareOptions mask, NSRange rangeOfReceiverToSearch) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1nmlvqcStret(
            _ptr,
            this.ref.pointer,
            _sel_rangeOfCharacterFromSet_options_range_,
            searchSet.ref.pointer,
            mask.value,
            rangeOfReceiverToSearch)
        : _ptr.ref = _objc_msgSend_1nmlvqc(
            this.ref.pointer,
            _sel_rangeOfCharacterFromSet_options_range_,
            searchSet.ref.pointer,
            mask.value,
            rangeOfReceiverToSearch);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// rangeOfComposedCharacterSequenceAtIndex:
  NSRange rangeOfComposedCharacterSequenceAtIndex_(DartNSUInteger index) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_d3i1uyStret(_ptr, this.ref.pointer,
            _sel_rangeOfComposedCharacterSequenceAtIndex_, index)
        : _ptr.ref = _objc_msgSend_d3i1uy(this.ref.pointer,
            _sel_rangeOfComposedCharacterSequenceAtIndex_, index);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// rangeOfComposedCharacterSequencesForRange:
  NSRange rangeOfComposedCharacterSequencesForRange_(NSRange range) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_uimyc7Stret(_ptr, this.ref.pointer,
            _sel_rangeOfComposedCharacterSequencesForRange_, range)
        : _ptr.ref = _objc_msgSend_uimyc7(this.ref.pointer,
            _sel_rangeOfComposedCharacterSequencesForRange_, range);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// stringByAppendingString:
  objc.NSString stringByAppendingString_(objc.NSString aString) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_stringByAppendingString_, aString.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByAppendingFormat:
  objc.NSString stringByAppendingFormat_(objc.NSString format) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_stringByAppendingFormat_, format.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// doubleValue
  double get doubleValue {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_doubleValue)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_doubleValue);
  }

  /// floatValue
  double get floatValue {
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(this.ref.pointer, _sel_floatValue)
        : _objc_msgSend_2cgrxl(this.ref.pointer, _sel_floatValue);
  }

  /// intValue
  int get intValue {
    return _objc_msgSend_13yqbb6(this.ref.pointer, _sel_intValue);
  }

  /// integerValue
  DartNSInteger get integerValue {
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_integerValue);
  }

  /// longLongValue
  int get longLongValue {
    return _objc_msgSend_1k101e3(this.ref.pointer, _sel_longLongValue);
  }

  /// boolValue
  bool get boolValue {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_boolValue);
  }

  /// uppercaseString
  objc.NSString get uppercaseString {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_uppercaseString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// lowercaseString
  objc.NSString get lowercaseString {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lowercaseString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// capitalizedString
  objc.NSString get capitalizedString {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_capitalizedString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedUppercaseString
  objc.NSString get localizedUppercaseString {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_localizedUppercaseString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedLowercaseString
  objc.NSString get localizedLowercaseString {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_localizedLowercaseString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedCapitalizedString
  objc.NSString get localizedCapitalizedString {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_localizedCapitalizedString);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// uppercaseStringWithLocale:
  objc.NSString uppercaseStringWithLocale_(objc.NSLocale? locale) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_uppercaseStringWithLocale_, locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// lowercaseStringWithLocale:
  objc.NSString lowercaseStringWithLocale_(objc.NSLocale? locale) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_lowercaseStringWithLocale_, locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// capitalizedStringWithLocale:
  objc.NSString capitalizedStringWithLocale_(objc.NSLocale? locale) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_capitalizedStringWithLocale_, locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// getLineStart:end:contentsEnd:forRange:
  void getLineStart_end_contentsEnd_forRange_(
      ffi.Pointer<NSUInteger> startPtr,
      ffi.Pointer<NSUInteger> lineEndPtr,
      ffi.Pointer<NSUInteger> contentsEndPtr,
      NSRange range) {
    _objc_msgSend_ourvf2(
        this.ref.pointer,
        _sel_getLineStart_end_contentsEnd_forRange_,
        startPtr,
        lineEndPtr,
        contentsEndPtr,
        range);
  }

  /// lineRangeForRange:
  NSRange lineRangeForRange_(NSRange range) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_uimyc7Stret(
            _ptr, this.ref.pointer, _sel_lineRangeForRange_, range)
        : _ptr.ref = _objc_msgSend_uimyc7(
            this.ref.pointer, _sel_lineRangeForRange_, range);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// getParagraphStart:end:contentsEnd:forRange:
  void getParagraphStart_end_contentsEnd_forRange_(
      ffi.Pointer<NSUInteger> startPtr,
      ffi.Pointer<NSUInteger> parEndPtr,
      ffi.Pointer<NSUInteger> contentsEndPtr,
      NSRange range) {
    _objc_msgSend_ourvf2(
        this.ref.pointer,
        _sel_getParagraphStart_end_contentsEnd_forRange_,
        startPtr,
        parEndPtr,
        contentsEndPtr,
        range);
  }

  /// paragraphRangeForRange:
  NSRange paragraphRangeForRange_(NSRange range) {
    final _ptr = pkg_ffi.calloc<NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_uimyc7Stret(
            _ptr, this.ref.pointer, _sel_paragraphRangeForRange_, range)
        : _ptr.ref = _objc_msgSend_uimyc7(
            this.ref.pointer, _sel_paragraphRangeForRange_, range);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<NSRange>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<NSRange>(_finalizable);
  }

  /// enumerateSubstringsInRange:options:usingBlock:
  void enumerateSubstringsInRange_options_usingBlock_(
      NSRange range,
      objc.NSStringEnumerationOptions opts,
      objc.ObjCBlock<
              ffi.Void Function(objc.NSString?, objc.NSRange, objc.NSRange,
                  ffi.Pointer<ffi.Bool>)>
          block) {
    _objc_msgSend_14ew8zr(
        this.ref.pointer,
        _sel_enumerateSubstringsInRange_options_usingBlock_,
        range,
        opts.value,
        block.ref.pointer);
  }

  /// enumerateLinesUsingBlock:
  void enumerateLinesUsingBlock_(
      objc.ObjCBlock<ffi.Void Function(objc.NSString, ffi.Pointer<ffi.Bool>)>
          block) {
    _objc_msgSend_f167m6(
        this.ref.pointer, _sel_enumerateLinesUsingBlock_, block.ref.pointer);
  }

  /// UTF8String
  ffi.Pointer<ffi.Char> get UTF8String {
    return _objc_msgSend_1fuqfwb(this.ref.pointer, _sel_UTF8String);
  }

  /// fastestEncoding
  DartNSUInteger get fastestEncoding {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_fastestEncoding);
  }

  /// smallestEncoding
  DartNSUInteger get smallestEncoding {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_smallestEncoding);
  }

  /// dataUsingEncoding:allowLossyConversion:
  objc.NSData? dataUsingEncoding_allowLossyConversion_(
      DartNSUInteger encoding, bool lossy) {
    final _ret = _objc_msgSend_hiwitm(this.ref.pointer,
        _sel_dataUsingEncoding_allowLossyConversion_, encoding, lossy);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// dataUsingEncoding:
  objc.NSData? dataUsingEncoding_(DartNSUInteger encoding) {
    final _ret = _objc_msgSend_14hpxwa(
        this.ref.pointer, _sel_dataUsingEncoding_, encoding);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// canBeConvertedToEncoding:
  bool canBeConvertedToEncoding_(DartNSUInteger encoding) {
    return _objc_msgSend_6peh6o(
        this.ref.pointer, _sel_canBeConvertedToEncoding_, encoding);
  }

  /// cStringUsingEncoding:
  ffi.Pointer<ffi.Char> cStringUsingEncoding_(DartNSUInteger encoding) {
    return _objc_msgSend_1jtxufi(
        this.ref.pointer, _sel_cStringUsingEncoding_, encoding);
  }

  /// getCString:maxLength:encoding:
  bool getCString_maxLength_encoding_(ffi.Pointer<ffi.Char> buffer,
      DartNSUInteger maxBufferCount, DartNSUInteger encoding) {
    return _objc_msgSend_1lv8yz3(this.ref.pointer,
        _sel_getCString_maxLength_encoding_, buffer, maxBufferCount, encoding);
  }

  /// getBytes:maxLength:usedLength:encoding:options:range:remainingRange:
  bool getBytes_maxLength_usedLength_encoding_options_range_remainingRange_(
      ffi.Pointer<ffi.Void> buffer,
      DartNSUInteger maxBufferCount,
      ffi.Pointer<NSUInteger> usedBufferCount,
      DartNSUInteger encoding,
      objc.NSStringEncodingConversionOptions options,
      NSRange range,
      NSRangePointer leftover) {
    return _objc_msgSend_i30zh3(
        this.ref.pointer,
        _sel_getBytes_maxLength_usedLength_encoding_options_range_remainingRange_,
        buffer,
        maxBufferCount,
        usedBufferCount,
        encoding,
        options.value,
        range,
        leftover);
  }

  /// maximumLengthOfBytesUsingEncoding:
  DartNSUInteger maximumLengthOfBytesUsingEncoding_(DartNSUInteger enc) {
    return _objc_msgSend_12py2ux(
        this.ref.pointer, _sel_maximumLengthOfBytesUsingEncoding_, enc);
  }

  /// lengthOfBytesUsingEncoding:
  DartNSUInteger lengthOfBytesUsingEncoding_(DartNSUInteger enc) {
    return _objc_msgSend_12py2ux(
        this.ref.pointer, _sel_lengthOfBytesUsingEncoding_, enc);
  }

  /// availableStringEncodings
  static ffi.Pointer<NSStringEncoding> getAvailableStringEncodings() {
    return _objc_msgSend_1h2q612(
        _class_NSString, _sel_availableStringEncodings);
  }

  /// localizedNameOfStringEncoding:
  static objc.NSString localizedNameOfStringEncoding_(DartNSUInteger encoding) {
    final _ret = _objc_msgSend_14hpxwa(
        _class_NSString, _sel_localizedNameOfStringEncoding_, encoding);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// defaultCStringEncoding
  static DartNSUInteger getDefaultCStringEncoding() {
    return _objc_msgSend_xw2lbc(_class_NSString, _sel_defaultCStringEncoding);
  }

  /// decomposedStringWithCanonicalMapping
  objc.NSString get decomposedStringWithCanonicalMapping {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_decomposedStringWithCanonicalMapping);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// precomposedStringWithCanonicalMapping
  objc.NSString get precomposedStringWithCanonicalMapping {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_precomposedStringWithCanonicalMapping);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// decomposedStringWithCompatibilityMapping
  objc.NSString get decomposedStringWithCompatibilityMapping {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_decomposedStringWithCompatibilityMapping);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// precomposedStringWithCompatibilityMapping
  objc.NSString get precomposedStringWithCompatibilityMapping {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_precomposedStringWithCompatibilityMapping);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// componentsSeparatedByString:
  objc.NSArray componentsSeparatedByString_(objc.NSString separator) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_componentsSeparatedByString_, separator.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// componentsSeparatedByCharactersInSet:
  objc.NSArray componentsSeparatedByCharactersInSet_(
      objc.NSCharacterSet separator) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_componentsSeparatedByCharactersInSet_, separator.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByTrimmingCharactersInSet:
  objc.NSString stringByTrimmingCharactersInSet_(objc.NSCharacterSet set) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_stringByTrimmingCharactersInSet_, set.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByPaddingToLength:withString:startingAtIndex:
  objc.NSString stringByPaddingToLength_withString_startingAtIndex_(
      DartNSUInteger newLength,
      objc.NSString padString,
      DartNSUInteger padIndex) {
    final _ret = _objc_msgSend_1tfztp(
        this.ref.pointer,
        _sel_stringByPaddingToLength_withString_startingAtIndex_,
        newLength,
        padString.ref.pointer,
        padIndex);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByFoldingWithOptions:locale:
  objc.NSString stringByFoldingWithOptions_locale_(
      objc.NSStringCompareOptions options, objc.NSLocale? locale) {
    final _ret = _objc_msgSend_11cbyu0(
        this.ref.pointer,
        _sel_stringByFoldingWithOptions_locale_,
        options.value,
        locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByReplacingOccurrencesOfString:withString:options:range:
  objc.NSString stringByReplacingOccurrencesOfString_withString_options_range_(
      objc.NSString target,
      objc.NSString replacement,
      objc.NSStringCompareOptions options,
      NSRange searchRange) {
    final _ret = _objc_msgSend_2u4jm6(
        this.ref.pointer,
        _sel_stringByReplacingOccurrencesOfString_withString_options_range_,
        target.ref.pointer,
        replacement.ref.pointer,
        options.value,
        searchRange);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByReplacingOccurrencesOfString:withString:
  objc.NSString stringByReplacingOccurrencesOfString_withString_(
      objc.NSString target, objc.NSString replacement) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_stringByReplacingOccurrencesOfString_withString_,
        target.ref.pointer,
        replacement.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByReplacingCharactersInRange:withString:
  objc.NSString stringByReplacingCharactersInRange_withString_(
      NSRange range, objc.NSString replacement) {
    final _ret = _objc_msgSend_bstjp9(
        this.ref.pointer,
        _sel_stringByReplacingCharactersInRange_withString_,
        range,
        replacement.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByApplyingTransform:reverse:
  objc.NSString? stringByApplyingTransform_reverse_(
      DartNSStringTransform transform, bool reverse) {
    final _ret = _objc_msgSend_17amj0z(
        this.ref.pointer,
        _sel_stringByApplyingTransform_reverse_,
        transform.ref.pointer,
        reverse);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// writeToURL:atomically:encoding:error:
  bool writeToURL_atomically_encoding_error_(
      objc.NSURL url,
      bool useAuxiliaryFile,
      DartNSUInteger enc,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    return _objc_msgSend_dv3z6r(
        this.ref.pointer,
        _sel_writeToURL_atomically_encoding_error_,
        url.ref.pointer,
        useAuxiliaryFile,
        enc,
        error);
  }

  /// writeToFile:atomically:encoding:error:
  bool writeToFile_atomically_encoding_error_(
      objc.NSString path,
      bool useAuxiliaryFile,
      DartNSUInteger enc,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    return _objc_msgSend_dv3z6r(
        this.ref.pointer,
        _sel_writeToFile_atomically_encoding_error_,
        path.ref.pointer,
        useAuxiliaryFile,
        enc,
        error);
  }

  /// description
  objc.NSString get description {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_description);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// hash
  DartNSUInteger get hash {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_hash);
  }

  /// initWithCharactersNoCopy:length:freeWhenDone:
  objc.NSString initWithCharactersNoCopy_length_freeWhenDone_(
      ffi.Pointer<unichar> characters, DartNSUInteger length, bool freeBuffer) {
    final _ret = _objc_msgSend_lh0jh5(
        this.ref.retainAndReturnPointer(),
        _sel_initWithCharactersNoCopy_length_freeWhenDone_,
        characters,
        length,
        freeBuffer);
    return objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCharactersNoCopy:length:deallocator:
  objc.NSString initWithCharactersNoCopy_length_deallocator_(
      ffi.Pointer<unichar> chars,
      DartNSUInteger len,
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<unichar>, ffi.UnsignedLong)>?
          deallocator) {
    final _ret = _objc_msgSend_talwei(
        this.ref.retainAndReturnPointer(),
        _sel_initWithCharactersNoCopy_length_deallocator_,
        chars,
        len,
        deallocator?.ref.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCharacters:length:
  objc.NSString initWithCharacters_length_(
      ffi.Pointer<unichar> characters, DartNSUInteger length) {
    final _ret = _objc_msgSend_9x4k8x(this.ref.retainAndReturnPointer(),
        _sel_initWithCharacters_length_, characters, length);
    return objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithUTF8String:
  objc.NSString? initWithUTF8String_(
      ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final _ret = _objc_msgSend_56zxyn(this.ref.retainAndReturnPointer(),
        _sel_initWithUTF8String_, nullTerminatedCString);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithString:
  objc.NSString initWithString_(objc.NSString aString) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithString_, aString.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithFormat:
  objc.NSString initWithFormat_(objc.NSString format) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithFormat_, format.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithFormat:locale:
  objc.NSString initWithFormat_locale_(
      objc.NSString format, objc.ObjCObjectBase? locale) {
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithFormat_locale_,
        format.ref.pointer,
        locale?.ref.pointer ?? ffi.nullptr);
    return objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithValidatedFormat:validFormatSpecifiers:error:
  objc.NSString? initWithValidatedFormat_validFormatSpecifiers_error_(
      objc.NSString format,
      objc.NSString validFormatSpecifiers,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1pnyuds(
        this.ref.retainAndReturnPointer(),
        _sel_initWithValidatedFormat_validFormatSpecifiers_error_,
        format.ref.pointer,
        validFormatSpecifiers.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithValidatedFormat:validFormatSpecifiers:locale:error:
  objc.NSString? initWithValidatedFormat_validFormatSpecifiers_locale_error_(
      objc.NSString format,
      objc.NSString validFormatSpecifiers,
      objc.ObjCObjectBase? locale,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1k0ezzm(
        this.ref.retainAndReturnPointer(),
        _sel_initWithValidatedFormat_validFormatSpecifiers_locale_error_,
        format.ref.pointer,
        validFormatSpecifiers.ref.pointer,
        locale?.ref.pointer ?? ffi.nullptr,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithData:encoding:
  objc.NSString? initWithData_encoding_(
      objc.NSData data, DartNSUInteger encoding) {
    final _ret = _objc_msgSend_1k4kd9s(this.ref.retainAndReturnPointer(),
        _sel_initWithData_encoding_, data.ref.pointer, encoding);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithBytes:length:encoding:
  objc.NSString? initWithBytes_length_encoding_(ffi.Pointer<ffi.Void> bytes,
      DartNSUInteger len, DartNSUInteger encoding) {
    final _ret = _objc_msgSend_9b3h4v(this.ref.retainAndReturnPointer(),
        _sel_initWithBytes_length_encoding_, bytes, len, encoding);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:encoding:freeWhenDone:
  objc.NSString? initWithBytesNoCopy_length_encoding_freeWhenDone_(
      ffi.Pointer<ffi.Void> bytes,
      DartNSUInteger len,
      DartNSUInteger encoding,
      bool freeBuffer) {
    final _ret = _objc_msgSend_k4j8m3(
        this.ref.retainAndReturnPointer(),
        _sel_initWithBytesNoCopy_length_encoding_freeWhenDone_,
        bytes,
        len,
        encoding,
        freeBuffer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithBytesNoCopy:length:encoding:deallocator:
  objc.NSString? initWithBytesNoCopy_length_encoding_deallocator_(
      ffi.Pointer<ffi.Void> bytes,
      DartNSUInteger len,
      DartNSUInteger encoding,
      objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.UnsignedLong)>?
          deallocator) {
    final _ret = _objc_msgSend_1lbgrac(
        this.ref.retainAndReturnPointer(),
        _sel_initWithBytesNoCopy_length_encoding_deallocator_,
        bytes,
        len,
        encoding,
        deallocator?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// string
  static objc.NSString string() {
    final _ret = _objc_msgSend_151sglz(_class_NSString, _sel_string);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringWithString:
  static objc.NSString stringWithString_(objc.NSString string) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSString, _sel_stringWithString_, string.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringWithCharacters:length:
  static objc.NSString stringWithCharacters_length_(
      ffi.Pointer<unichar> characters, DartNSUInteger length) {
    final _ret = _objc_msgSend_9x4k8x(
        _class_NSString, _sel_stringWithCharacters_length_, characters, length);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringWithUTF8String:
  static objc.NSString? stringWithUTF8String_(
      ffi.Pointer<ffi.Char> nullTerminatedCString) {
    final _ret = _objc_msgSend_56zxyn(
        _class_NSString, _sel_stringWithUTF8String_, nullTerminatedCString);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringWithFormat:
  static objc.NSString stringWithFormat_(objc.NSString format) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSString, _sel_stringWithFormat_, format.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedStringWithFormat:
  static objc.NSString localizedStringWithFormat_(objc.NSString format) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSString, _sel_localizedStringWithFormat_, format.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringWithValidatedFormat:validFormatSpecifiers:error:
  static objc.NSString? stringWithValidatedFormat_validFormatSpecifiers_error_(
      objc.NSString format,
      objc.NSString validFormatSpecifiers,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1pnyuds(
        _class_NSString,
        _sel_stringWithValidatedFormat_validFormatSpecifiers_error_,
        format.ref.pointer,
        validFormatSpecifiers.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedStringWithValidatedFormat:validFormatSpecifiers:error:
  static objc.NSString?
      localizedStringWithValidatedFormat_validFormatSpecifiers_error_(
          objc.NSString format,
          objc.NSString validFormatSpecifiers,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1pnyuds(
        _class_NSString,
        _sel_localizedStringWithValidatedFormat_validFormatSpecifiers_error_,
        format.ref.pointer,
        validFormatSpecifiers.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCString:encoding:
  objc.NSString? initWithCString_encoding_(
      ffi.Pointer<ffi.Char> nullTerminatedCString, DartNSUInteger encoding) {
    final _ret = _objc_msgSend_erqryg(this.ref.retainAndReturnPointer(),
        _sel_initWithCString_encoding_, nullTerminatedCString, encoding);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// stringWithCString:encoding:
  static objc.NSString? stringWithCString_encoding_(
      ffi.Pointer<ffi.Char> cString, DartNSUInteger enc) {
    final _ret = _objc_msgSend_erqryg(
        _class_NSString, _sel_stringWithCString_encoding_, cString, enc);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithContentsOfURL:encoding:error:
  objc.NSString? initWithContentsOfURL_encoding_error_(objc.NSURL url,
      DartNSUInteger enc, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1nomli1(
        this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_encoding_error_,
        url.ref.pointer,
        enc,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:encoding:error:
  objc.NSString? initWithContentsOfFile_encoding_error_(objc.NSString path,
      DartNSUInteger enc, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1nomli1(
        this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfFile_encoding_error_,
        path.ref.pointer,
        enc,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// stringWithContentsOfURL:encoding:error:
  static objc.NSString? stringWithContentsOfURL_encoding_error_(objc.NSURL url,
      DartNSUInteger enc, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1nomli1(
        _class_NSString,
        _sel_stringWithContentsOfURL_encoding_error_,
        url.ref.pointer,
        enc,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringWithContentsOfFile:encoding:error:
  static objc.NSString? stringWithContentsOfFile_encoding_error_(
      objc.NSString path,
      DartNSUInteger enc,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1nomli1(
        _class_NSString,
        _sel_stringWithContentsOfFile_encoding_error_,
        path.ref.pointer,
        enc,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithContentsOfURL:usedEncoding:error:
  objc.NSString? initWithContentsOfURL_usedEncoding_error_(
      objc.NSURL url,
      ffi.Pointer<NSStringEncoding> enc,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1alewu7(
        this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_usedEncoding_error_,
        url.ref.pointer,
        enc,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:usedEncoding:error:
  objc.NSString? initWithContentsOfFile_usedEncoding_error_(
      objc.NSString path,
      ffi.Pointer<NSStringEncoding> enc,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1alewu7(
        this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfFile_usedEncoding_error_,
        path.ref.pointer,
        enc,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: false, release: true);
  }

  /// stringWithContentsOfURL:usedEncoding:error:
  static objc.NSString? stringWithContentsOfURL_usedEncoding_error_(
      objc.NSURL url,
      ffi.Pointer<NSStringEncoding> enc,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1alewu7(
        _class_NSString,
        _sel_stringWithContentsOfURL_usedEncoding_error_,
        url.ref.pointer,
        enc,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringWithContentsOfFile:usedEncoding:error:
  static objc.NSString? stringWithContentsOfFile_usedEncoding_error_(
      objc.NSString path,
      ffi.Pointer<NSStringEncoding> enc,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1alewu7(
        _class_NSString,
        _sel_stringWithContentsOfFile_usedEncoding_error_,
        path.ref.pointer,
        enc,
        error);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

typedef NSStringEncodingDetectionOptionsKey = ffi.Pointer<objc.ObjCObject>;
typedef DartNSStringEncodingDetectionOptionsKey = objc.NSString;
late final _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_ =
    objc.registerName(
        "stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:");
final _objc_msgSend_1q2ox4r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<ffi.Bool>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<ffi.Bool>)>();

/// NSStringEncodingDetection
extension NSStringEncodingDetection on objc.NSString {
  /// stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:
  static DartNSUInteger
      stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_(
          objc.NSData data,
          objc.NSDictionary? opts,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> string,
          ffi.Pointer<ffi.Bool> usedLossyConversion) {
    return _objc_msgSend_1q2ox4r(
        _class_NSString,
        _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_,
        data.ref.pointer,
        opts?.ref.pointer ?? ffi.nullptr,
        string,
        usedLossyConversion);
  }
}

late final _sel_readableTypeIdentifiersForItemProvider =
    objc.registerName("readableTypeIdentifiersForItemProvider");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSArray_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_NSArray_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSArray_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSArray_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSArray_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.NSArray Function(ffi.Pointer<ffi.Void>) fn) =>
          objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSArray_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease()),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid_CallExtension
    on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) => objc.NSArray.castFromPointer(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_objectWithItemProviderData_typeIdentifier_error_ =
    objc.registerName("objectWithItemProviderData:typeIdentifier:error:");
instancetype
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
        block.ref.target
                .cast<
                    ffi.NativeFunction<
                        instancetype Function(
                            ffi.Pointer<ffi.Void> arg0,
                            ffi.Pointer<objc.ObjCObject> arg1,
                            ffi.Pointer<objc.ObjCObject> arg2,
                            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>()
                .asFunction<
                    instancetype Function(
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()(
            arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
            _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrTrampoline)
        .cast();
instancetype
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
        (objc.getBlockClosure(block) as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
            _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>,
              objc.NSData,
              objc.NSString,
              ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Pointer<objc.ObjCObject>? Function(
                  ffi.Pointer<ffi.Void>,
                  objc.NSData,
                  objc.NSString,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
              ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>,
                      objc.NSData,
                      objc.NSString,
                      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
              objc.newPointerBlock(_ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>
      fromFunction(Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>) fn) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>(
              objc.newClosureBlock(
                  _ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) =>
                      fn(arg0, objc.NSData.castFromPointer(arg1, retain: true, release: true), objc.NSString.castFromPointer(arg2, retain: true, release: true), arg3)?.ref.retainAndAutorelease() ??
                      ffi.nullptr),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
extension ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError_CallExtension
    on objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSData,
            objc.NSString,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSData arg1, objc.NSString arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>()
              .asFunction<
                  instancetype Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()
              (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke.cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3)>>().asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3),
          retain: true,
          release: true);
}

late final _sel_writableTypeIdentifiersForItemProvider =
    objc.registerName("writableTypeIdentifiersForItemProvider");
late final _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_ =
    objc.registerName(
        "itemProviderVisibilityForRepresentationWithTypeIdentifier:");
final _objc_msgSend_16fy0up = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            NSInteger Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
int _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                NSInteger Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            int Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
                NSInteger Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrTrampoline,
            0)
        .cast();
int _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as int Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureCallable =
    ffi.Pointer.fromFunction<
                NSInteger Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureTrampoline,
            0)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSInteger Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
      NSInteger Function(ffi.Pointer<ffi.Void>, objc.NSString)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<NSInteger Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          pointer,
          retain: retain,
          release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSInteger Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          NSInteger Function(ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<NSInteger Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
              objc.newPointerBlock(_ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSInteger Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(
          objc.NSItemProviderRepresentationVisibility Function(
                  ffi.Pointer<ffi.Void>, objc.NSString)
              fn) =>
      objc.ObjCBlock<NSInteger Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          objc.newClosureBlock(
              _ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true))
                      .value),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<NSInteger Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString_CallExtension
    on objc
    .ObjCBlock<NSInteger Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  objc.NSItemProviderRepresentationVisibility call(
          ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      objc.NSItemProviderRepresentationVisibility.fromValue(ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      NSInteger Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer, arg0, arg1.ref.pointer));
}

void _ObjCBlock_ffiVoid_NSData_NSError_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_NSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_NSError_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSError_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_NSData_NSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSData_NSError_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_NSData_NSError_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSError_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_NSError_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSError_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSData_NSError_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_NSData_NSError_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunction(
          void Function(objc.NSData?, objc.NSError?) fn) =>
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSData_NSError_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
                  arg0.address == 0
                      ? null
                      : objc.NSData.castFromPointer(arg0,
                          retain: true, release: true),
                  arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      listener(void Function(objc.NSData?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSError_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
      blocking(void Function(objc.NSData?, objc.NSError?) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSData_NSError_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1) =>
            fn(
                arg0.address == 0
                    ? null
                    : objc.NSData.castFromPointer(arg0,
                        retain: false, release: true),
                arg1.address == 0
                    ? null
                    : objc.NSError.castFromPointer(arg1,
                        retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_pfv6jd, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
        wrapper,
        retain: false,
        release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError_CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>)>()(ref.pointer,
      arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ =
    objc.registerName(
        "loadDataWithTypeIdentifier:forItemProviderCompletionHandler:");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1, arg2);
ffi.Pointer<ffi.Void>
    _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
              objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
                      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
              objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>> ptr) =>
          objc.ObjCBlock<
                  NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
                      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(
              objc.newPointerBlock(_ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>
      fromFunction(NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>) fn) =>
          objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
                      fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true), ObjCBlock_ffiVoid_NSData_NSError.castFromPointer(arg2, retain: true, release: true))
                          ?.ref
                          .retainAndAutorelease() ??
                      ffi.nullptr),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError_CallExtension
    on objc.ObjCBlock<
        NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString,
            objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)> {
  NSProgress? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> arg2) =>
      ref.pointer.ref.invoke
                  .cast<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<objc.ObjCBlockImpl> block,
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1,
                              ffi.Pointer<objc.ObjCBlockImpl> arg2)>>()
                  .asFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<objc.ObjCObject>,
                          ffi.Pointer<objc.ObjCBlockImpl>)>()
                  (ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
                  .address ==
              0
          ? null
          : NSProgress.castFromPointer(
              ref.pointer.ref.invoke.cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2)>>().asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCBlockImpl>)>()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
              retain: true,
              release: true);
}

/// NSItemProvider
extension NSItemProvider on objc.NSString {
  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSString, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// objectWithItemProviderData:typeIdentifier:error:
  static objc.NSString? objectWithItemProviderData_typeIdentifier_error_(
      objc.NSData data,
      objc.NSString typeIdentifier,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> outError) {
    final _ret = _objc_msgSend_1pnyuds(
        _class_NSString,
        _sel_objectWithItemProviderData_typeIdentifier_error_,
        data.ref.pointer,
        typeIdentifier.ref.pointer,
        outError);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSString, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider1 {
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException(
          'NSString', 'writableTypeIdentifiersForItemProvider');
    }
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier_(
          objc.NSString typeIdentifier) {
    if (!objc.respondsToSelector(_class_NSString,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSString',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_16fy0up(
        _class_NSString,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier_1(
          objc.NSString typeIdentifier) {
    if (!objc.respondsToSelector(this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSString',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_16fy0up(
        this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  NSProgress? loadDataWithTypeIdentifier_forItemProviderCompletionHandler_(
      objc.NSString typeIdentifier,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
        typeIdentifier.ref.pointer,
        completionHandler.ref.pointer);
    return _ret.address == 0
        ? null
        : NSProgress.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_NSMutableString = objc.getClass("NSMutableString");
late final _sel_insertString_atIndex_ =
    objc.registerName("insertString:atIndex:");
late final _sel_deleteCharactersInRange_ =
    objc.registerName("deleteCharactersInRange:");
late final _sel_appendString_ = objc.registerName("appendString:");
late final _sel_appendFormat_ = objc.registerName("appendFormat:");
late final _sel_setString_ = objc.registerName("setString:");
late final _sel_replaceOccurrencesOfString_withString_options_range_ =
    objc.registerName("replaceOccurrencesOfString:withString:options:range:");
final _objc_msgSend_1upeo1d = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                NSUInteger,
                objc.NSRange)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            objc.NSRange)>();
late final _sel_applyTransform_reverse_range_updatedRange_ =
    objc.registerName("applyTransform:reverse:range:updatedRange:");
final _objc_msgSend_zy00wz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Bool,
                objc.NSRange,
                ffi.Pointer<objc.NSRange>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            bool,
            objc.NSRange,
            ffi.Pointer<objc.NSRange>)>();
late final _sel_initWithCapacity_ = objc.registerName("initWithCapacity:");
late final _sel_stringWithCapacity_ = objc.registerName("stringWithCapacity:");

/// NSMutableStringExtensionMethods
extension NSMutableStringExtensionMethods on objc.NSMutableString {
  /// insertString:atIndex:
  void insertString_atIndex_(objc.NSString aString, DartNSUInteger loc) {
    _objc_msgSend_djsa9o(
        this.ref.pointer, _sel_insertString_atIndex_, aString.ref.pointer, loc);
  }

  /// deleteCharactersInRange:
  void deleteCharactersInRange_(NSRange range) {
    _objc_msgSend_1e3pm0z(
        this.ref.pointer, _sel_deleteCharactersInRange_, range);
  }

  /// appendString:
  void appendString_(objc.NSString aString) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_appendString_, aString.ref.pointer);
  }

  /// appendFormat:
  void appendFormat_(objc.NSString format) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_appendFormat_, format.ref.pointer);
  }

  /// setString:
  void setString_(objc.NSString aString) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setString_, aString.ref.pointer);
  }

  /// replaceOccurrencesOfString:withString:options:range:
  DartNSUInteger replaceOccurrencesOfString_withString_options_range_(
      objc.NSString target,
      objc.NSString replacement,
      objc.NSStringCompareOptions options,
      NSRange searchRange) {
    return _objc_msgSend_1upeo1d(
        this.ref.pointer,
        _sel_replaceOccurrencesOfString_withString_options_range_,
        target.ref.pointer,
        replacement.ref.pointer,
        options.value,
        searchRange);
  }

  /// applyTransform:reverse:range:updatedRange:
  bool applyTransform_reverse_range_updatedRange_(
      DartNSStringTransform transform,
      bool reverse,
      NSRange range,
      NSRangePointer resultingRange) {
    return _objc_msgSend_zy00wz(
        this.ref.pointer,
        _sel_applyTransform_reverse_range_updatedRange_,
        transform.ref.pointer,
        reverse,
        range,
        resultingRange);
  }

  /// initWithCapacity:
  objc.NSMutableString initWithCapacity_(DartNSUInteger capacity) {
    final _ret = _objc_msgSend_14hpxwa(
        this.ref.retainAndReturnPointer(), _sel_initWithCapacity_, capacity);
    return objc.NSMutableString.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// stringWithCapacity:
  static objc.NSMutableString stringWithCapacity_(DartNSUInteger capacity) {
    final _ret = _objc_msgSend_14hpxwa(
        _class_NSMutableString, _sel_stringWithCapacity_, capacity);
    return objc.NSMutableString.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_propertyList = objc.registerName("propertyList");
late final _sel_propertyListFromStringsFileFormat =
    objc.registerName("propertyListFromStringsFileFormat");

/// NSExtendedStringPropertyListParsing
extension NSExtendedStringPropertyListParsing on objc.NSString {
  /// propertyList
  objc.ObjCObjectBase propertyList() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_propertyList);
    return objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// propertyListFromStringsFileFormat
  objc.NSDictionary? propertyListFromStringsFileFormat() {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_propertyListFromStringsFileFormat);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_cString = objc.registerName("cString");
late final _sel_lossyCString = objc.registerName("lossyCString");
late final _sel_cStringLength = objc.registerName("cStringLength");
late final _sel_getCString_ = objc.registerName("getCString:");
final _objc_msgSend_1r7ue5f = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>)>();
late final _sel_getCString_maxLength_ =
    objc.registerName("getCString:maxLength:");
final _objc_msgSend_1h3mito = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>, int)>();
late final _sel_getCString_maxLength_range_remainingRange_ =
    objc.registerName("getCString:maxLength:range:remainingRange:");
final _objc_msgSend_3gpdva = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong,
                objc.NSRange,
                ffi.Pointer<objc.NSRange>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Char>,
            int,
            objc.NSRange,
            ffi.Pointer<objc.NSRange>)>();
late final _sel_stringWithContentsOfFile_ =
    objc.registerName("stringWithContentsOfFile:");
late final _sel_stringWithContentsOfURL_ =
    objc.registerName("stringWithContentsOfURL:");
late final _sel_initWithCStringNoCopy_length_freeWhenDone_ =
    objc.registerName("initWithCStringNoCopy:length:freeWhenDone:");
final _objc_msgSend_1ojrli4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Char>,
                ffi.UnsignedLong,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Char>,
            int,
            bool)>();
late final _sel_initWithCString_length_ =
    objc.registerName("initWithCString:length:");
late final _sel_initWithCString_ = objc.registerName("initWithCString:");
late final _sel_stringWithCString_length_ =
    objc.registerName("stringWithCString:length:");
late final _sel_stringWithCString_ = objc.registerName("stringWithCString:");
late final _sel_getCharacters_ = objc.registerName("getCharacters:");
final _objc_msgSend_g3kdhc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.UnsignedShort>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.UnsignedShort>)>();

/// NSStringDeprecated
extension NSStringDeprecated on objc.NSString {
  /// cString
  ffi.Pointer<ffi.Char> cString() {
    return _objc_msgSend_1fuqfwb(this.ref.pointer, _sel_cString);
  }

  /// lossyCString
  ffi.Pointer<ffi.Char> lossyCString() {
    return _objc_msgSend_1fuqfwb(this.ref.pointer, _sel_lossyCString);
  }

  /// cStringLength
  DartNSUInteger cStringLength() {
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_cStringLength);
  }

  /// getCString:
  void getCString_(ffi.Pointer<ffi.Char> bytes) {
    _objc_msgSend_1r7ue5f(this.ref.pointer, _sel_getCString_, bytes);
  }

  /// getCString:maxLength:
  void getCString_maxLength_(
      ffi.Pointer<ffi.Char> bytes, DartNSUInteger maxLength) {
    _objc_msgSend_1h3mito(
        this.ref.pointer, _sel_getCString_maxLength_, bytes, maxLength);
  }

  /// getCString:maxLength:range:remainingRange:
  void getCString_maxLength_range_remainingRange_(ffi.Pointer<ffi.Char> bytes,
      DartNSUInteger maxLength, NSRange aRange, NSRangePointer leftoverRange) {
    _objc_msgSend_3gpdva(
        this.ref.pointer,
        _sel_getCString_maxLength_range_remainingRange_,
        bytes,
        maxLength,
        aRange,
        leftoverRange);
  }

  /// writeToFile:atomically:
  bool writeToFile_atomically_(objc.NSString path, bool useAuxiliaryFile) {
    return _objc_msgSend_1iyq28l(this.ref.pointer, _sel_writeToFile_atomically_,
        path.ref.pointer, useAuxiliaryFile);
  }

  /// writeToURL:atomically:
  bool writeToURL_atomically_(objc.NSURL url, bool atomically) {
    return _objc_msgSend_1iyq28l(this.ref.pointer, _sel_writeToURL_atomically_,
        url.ref.pointer, atomically);
  }

  /// initWithContentsOfFile:
  objc.ObjCObjectBase? initWithContentsOfFile_(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  objc.ObjCObjectBase? initWithContentsOfURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// stringWithContentsOfFile:
  static objc.ObjCObjectBase? stringWithContentsOfFile_(objc.NSString path) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSString, _sel_stringWithContentsOfFile_, path.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// stringWithContentsOfURL:
  static objc.ObjCObjectBase? stringWithContentsOfURL_(objc.NSURL url) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSString, _sel_stringWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// initWithCStringNoCopy:length:freeWhenDone:
  objc.ObjCObjectBase? initWithCStringNoCopy_length_freeWhenDone_(
      ffi.Pointer<ffi.Char> bytes, DartNSUInteger length, bool freeBuffer) {
    final _ret = _objc_msgSend_1ojrli4(
        this.ref.retainAndReturnPointer(),
        _sel_initWithCStringNoCopy_length_freeWhenDone_,
        bytes,
        length,
        freeBuffer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// initWithCString:length:
  objc.ObjCObjectBase? initWithCString_length_(
      ffi.Pointer<ffi.Char> bytes, DartNSUInteger length) {
    final _ret = _objc_msgSend_erqryg(this.ref.retainAndReturnPointer(),
        _sel_initWithCString_length_, bytes, length);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// initWithCString:
  objc.ObjCObjectBase? initWithCString_(ffi.Pointer<ffi.Char> bytes) {
    final _ret = _objc_msgSend_56zxyn(
        this.ref.retainAndReturnPointer(), _sel_initWithCString_, bytes);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: false, release: true);
  }

  /// stringWithCString:length:
  static objc.ObjCObjectBase? stringWithCString_length_(
      ffi.Pointer<ffi.Char> bytes, DartNSUInteger length) {
    final _ret = _objc_msgSend_erqryg(
        _class_NSString, _sel_stringWithCString_length_, bytes, length);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// stringWithCString:
  static objc.ObjCObjectBase? stringWithCString_(ffi.Pointer<ffi.Char> bytes) {
    final _ret =
        _objc_msgSend_56zxyn(_class_NSString, _sel_stringWithCString_, bytes);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// getCharacters:
  void getCharacters_(ffi.Pointer<unichar> buffer) {
    _objc_msgSend_g3kdhc(this.ref.pointer, _sel_getCharacters_, buffer);
  }
}

typedef NSURLResourceKey = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLResourceKey = objc.NSString;
typedef NSURLFileResourceType = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLFileResourceType = objc.NSString;
typedef NSURLThumbnailDictionaryItem = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLThumbnailDictionaryItem = objc.NSString;
typedef NSURLFileProtectionType = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLFileProtectionType = objc.NSString;
typedef NSURLUbiquitousItemDownloadingStatus = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLUbiquitousItemDownloadingStatus = objc.NSString;
typedef NSURLUbiquitousSharedItemRole = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLUbiquitousSharedItemRole = objc.NSString;
typedef NSURLUbiquitousSharedItemPermissions = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLUbiquitousSharedItemPermissions = objc.NSString;
typedef NSURLBookmarkFileCreationOptions = NSUInteger;
late final _class_NSURL = objc.getClass("NSURL");
late final _sel_getPromisedItemResourceValue_forKey_error_ =
    objc.registerName("getPromisedItemResourceValue:forKey:error:");
final _objc_msgSend_1j9bhml = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_promisedItemResourceValuesForKeys_error_ =
    objc.registerName("promisedItemResourceValuesForKeys:error:");
late final _sel_checkPromisedItemIsReachableAndReturnError_ =
    objc.registerName("checkPromisedItemIsReachableAndReturnError:");
final _objc_msgSend_1dom33q = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();

/// NSPromisedItems
extension NSPromisedItems on objc.NSURL {
  /// Get resource values from URLs of 'promised' items. A promised item is not guaranteed to have its contents in the file system until you use NSFileCoordinator to perform a coordinated read on its URL, which causes the contents to be downloaded or otherwise generated. Promised item URLs are returned by various APIs, including currently:
  /// - NSMetadataQueryUbiquitousDataScope
  /// - NSMetadataQueryUbiquitousDocumentsScope
  /// - An NSFilePresenter presenting the contents of the directory located by -URLForUbiquitousContainerIdentifier: or a subdirectory thereof
  ///
  /// The following methods behave identically to their similarly named methods above (-getResourceValue:forKey:error:, etc.), except that they allow you to get resource values and check for presence regardless of whether the promised item's contents currently exist at the URL. You must use these APIs instead of the normal NSURL resource value APIs if and only if any of the following are true:
  /// - You are using a URL that you know came directly from one of the above APIs
  /// - You are inside the accessor block of a coordinated read or write that used NSFileCoordinatorReadingImmediatelyAvailableMetadataOnly, NSFileCoordinatorWritingForDeleting, NSFileCoordinatorWritingForMoving, or NSFileCoordinatorWritingContentIndependentMetadataOnly
  ///
  /// Most of the NSURL resource value keys will work with these APIs. However, there are some that are tied to the item's contents that will not work, such as NSURLContentAccessDateKey or NSURLGenerationIdentifierKey. If one of these keys is used, the method will return YES, but the value for the key will be nil.
  bool getPromisedItemResourceValue_forKey_error_(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> value,
      DartNSURLResourceKey key,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    return _objc_msgSend_1j9bhml(
        this.ref.pointer,
        _sel_getPromisedItemResourceValue_forKey_error_,
        value,
        key.ref.pointer,
        error);
  }

  /// promisedItemResourceValuesForKeys:error:
  objc.NSDictionary? promisedItemResourceValuesForKeys_error_(
      objc.NSArray keys, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    final _ret = _objc_msgSend_1lhpu4m(this.ref.pointer,
        _sel_promisedItemResourceValuesForKeys_error_, keys.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// checkPromisedItemIsReachableAndReturnError:
  bool checkPromisedItemIsReachableAndReturnError_(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    return _objc_msgSend_1dom33q(this.ref.pointer,
        _sel_checkPromisedItemIsReachableAndReturnError_, error);
  }
}

/// NSItemProvider
extension NSItemProvider1 on objc.NSURL {
  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSURL, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// objectWithItemProviderData:typeIdentifier:error:
  static objc.NSURL? objectWithItemProviderData_typeIdentifier_error_(
      objc.NSData data,
      objc.NSString typeIdentifier,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> outError) {
    final _ret = _objc_msgSend_1pnyuds(
        _class_NSURL,
        _sel_objectWithItemProviderData_typeIdentifier_error_,
        data.ref.pointer,
        typeIdentifier.ref.pointer,
        outError);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSURL, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider1 {
    if (!objc.respondsToSelector(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException(
          'NSURL', 'writableTypeIdentifiersForItemProvider');
    }
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier_(
          objc.NSString typeIdentifier) {
    if (!objc.respondsToSelector(_class_NSURL,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSURL',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_16fy0up(
        _class_NSURL,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  objc.NSItemProviderRepresentationVisibility
      itemProviderVisibilityForRepresentationWithTypeIdentifier_1(
          objc.NSString typeIdentifier) {
    if (!objc.respondsToSelector(this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException('NSURL',
          'itemProviderVisibilityForRepresentationWithTypeIdentifier:');
    }
    final _ret = _objc_msgSend_16fy0up(
        this.ref.pointer,
        _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
        typeIdentifier.ref.pointer);
    return objc.NSItemProviderRepresentationVisibility.fromValue(_ret);
  }

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  NSProgress? loadDataWithTypeIdentifier_forItemProviderCompletionHandler_(
      objc.NSString typeIdentifier,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>
          completionHandler) {
    final _ret = _objc_msgSend_r0bo0s(
        this.ref.pointer,
        _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
        typeIdentifier.ref.pointer,
        completionHandler.ref.pointer);
    return _ret.address == 0
        ? null
        : NSProgress.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_NSCharacterSet = objc.getClass("NSCharacterSet");
late final _sel_URLUserAllowedCharacterSet =
    objc.registerName("URLUserAllowedCharacterSet");
late final _sel_URLPasswordAllowedCharacterSet =
    objc.registerName("URLPasswordAllowedCharacterSet");
late final _sel_URLHostAllowedCharacterSet =
    objc.registerName("URLHostAllowedCharacterSet");
late final _sel_URLPathAllowedCharacterSet =
    objc.registerName("URLPathAllowedCharacterSet");
late final _sel_URLQueryAllowedCharacterSet =
    objc.registerName("URLQueryAllowedCharacterSet");
late final _sel_URLFragmentAllowedCharacterSet =
    objc.registerName("URLFragmentAllowedCharacterSet");

/// NSURLUtilities
extension NSURLUtilities on objc.NSCharacterSet {
  /// Returns a character set containing the characters allowed in a URL's user subcomponent.
  static objc.NSCharacterSet getURLUserAllowedCharacterSet() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSCharacterSet, _sel_URLUserAllowedCharacterSet);
    return objc.NSCharacterSet.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in a URL's password subcomponent.
  static objc.NSCharacterSet getURLPasswordAllowedCharacterSet() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSCharacterSet, _sel_URLPasswordAllowedCharacterSet);
    return objc.NSCharacterSet.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in a URL's host subcomponent.
  static objc.NSCharacterSet getURLHostAllowedCharacterSet() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSCharacterSet, _sel_URLHostAllowedCharacterSet);
    return objc.NSCharacterSet.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in a URL's path component. ';' is a legal path character, but it is recommended that it be percent-encoded for best compatibility with NSURL (-stringByAddingPercentEncodingWithAllowedCharacters: will percent-encode any ';' characters if you pass the URLPathAllowedCharacterSet).
  static objc.NSCharacterSet getURLPathAllowedCharacterSet() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSCharacterSet, _sel_URLPathAllowedCharacterSet);
    return objc.NSCharacterSet.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in a URL's query component.
  static objc.NSCharacterSet getURLQueryAllowedCharacterSet() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSCharacterSet, _sel_URLQueryAllowedCharacterSet);
    return objc.NSCharacterSet.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a character set containing the characters allowed in a URL's fragment component.
  static objc.NSCharacterSet getURLFragmentAllowedCharacterSet() {
    final _ret = _objc_msgSend_151sglz(
        _class_NSCharacterSet, _sel_URLFragmentAllowedCharacterSet);
    return objc.NSCharacterSet.castFromPointer(_ret,
        retain: true, release: true);
  }
}

late final _sel_stringByAddingPercentEncodingWithAllowedCharacters_ =
    objc.registerName("stringByAddingPercentEncodingWithAllowedCharacters:");
late final _sel_stringByRemovingPercentEncoding =
    objc.registerName("stringByRemovingPercentEncoding");
late final _sel_stringByAddingPercentEscapesUsingEncoding_ =
    objc.registerName("stringByAddingPercentEscapesUsingEncoding:");
late final _sel_stringByReplacingPercentEscapesUsingEncoding_ =
    objc.registerName("stringByReplacingPercentEscapesUsingEncoding:");

/// NSURLUtilities
extension NSURLUtilities1 on objc.NSString {
  /// Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters. UTF-8 encoding is used to determine the correct percent encoded characters. Entire URL strings cannot be percent-encoded. This method is intended to percent-encode a URL component or subcomponent string, NOT the entire URL string. Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.
  objc.NSString? stringByAddingPercentEncodingWithAllowedCharacters_(
      objc.NSCharacterSet allowedCharacters) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_stringByAddingPercentEncodingWithAllowedCharacters_,
        allowedCharacters.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new string made from the receiver by replacing all percent encoded sequences with the matching UTF-8 characters.
  objc.NSString? get stringByRemovingPercentEncoding {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_stringByRemovingPercentEncoding);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByAddingPercentEscapesUsingEncoding:
  objc.NSString? stringByAddingPercentEscapesUsingEncoding_(
      DartNSUInteger enc) {
    final _ret = _objc_msgSend_14hpxwa(
        this.ref.pointer, _sel_stringByAddingPercentEscapesUsingEncoding_, enc);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// stringByReplacingPercentEscapesUsingEncoding:
  objc.NSString? stringByReplacingPercentEscapesUsingEncoding_(
      DartNSUInteger enc) {
    final _ret = _objc_msgSend_14hpxwa(this.ref.pointer,
        _sel_stringByReplacingPercentEscapesUsingEncoding_, enc);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_fileURLWithPathComponents_ =
    objc.registerName("fileURLWithPathComponents:");
late final _sel_pathComponents = objc.registerName("pathComponents");
late final _sel_lastPathComponent = objc.registerName("lastPathComponent");
late final _sel_pathExtension = objc.registerName("pathExtension");
late final _sel_URLByAppendingPathComponent_ =
    objc.registerName("URLByAppendingPathComponent:");
late final _sel_URLByAppendingPathComponent_isDirectory_ =
    objc.registerName("URLByAppendingPathComponent:isDirectory:");
late final _sel_URLByDeletingLastPathComponent =
    objc.registerName("URLByDeletingLastPathComponent");
late final _sel_URLByAppendingPathExtension_ =
    objc.registerName("URLByAppendingPathExtension:");
late final _sel_URLByDeletingPathExtension =
    objc.registerName("URLByDeletingPathExtension");
late final _sel_checkResourceIsReachableAndReturnError_ =
    objc.registerName("checkResourceIsReachableAndReturnError:");
late final _sel_URLByStandardizingPath =
    objc.registerName("URLByStandardizingPath");
late final _sel_URLByResolvingSymlinksInPath =
    objc.registerName("URLByResolvingSymlinksInPath");

/// NSURLPathUtilities
extension NSURLPathUtilities on objc.NSURL {
  /// The following methods work on the path portion of a URL in the same manner that the NSPathUtilities methods on NSString do.
  static objc.NSURL? fileURLWithPathComponents_(objc.NSArray components) {
    final _ret = _objc_msgSend_1sotr3r(
        _class_NSURL, _sel_fileURLWithPathComponents_, components.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathComponents
  objc.NSArray? get pathComponents {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_pathComponents);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// lastPathComponent
  objc.NSString? get lastPathComponent {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_lastPathComponent);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// pathExtension
  objc.NSString? get pathExtension {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_pathExtension);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByAppendingPathComponent:
  objc.NSURL? URLByAppendingPathComponent_(objc.NSString pathComponent) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_URLByAppendingPathComponent_, pathComponent.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByAppendingPathComponent:isDirectory:
  objc.NSURL? URLByAppendingPathComponent_isDirectory_(
      objc.NSString pathComponent, bool isDirectory) {
    final _ret = _objc_msgSend_17amj0z(
        this.ref.pointer,
        _sel_URLByAppendingPathComponent_isDirectory_,
        pathComponent.ref.pointer,
        isDirectory);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByDeletingLastPathComponent
  objc.NSURL? get URLByDeletingLastPathComponent {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_URLByDeletingLastPathComponent);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByAppendingPathExtension:
  objc.NSURL? URLByAppendingPathExtension_(objc.NSString pathExtension) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_URLByAppendingPathExtension_, pathExtension.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByDeletingPathExtension
  objc.NSURL? get URLByDeletingPathExtension {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_URLByDeletingPathExtension);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns whether the URL's resource exists and is reachable. This method synchronously checks if the resource's backing store is reachable. Checking reachability is appropriate when making decisions that do not require other immediate operations on the resource, e.g. periodic maintenance of UI state that depends on the existence of a specific document. When performing operations such as opening a file or copying resource properties, it is more efficient to simply try the operation and handle failures. If this method returns NO, the optional error is populated. This method is currently applicable only to URLs for file system resources. For other URL types, NO is returned. Symbol is present in iOS 4, but performs no operation.
  bool checkResourceIsReachableAndReturnError_(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    return _objc_msgSend_1dom33q(
        this.ref.pointer, _sel_checkResourceIsReachableAndReturnError_, error);
  }

  /// URLByStandardizingPath
  objc.NSURL? get URLByStandardizingPath {
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_URLByStandardizingPath);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// URLByResolvingSymlinksInPath
  objc.NSURL? get URLByResolvingSymlinksInPath {
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_URLByResolvingSymlinksInPath);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_URL_resourceDataDidBecomeAvailable_ =
    objc.registerName("URL:resourceDataDidBecomeAvailable:");
late final _sel_URLResourceDidFinishLoading_ =
    objc.registerName("URLResourceDidFinishLoading:");
late final _sel_URLResourceDidCancelLoading_ =
    objc.registerName("URLResourceDidCancelLoading:");
late final _sel_URL_resourceDidFailLoadingWithReason_ =
    objc.registerName("URL:resourceDidFailLoadingWithReason:");

/// NSURLClient
extension NSURLClient on objc.NSObject {
  /// URL:resourceDataDidBecomeAvailable:
  void URL_resourceDataDidBecomeAvailable_(
      objc.NSURL sender, objc.NSData newBytes) {
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_URL_resourceDataDidBecomeAvailable_,
        sender.ref.pointer,
        newBytes.ref.pointer);
  }

  /// URLResourceDidFinishLoading:
  void URLResourceDidFinishLoading_(objc.NSURL sender) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_URLResourceDidFinishLoading_,
        sender.ref.pointer);
  }

  /// URLResourceDidCancelLoading:
  void URLResourceDidCancelLoading_(objc.NSURL sender) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_URLResourceDidCancelLoading_,
        sender.ref.pointer);
  }

  /// URL:resourceDidFailLoadingWithReason:
  void URL_resourceDidFailLoadingWithReason_(
      objc.NSURL sender, objc.NSString reason) {
    _objc_msgSend_pfv6jd(
        this.ref.pointer,
        _sel_URL_resourceDidFailLoadingWithReason_,
        sender.ref.pointer,
        reason.ref.pointer);
  }
}

late final _sel_resourceDataUsingCache_ =
    objc.registerName("resourceDataUsingCache:");
late final _sel_loadResourceDataNotifyingClient_usingCache_ =
    objc.registerName("loadResourceDataNotifyingClient:usingCache:");
late final _sel_propertyForKey_ = objc.registerName("propertyForKey:");
late final _sel_setResourceData_ = objc.registerName("setResourceData:");
late final _sel_setProperty_forKey_ = objc.registerName("setProperty:forKey:");
final _objc_msgSend_1lsax7n = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_URLHandleUsingCache_ =
    objc.registerName("URLHandleUsingCache:");

/// NSURLLoading
extension NSURLLoading on objc.NSURL {
  /// Blocks to load the data if necessary.  If shouldUseCache is YES, then if an equivalent URL has already been loaded and cached, its resource data will be returned immediately.  If shouldUseCache is NO, a new load will be started
  objc.NSData? resourceDataUsingCache_(bool shouldUseCache) {
    final _ret = _objc_msgSend_1t6aok9(
        this.ref.pointer, _sel_resourceDataUsingCache_, shouldUseCache);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// Starts an asynchronous load of the data, registering delegate to receive notification.  Only one such background load can proceed at a time.
  void loadResourceDataNotifyingClient_usingCache_(
      objc.ObjCObjectBase client, bool shouldUseCache) {
    _objc_msgSend_6p7ndb(
        this.ref.pointer,
        _sel_loadResourceDataNotifyingClient_usingCache_,
        client.ref.pointer,
        shouldUseCache);
  }

  /// propertyForKey:
  objc.ObjCObjectBase? propertyForKey_(objc.NSString propertyKey) {
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_propertyForKey_, propertyKey.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// These attempt to write the given arguments for the resource specified by the URL; they return success or failure
  bool setResourceData_(objc.NSData data) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_setResourceData_, data.ref.pointer);
  }

  /// setProperty:forKey:
  bool setProperty_forKey_(
      objc.ObjCObjectBase property, objc.NSString propertyKey) {
    return _objc_msgSend_1lsax7n(this.ref.pointer, _sel_setProperty_forKey_,
        property.ref.pointer, propertyKey.ref.pointer);
  }

  /// Sophisticated clients will want to ask for this, then message the handle directly.  If shouldUseCache is NO, a newly instantiated handle is returned, even if an equivalent URL has been loaded
  objc.NSURLHandle? URLHandleUsingCache_(bool shouldUseCache) {
    final _ret = _objc_msgSend_1t6aok9(
        this.ref.pointer, _sel_URLHandleUsingCache_, shouldUseCache);
    return _ret.address == 0
        ? null
        : objc.NSURLHandle.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_NSCondition = objc.getClass("NSCondition");
late final _sel_wait = objc.registerName("wait");
late final _sel_waitUntilDate_ = objc.registerName("waitUntilDate:");
late final _sel_signal = objc.registerName("signal");
late final _sel_broadcast = objc.registerName("broadcast");
late final _sel_lock = objc.registerName("lock");
void _ObjCBlock_ffiVoid_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_ffiVoid_ffiVoid_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_ffiVoid_ffiVoid_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) {
  (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_ffiVoid_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0) {
  try {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_ffiVoid_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>
    _ObjCBlock_ffiVoid_ffiVoid_blockingListenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiVoid_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>) fn) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_ffiVoid_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0)),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(
      void Function(ffi.Pointer<ffi.Void>) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_listenerCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(
      void Function(ffi.Pointer<ffi.Void>) fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_blockingCallable.nativeFunction.cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_blockingListenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0) => fn(arg0));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_ovsamd, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          void Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_unlock = objc.registerName("unlock");

/// NSCondition
class NSCondition extends objc.NSObject {
  NSCondition._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSCondition] that points to the same underlying object as [other].
  NSCondition.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSCondition] that wraps the given raw object pointer.
  NSCondition.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSCondition].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_NSCondition);
  }

  /// wait
  void wait1() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_wait);
  }

  /// waitUntilDate:
  bool waitUntilDate_(objc.NSDate limit) {
    return _objc_msgSend_19nvye5(
        this.ref.pointer, _sel_waitUntilDate_, limit.ref.pointer);
  }

  /// signal
  void signal() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_signal);
  }

  /// broadcast
  void broadcast() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_broadcast);
  }

  /// name
  objc.NSString? get name {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setName:
  set name(objc.NSString? value) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setName_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  NSCondition init() {
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSCondition.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static NSCondition new1() {
    final _ret = _objc_msgSend_151sglz(_class_NSCondition, _sel_new);
    return NSCondition.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSCondition allocWithZone_(ffi.Pointer<_NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_NSCondition, _sel_allocWithZone_, zone);
    return NSCondition.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static NSCondition alloc() {
    final _ret = _objc_msgSend_151sglz(_class_NSCondition, _sel_alloc);
    return NSCondition.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  NSCondition self() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return NSCondition.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  NSCondition retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return NSCondition.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  NSCondition autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return NSCondition.castFromPointer(_ret, retain: true, release: true);
  }

  /// lock
  void lock() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_lock);
  }

  /// unlock
  void unlock() {
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_unlock);
  }
}

typedef NSProgressKind1 = ffi.Pointer<objc.ObjCObject>;
typedef DartNSProgressKind1 = objc.NSString;
typedef NSProgressUserInfoKey1 = ffi.Pointer<objc.ObjCObject>;
typedef DartNSProgressUserInfoKey1 = objc.NSString;
typedef NSProgressFileOperationKind1 = ffi.Pointer<objc.ObjCObject>;
typedef DartNSProgressFileOperationKind1 = objc.NSString;
typedef NSProgressUnpublishingHandler1 = ffi.Pointer<objc.ObjCBlockImpl>;
typedef DartNSProgressUnpublishingHandler1
    = objc.ObjCBlock<ffi.Void Function()>;
typedef NSProgressPublishingHandler1 = ffi.Pointer<objc.ObjCBlockImpl>;
typedef DartNSProgressPublishingHandler1
    = objc.ObjCBlock<objc.ObjCBlock<ffi.Void Function()>? Function(NSProgress)>;

/// WARNING: NSException is a stub. To generate bindings for this class, include
/// NSException in your config's objc-interfaces list.
///
/// NSException
class NSException extends objc.NSObject {
  NSException._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSException] that points to the same underlying object as [other].
  NSException.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSException] that wraps the given raw object pointer.
  NSException.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);
}

late final _class_NSException = objc.getClass("NSException");
late final _sel_raise_format_ = objc.registerName("raise:format:");

/// NSExceptionRaisingConveniences
extension NSExceptionRaisingConveniences on NSException {
  /// raise:format:
  static void raise_format_(DartNSExceptionName name, objc.NSString format) {
    _objc_msgSend_pfv6jd(_class_NSException, _sel_raise_format_,
        name.ref.pointer, format.ref.pointer);
  }
}

typedef NSUncaughtExceptionHandler = ffi
    .NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> exception)>;
typedef os_function_tFunction1 = ffi.Void Function(ffi.Pointer<ffi.Void>);
typedef Dartos_function_tFunction1 = void Function(ffi.Pointer<ffi.Void>);
typedef os_function_t1
    = ffi.Pointer<ffi.NativeFunction<os_function_tFunction1>>;

/// !
/// @typedef os_block_t
///
/// @abstract
/// Generic type for a block taking no arguments and returning no value.
///
/// @discussion
/// When not building with Objective-C ARC, a block object allocated on or
/// copied to the heap must be released with a -[release] message or the
/// Block_release() function.
///
/// The declaration of a block literal allocates storage on the stack.
/// Therefore, this is an invalid construct:
/// <code>
/// os_block_t block;
/// if (x) {
/// block = ^{ printf("true\n"); };
/// } else {
/// block = ^{ printf("false\n"); };
/// }
/// block(); // unsafe!!!
/// </code>
///
/// What is happening behind the scenes:
/// <code>
/// if (x) {
/// struct Block __tmp_1 = ...; // setup details
/// block = &__tmp_1;
/// } else {
/// struct Block __tmp_2 = ...; // setup details
/// block = &__tmp_2;
/// }
/// </code>
///
/// As the example demonstrates, the address of a stack variable is escaping the
/// scope in which it is allocated. That is a classic C bug.
///
/// Instead, the block literal must be copied to the heap with the Block_copy()
/// function or by sending it a -[copy] message.
typedef os_block_t1 = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartos_block_t1 = objc.ObjCBlock<ffi.Void Function()>;
typedef fsignatures_t1 = fsignatures;
typedef fsupplement_t1 = fsupplement;

/// DYLD needs to check if the object is allowed to be combined
/// into the main binary. This is done between the code signature
/// is loaded and dyld is doing all the work to process the LOAD commands.
///
/// While this could be done in F_ADDFILESIGS.* family the hook into
/// the MAC module doesn't say no when LV isn't enabled and then that
/// is cached on the vnode, and the MAC module never gets change once
/// a process that library validation enabled.
typedef fchecklv_t1 = fchecklv;

/// fgetsigsinfo_t used by F_GETSIGSINFO command
typedef fgetsigsinfo_t1 = fgetsigsinfo;

/// fstore_t type used by F_PREALLOCATE command
typedef fstore_t1 = fstore;

/// fpunchhole_t used by F_PUNCHHOLE
typedef fpunchhole_t1 = fpunchhole;

/// factive_file_trim_t used by F_TRIM_ACTIVE_FILE
typedef ftrimactivefile_t1 = ftrimactivefile;

/// fspecread_t used by F_SPECULATIVE_READ
typedef fspecread_t1 = fspecread;
typedef fattributiontag_t1 = fattributiontag;
typedef filesec_t1 = ffi.Pointer<_filesec>;
typedef boolean_t1 = ffi.Int;
typedef Dartboolean_t1 = int;

/// natural_t and integer_t are Mach's legacy types for machine-
/// independent integer types (unsigned, and signed, respectively).
/// Their original purpose was to define other types in a machine/
/// compiler independent way.
///
/// They also had an implicit "same size as pointer" characteristic
/// to them (i.e. Mach's traditional types are very ILP32 or ILP64
/// centric).  We will likely support x86 ABIs that do not follow
/// either ofthese models (specifically LP64).  Therefore, we had to
/// make a choice between making these types scale with pointers or stay
/// tied to integers.  Because their use is predominantly tied to
/// to the size of an integer, we are keeping that association and
/// breaking free from pointer size guarantees.
///
/// New use of these types is discouraged.
typedef natural_t1 = __darwin_natural_t;
typedef integer_t1 = ffi.Int;
typedef Dartinteger_t1 = int;
typedef vm_offset_t1 = ffi.UintPtr;
typedef Dartvm_offset_t1 = int;
typedef vm_size_t1 = ffi.UintPtr;
typedef Dartvm_size_t1 = int;
typedef mach_vm_address_t1 = ffi.Uint64;
typedef Dartmach_vm_address_t1 = int;
typedef mach_vm_offset_t1 = ffi.Uint64;
typedef Dartmach_vm_offset_t1 = int;
typedef mach_vm_size_t1 = ffi.Uint64;
typedef Dartmach_vm_size_t1 = int;
typedef vm_map_offset_t1 = ffi.Uint64;
typedef Dartvm_map_offset_t1 = int;
typedef vm_map_address_t1 = ffi.Uint64;
typedef Dartvm_map_address_t1 = int;
typedef vm_map_size_t1 = ffi.Uint64;
typedef Dartvm_map_size_t1 = int;
typedef vm32_offset_t1 = ffi.Uint32;
typedef Dartvm32_offset_t1 = int;
typedef vm32_address_t1 = ffi.Uint32;
typedef Dartvm32_address_t1 = int;
typedef vm32_size_t1 = ffi.Uint32;
typedef Dartvm32_size_t1 = int;
typedef mach_port_context_t1 = vm_offset_t1;

/// mach_port_name_t - the local identity for a Mach port
///
/// The name is Mach port namespace specific.  It is used to
/// identify the rights held for that port by the task whose
/// namespace is implied [or specifically provided].
///
/// Use of this type usually implies just a name - no rights.
/// See mach_port_t for a type that implies a "named right."
typedef mach_port_name_t1 = natural_t1;
typedef mach_port_name_array_t1 = ffi.Pointer<mach_port_name_t1>;
typedef mach_port_t1 = __darwin_mach_port_t;
typedef mach_port_array_t1 = ffi.Pointer<mach_port_t1>;

/// These are the different rights a task may have for a port.
/// The MACH_PORT_RIGHT_* definitions are used as arguments
/// to mach_port_allocate, mach_port_get_refs, etc, to specify
/// a particular right to act upon.  The mach_port_names and
/// mach_port_type calls return bitmasks using the MACH_PORT_TYPE_*
/// definitions.  This is because a single name may denote
/// multiple rights.
typedef mach_port_right_t1 = natural_t1;
typedef mach_port_type_t1 = natural_t1;
typedef mach_port_type_array_t1 = ffi.Pointer<mach_port_type_t1>;

/// User-references for capabilities.
typedef mach_port_urefs_t1 = natural_t1;
typedef mach_port_delta_t1 = integer_t1;

/// Attributes of ports.  (See mach_port_get_receive_status.)
typedef mach_port_seqno_t1 = natural_t1;
typedef mach_port_mscount_t1 = natural_t1;
typedef mach_port_msgcount_t1 = natural_t1;
typedef mach_port_rights_t1 = natural_t1;
typedef mach_port_srights_t1 = ffi.UnsignedInt;
typedef Dartmach_port_srights_t1 = int;
typedef mach_port_status_t1 = mach_port_status;
typedef mach_port_limits_t1 = mach_port_limits;
typedef mach_port_info_ext_t1 = mach_port_info_ext;
typedef mach_port_guard_info_t1 = mach_port_guard_info;
typedef mach_port_info_t1 = ffi.Pointer<integer_t1>;

/// Flavors for mach_port_get/set/assert_attributes()
typedef mach_port_flavor_t1 = ffi.Int;
typedef Dartmach_port_flavor_t1 = int;

/// Structure used to pass information about port allocation requests.
/// Must be padded to 64-bits total length.
typedef mach_port_qos_t1 = mach_port_qos;
typedef mach_service_port_info_data_t1 = mach_service_port_info;
typedef mach_service_port_info_t1 = ffi.Pointer<mach_service_port_info>;

/// Structure to define optional attributes for a newly
/// constructed port.
typedef mach_port_options_t1 = mach_port_options;
typedef mach_port_options_ptr_t1 = ffi.Pointer<mach_port_options_t1>;

/// !
/// @typedef os_workgroup_t
///
/// @abstract
/// A reference counted os object representing a workload that needs to
/// be distinctly recognized and tracked by the system.  The workgroup
/// tracks a collection of threads all working cooperatively. An os_workgroup
/// object - when not an instance of a specific os_workgroup_t subclass -
/// represents a generic workload and makes no assumptions about the kind of
/// work done.
///
/// @discussion
/// Threads can explicitly join an os_workgroup_t to mark themselves as
/// participants in the workload.
typedef os_workgroup_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartos_workgroup_t1 = OS_os_workgroup;

/// !
/// @typedef os_workgroup_attr_t
///
/// @abstract
/// Pointer to an opaque structure for describing attributes that can be
/// configured on a workgroup at creation.
typedef os_workgroup_attr_s1 = os_workgroup_attr_opaque_s;
typedef os_workgroup_attr_t1 = ffi.Pointer<os_workgroup_attr_opaque_s>;

/// !
/// @typedef os_workgroup_join_token, os_workgroup_join_token_t
///
/// @abstract
/// An opaque join token which the client needs to pass to os_workgroup_join
/// and os_workgroup_leave
typedef os_workgroup_join_token_s1 = os_workgroup_join_token_opaque_s;
typedef os_workgroup_join_token_t1
    = ffi.Pointer<os_workgroup_join_token_opaque_s>;

/// Working Arena index of a thread in a workgroup
typedef os_workgroup_index1 = ffi.Uint32;
typedef Dartos_workgroup_index1 = int;
typedef os_workgroup_working_arena_destructor_tFunction1 = ffi.Void Function(
    ffi.Pointer<ffi.Void>);
typedef Dartos_workgroup_working_arena_destructor_tFunction1 = void Function(
    ffi.Pointer<ffi.Void>);

/// Destructor for Working Arena
typedef os_workgroup_working_arena_destructor_t1 = ffi.Pointer<
    ffi.NativeFunction<os_workgroup_working_arena_destructor_tFunction1>>;

/// !
/// @typedef os_workgroup_max_parallel_threads_attr_t
///
/// @abstract
/// A pointer to a structure describing the set of properties of a workgroup to
/// override with the explicitly specified values in the structure.
///
/// See also os_workgroup_max_parallel_threads.
typedef os_workgroup_mpt_attr_s1 = os_workgroup_max_parallel_threads_attr_s;
typedef os_workgroup_mpt_attr_t1
    = ffi.Pointer<os_workgroup_max_parallel_threads_attr_s>;
typedef os_workgroup_interval_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartos_workgroup_interval_t1 = OS_os_workgroup;

/// @typedef os_workgroup_interval_data, os_workgroup_interval_data_t
///
/// @abstract
/// An opaque structure containing additional configuration for the workgroup
/// interval.
typedef os_workgroup_interval_data_s1 = os_workgroup_interval_data_opaque_s;
typedef os_workgroup_interval_data_t1
    = ffi.Pointer<os_workgroup_interval_data_opaque_s>;
typedef os_workgroup_parallel_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartos_workgroup_parallel_t1 = OS_os_workgroup;
typedef dispatch_function_tFunction1 = ffi.Void Function(ffi.Pointer<ffi.Void>);
typedef Dartdispatch_function_tFunction1 = void Function(ffi.Pointer<ffi.Void>);
typedef dispatch_function_t1
    = ffi.Pointer<ffi.NativeFunction<dispatch_function_tFunction1>>;
typedef time_value_t1 = time_value;

/// Type definitions.
typedef alarm_type_t1 = ffi.Int;
typedef Dartalarm_type_t1 = int;
typedef sleep_type_t1 = ffi.Int;
typedef Dartsleep_type_t1 = int;
typedef clock_id_t1 = ffi.Int;
typedef Dartclock_id_t1 = int;
typedef clock_flavor_t1 = ffi.Int;
typedef Dartclock_flavor_t1 = int;
typedef clock_attr_t1 = ffi.Pointer<ffi.Int>;
typedef clock_res_t1 = ffi.Int;
typedef Dartclock_res_t1 = int;
typedef mach_timespec_t1 = mach_timespec;

/// !
/// @typedef dispatch_time_t
///
/// @abstract
/// A somewhat abstract representation of time; where zero means "now" and
/// DISPATCH_TIME_FOREVER means "infinity" and every value in between is an
/// opaque encoding.
typedef dispatch_time_t1 = ffi.Uint64;
typedef Dartdispatch_time_t1 = int;

/// By default, dispatch objects are declared as Objective-C types when building
/// with an Objective-C compiler. This allows them to participate in ARC, in RR
/// management by the Blocks runtime and in leaks checking by the static
/// analyzer, and enables them to be added to Cocoa collections.
/// See <os/object.h> for details.
typedef dispatch_object_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_object_t1 = objc.NSObject;

/// !
/// @typedef dispatch_block_t
///
/// @abstract
/// The type of blocks submitted to dispatch queues, which take no arguments
/// and have no return value.
///
/// @discussion
/// When not building with Objective-C ARC, a block object allocated on or
/// copied to the heap must be released with a -[release] message or the
/// Block_release() function.
///
/// The declaration of a block literal allocates storage on the stack.
/// Therefore, this is an invalid construct:
/// <code>
/// dispatch_block_t block;
/// if (x) {
/// block = ^{ printf("true\n"); };
/// } else {
/// block = ^{ printf("false\n"); };
/// }
/// block(); // unsafe!!!
/// </code>
///
/// What is happening behind the scenes:
/// <code>
/// if (x) {
/// struct Block __tmp_1 = ...; // setup details
/// block = &__tmp_1;
/// } else {
/// struct Block __tmp_2 = ...; // setup details
/// block = &__tmp_2;
/// }
/// </code>
///
/// As the example demonstrates, the address of a stack variable is escaping the
/// scope in which it is allocated. That is a classic C bug.
///
/// Instead, the block literal must be copied to the heap with the Block_copy()
/// function or by sending it a -[copy] message.
typedef dispatch_block_t1 = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartdispatch_block_t1 = objc.ObjCBlock<ffi.Void Function()>;

/// !
/// @typedef dispatch_queue_global_t
///
/// @abstract
/// Dispatch global concurrent queues are an abstraction around the system thread
/// pool which invokes workitems that are submitted to dispatch queues.
///
/// @discussion
/// Dispatch global concurrent queues provide buckets of priorities on top of the
/// thread pool the system manages. The system will decide how many threads
/// to allocate to this pool depending on demand and system load. In particular,
/// the system tries to maintain a good level of concurrency for this resource,
/// and will create new threads when too many existing worker threads block in
/// system calls.
///
/// The global concurrent queues are a shared resource and as such it is the
/// responsiblity of every user of this resource to not submit an unbounded
/// amount of work to this pool, especially work that may block, as this can
/// cause the system to spawn very large numbers of threads (aka. thread
/// explosion).
///
/// Work items submitted to the global concurrent queues have no ordering
/// guarantee with respect to the order of submission, and workitems submitted
/// to these queues may be invoked concurrently.
///
/// Dispatch global concurrent queues are well-known global objects that are
/// returned by dispatch_get_global_queue(). These objects cannot be modified.
/// Calls to dispatch_suspend(), dispatch_resume(), dispatch_set_context(), etc.,
/// will have no effect when used with queues of this type.
typedef dispatch_queue_global_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_global_t1 = objc.NSObject;

/// !
/// @typedef dispatch_queue_serial_executor_t
///
/// @abstract
/// An abstract class of dispatch queues which conform to the serial executor
/// protocol.
///
/// @discussion
/// A serial executor in Swift Concurrency represents a mutual exclusion context.
/// Queues with a singular owner, which invoke only one workItem at a time
/// provide such a mutual exclusion context and are serial executors.
///
/// Subclasses of this abstract class can be therefore be setup as Custom
/// Executors for Swift Actors.
///
/// See dispatch_queue_serial_t and dispatch_workloop_t.
typedef dispatch_queue_serial_executor_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_serial_executor_t1 = objc.NSObject;

/// !
/// @typedef dispatch_queue_serial_t
///
/// @abstract
/// Dispatch serial queues invoke workitems submitted to them serially in FIFO
/// order.
///
/// @discussion
/// Dispatch serial queues are lightweight objects to which workitems may be
/// submitted to be invoked in FIFO order. A serial queue will only invoke one
/// workitem at a time, but independent serial queues may each invoke their work
/// items concurrently with respect to each other.
///
/// Serial queues can target each other (See dispatch_set_target_queue()). The
/// serial queue at the bottom of a queue hierarchy provides an exclusion
/// context: at most one workitem submitted to any of the queues in such
/// a hiearchy will run at any given time.
///
/// Such hierarchies provide a natural construct to organize an application
/// subsystem around.
///
/// Serial queues are created by passing a dispatch queue attribute derived from
/// DISPATCH_QUEUE_SERIAL to dispatch_queue_create_with_target().
typedef dispatch_queue_serial_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_serial_t1 = objc.NSObject;

/// !
/// @typedef dispatch_queue_main_t
///
/// @abstract
/// The type of the default queue that is bound to the main thread.
///
/// @discussion
/// The main queue is a serial queue (See dispatch_queue_serial_t) which is bound
/// to the main thread of an application.
///
/// In order to invoke workitems submitted to the main queue, the application
/// must call dispatch_main(), NSApplicationMain(), or use a CFRunLoop on the
/// main thread.
///
/// The main queue is a well known global object that is made automatically on
/// behalf of the main thread during process initialization and is returned by
/// dispatch_get_main_queue(). This object cannot be modified.  Calls to
/// dispatch_suspend(), dispatch_resume(), dispatch_set_context(), etc., will
/// have no effect when used on the main queue.
typedef dispatch_queue_main_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_main_t1 = objc.NSObject;

/// !
/// @typedef dispatch_queue_concurrent_t
///
/// @abstract
/// Dispatch concurrent queues invoke workitems submitted to them concurrently,
/// and admit a notion of barrier workitems.
///
/// @discussion
/// Dispatch concurrent queues are lightweight objects to which regular and
/// barrier workitems may be submited. Barrier workitems are invoked in
/// exclusion of any other kind of workitem in FIFO order.
///
/// Regular workitems can be invoked concurrently for the same concurrent queue,
/// in any order. However, regular workitems will not be invoked before any
/// barrier workitem submited ahead of them has been invoked.
///
/// In other words, if a serial queue is equivalent to a mutex in the Dispatch
/// world, a concurrent queue is equivalent to a reader-writer lock, where
/// regular items are readers and barriers are writers.
///
/// Concurrent queues are created by passing a dispatch queue attribute derived
/// from DISPATCH_QUEUE_CONCURRENT to dispatch_queue_create_with_target().
///
/// Caveat:
/// Dispatch concurrent queues at this time do not implement priority inversion
/// avoidance when lower priority regular workitems (readers) are being invoked
/// and are preventing a higher priority barrier (writer) from being invoked.
typedef dispatch_queue_concurrent_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_concurrent_t1 = objc.NSObject;
typedef dispatch_queue_priority_t1 = ffi.Long;
typedef Dartdispatch_queue_priority_t1 = int;

/// !
/// @typedef dispatch_queue_attr_t
///
/// @abstract
/// Attribute for dispatch queues.
typedef dispatch_queue_attr_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_queue_attr_t1 = objc.NSObject;
typedef kern_return_t1 = ffi.Int;
typedef Dartkern_return_t1 = int;

/// The timeout mechanism uses mach_msg_timeout_t values,
/// passed by value.  The timeout units are milliseconds.
/// It is controlled with the MACH_SEND_TIMEOUT
/// and MACH_RCV_TIMEOUT options.
typedef mach_msg_timeout_t1 = natural_t1;

/// Every message starts with a message header.
/// Following the message header, if the message is complex, are a count
/// of type descriptors and the type descriptors themselves
/// (mach_msg_descriptor_t). The size of the message must be specified in
/// bytes, and includes the message header, descriptor count, descriptors,
/// and inline data.
///
/// The msgh_remote_port field specifies the destination of the message.
/// It must specify a valid send or send-once right for a port.
///
/// The msgh_local_port field specifies a "reply port".  Normally,
/// This field carries a send-once right that the receiver will use
/// to reply to the message.  It may carry the values MACH_PORT_NULL,
/// MACH_PORT_DEAD, a send-once right, or a send right.
///
/// The msgh_voucher_port field specifies a Mach voucher port. Only
/// send rights to kernel-implemented Mach Voucher kernel objects in
/// addition to MACH_PORT_NULL or MACH_PORT_DEAD may be passed.
///
/// The msgh_id field is uninterpreted by the message primitives.
/// It normally carries information specifying the format
/// or meaning of the message.
typedef mach_msg_bits_t1 = ffi.UnsignedInt;
typedef Dartmach_msg_bits_t1 = int;
typedef mach_msg_size_t1 = natural_t1;
typedef mach_msg_id_t1 = integer_t1;
typedef mach_msg_priority_t1 = ffi.UnsignedInt;
typedef Dartmach_msg_priority_t1 = int;
typedef mach_msg_type_name_t1 = ffi.UnsignedInt;
typedef Dartmach_msg_type_name_t1 = int;
typedef mach_msg_copy_options_t1 = ffi.UnsignedInt;
typedef Dartmach_msg_copy_options_t1 = int;
typedef mach_msg_guard_flags_t1 = ffi.UnsignedInt;
typedef Dartmach_msg_guard_flags_t1 = int;

/// In a complex mach message, the mach_msg_header_t is followed by
/// a descriptor count, then an array of that number of descriptors
/// (mach_msg_*_descriptor_t). The type field of mach_msg_type_descriptor_t
/// (which any descriptor can be cast to) indicates the flavor of the
/// descriptor.
///
/// Note that in LP64, the various types of descriptors are no longer all
/// the same size as mach_msg_descriptor_t, so the array cannot be indexed
/// as expected.
typedef mach_msg_descriptor_type_t1 = ffi.UnsignedInt;
typedef Dartmach_msg_descriptor_type_t1 = int;
typedef mach_msg_trailer_type_t1 = ffi.UnsignedInt;
typedef Dartmach_msg_trailer_type_t1 = int;
typedef mach_msg_trailer_size_t1 = ffi.UnsignedInt;
typedef Dartmach_msg_trailer_size_t1 = int;
typedef mach_msg_trailer_info_t1 = ffi.Pointer<ffi.Char>;
typedef mach_msg_filter_id1 = ffi.Int;
typedef Dartmach_msg_filter_id1 = int;

/// These values can change from release to release - but clearly
/// code cannot request additional trailer elements one was not
/// compiled to understand.  Therefore, it is safe to use this
/// constant when the same module specified the receive options.
/// Otherwise, you run the risk that the options requested by
/// another module may exceed the local modules notion of
/// MAX_TRAILER_SIZE.
typedef mach_msg_max_trailer_t1 = mach_msg_mac_trailer_t;

/// Legacy requirements keep us from ever updating these defines (even
/// when the format_0 trailers gain new option data fields in the future).
/// Therefore, they shouldn't be used going forward.  Instead, the sizes
/// should be compared against the specific element size requested using
/// REQUESTED_TRAILER_SIZE.
typedef mach_msg_format_0_trailer_t1 = mach_msg_security_trailer_t;
typedef mach_msg_options_t1 = integer_t1;
typedef mach_msg_type_size_t1 = natural_t1;
typedef mach_msg_type_number_t1 = natural_t1;
typedef mach_msg_option_t1 = integer_t1;

/// Much code assumes that mach_msg_return_t == kern_return_t.
/// This definition is useful for descriptive purposes.
///
/// See <mach/error.h> for the format of error codes.
/// IPC errors are system 4.  Send errors are subsystem 0;
/// receive errors are subsystem 1.  The code field is always non-zero.
/// The high bits of the code field communicate extra information
/// for some error codes.  MACH_MSG_MASK masks off these special bits.
typedef mach_msg_return_t1 = kern_return_t1;

/// !
/// @typedef dispatch_source_t
///
/// @abstract
/// Dispatch sources are used to automatically submit event handler blocks to
/// dispatch queues in response to external events.
typedef dispatch_source_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_source_t1 = objc.NSObject;

/// !
/// @typedef dispatch_source_type_t
///
/// @abstract
/// Constants of this type represent the class of low-level system object that
/// is being monitored by the dispatch source. Constants of this type are
/// passed as a parameter to dispatch_source_create() and determine how the
/// handle argument is interpreted (i.e. as a file descriptor, mach port,
/// signal number, process identifier, etc.), and how the mask argument is
/// interpreted.
typedef dispatch_source_type_t1 = ffi.Pointer<dispatch_source_type_s>;
typedef dispatch_source_mach_send_flags_t1 = ffi.UnsignedLong;
typedef Dartdispatch_source_mach_send_flags_t1 = int;

/// !
/// @typedef dispatch_source_mach_recv_flags_t
/// Type of dispatch_source_mach_recv flags
typedef dispatch_source_mach_recv_flags_t1 = ffi.UnsignedLong;
typedef Dartdispatch_source_mach_recv_flags_t1 = int;
typedef dispatch_source_memorypressure_flags_t1 = ffi.UnsignedLong;
typedef Dartdispatch_source_memorypressure_flags_t1 = int;
typedef dispatch_source_proc_flags_t1 = ffi.UnsignedLong;
typedef Dartdispatch_source_proc_flags_t1 = int;
typedef dispatch_source_vnode_flags_t1 = ffi.UnsignedLong;
typedef Dartdispatch_source_vnode_flags_t1 = int;
typedef dispatch_source_timer_flags_t1 = ffi.UnsignedLong;
typedef Dartdispatch_source_timer_flags_t1 = int;

/// !
/// @typedef dispatch_group_t
/// @abstract
/// A group of blocks submitted to queues for asynchronous invocation.
typedef dispatch_group_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_group_t1 = objc.NSObject;

/// !
/// @typedef dispatch_semaphore_t
///
/// @abstract
/// A counting semaphore.
typedef dispatch_semaphore_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_semaphore_t1 = objc.NSObject;

/// !
/// @typedef dispatch_once_t
///
/// @abstract
/// A predicate for use with dispatch_once(). It must be initialized to zero.
/// Note: static and global variables default to zero.
typedef dispatch_once_t1 = ffi.IntPtr;
typedef Dartdispatch_once_t1 = int;

/// !
/// @typedef dispatch_data_t
/// A dispatch object representing memory regions.
typedef dispatch_data_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_data_t1 = objc.NSObject;

/// !
/// @typedef dispatch_data_applier_t
/// A block to be invoked for every contiguous memory region in a data object.
///
/// @param region	A data object representing the current region.
/// @param offset	The logical offset of the current region to the start
/// of the data object.
/// @param buffer	The location of the memory for the current region.
/// @param size		The size of the memory for the current region.
/// @result		A Boolean indicating whether traversal should continue.
typedef dispatch_data_applier_t1 = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartdispatch_data_applier_t1 = objc.ObjCBlock<
    ffi.Bool Function(
        objc.NSObject, ffi.Size, ffi.Pointer<ffi.Void>, ffi.Size)>;
typedef dispatch_fd_t1 = ffi.Int;
typedef Dartdispatch_fd_t1 = int;

/// !
/// @typedef dispatch_io_t
/// A dispatch I/O channel represents the asynchronous I/O policy applied to a
/// file descriptor. I/O channels are first class dispatch objects and may be
/// retained and released, suspended and resumed, etc.
typedef dispatch_io_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_io_t1 = objc.NSObject;
typedef dispatch_io_type_t1 = ffi.UnsignedLong;
typedef Dartdispatch_io_type_t1 = int;

/// !
/// @typedef dispatch_io_handler_t
/// The prototype of I/O handler blocks for dispatch I/O operations.
///
/// @param done		A flag indicating whether the operation is complete.
/// @param data		The data object to be handled.
/// @param error		An errno condition for the operation.
typedef dispatch_io_handler_t1 = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dartdispatch_io_handler_t1
    = objc.ObjCBlock<ffi.Void Function(ffi.Bool, objc.NSObject?, ffi.Int)>;
typedef dispatch_io_close_flags_t1 = ffi.UnsignedLong;
typedef Dartdispatch_io_close_flags_t1 = int;
typedef dispatch_io_interval_flags_t1 = ffi.UnsignedLong;
typedef Dartdispatch_io_interval_flags_t1 = int;

/// !
/// @typedef dispatch_workloop_t
///
/// @abstract
/// Dispatch workloops invoke workitems submitted to them in priority order.
///
/// @discussion
/// A dispatch workloop is a flavor of dispatch_queue_t that is a priority
/// ordered queue (using the QOS class of the submitted workitems as the
/// ordering). Dispatch workloops are an exclusion context and it is guaranteed
/// that only one work item submitted to the dispatch workloop will be invoked at
/// a time.
///
/// Between each workitem invocation, the workloop will evaluate whether higher
/// priority workitems have since been submitted, either directly to the
/// workloop or to any queues that target the workloop, and execute these first.
///
/// Serial queues targeting a workloop maintain FIFO execution of their
/// workitems. However, the workloop may reorder workitems submitted to
/// independent serial queues targeting it with respect to each other,
/// based on their priorities, while preserving FIFO execution with respect to
/// each serial queue.
///
/// A dispatch workloop is a "subclass" of dispatch_queue_t which can be passed
/// to all APIs accepting a dispatch queue, except for functions from the
/// dispatch_sync() family. dispatch_async_and_wait() must be used for workloop
/// objects. Functions from the dispatch_sync() family on queues targeting
/// a workloop are still permitted but discouraged for performance reasons.
typedef dispatch_workloop_t1 = ffi.Pointer<objc.ObjCObject>;
typedef Dartdispatch_workloop_t1 = objc.NSObject;

enum NSOperationQueuePriority {
  NSOperationQueuePriorityVeryLow(-8),
  NSOperationQueuePriorityLow(-4),
  NSOperationQueuePriorityNormal(0),
  NSOperationQueuePriorityHigh(4),
  NSOperationQueuePriorityVeryHigh(8);

  final int value;
  const NSOperationQueuePriority(this.value);

  static NSOperationQueuePriority fromValue(int value) => switch (value) {
        -8 => NSOperationQueuePriorityVeryLow,
        -4 => NSOperationQueuePriorityLow,
        0 => NSOperationQueuePriorityNormal,
        4 => NSOperationQueuePriorityHigh,
        8 => NSOperationQueuePriorityVeryHigh,
        _ => throw ArgumentError(
            "Unknown value for NSOperationQueuePriority: $value"),
      };
}

typedef NSErrorDomain = ffi.Pointer<objc.ObjCObject>;
typedef DartNSErrorDomain = objc.NSString;
typedef NSErrorUserInfoKey = ffi.Pointer<objc.ObjCObject>;
typedef DartNSErrorUserInfoKey = objc.NSString;
late final _sel_attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo_ =
    objc.registerName(
        "attemptRecoveryFromError:optionIndex:delegate:didRecoverSelector:contextInfo:");
final _objc_msgSend_10txwc9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Void>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Void>)>();
late final _sel_attemptRecoveryFromError_optionIndex_ =
    objc.registerName("attemptRecoveryFromError:optionIndex:");
final _objc_msgSend_z7gxsm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.UnsignedLong)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int)>();

/// NSErrorRecoveryAttempting
extension NSErrorRecoveryAttempting on objc.NSObject {
  /// Given that an error alert has been presented document-modally to the user, and the user has chosen one of the error's recovery options, attempt recovery from the error, and send the selected message to the specified delegate. The option index is an index into the error's array of localized recovery options. The method selected by didRecoverSelector must have the same signature as:
  ///
  /// - (void)didPresentErrorWithRecovery:(BOOL)didRecover contextInfo:(void *)contextInfo;
  ///
  /// The value passed for didRecover must be YES if error recovery was completely successful, NO otherwise.
  void
      attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo_(
          objc.NSError error,
          DartNSUInteger recoveryOptionIndex,
          objc.ObjCObjectBase? delegate,
          ffi.Pointer<objc.ObjCSelector> didRecoverSelector,
          ffi.Pointer<ffi.Void> contextInfo) {
    _objc_msgSend_10txwc9(
        this.ref.pointer,
        _sel_attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo_,
        error.ref.pointer,
        recoveryOptionIndex,
        delegate?.ref.pointer ?? ffi.nullptr,
        didRecoverSelector,
        contextInfo);
  }

  /// Given that an error alert has been presented applicaton-modally to the user, and the user has chosen one of the error's recovery options, attempt recovery from the error, and return YES if error recovery was completely successful, NO otherwise. The recovery option index is an index into the error's array of localized recovery options.
  bool attemptRecoveryFromError_optionIndex_(
      objc.NSError error, DartNSUInteger recoveryOptionIndex) {
    return _objc_msgSend_z7gxsm(
        this.ref.pointer,
        _sel_attemptRecoveryFromError_optionIndex_,
        error.ref.pointer,
        recoveryOptionIndex);
  }
}

typedef NSURLResourceKey1 = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLResourceKey1 = objc.NSString;
typedef NSURLFileResourceType1 = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLFileResourceType1 = objc.NSString;
typedef NSURLThumbnailDictionaryItem1 = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLThumbnailDictionaryItem1 = objc.NSString;
typedef NSURLFileProtectionType1 = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLFileProtectionType1 = objc.NSString;
typedef NSURLUbiquitousItemDownloadingStatus1 = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLUbiquitousItemDownloadingStatus1 = objc.NSString;
typedef NSURLUbiquitousSharedItemRole1 = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLUbiquitousSharedItemRole1 = objc.NSString;
typedef NSURLUbiquitousSharedItemPermissions1 = ffi.Pointer<objc.ObjCObject>;
typedef DartNSURLUbiquitousSharedItemPermissions1 = objc.NSString;
typedef NSURLBookmarkFileCreationOptions1 = NSUInteger;
typedef _DidFinish = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dart_DidFinish = objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, NSURLSession,
        NSURLSessionDownloadTask, objc.NSURL)>;
void
    _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Void Function(
                        ffi.Pointer<objc.ObjCObject> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1,
                        ffi.Pointer<objc.ObjCObject> arg2,
                        ffi.Pointer<objc.ObjCObject> arg3)>>()
            .asFunction<
                void Function(
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_fnPtrTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<objc.ObjCObject> arg3) =>
        (objc.getBlockClosure(block) as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
ffi.Pointer<ffi.Void>
    _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_closureTrampoline)
        .cast();
void
    _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_listenerTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_listenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_listenerTrampoline)
      ..keepIsolateAlive = false;
void
    _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> waiter,
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCObject> arg2,
        ffi.Pointer<objc.ObjCObject> arg3) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2, arg3);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingListenerCallable =
    ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>`.
abstract final class ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          ffi.Void Function(
              NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(
                  NSCondition,
                  NSURLSession,
                  NSURLSessionDownloadTask,
                  objc.NSURL)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, ffi.Pointer<objc.ObjCObject> arg3)>> ptr) =>
          objc.ObjCBlock<
                  ffi.Void Function(NSCondition, NSURLSession,
                      NSURLSessionDownloadTask, objc.NSURL)>(
              objc.newPointerBlock(
                  _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_fnPtrCallable,
                  ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)> fromFunction(void Function(NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL) fn) =>
      objc.ObjCBlock<ffi.Void Function(NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_closureCallable,
              (ffi.Pointer<objc.ObjCObject> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1,
                      ffi.Pointer<objc.ObjCObject> arg2,
                      ffi.Pointer<objc.ObjCObject> arg3) =>
                  fn(
                      NSCondition.castFromPointer(arg0, retain: true, release: true),
                      NSURLSession.castFromPointer(arg1, retain: true, release: true),
                      NSURLSessionDownloadTask.castFromPointer(arg2, retain: true, release: true),
                      objc.NSURL.castFromPointer(arg3, retain: true, release: true))),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// Note that unlike the default behavior of NativeCallable.listener, listener
  /// blocks do not keep the isolate alive.
  static objc.ObjCBlock<
      ffi.Void Function(NSCondition, NSURLSession, NSURLSessionDownloadTask,
          objc.NSURL)> listener(
      void Function(
              NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_listenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                NSCondition.castFromPointer(arg0, retain: false, release: true),
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSURL
                    .castFromPointer(arg3, retain: false, release: true)));
    final wrapper = _NativeCupertinoHttp_wrapListenerBlock_mlcr8l(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
        ffi.Void Function(NSCondition, NSURLSession, NSURLSessionDownloadTask,
            objc.NSURL)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// This block does not keep the owner isolate alive. If the owner isolate has
  /// shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
      ffi.Void Function(NSCondition, NSURLSession, NSURLSessionDownloadTask,
          objc.NSURL)> blocking(
      void Function(
              NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)
          fn) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                NSCondition.castFromPointer(arg0, retain: false, release: true),
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSURL
                    .castFromPointer(arg3, retain: false, release: true)));
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<objc.ObjCObject> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<objc.ObjCObject> arg2,
                ffi.Pointer<objc.ObjCObject> arg3) =>
            fn(
                NSCondition.castFromPointer(arg0, retain: false, release: true),
                NSURLSession.castFromPointer(arg1,
                    retain: false, release: true),
                NSURLSessionDownloadTask.castFromPointer(arg2,
                    retain: false, release: true),
                objc.NSURL
                    .castFromPointer(arg3, retain: false, release: true)));
    final wrapper = objc.wrapBlockingBlock(
        _NativeCupertinoHttp_wrapBlockingBlock_mlcr8l, raw, rawListener);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
        ffi.Void Function(NSCondition, NSURLSession, NSURLSessionDownloadTask,
            objc.NSURL)>(wrapper, retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>`.
extension ObjCBlock_ffiVoid_NSCondition_NSURLSession_NSURLSessionDownloadTask_NSURL_CallExtension
    on objc.ObjCBlock<
        ffi.Void Function(
            NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)> {
  void call(NSCondition arg0, NSURLSession arg1, NSURLSessionDownloadTask arg2,
          objc.NSURL arg3) =>
      ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<objc.ObjCObject> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1,
                          ffi.Pointer<objc.ObjCObject> arg2,
                          ffi.Pointer<objc.ObjCObject> arg3)>>()
              .asFunction<
                  void Function(
                      ffi.Pointer<objc.ObjCBlockImpl>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>,
                      ffi.Pointer<objc.ObjCObject>)>()(
          ref.pointer,
          arg0.ref.pointer,
          arg1.ref.pointer,
          arg2.ref.pointer,
          arg3.ref.pointer);
}

typedef _DidFinishWithLock = ffi.Pointer<objc.ObjCBlockImpl>;
typedef Dart_DidFinishWithLock = objc.ObjCBlock<
    ffi.Void Function(
        NSCondition, NSURLSession, NSURLSessionDownloadTask, objc.NSURL)>;

const int noErr = 0;

const int kNilOptions = 0;

const int kVariableLengthArray = 1;

const int kUnknownType = 1061109567;

const int normal = 0;

const int bold = 1;

const int italic = 2;

const int underline = 4;

const int outline = 8;

const int shadow = 16;

const int condense = 32;

const int extend = 64;

const int developStage = 32;

const int alphaStage = 64;

const int betaStage = 96;

const int finalStage = 128;

const int NSScannedOption = 1;

const int NSCollectorDisabledOption = 2;

const int noErr1 = 0;

const int kNilOptions1 = 0;

const int kVariableLengthArray1 = 1;

const int kUnknownType1 = 1061109567;

const int normal1 = 0;

const int bold1 = 1;

const int italic1 = 2;

const int underline1 = 4;

const int outline1 = 8;

const int shadow1 = 16;

const int condense1 = 32;

const int extend1 = 64;

const int developStage1 = 32;

const int alphaStage1 = 64;

const int betaStage1 = 96;

const int finalStage1 = 128;

const int NSScannedOption1 = 1;

const int NSCollectorDisabledOption1 = 2;

const int noErr2 = 0;

const int kNilOptions2 = 0;

const int kVariableLengthArray2 = 1;

const int kUnknownType2 = 1061109567;

const int normal2 = 0;

const int bold2 = 1;

const int italic2 = 2;

const int underline2 = 4;

const int outline2 = 8;

const int shadow2 = 16;

const int condense2 = 32;

const int extend2 = 64;

const int developStage2 = 32;

const int alphaStage2 = 64;

const int betaStage2 = 96;

const int finalStage2 = 128;

const int NSScannedOption2 = 1;

const int NSCollectorDisabledOption2 = 2;

const int errSecSuccess = 0;

const int errSecUnimplemented = -4;

const int errSecDiskFull = -34;

const int errSecDskFull = -34;

const int errSecIO = -36;

const int errSecOpWr = -49;

const int errSecParam = -50;

const int errSecWrPerm = -61;

const int errSecAllocate = -108;

const int errSecUserCanceled = -128;

const int errSecBadReq = -909;

const int errSecInternalComponent = -2070;

const int errSecCoreFoundationUnknown = -4960;

const int errSecMissingEntitlement = -34018;

const int errSecRestrictedAPI = -34020;

const int errSecNotAvailable = -25291;

const int errSecReadOnly = -25292;

const int errSecAuthFailed = -25293;

const int errSecNoSuchKeychain = -25294;

const int errSecInvalidKeychain = -25295;

const int errSecDuplicateKeychain = -25296;

const int errSecDuplicateCallback = -25297;

const int errSecInvalidCallback = -25298;

const int errSecDuplicateItem = -25299;

const int errSecItemNotFound = -25300;

const int errSecBufferTooSmall = -25301;

const int errSecDataTooLarge = -25302;

const int errSecNoSuchAttr = -25303;

const int errSecInvalidItemRef = -25304;

const int errSecInvalidSearchRef = -25305;

const int errSecNoSuchClass = -25306;

const int errSecNoDefaultKeychain = -25307;

const int errSecInteractionNotAllowed = -25308;

const int errSecReadOnlyAttr = -25309;

const int errSecWrongSecVersion = -25310;

const int errSecKeySizeNotAllowed = -25311;

const int errSecNoStorageModule = -25312;

const int errSecNoCertificateModule = -25313;

const int errSecNoPolicyModule = -25314;

const int errSecInteractionRequired = -25315;

const int errSecDataNotAvailable = -25316;

const int errSecDataNotModifiable = -25317;

const int errSecCreateChainFailed = -25318;

const int errSecInvalidPrefsDomain = -25319;

const int errSecInDarkWake = -25320;

const int errSecACLNotSimple = -25240;

const int errSecPolicyNotFound = -25241;

const int errSecInvalidTrustSetting = -25242;

const int errSecNoAccessForItem = -25243;

const int errSecInvalidOwnerEdit = -25244;

const int errSecTrustNotAvailable = -25245;

const int errSecUnsupportedFormat = -25256;

const int errSecUnknownFormat = -25257;

const int errSecKeyIsSensitive = -25258;

const int errSecMultiplePrivKeys = -25259;

const int errSecPassphraseRequired = -25260;

const int errSecInvalidPasswordRef = -25261;

const int errSecInvalidTrustSettings = -25262;

const int errSecNoTrustSettings = -25263;

const int errSecPkcs12VerifyFailure = -25264;

const int errSecNotSigner = -26267;

const int errSecDecode = -26275;

const int errSecServiceNotAvailable = -67585;

const int errSecInsufficientClientID = -67586;

const int errSecDeviceReset = -67587;

const int errSecDeviceFailed = -67588;

const int errSecAppleAddAppACLSubject = -67589;

const int errSecApplePublicKeyIncomplete = -67590;

const int errSecAppleSignatureMismatch = -67591;

const int errSecAppleInvalidKeyStartDate = -67592;

const int errSecAppleInvalidKeyEndDate = -67593;

const int errSecConversionError = -67594;

const int errSecAppleSSLv2Rollback = -67595;

const int errSecQuotaExceeded = -67596;

const int errSecFileTooBig = -67597;

const int errSecInvalidDatabaseBlob = -67598;

const int errSecInvalidKeyBlob = -67599;

const int errSecIncompatibleDatabaseBlob = -67600;

const int errSecIncompatibleKeyBlob = -67601;

const int errSecHostNameMismatch = -67602;

const int errSecUnknownCriticalExtensionFlag = -67603;

const int errSecNoBasicConstraints = -67604;

const int errSecNoBasicConstraintsCA = -67605;

const int errSecInvalidAuthorityKeyID = -67606;

const int errSecInvalidSubjectKeyID = -67607;

const int errSecInvalidKeyUsageForPolicy = -67608;

const int errSecInvalidExtendedKeyUsage = -67609;

const int errSecInvalidIDLinkage = -67610;

const int errSecPathLengthConstraintExceeded = -67611;

const int errSecInvalidRoot = -67612;

const int errSecCRLExpired = -67613;

const int errSecCRLNotValidYet = -67614;

const int errSecCRLNotFound = -67615;

const int errSecCRLServerDown = -67616;

const int errSecCRLBadURI = -67617;

const int errSecUnknownCertExtension = -67618;

const int errSecUnknownCRLExtension = -67619;

const int errSecCRLNotTrusted = -67620;

const int errSecCRLPolicyFailed = -67621;

const int errSecIDPFailure = -67622;

const int errSecSMIMEEmailAddressesNotFound = -67623;

const int errSecSMIMEBadExtendedKeyUsage = -67624;

const int errSecSMIMEBadKeyUsage = -67625;

const int errSecSMIMEKeyUsageNotCritical = -67626;

const int errSecSMIMENoEmailAddress = -67627;

const int errSecSMIMESubjAltNameNotCritical = -67628;

const int errSecSSLBadExtendedKeyUsage = -67629;

const int errSecOCSPBadResponse = -67630;

const int errSecOCSPBadRequest = -67631;

const int errSecOCSPUnavailable = -67632;

const int errSecOCSPStatusUnrecognized = -67633;

const int errSecEndOfData = -67634;

const int errSecIncompleteCertRevocationCheck = -67635;

const int errSecNetworkFailure = -67636;

const int errSecOCSPNotTrustedToAnchor = -67637;

const int errSecRecordModified = -67638;

const int errSecOCSPSignatureError = -67639;

const int errSecOCSPNoSigner = -67640;

const int errSecOCSPResponderMalformedReq = -67641;

const int errSecOCSPResponderInternalError = -67642;

const int errSecOCSPResponderTryLater = -67643;

const int errSecOCSPResponderSignatureRequired = -67644;

const int errSecOCSPResponderUnauthorized = -67645;

const int errSecOCSPResponseNonceMismatch = -67646;

const int errSecCodeSigningBadCertChainLength = -67647;

const int errSecCodeSigningNoBasicConstraints = -67648;

const int errSecCodeSigningBadPathLengthConstraint = -67649;

const int errSecCodeSigningNoExtendedKeyUsage = -67650;

const int errSecCodeSigningDevelopment = -67651;

const int errSecResourceSignBadCertChainLength = -67652;

const int errSecResourceSignBadExtKeyUsage = -67653;

const int errSecTrustSettingDeny = -67654;

const int errSecInvalidSubjectName = -67655;

const int errSecUnknownQualifiedCertStatement = -67656;

const int errSecMobileMeRequestQueued = -67657;

const int errSecMobileMeRequestRedirected = -67658;

const int errSecMobileMeServerError = -67659;

const int errSecMobileMeServerNotAvailable = -67660;

const int errSecMobileMeServerAlreadyExists = -67661;

const int errSecMobileMeServerServiceErr = -67662;

const int errSecMobileMeRequestAlreadyPending = -67663;

const int errSecMobileMeNoRequestPending = -67664;

const int errSecMobileMeCSRVerifyFailure = -67665;

const int errSecMobileMeFailedConsistencyCheck = -67666;

const int errSecNotInitialized = -67667;

const int errSecInvalidHandleUsage = -67668;

const int errSecPVCReferentNotFound = -67669;

const int errSecFunctionIntegrityFail = -67670;

const int errSecInternalError = -67671;

const int errSecMemoryError = -67672;

const int errSecInvalidData = -67673;

const int errSecMDSError = -67674;

const int errSecInvalidPointer = -67675;

const int errSecSelfCheckFailed = -67676;

const int errSecFunctionFailed = -67677;

const int errSecModuleManifestVerifyFailed = -67678;

const int errSecInvalidGUID = -67679;

const int errSecInvalidHandle = -67680;

const int errSecInvalidDBList = -67681;

const int errSecInvalidPassthroughID = -67682;

const int errSecInvalidNetworkAddress = -67683;

const int errSecCRLAlreadySigned = -67684;

const int errSecInvalidNumberOfFields = -67685;

const int errSecVerificationFailure = -67686;

const int errSecUnknownTag = -67687;

const int errSecInvalidSignature = -67688;

const int errSecInvalidName = -67689;

const int errSecInvalidCertificateRef = -67690;

const int errSecInvalidCertificateGroup = -67691;

const int errSecTagNotFound = -67692;

const int errSecInvalidQuery = -67693;

const int errSecInvalidValue = -67694;

const int errSecCallbackFailed = -67695;

const int errSecACLDeleteFailed = -67696;

const int errSecACLReplaceFailed = -67697;

const int errSecACLAddFailed = -67698;

const int errSecACLChangeFailed = -67699;

const int errSecInvalidAccessCredentials = -67700;

const int errSecInvalidRecord = -67701;

const int errSecInvalidACL = -67702;

const int errSecInvalidSampleValue = -67703;

const int errSecIncompatibleVersion = -67704;

const int errSecPrivilegeNotGranted = -67705;

const int errSecInvalidScope = -67706;

const int errSecPVCAlreadyConfigured = -67707;

const int errSecInvalidPVC = -67708;

const int errSecEMMLoadFailed = -67709;

const int errSecEMMUnloadFailed = -67710;

const int errSecAddinLoadFailed = -67711;

const int errSecInvalidKeyRef = -67712;

const int errSecInvalidKeyHierarchy = -67713;

const int errSecAddinUnloadFailed = -67714;

const int errSecLibraryReferenceNotFound = -67715;

const int errSecInvalidAddinFunctionTable = -67716;

const int errSecInvalidServiceMask = -67717;

const int errSecModuleNotLoaded = -67718;

const int errSecInvalidSubServiceID = -67719;

const int errSecAttributeNotInContext = -67720;

const int errSecModuleManagerInitializeFailed = -67721;

const int errSecModuleManagerNotFound = -67722;

const int errSecEventNotificationCallbackNotFound = -67723;

const int errSecInputLengthError = -67724;

const int errSecOutputLengthError = -67725;

const int errSecPrivilegeNotSupported = -67726;

const int errSecDeviceError = -67727;

const int errSecAttachHandleBusy = -67728;

const int errSecNotLoggedIn = -67729;

const int errSecAlgorithmMismatch = -67730;

const int errSecKeyUsageIncorrect = -67731;

const int errSecKeyBlobTypeIncorrect = -67732;

const int errSecKeyHeaderInconsistent = -67733;

const int errSecUnsupportedKeyFormat = -67734;

const int errSecUnsupportedKeySize = -67735;

const int errSecInvalidKeyUsageMask = -67736;

const int errSecUnsupportedKeyUsageMask = -67737;

const int errSecInvalidKeyAttributeMask = -67738;

const int errSecUnsupportedKeyAttributeMask = -67739;

const int errSecInvalidKeyLabel = -67740;

const int errSecUnsupportedKeyLabel = -67741;

const int errSecInvalidKeyFormat = -67742;

const int errSecUnsupportedVectorOfBuffers = -67743;

const int errSecInvalidInputVector = -67744;

const int errSecInvalidOutputVector = -67745;

const int errSecInvalidContext = -67746;

const int errSecInvalidAlgorithm = -67747;

const int errSecInvalidAttributeKey = -67748;

const int errSecMissingAttributeKey = -67749;

const int errSecInvalidAttributeInitVector = -67750;

const int errSecMissingAttributeInitVector = -67751;

const int errSecInvalidAttributeSalt = -67752;

const int errSecMissingAttributeSalt = -67753;

const int errSecInvalidAttributePadding = -67754;

const int errSecMissingAttributePadding = -67755;

const int errSecInvalidAttributeRandom = -67756;

const int errSecMissingAttributeRandom = -67757;

const int errSecInvalidAttributeSeed = -67758;

const int errSecMissingAttributeSeed = -67759;

const int errSecInvalidAttributePassphrase = -67760;

const int errSecMissingAttributePassphrase = -67761;

const int errSecInvalidAttributeKeyLength = -67762;

const int errSecMissingAttributeKeyLength = -67763;

const int errSecInvalidAttributeBlockSize = -67764;

const int errSecMissingAttributeBlockSize = -67765;

const int errSecInvalidAttributeOutputSize = -67766;

const int errSecMissingAttributeOutputSize = -67767;

const int errSecInvalidAttributeRounds = -67768;

const int errSecMissingAttributeRounds = -67769;

const int errSecInvalidAlgorithmParms = -67770;

const int errSecMissingAlgorithmParms = -67771;

const int errSecInvalidAttributeLabel = -67772;

const int errSecMissingAttributeLabel = -67773;

const int errSecInvalidAttributeKeyType = -67774;

const int errSecMissingAttributeKeyType = -67775;

const int errSecInvalidAttributeMode = -67776;

const int errSecMissingAttributeMode = -67777;

const int errSecInvalidAttributeEffectiveBits = -67778;

const int errSecMissingAttributeEffectiveBits = -67779;

const int errSecInvalidAttributeStartDate = -67780;

const int errSecMissingAttributeStartDate = -67781;

const int errSecInvalidAttributeEndDate = -67782;

const int errSecMissingAttributeEndDate = -67783;

const int errSecInvalidAttributeVersion = -67784;

const int errSecMissingAttributeVersion = -67785;

const int errSecInvalidAttributePrime = -67786;

const int errSecMissingAttributePrime = -67787;

const int errSecInvalidAttributeBase = -67788;

const int errSecMissingAttributeBase = -67789;

const int errSecInvalidAttributeSubprime = -67790;

const int errSecMissingAttributeSubprime = -67791;

const int errSecInvalidAttributeIterationCount = -67792;

const int errSecMissingAttributeIterationCount = -67793;

const int errSecInvalidAttributeDLDBHandle = -67794;

const int errSecMissingAttributeDLDBHandle = -67795;

const int errSecInvalidAttributeAccessCredentials = -67796;

const int errSecMissingAttributeAccessCredentials = -67797;

const int errSecInvalidAttributePublicKeyFormat = -67798;

const int errSecMissingAttributePublicKeyFormat = -67799;

const int errSecInvalidAttributePrivateKeyFormat = -67800;

const int errSecMissingAttributePrivateKeyFormat = -67801;

const int errSecInvalidAttributeSymmetricKeyFormat = -67802;

const int errSecMissingAttributeSymmetricKeyFormat = -67803;

const int errSecInvalidAttributeWrappedKeyFormat = -67804;

const int errSecMissingAttributeWrappedKeyFormat = -67805;

const int errSecStagedOperationInProgress = -67806;

const int errSecStagedOperationNotStarted = -67807;

const int errSecVerifyFailed = -67808;

const int errSecQuerySizeUnknown = -67809;

const int errSecBlockSizeMismatch = -67810;

const int errSecPublicKeyInconsistent = -67811;

const int errSecDeviceVerifyFailed = -67812;

const int errSecInvalidLoginName = -67813;

const int errSecAlreadyLoggedIn = -67814;

const int errSecInvalidDigestAlgorithm = -67815;

const int errSecInvalidCRLGroup = -67816;

const int errSecCertificateCannotOperate = -67817;

const int errSecCertificateExpired = -67818;

const int errSecCertificateNotValidYet = -67819;

const int errSecCertificateRevoked = -67820;

const int errSecCertificateSuspended = -67821;

const int errSecInsufficientCredentials = -67822;

const int errSecInvalidAction = -67823;

const int errSecInvalidAuthority = -67824;

const int errSecVerifyActionFailed = -67825;

const int errSecInvalidCertAuthority = -67826;

const int errSecInvalidCRLAuthority = -67827;

const int errSecInvaldCRLAuthority = -67827;

const int errSecInvalidCRLEncoding = -67828;

const int errSecInvalidCRLType = -67829;

const int errSecInvalidCRL = -67830;

const int errSecInvalidFormType = -67831;

const int errSecInvalidID = -67832;

const int errSecInvalidIdentifier = -67833;

const int errSecInvalidIndex = -67834;

const int errSecInvalidPolicyIdentifiers = -67835;

const int errSecInvalidTimeString = -67836;

const int errSecInvalidReason = -67837;

const int errSecInvalidRequestInputs = -67838;

const int errSecInvalidResponseVector = -67839;

const int errSecInvalidStopOnPolicy = -67840;

const int errSecInvalidTuple = -67841;

const int errSecMultipleValuesUnsupported = -67842;

const int errSecNotTrusted = -67843;

const int errSecNoDefaultAuthority = -67844;

const int errSecRejectedForm = -67845;

const int errSecRequestLost = -67846;

const int errSecRequestRejected = -67847;

const int errSecUnsupportedAddressType = -67848;

const int errSecUnsupportedService = -67849;

const int errSecInvalidTupleGroup = -67850;

const int errSecInvalidBaseACLs = -67851;

const int errSecInvalidTupleCredentials = -67852;

const int errSecInvalidTupleCredendtials = -67852;

const int errSecInvalidEncoding = -67853;

const int errSecInvalidValidityPeriod = -67854;

const int errSecInvalidRequestor = -67855;

const int errSecRequestDescriptor = -67856;

const int errSecInvalidBundleInfo = -67857;

const int errSecInvalidCRLIndex = -67858;

const int errSecNoFieldValues = -67859;

const int errSecUnsupportedFieldFormat = -67860;

const int errSecUnsupportedIndexInfo = -67861;

const int errSecUnsupportedLocality = -67862;

const int errSecUnsupportedNumAttributes = -67863;

const int errSecUnsupportedNumIndexes = -67864;

const int errSecUnsupportedNumRecordTypes = -67865;

const int errSecFieldSpecifiedMultiple = -67866;

const int errSecIncompatibleFieldFormat = -67867;

const int errSecInvalidParsingModule = -67868;

const int errSecDatabaseLocked = -67869;

const int errSecDatastoreIsOpen = -67870;

const int errSecMissingValue = -67871;

const int errSecUnsupportedQueryLimits = -67872;

const int errSecUnsupportedNumSelectionPreds = -67873;

const int errSecUnsupportedOperator = -67874;

const int errSecInvalidDBLocation = -67875;

const int errSecInvalidAccessRequest = -67876;

const int errSecInvalidIndexInfo = -67877;

const int errSecInvalidNewOwner = -67878;

const int errSecInvalidModifyMode = -67879;

const int errSecMissingRequiredExtension = -67880;

const int errSecExtendedKeyUsageNotCritical = -67881;

const int errSecTimestampMissing = -67882;

const int errSecTimestampInvalid = -67883;

const int errSecTimestampNotTrusted = -67884;

const int errSecTimestampServiceNotAvailable = -67885;

const int errSecTimestampBadAlg = -67886;

const int errSecTimestampBadRequest = -67887;

const int errSecTimestampBadDataFormat = -67888;

const int errSecTimestampTimeNotAvailable = -67889;

const int errSecTimestampUnacceptedPolicy = -67890;

const int errSecTimestampUnacceptedExtension = -67891;

const int errSecTimestampAddInfoNotAvailable = -67892;

const int errSecTimestampSystemFailure = -67893;

const int errSecSigningTimeMissing = -67894;

const int errSecTimestampRejection = -67895;

const int errSecTimestampWaiting = -67896;

const int errSecTimestampRevocationWarning = -67897;

const int errSecTimestampRevocationNotification = -67898;

const int errSecCertificatePolicyNotAllowed = -67899;

const int errSecCertificateNameNotAllowed = -67900;

const int errSecCertificateValidityPeriodTooLong = -67901;

const int errSecCertificateIsCA = -67902;

const int errSecCertificateDuplicateExtension = -67903;

const int errSSLProtocol = -9800;

const int errSSLNegotiation = -9801;

const int errSSLFatalAlert = -9802;

const int errSSLWouldBlock = -9803;

const int errSSLSessionNotFound = -9804;

const int errSSLClosedGraceful = -9805;

const int errSSLClosedAbort = -9806;

const int errSSLXCertChainInvalid = -9807;

const int errSSLBadCert = -9808;

const int errSSLCrypto = -9809;

const int errSSLInternal = -9810;

const int errSSLModuleAttach = -9811;

const int errSSLUnknownRootCert = -9812;

const int errSSLNoRootCert = -9813;

const int errSSLCertExpired = -9814;

const int errSSLCertNotYetValid = -9815;

const int errSSLClosedNoNotify = -9816;

const int errSSLBufferOverflow = -9817;

const int errSSLBadCipherSuite = -9818;

const int errSSLPeerUnexpectedMsg = -9819;

const int errSSLPeerBadRecordMac = -9820;

const int errSSLPeerDecryptionFail = -9821;

const int errSSLPeerRecordOverflow = -9822;

const int errSSLPeerDecompressFail = -9823;

const int errSSLPeerHandshakeFail = -9824;

const int errSSLPeerBadCert = -9825;

const int errSSLPeerUnsupportedCert = -9826;

const int errSSLPeerCertRevoked = -9827;

const int errSSLPeerCertExpired = -9828;

const int errSSLPeerCertUnknown = -9829;

const int errSSLIllegalParam = -9830;

const int errSSLPeerUnknownCA = -9831;

const int errSSLPeerAccessDenied = -9832;

const int errSSLPeerDecodeError = -9833;

const int errSSLPeerDecryptError = -9834;

const int errSSLPeerExportRestriction = -9835;

const int errSSLPeerProtocolVersion = -9836;

const int errSSLPeerInsufficientSecurity = -9837;

const int errSSLPeerInternalError = -9838;

const int errSSLPeerUserCancelled = -9839;

const int errSSLPeerNoRenegotiation = -9840;

const int errSSLPeerAuthCompleted = -9841;

const int errSSLClientCertRequested = -9842;

const int errSSLHostNameMismatch = -9843;

const int errSSLConnectionRefused = -9844;

const int errSSLDecryptionFail = -9845;

const int errSSLBadRecordMac = -9846;

const int errSSLRecordOverflow = -9847;

const int errSSLBadConfiguration = -9848;

const int errSSLUnexpectedRecord = -9849;

const int errSSLWeakPeerEphemeralDHKey = -9850;

const int errSSLClientHelloReceived = -9851;

const int errSSLTransportReset = -9852;

const int errSSLNetworkTimeout = -9853;

const int errSSLConfigurationFailed = -9854;

const int errSSLUnsupportedExtension = -9855;

const int errSSLUnexpectedMessage = -9856;

const int errSSLDecompressFail = -9857;

const int errSSLHandshakeFail = -9858;

const int errSSLDecodeError = -9859;

const int errSSLInappropriateFallback = -9860;

const int errSSLMissingExtension = -9861;

const int errSSLBadCertificateStatusResponse = -9862;

const int errSSLCertificateRequired = -9863;

const int errSSLUnknownPSKIdentity = -9864;

const int errSSLUnrecognizedName = -9865;

const int errSSLATSViolation = -9880;

const int errSSLATSMinimumVersionViolation = -9881;

const int errSSLATSCiphersuiteViolation = -9882;

const int errSSLATSMinimumKeySizeViolation = -9883;

const int errSSLATSLeafCertificateHashAlgorithmViolation = -9884;

const int errSSLATSCertificateHashAlgorithmViolation = -9885;

const int errSSLATSCertificateTrustViolation = -9886;

const int errSSLEarlyDataRejected = -9890;

const int OSUnknownByteOrder = 0;

const int OSLittleEndian = 1;

const int OSBigEndian = 2;

const int kCFNotificationDeliverImmediately = 1;

const int kCFNotificationPostToAllSessions = 2;

const int kCFCalendarComponentsWrap = 1;

const int kCFSocketAutomaticallyReenableReadCallBack = 1;

const int kCFSocketAutomaticallyReenableAcceptCallBack = 2;

const int kCFSocketAutomaticallyReenableDataCallBack = 3;

const int kCFSocketAutomaticallyReenableWriteCallBack = 8;

const int kCFSocketLeaveErrors = 64;

const int kCFSocketCloseOnInvalidate = 128;

const int DISPATCH_WALLTIME_NOW = -2;

const int kCFPropertyListReadCorruptError = 3840;

const int kCFPropertyListReadUnknownVersionError = 3841;

const int kCFPropertyListReadStreamError = 3842;

const int kCFPropertyListWriteStreamError = 3851;

const int kCFBundleExecutableArchitectureI386 = 7;

const int kCFBundleExecutableArchitecturePPC = 18;

const int kCFBundleExecutableArchitectureX86_64 = 16777223;

const int kCFBundleExecutableArchitecturePPC64 = 16777234;

const int kCFBundleExecutableArchitectureARM64 = 16777228;

const int kCFMessagePortSuccess = 0;

const int kCFMessagePortSendTimeout = -1;

const int kCFMessagePortReceiveTimeout = -2;

const int kCFMessagePortIsInvalid = -3;

const int kCFMessagePortTransportError = -4;

const int kCFMessagePortBecameInvalidError = -5;

const int kCFStringTokenizerUnitWord = 0;

const int kCFStringTokenizerUnitSentence = 1;

const int kCFStringTokenizerUnitParagraph = 2;

const int kCFStringTokenizerUnitLineBreak = 3;

const int kCFStringTokenizerUnitWordBoundary = 4;

const int kCFStringTokenizerAttributeLatinTranscription = 65536;

const int kCFStringTokenizerAttributeLanguage = 131072;

const int kCFFileDescriptorReadCallBack = 1;

const int kCFFileDescriptorWriteCallBack = 2;

const int kCFUserNotificationStopAlertLevel = 0;

const int kCFUserNotificationNoteAlertLevel = 1;

const int kCFUserNotificationCautionAlertLevel = 2;

const int kCFUserNotificationPlainAlertLevel = 3;

const int kCFUserNotificationDefaultResponse = 0;

const int kCFUserNotificationAlternateResponse = 1;

const int kCFUserNotificationOtherResponse = 2;

const int kCFUserNotificationCancelResponse = 3;

const int kCFUserNotificationNoDefaultButtonFlag = 32;

const int kCFUserNotificationUseRadioButtonsFlag = 64;

const int kCFXMLNodeCurrentVersion = 1;

const int CSSM_INVALID_HANDLE = 0;

const int CSSM_FALSE = 0;

const int CSSM_TRUE = 1;

const int CSSM_OK = 0;

const int CSSM_MODULE_STRING_SIZE = 64;

const int CSSM_KEY_HIERARCHY_NONE = 0;

const int CSSM_KEY_HIERARCHY_INTEG = 1;

const int CSSM_KEY_HIERARCHY_EXPORT = 2;

const int CSSM_PVC_NONE = 0;

const int CSSM_PVC_APP = 1;

const int CSSM_PVC_SP = 2;

const int CSSM_PRIVILEGE_SCOPE_NONE = 0;

const int CSSM_PRIVILEGE_SCOPE_PROCESS = 1;

const int CSSM_PRIVILEGE_SCOPE_THREAD = 2;

const int CSSM_SERVICE_CSSM = 1;

const int CSSM_SERVICE_CSP = 2;

const int CSSM_SERVICE_DL = 4;

const int CSSM_SERVICE_CL = 8;

const int CSSM_SERVICE_TP = 16;

const int CSSM_SERVICE_AC = 32;

const int CSSM_SERVICE_KR = 64;

const int CSSM_NOTIFY_INSERT = 1;

const int CSSM_NOTIFY_REMOVE = 2;

const int CSSM_NOTIFY_FAULT = 3;

const int CSSM_ATTACH_READ_ONLY = 1;

const int CSSM_USEE_LAST = 255;

const int CSSM_USEE_NONE = 0;

const int CSSM_USEE_DOMESTIC = 1;

const int CSSM_USEE_FINANCIAL = 2;

const int CSSM_USEE_KRLE = 3;

const int CSSM_USEE_KRENT = 4;

const int CSSM_USEE_SSL = 5;

const int CSSM_USEE_AUTHENTICATION = 6;

const int CSSM_USEE_KEYEXCH = 7;

const int CSSM_USEE_MEDICAL = 8;

const int CSSM_USEE_INSURANCE = 9;

const int CSSM_USEE_WEAK = 10;

const int CSSM_ADDR_NONE = 0;

const int CSSM_ADDR_CUSTOM = 1;

const int CSSM_ADDR_URL = 2;

const int CSSM_ADDR_SOCKADDR = 3;

const int CSSM_ADDR_NAME = 4;

const int CSSM_NET_PROTO_NONE = 0;

const int CSSM_NET_PROTO_CUSTOM = 1;

const int CSSM_NET_PROTO_UNSPECIFIED = 2;

const int CSSM_NET_PROTO_LDAP = 3;

const int CSSM_NET_PROTO_LDAPS = 4;

const int CSSM_NET_PROTO_LDAPNS = 5;

const int CSSM_NET_PROTO_X500DAP = 6;

const int CSSM_NET_PROTO_FTP = 7;

const int CSSM_NET_PROTO_FTPS = 8;

const int CSSM_NET_PROTO_OCSP = 9;

const int CSSM_NET_PROTO_CMP = 10;

const int CSSM_NET_PROTO_CMPS = 11;

const int CSSM_WORDID__UNK_ = -1;

const int CSSM_WORDID__NLU_ = 0;

const int CSSM_WORDID__STAR_ = 1;

const int CSSM_WORDID_A = 2;

const int CSSM_WORDID_ACL = 3;

const int CSSM_WORDID_ALPHA = 4;

const int CSSM_WORDID_B = 5;

const int CSSM_WORDID_BER = 6;

const int CSSM_WORDID_BINARY = 7;

const int CSSM_WORDID_BIOMETRIC = 8;

const int CSSM_WORDID_C = 9;

const int CSSM_WORDID_CANCELED = 10;

const int CSSM_WORDID_CERT = 11;

const int CSSM_WORDID_COMMENT = 12;

const int CSSM_WORDID_CRL = 13;

const int CSSM_WORDID_CUSTOM = 14;

const int CSSM_WORDID_D = 15;

const int CSSM_WORDID_DATE = 16;

const int CSSM_WORDID_DB_DELETE = 17;

const int CSSM_WORDID_DB_EXEC_STORED_QUERY = 18;

const int CSSM_WORDID_DB_INSERT = 19;

const int CSSM_WORDID_DB_MODIFY = 20;

const int CSSM_WORDID_DB_READ = 21;

const int CSSM_WORDID_DBS_CREATE = 22;

const int CSSM_WORDID_DBS_DELETE = 23;

const int CSSM_WORDID_DECRYPT = 24;

const int CSSM_WORDID_DELETE = 25;

const int CSSM_WORDID_DELTA_CRL = 26;

const int CSSM_WORDID_DER = 27;

const int CSSM_WORDID_DERIVE = 28;

const int CSSM_WORDID_DISPLAY = 29;

const int CSSM_WORDID_DO = 30;

const int CSSM_WORDID_DSA = 31;

const int CSSM_WORDID_DSA_SHA1 = 32;

const int CSSM_WORDID_E = 33;

const int CSSM_WORDID_ELGAMAL = 34;

const int CSSM_WORDID_ENCRYPT = 35;

const int CSSM_WORDID_ENTRY = 36;

const int CSSM_WORDID_EXPORT_CLEAR = 37;

const int CSSM_WORDID_EXPORT_WRAPPED = 38;

const int CSSM_WORDID_G = 39;

const int CSSM_WORDID_GE = 40;

const int CSSM_WORDID_GENKEY = 41;

const int CSSM_WORDID_HASH = 42;

const int CSSM_WORDID_HASHED_PASSWORD = 43;

const int CSSM_WORDID_HASHED_SUBJECT = 44;

const int CSSM_WORDID_HAVAL = 45;

const int CSSM_WORDID_IBCHASH = 46;

const int CSSM_WORDID_IMPORT_CLEAR = 47;

const int CSSM_WORDID_IMPORT_WRAPPED = 48;

const int CSSM_WORDID_INTEL = 49;

const int CSSM_WORDID_ISSUER = 50;

const int CSSM_WORDID_ISSUER_INFO = 51;

const int CSSM_WORDID_K_OF_N = 52;

const int CSSM_WORDID_KEA = 53;

const int CSSM_WORDID_KEYHOLDER = 54;

const int CSSM_WORDID_L = 55;

const int CSSM_WORDID_LE = 56;

const int CSSM_WORDID_LOGIN = 57;

const int CSSM_WORDID_LOGIN_NAME = 58;

const int CSSM_WORDID_MAC = 59;

const int CSSM_WORDID_MD2 = 60;

const int CSSM_WORDID_MD2WITHRSA = 61;

const int CSSM_WORDID_MD4 = 62;

const int CSSM_WORDID_MD5 = 63;

const int CSSM_WORDID_MD5WITHRSA = 64;

const int CSSM_WORDID_N = 65;

const int CSSM_WORDID_NAME = 66;

const int CSSM_WORDID_NDR = 67;

const int CSSM_WORDID_NHASH = 68;

const int CSSM_WORDID_NOT_AFTER = 69;

const int CSSM_WORDID_NOT_BEFORE = 70;

const int CSSM_WORDID_NULL = 71;

const int CSSM_WORDID_NUMERIC = 72;

const int CSSM_WORDID_OBJECT_HASH = 73;

const int CSSM_WORDID_ONE_TIME = 74;

const int CSSM_WORDID_ONLINE = 75;

const int CSSM_WORDID_OWNER = 76;

const int CSSM_WORDID_P = 77;

const int CSSM_WORDID_PAM_NAME = 78;

const int CSSM_WORDID_PASSWORD = 79;

const int CSSM_WORDID_PGP = 80;

const int CSSM_WORDID_PREFIX = 81;

const int CSSM_WORDID_PRIVATE_KEY = 82;

const int CSSM_WORDID_PROMPTED_BIOMETRIC = 83;

const int CSSM_WORDID_PROMPTED_PASSWORD = 84;

const int CSSM_WORDID_PROPAGATE = 85;

const int CSSM_WORDID_PROTECTED_BIOMETRIC = 86;

const int CSSM_WORDID_PROTECTED_PASSWORD = 87;

const int CSSM_WORDID_PROTECTED_PIN = 88;

const int CSSM_WORDID_PUBLIC_KEY = 89;

const int CSSM_WORDID_PUBLIC_KEY_FROM_CERT = 90;

const int CSSM_WORDID_Q = 91;

const int CSSM_WORDID_RANGE = 92;

const int CSSM_WORDID_REVAL = 93;

const int CSSM_WORDID_RIPEMAC = 94;

const int CSSM_WORDID_RIPEMD = 95;

const int CSSM_WORDID_RIPEMD160 = 96;

const int CSSM_WORDID_RSA = 97;

const int CSSM_WORDID_RSA_ISO9796 = 98;

const int CSSM_WORDID_RSA_PKCS = 99;

const int CSSM_WORDID_RSA_PKCS_MD5 = 100;

const int CSSM_WORDID_RSA_PKCS_SHA1 = 101;

const int CSSM_WORDID_RSA_PKCS1 = 102;

const int CSSM_WORDID_RSA_PKCS1_MD5 = 103;

const int CSSM_WORDID_RSA_PKCS1_SHA1 = 104;

const int CSSM_WORDID_RSA_PKCS1_SIG = 105;

const int CSSM_WORDID_RSA_RAW = 106;

const int CSSM_WORDID_SDSIV1 = 107;

const int CSSM_WORDID_SEQUENCE = 108;

const int CSSM_WORDID_SET = 109;

const int CSSM_WORDID_SEXPR = 110;

const int CSSM_WORDID_SHA1 = 111;

const int CSSM_WORDID_SHA1WITHDSA = 112;

const int CSSM_WORDID_SHA1WITHECDSA = 113;

const int CSSM_WORDID_SHA1WITHRSA = 114;

const int CSSM_WORDID_SIGN = 115;

const int CSSM_WORDID_SIGNATURE = 116;

const int CSSM_WORDID_SIGNED_NONCE = 117;

const int CSSM_WORDID_SIGNED_SECRET = 118;

const int CSSM_WORDID_SPKI = 119;

const int CSSM_WORDID_SUBJECT = 120;

const int CSSM_WORDID_SUBJECT_INFO = 121;

const int CSSM_WORDID_TAG = 122;

const int CSSM_WORDID_THRESHOLD = 123;

const int CSSM_WORDID_TIME = 124;

const int CSSM_WORDID_URI = 125;

const int CSSM_WORDID_VERSION = 126;

const int CSSM_WORDID_X509_ATTRIBUTE = 127;

const int CSSM_WORDID_X509V1 = 128;

const int CSSM_WORDID_X509V2 = 129;

const int CSSM_WORDID_X509V3 = 130;

const int CSSM_WORDID_X9_ATTRIBUTE = 131;

const int CSSM_WORDID_VENDOR_START = 65536;

const int CSSM_WORDID_VENDOR_END = 2147418112;

const int CSSM_LIST_ELEMENT_DATUM = 0;

const int CSSM_LIST_ELEMENT_SUBLIST = 1;

const int CSSM_LIST_ELEMENT_WORDID = 2;

const int CSSM_LIST_TYPE_UNKNOWN = 0;

const int CSSM_LIST_TYPE_CUSTOM = 1;

const int CSSM_LIST_TYPE_SEXPR = 2;

const int CSSM_SAMPLE_TYPE_PASSWORD = 79;

const int CSSM_SAMPLE_TYPE_HASHED_PASSWORD = 43;

const int CSSM_SAMPLE_TYPE_PROTECTED_PASSWORD = 87;

const int CSSM_SAMPLE_TYPE_PROMPTED_PASSWORD = 84;

const int CSSM_SAMPLE_TYPE_SIGNED_NONCE = 117;

const int CSSM_SAMPLE_TYPE_SIGNED_SECRET = 118;

const int CSSM_SAMPLE_TYPE_BIOMETRIC = 8;

const int CSSM_SAMPLE_TYPE_PROTECTED_BIOMETRIC = 86;

const int CSSM_SAMPLE_TYPE_PROMPTED_BIOMETRIC = 83;

const int CSSM_SAMPLE_TYPE_THRESHOLD = 123;

const int CSSM_CERT_UNKNOWN = 0;

const int CSSM_CERT_X_509v1 = 1;

const int CSSM_CERT_X_509v2 = 2;

const int CSSM_CERT_X_509v3 = 3;

const int CSSM_CERT_PGP = 4;

const int CSSM_CERT_SPKI = 5;

const int CSSM_CERT_SDSIv1 = 6;

const int CSSM_CERT_Intel = 8;

const int CSSM_CERT_X_509_ATTRIBUTE = 9;

const int CSSM_CERT_X9_ATTRIBUTE = 10;

const int CSSM_CERT_TUPLE = 11;

const int CSSM_CERT_ACL_ENTRY = 12;

const int CSSM_CERT_MULTIPLE = 32766;

const int CSSM_CERT_LAST = 32767;

const int CSSM_CL_CUSTOM_CERT_TYPE = 32768;

const int CSSM_CERT_ENCODING_UNKNOWN = 0;

const int CSSM_CERT_ENCODING_CUSTOM = 1;

const int CSSM_CERT_ENCODING_BER = 2;

const int CSSM_CERT_ENCODING_DER = 3;

const int CSSM_CERT_ENCODING_NDR = 4;

const int CSSM_CERT_ENCODING_SEXPR = 5;

const int CSSM_CERT_ENCODING_PGP = 6;

const int CSSM_CERT_ENCODING_MULTIPLE = 32766;

const int CSSM_CERT_ENCODING_LAST = 32767;

const int CSSM_CL_CUSTOM_CERT_ENCODING = 32768;

const int CSSM_CERT_PARSE_FORMAT_NONE = 0;

const int CSSM_CERT_PARSE_FORMAT_CUSTOM = 1;

const int CSSM_CERT_PARSE_FORMAT_SEXPR = 2;

const int CSSM_CERT_PARSE_FORMAT_COMPLEX = 3;

const int CSSM_CERT_PARSE_FORMAT_OID_NAMED = 4;

const int CSSM_CERT_PARSE_FORMAT_TUPLE = 5;

const int CSSM_CERT_PARSE_FORMAT_MULTIPLE = 32766;

const int CSSM_CERT_PARSE_FORMAT_LAST = 32767;

const int CSSM_CL_CUSTOM_CERT_PARSE_FORMAT = 32768;

const int CSSM_CERTGROUP_DATA = 0;

const int CSSM_CERTGROUP_ENCODED_CERT = 1;

const int CSSM_CERTGROUP_PARSED_CERT = 2;

const int CSSM_CERTGROUP_CERT_PAIR = 3;

const int CSSM_ACL_SUBJECT_TYPE_ANY = 1;

const int CSSM_ACL_SUBJECT_TYPE_THRESHOLD = 123;

const int CSSM_ACL_SUBJECT_TYPE_PASSWORD = 79;

const int CSSM_ACL_SUBJECT_TYPE_PROTECTED_PASSWORD = 87;

const int CSSM_ACL_SUBJECT_TYPE_PROMPTED_PASSWORD = 84;

const int CSSM_ACL_SUBJECT_TYPE_PUBLIC_KEY = 89;

const int CSSM_ACL_SUBJECT_TYPE_HASHED_SUBJECT = 44;

const int CSSM_ACL_SUBJECT_TYPE_BIOMETRIC = 8;

const int CSSM_ACL_SUBJECT_TYPE_PROTECTED_BIOMETRIC = 86;

const int CSSM_ACL_SUBJECT_TYPE_PROMPTED_BIOMETRIC = 83;

const int CSSM_ACL_SUBJECT_TYPE_LOGIN_NAME = 58;

const int CSSM_ACL_SUBJECT_TYPE_EXT_PAM_NAME = 78;

const int CSSM_ACL_AUTHORIZATION_TAG_VENDOR_DEFINED_START = 65536;

const int CSSM_ACL_AUTHORIZATION_ANY = 1;

const int CSSM_ACL_AUTHORIZATION_LOGIN = 57;

const int CSSM_ACL_AUTHORIZATION_GENKEY = 41;

const int CSSM_ACL_AUTHORIZATION_DELETE = 25;

const int CSSM_ACL_AUTHORIZATION_EXPORT_WRAPPED = 38;

const int CSSM_ACL_AUTHORIZATION_EXPORT_CLEAR = 37;

const int CSSM_ACL_AUTHORIZATION_IMPORT_WRAPPED = 48;

const int CSSM_ACL_AUTHORIZATION_IMPORT_CLEAR = 47;

const int CSSM_ACL_AUTHORIZATION_SIGN = 115;

const int CSSM_ACL_AUTHORIZATION_ENCRYPT = 35;

const int CSSM_ACL_AUTHORIZATION_DECRYPT = 24;

const int CSSM_ACL_AUTHORIZATION_MAC = 59;

const int CSSM_ACL_AUTHORIZATION_DERIVE = 28;

const int CSSM_ACL_AUTHORIZATION_DBS_CREATE = 22;

const int CSSM_ACL_AUTHORIZATION_DBS_DELETE = 23;

const int CSSM_ACL_AUTHORIZATION_DB_READ = 21;

const int CSSM_ACL_AUTHORIZATION_DB_INSERT = 19;

const int CSSM_ACL_AUTHORIZATION_DB_MODIFY = 20;

const int CSSM_ACL_AUTHORIZATION_DB_DELETE = 17;

const int CSSM_ACL_EDIT_MODE_ADD = 1;

const int CSSM_ACL_EDIT_MODE_DELETE = 2;

const int CSSM_ACL_EDIT_MODE_REPLACE = 3;

const int CSSM_KEYHEADER_VERSION = 2;

const int CSSM_KEYBLOB_RAW = 0;

const int CSSM_KEYBLOB_REFERENCE = 2;

const int CSSM_KEYBLOB_WRAPPED = 3;

const int CSSM_KEYBLOB_OTHER = -1;

const int CSSM_KEYBLOB_RAW_FORMAT_NONE = 0;

const int CSSM_KEYBLOB_RAW_FORMAT_PKCS1 = 1;

const int CSSM_KEYBLOB_RAW_FORMAT_PKCS3 = 2;

const int CSSM_KEYBLOB_RAW_FORMAT_MSCAPI = 3;

const int CSSM_KEYBLOB_RAW_FORMAT_PGP = 4;

const int CSSM_KEYBLOB_RAW_FORMAT_FIPS186 = 5;

const int CSSM_KEYBLOB_RAW_FORMAT_BSAFE = 6;

const int CSSM_KEYBLOB_RAW_FORMAT_CCA = 9;

const int CSSM_KEYBLOB_RAW_FORMAT_PKCS8 = 10;

const int CSSM_KEYBLOB_RAW_FORMAT_SPKI = 11;

const int CSSM_KEYBLOB_RAW_FORMAT_OCTET_STRING = 12;

const int CSSM_KEYBLOB_RAW_FORMAT_OTHER = -1;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_NONE = 0;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_PKCS8 = 1;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_PKCS7 = 2;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_MSCAPI = 3;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_OTHER = -1;

const int CSSM_KEYBLOB_REF_FORMAT_INTEGER = 0;

const int CSSM_KEYBLOB_REF_FORMAT_STRING = 1;

const int CSSM_KEYBLOB_REF_FORMAT_SPKI = 2;

const int CSSM_KEYBLOB_REF_FORMAT_OTHER = -1;

const int CSSM_KEYCLASS_PUBLIC_KEY = 0;

const int CSSM_KEYCLASS_PRIVATE_KEY = 1;

const int CSSM_KEYCLASS_SESSION_KEY = 2;

const int CSSM_KEYCLASS_SECRET_PART = 3;

const int CSSM_KEYCLASS_OTHER = -1;

const int CSSM_KEYATTR_RETURN_DEFAULT = 0;

const int CSSM_KEYATTR_RETURN_DATA = 268435456;

const int CSSM_KEYATTR_RETURN_REF = 536870912;

const int CSSM_KEYATTR_RETURN_NONE = 1073741824;

const int CSSM_KEYATTR_PERMANENT = 1;

const int CSSM_KEYATTR_PRIVATE = 2;

const int CSSM_KEYATTR_MODIFIABLE = 4;

const int CSSM_KEYATTR_SENSITIVE = 8;

const int CSSM_KEYATTR_EXTRACTABLE = 32;

const int CSSM_KEYATTR_ALWAYS_SENSITIVE = 16;

const int CSSM_KEYATTR_NEVER_EXTRACTABLE = 64;

const int CSSM_KEYUSE_ANY = -2147483648;

const int CSSM_KEYUSE_ENCRYPT = 1;

const int CSSM_KEYUSE_DECRYPT = 2;

const int CSSM_KEYUSE_SIGN = 4;

const int CSSM_KEYUSE_VERIFY = 8;

const int CSSM_KEYUSE_SIGN_RECOVER = 16;

const int CSSM_KEYUSE_VERIFY_RECOVER = 32;

const int CSSM_KEYUSE_WRAP = 64;

const int CSSM_KEYUSE_UNWRAP = 128;

const int CSSM_KEYUSE_DERIVE = 256;

const int CSSM_ALGID_NONE = 0;

const int CSSM_ALGID_CUSTOM = 1;

const int CSSM_ALGID_DH = 2;

const int CSSM_ALGID_PH = 3;

const int CSSM_ALGID_KEA = 4;

const int CSSM_ALGID_MD2 = 5;

const int CSSM_ALGID_MD4 = 6;

const int CSSM_ALGID_MD5 = 7;

const int CSSM_ALGID_SHA1 = 8;

const int CSSM_ALGID_NHASH = 9;

const int CSSM_ALGID_HAVAL = 10;

const int CSSM_ALGID_RIPEMD = 11;

const int CSSM_ALGID_IBCHASH = 12;

const int CSSM_ALGID_RIPEMAC = 13;

const int CSSM_ALGID_DES = 14;

const int CSSM_ALGID_DESX = 15;

const int CSSM_ALGID_RDES = 16;

const int CSSM_ALGID_3DES_3KEY_EDE = 17;

const int CSSM_ALGID_3DES_2KEY_EDE = 18;

const int CSSM_ALGID_3DES_1KEY_EEE = 19;

const int CSSM_ALGID_3DES_3KEY = 17;

const int CSSM_ALGID_3DES_3KEY_EEE = 20;

const int CSSM_ALGID_3DES_2KEY = 18;

const int CSSM_ALGID_3DES_2KEY_EEE = 21;

const int CSSM_ALGID_3DES_1KEY = 20;

const int CSSM_ALGID_IDEA = 22;

const int CSSM_ALGID_RC2 = 23;

const int CSSM_ALGID_RC5 = 24;

const int CSSM_ALGID_RC4 = 25;

const int CSSM_ALGID_SEAL = 26;

const int CSSM_ALGID_CAST = 27;

const int CSSM_ALGID_BLOWFISH = 28;

const int CSSM_ALGID_SKIPJACK = 29;

const int CSSM_ALGID_LUCIFER = 30;

const int CSSM_ALGID_MADRYGA = 31;

const int CSSM_ALGID_FEAL = 32;

const int CSSM_ALGID_REDOC = 33;

const int CSSM_ALGID_REDOC3 = 34;

const int CSSM_ALGID_LOKI = 35;

const int CSSM_ALGID_KHUFU = 36;

const int CSSM_ALGID_KHAFRE = 37;

const int CSSM_ALGID_MMB = 38;

const int CSSM_ALGID_GOST = 39;

const int CSSM_ALGID_SAFER = 40;

const int CSSM_ALGID_CRAB = 41;

const int CSSM_ALGID_RSA = 42;

const int CSSM_ALGID_DSA = 43;

const int CSSM_ALGID_MD5WithRSA = 44;

const int CSSM_ALGID_MD2WithRSA = 45;

const int CSSM_ALGID_ElGamal = 46;

const int CSSM_ALGID_MD2Random = 47;

const int CSSM_ALGID_MD5Random = 48;

const int CSSM_ALGID_SHARandom = 49;

const int CSSM_ALGID_DESRandom = 50;

const int CSSM_ALGID_SHA1WithRSA = 51;

const int CSSM_ALGID_CDMF = 52;

const int CSSM_ALGID_CAST3 = 53;

const int CSSM_ALGID_CAST5 = 54;

const int CSSM_ALGID_GenericSecret = 55;

const int CSSM_ALGID_ConcatBaseAndKey = 56;

const int CSSM_ALGID_ConcatKeyAndBase = 57;

const int CSSM_ALGID_ConcatBaseAndData = 58;

const int CSSM_ALGID_ConcatDataAndBase = 59;

const int CSSM_ALGID_XORBaseAndData = 60;

const int CSSM_ALGID_ExtractFromKey = 61;

const int CSSM_ALGID_SSL3PrePrimaryGen = 62;

const int CSSM_ALGID_SSL3PreMasterGen = 62;

const int CSSM_ALGID_SSL3PrimaryDerive = 63;

const int CSSM_ALGID_SSL3MasterDerive = 63;

const int CSSM_ALGID_SSL3KeyAndMacDerive = 64;

const int CSSM_ALGID_SSL3MD5_MAC = 65;

const int CSSM_ALGID_SSL3SHA1_MAC = 66;

const int CSSM_ALGID_PKCS5_PBKDF1_MD5 = 67;

const int CSSM_ALGID_PKCS5_PBKDF1_MD2 = 68;

const int CSSM_ALGID_PKCS5_PBKDF1_SHA1 = 69;

const int CSSM_ALGID_WrapLynks = 70;

const int CSSM_ALGID_WrapSET_OAEP = 71;

const int CSSM_ALGID_BATON = 72;

const int CSSM_ALGID_ECDSA = 73;

const int CSSM_ALGID_MAYFLY = 74;

const int CSSM_ALGID_JUNIPER = 75;

const int CSSM_ALGID_FASTHASH = 76;

const int CSSM_ALGID_3DES = 77;

const int CSSM_ALGID_SSL3MD5 = 78;

const int CSSM_ALGID_SSL3SHA1 = 79;

const int CSSM_ALGID_FortezzaTimestamp = 80;

const int CSSM_ALGID_SHA1WithDSA = 81;

const int CSSM_ALGID_SHA1WithECDSA = 82;

const int CSSM_ALGID_DSA_BSAFE = 83;

const int CSSM_ALGID_ECDH = 84;

const int CSSM_ALGID_ECMQV = 85;

const int CSSM_ALGID_PKCS12_SHA1_PBE = 86;

const int CSSM_ALGID_ECNRA = 87;

const int CSSM_ALGID_SHA1WithECNRA = 88;

const int CSSM_ALGID_ECES = 89;

const int CSSM_ALGID_ECAES = 90;

const int CSSM_ALGID_SHA1HMAC = 91;

const int CSSM_ALGID_FIPS186Random = 92;

const int CSSM_ALGID_ECC = 93;

const int CSSM_ALGID_MQV = 94;

const int CSSM_ALGID_NRA = 95;

const int CSSM_ALGID_IntelPlatformRandom = 96;

const int CSSM_ALGID_UTC = 97;

const int CSSM_ALGID_HAVAL3 = 98;

const int CSSM_ALGID_HAVAL4 = 99;

const int CSSM_ALGID_HAVAL5 = 100;

const int CSSM_ALGID_TIGER = 101;

const int CSSM_ALGID_MD5HMAC = 102;

const int CSSM_ALGID_PKCS5_PBKDF2 = 103;

const int CSSM_ALGID_RUNNING_COUNTER = 104;

const int CSSM_ALGID_LAST = 2147483647;

const int CSSM_ALGID_VENDOR_DEFINED = -2147483648;

const int CSSM_ALGMODE_NONE = 0;

const int CSSM_ALGMODE_CUSTOM = 1;

const int CSSM_ALGMODE_ECB = 2;

const int CSSM_ALGMODE_ECBPad = 3;

const int CSSM_ALGMODE_CBC = 4;

const int CSSM_ALGMODE_CBC_IV8 = 5;

const int CSSM_ALGMODE_CBCPadIV8 = 6;

const int CSSM_ALGMODE_CFB = 7;

const int CSSM_ALGMODE_CFB_IV8 = 8;

const int CSSM_ALGMODE_CFBPadIV8 = 9;

const int CSSM_ALGMODE_OFB = 10;

const int CSSM_ALGMODE_OFB_IV8 = 11;

const int CSSM_ALGMODE_OFBPadIV8 = 12;

const int CSSM_ALGMODE_COUNTER = 13;

const int CSSM_ALGMODE_BC = 14;

const int CSSM_ALGMODE_PCBC = 15;

const int CSSM_ALGMODE_CBCC = 16;

const int CSSM_ALGMODE_OFBNLF = 17;

const int CSSM_ALGMODE_PBC = 18;

const int CSSM_ALGMODE_PFB = 19;

const int CSSM_ALGMODE_CBCPD = 20;

const int CSSM_ALGMODE_PUBLIC_KEY = 21;

const int CSSM_ALGMODE_PRIVATE_KEY = 22;

const int CSSM_ALGMODE_SHUFFLE = 23;

const int CSSM_ALGMODE_ECB64 = 24;

const int CSSM_ALGMODE_CBC64 = 25;

const int CSSM_ALGMODE_OFB64 = 26;

const int CSSM_ALGMODE_CFB32 = 28;

const int CSSM_ALGMODE_CFB16 = 29;

const int CSSM_ALGMODE_CFB8 = 30;

const int CSSM_ALGMODE_WRAP = 31;

const int CSSM_ALGMODE_PRIVATE_WRAP = 32;

const int CSSM_ALGMODE_RELAYX = 33;

const int CSSM_ALGMODE_ECB128 = 34;

const int CSSM_ALGMODE_ECB96 = 35;

const int CSSM_ALGMODE_CBC128 = 36;

const int CSSM_ALGMODE_OAEP_HASH = 37;

const int CSSM_ALGMODE_PKCS1_EME_V15 = 38;

const int CSSM_ALGMODE_PKCS1_EME_OAEP = 39;

const int CSSM_ALGMODE_PKCS1_EMSA_V15 = 40;

const int CSSM_ALGMODE_ISO_9796 = 41;

const int CSSM_ALGMODE_X9_31 = 42;

const int CSSM_ALGMODE_LAST = 2147483647;

const int CSSM_ALGMODE_VENDOR_DEFINED = -2147483648;

const int CSSM_CSP_SOFTWARE = 1;

const int CSSM_CSP_HARDWARE = 2;

const int CSSM_CSP_HYBRID = 3;

const int CSSM_ALGCLASS_NONE = 0;

const int CSSM_ALGCLASS_CUSTOM = 1;

const int CSSM_ALGCLASS_SIGNATURE = 2;

const int CSSM_ALGCLASS_SYMMETRIC = 3;

const int CSSM_ALGCLASS_DIGEST = 4;

const int CSSM_ALGCLASS_RANDOMGEN = 5;

const int CSSM_ALGCLASS_UNIQUEGEN = 6;

const int CSSM_ALGCLASS_MAC = 7;

const int CSSM_ALGCLASS_ASYMMETRIC = 8;

const int CSSM_ALGCLASS_KEYGEN = 9;

const int CSSM_ALGCLASS_DERIVEKEY = 10;

const int CSSM_ATTRIBUTE_DATA_NONE = 0;

const int CSSM_ATTRIBUTE_DATA_UINT32 = 268435456;

const int CSSM_ATTRIBUTE_DATA_CSSM_DATA = 536870912;

const int CSSM_ATTRIBUTE_DATA_CRYPTO_DATA = 805306368;

const int CSSM_ATTRIBUTE_DATA_KEY = 1073741824;

const int CSSM_ATTRIBUTE_DATA_STRING = 1342177280;

const int CSSM_ATTRIBUTE_DATA_DATE = 1610612736;

const int CSSM_ATTRIBUTE_DATA_RANGE = 1879048192;

const int CSSM_ATTRIBUTE_DATA_ACCESS_CREDENTIALS = -2147483648;

const int CSSM_ATTRIBUTE_DATA_VERSION = 16777216;

const int CSSM_ATTRIBUTE_DATA_DL_DB_HANDLE = 33554432;

const int CSSM_ATTRIBUTE_DATA_KR_PROFILE = 50331648;

const int CSSM_ATTRIBUTE_TYPE_MASK = -16777216;

const int CSSM_ATTRIBUTE_NONE = 0;

const int CSSM_ATTRIBUTE_CUSTOM = 536870913;

const int CSSM_ATTRIBUTE_DESCRIPTION = 1342177282;

const int CSSM_ATTRIBUTE_KEY = 1073741827;

const int CSSM_ATTRIBUTE_INIT_VECTOR = 536870916;

const int CSSM_ATTRIBUTE_SALT = 536870917;

const int CSSM_ATTRIBUTE_PADDING = 268435462;

const int CSSM_ATTRIBUTE_RANDOM = 536870919;

const int CSSM_ATTRIBUTE_SEED = 805306376;

const int CSSM_ATTRIBUTE_PASSPHRASE = 805306377;

const int CSSM_ATTRIBUTE_KEY_LENGTH = 268435466;

const int CSSM_ATTRIBUTE_KEY_LENGTH_RANGE = 1879048203;

const int CSSM_ATTRIBUTE_BLOCK_SIZE = 268435468;

const int CSSM_ATTRIBUTE_OUTPUT_SIZE = 268435469;

const int CSSM_ATTRIBUTE_ROUNDS = 268435470;

const int CSSM_ATTRIBUTE_IV_SIZE = 268435471;

const int CSSM_ATTRIBUTE_ALG_PARAMS = 536870928;

const int CSSM_ATTRIBUTE_LABEL = 536870929;

const int CSSM_ATTRIBUTE_KEY_TYPE = 268435474;

const int CSSM_ATTRIBUTE_MODE = 268435475;

const int CSSM_ATTRIBUTE_EFFECTIVE_BITS = 268435476;

const int CSSM_ATTRIBUTE_START_DATE = 1610612757;

const int CSSM_ATTRIBUTE_END_DATE = 1610612758;

const int CSSM_ATTRIBUTE_KEYUSAGE = 268435479;

const int CSSM_ATTRIBUTE_KEYATTR = 268435480;

const int CSSM_ATTRIBUTE_VERSION = 16777241;

const int CSSM_ATTRIBUTE_PRIME = 536870938;

const int CSSM_ATTRIBUTE_BASE = 536870939;

const int CSSM_ATTRIBUTE_SUBPRIME = 536870940;

const int CSSM_ATTRIBUTE_ALG_ID = 268435485;

const int CSSM_ATTRIBUTE_ITERATION_COUNT = 268435486;

const int CSSM_ATTRIBUTE_ROUNDS_RANGE = 1879048223;

const int CSSM_ATTRIBUTE_KRPROFILE_LOCAL = 50331680;

const int CSSM_ATTRIBUTE_KRPROFILE_REMOTE = 50331681;

const int CSSM_ATTRIBUTE_CSP_HANDLE = 268435490;

const int CSSM_ATTRIBUTE_DL_DB_HANDLE = 33554467;

const int CSSM_ATTRIBUTE_ACCESS_CREDENTIALS = -2147483612;

const int CSSM_ATTRIBUTE_PUBLIC_KEY_FORMAT = 268435493;

const int CSSM_ATTRIBUTE_PRIVATE_KEY_FORMAT = 268435494;

const int CSSM_ATTRIBUTE_SYMMETRIC_KEY_FORMAT = 268435495;

const int CSSM_ATTRIBUTE_WRAPPED_KEY_FORMAT = 268435496;

const int CSSM_PADDING_NONE = 0;

const int CSSM_PADDING_CUSTOM = 1;

const int CSSM_PADDING_ZERO = 2;

const int CSSM_PADDING_ONE = 3;

const int CSSM_PADDING_ALTERNATE = 4;

const int CSSM_PADDING_FF = 5;

const int CSSM_PADDING_PKCS5 = 6;

const int CSSM_PADDING_PKCS7 = 7;

const int CSSM_PADDING_CIPHERSTEALING = 8;

const int CSSM_PADDING_RANDOM = 9;

const int CSSM_PADDING_PKCS1 = 10;

const int CSSM_PADDING_SIGRAW = 11;

const int CSSM_PADDING_VENDOR_DEFINED = -2147483648;

const int CSSM_CSP_TOK_RNG = 1;

const int CSSM_CSP_TOK_CLOCK_EXISTS = 64;

const int CSSM_CSP_RDR_TOKENPRESENT = 1;

const int CSSM_CSP_RDR_EXISTS = 2;

const int CSSM_CSP_RDR_HW = 4;

const int CSSM_CSP_TOK_WRITE_PROTECTED = 2;

const int CSSM_CSP_TOK_LOGIN_REQUIRED = 4;

const int CSSM_CSP_TOK_USER_PIN_INITIALIZED = 8;

const int CSSM_CSP_TOK_PROT_AUTHENTICATION = 256;

const int CSSM_CSP_TOK_USER_PIN_EXPIRED = 1048576;

const int CSSM_CSP_TOK_SESSION_KEY_PASSWORD = 2097152;

const int CSSM_CSP_TOK_PRIVATE_KEY_PASSWORD = 4194304;

const int CSSM_CSP_STORES_PRIVATE_KEYS = 16777216;

const int CSSM_CSP_STORES_PUBLIC_KEYS = 33554432;

const int CSSM_CSP_STORES_SESSION_KEYS = 67108864;

const int CSSM_CSP_STORES_CERTIFICATES = 134217728;

const int CSSM_CSP_STORES_GENERIC = 268435456;

const int CSSM_PKCS_OAEP_MGF_NONE = 0;

const int CSSM_PKCS_OAEP_MGF1_SHA1 = 1;

const int CSSM_PKCS_OAEP_MGF1_MD5 = 2;

const int CSSM_PKCS_OAEP_PSOURCE_NONE = 0;

const int CSSM_PKCS_OAEP_PSOURCE_Pspecified = 1;

const int CSSM_VALUE_NOT_AVAILABLE = -1;

const int CSSM_PKCS5_PBKDF2_PRF_HMAC_SHA1 = 0;

const int CSSM_TP_AUTHORITY_REQUEST_CERTISSUE = 1;

const int CSSM_TP_AUTHORITY_REQUEST_CERTREVOKE = 2;

const int CSSM_TP_AUTHORITY_REQUEST_CERTSUSPEND = 3;

const int CSSM_TP_AUTHORITY_REQUEST_CERTRESUME = 4;

const int CSSM_TP_AUTHORITY_REQUEST_CERTVERIFY = 5;

const int CSSM_TP_AUTHORITY_REQUEST_CERTNOTARIZE = 6;

const int CSSM_TP_AUTHORITY_REQUEST_CERTUSERECOVER = 7;

const int CSSM_TP_AUTHORITY_REQUEST_CRLISSUE = 256;

const int CSSM_TP_KEY_ARCHIVE = 1;

const int CSSM_TP_CERT_PUBLISH = 2;

const int CSSM_TP_CERT_NOTIFY_RENEW = 4;

const int CSSM_TP_CERT_DIR_UPDATE = 8;

const int CSSM_TP_CRL_DISTRIBUTE = 16;

const int CSSM_TP_ACTION_DEFAULT = 0;

const int CSSM_TP_STOP_ON_POLICY = 0;

const int CSSM_TP_STOP_ON_NONE = 1;

const int CSSM_TP_STOP_ON_FIRST_PASS = 2;

const int CSSM_TP_STOP_ON_FIRST_FAIL = 3;

const int CSSM_CRL_PARSE_FORMAT_NONE = 0;

const int CSSM_CRL_PARSE_FORMAT_CUSTOM = 1;

const int CSSM_CRL_PARSE_FORMAT_SEXPR = 2;

const int CSSM_CRL_PARSE_FORMAT_COMPLEX = 3;

const int CSSM_CRL_PARSE_FORMAT_OID_NAMED = 4;

const int CSSM_CRL_PARSE_FORMAT_TUPLE = 5;

const int CSSM_CRL_PARSE_FORMAT_MULTIPLE = 32766;

const int CSSM_CRL_PARSE_FORMAT_LAST = 32767;

const int CSSM_CL_CUSTOM_CRL_PARSE_FORMAT = 32768;

const int CSSM_CRL_TYPE_UNKNOWN = 0;

const int CSSM_CRL_TYPE_X_509v1 = 1;

const int CSSM_CRL_TYPE_X_509v2 = 2;

const int CSSM_CRL_TYPE_SPKI = 3;

const int CSSM_CRL_TYPE_MULTIPLE = 32766;

const int CSSM_CRL_ENCODING_UNKNOWN = 0;

const int CSSM_CRL_ENCODING_CUSTOM = 1;

const int CSSM_CRL_ENCODING_BER = 2;

const int CSSM_CRL_ENCODING_DER = 3;

const int CSSM_CRL_ENCODING_BLOOM = 4;

const int CSSM_CRL_ENCODING_SEXPR = 5;

const int CSSM_CRL_ENCODING_MULTIPLE = 32766;

const int CSSM_CRLGROUP_DATA = 0;

const int CSSM_CRLGROUP_ENCODED_CRL = 1;

const int CSSM_CRLGROUP_PARSED_CRL = 2;

const int CSSM_CRLGROUP_CRL_PAIR = 3;

const int CSSM_EVIDENCE_FORM_UNSPECIFIC = 0;

const int CSSM_EVIDENCE_FORM_CERT = 1;

const int CSSM_EVIDENCE_FORM_CRL = 2;

const int CSSM_EVIDENCE_FORM_CERT_ID = 3;

const int CSSM_EVIDENCE_FORM_CRL_ID = 4;

const int CSSM_EVIDENCE_FORM_VERIFIER_TIME = 5;

const int CSSM_EVIDENCE_FORM_CRL_THISTIME = 6;

const int CSSM_EVIDENCE_FORM_CRL_NEXTTIME = 7;

const int CSSM_EVIDENCE_FORM_POLICYINFO = 8;

const int CSSM_EVIDENCE_FORM_TUPLEGROUP = 9;

const int CSSM_TP_CONFIRM_STATUS_UNKNOWN = 0;

const int CSSM_TP_CONFIRM_ACCEPT = 1;

const int CSSM_TP_CONFIRM_REJECT = 2;

const int CSSM_ESTIMATED_TIME_UNKNOWN = -1;

const int CSSM_ELAPSED_TIME_UNKNOWN = -1;

const int CSSM_ELAPSED_TIME_COMPLETE = -2;

const int CSSM_TP_CERTISSUE_STATUS_UNKNOWN = 0;

const int CSSM_TP_CERTISSUE_OK = 1;

const int CSSM_TP_CERTISSUE_OKWITHCERTMODS = 2;

const int CSSM_TP_CERTISSUE_OKWITHSERVICEMODS = 3;

const int CSSM_TP_CERTISSUE_REJECTED = 4;

const int CSSM_TP_CERTISSUE_NOT_AUTHORIZED = 5;

const int CSSM_TP_CERTISSUE_WILL_BE_REVOKED = 6;

const int CSSM_TP_CERTCHANGE_NONE = 0;

const int CSSM_TP_CERTCHANGE_REVOKE = 1;

const int CSSM_TP_CERTCHANGE_HOLD = 2;

const int CSSM_TP_CERTCHANGE_RELEASE = 3;

const int CSSM_TP_CERTCHANGE_REASON_UNKNOWN = 0;

const int CSSM_TP_CERTCHANGE_REASON_KEYCOMPROMISE = 1;

const int CSSM_TP_CERTCHANGE_REASON_CACOMPROMISE = 2;

const int CSSM_TP_CERTCHANGE_REASON_CEASEOPERATION = 3;

const int CSSM_TP_CERTCHANGE_REASON_AFFILIATIONCHANGE = 4;

const int CSSM_TP_CERTCHANGE_REASON_SUPERCEDED = 5;

const int CSSM_TP_CERTCHANGE_REASON_SUSPECTEDCOMPROMISE = 6;

const int CSSM_TP_CERTCHANGE_REASON_HOLDRELEASE = 7;

const int CSSM_TP_CERTCHANGE_STATUS_UNKNOWN = 0;

const int CSSM_TP_CERTCHANGE_OK = 1;

const int CSSM_TP_CERTCHANGE_OKWITHNEWTIME = 2;

const int CSSM_TP_CERTCHANGE_WRONGCA = 3;

const int CSSM_TP_CERTCHANGE_REJECTED = 4;

const int CSSM_TP_CERTCHANGE_NOT_AUTHORIZED = 5;

const int CSSM_TP_CERTVERIFY_UNKNOWN = 0;

const int CSSM_TP_CERTVERIFY_VALID = 1;

const int CSSM_TP_CERTVERIFY_INVALID = 2;

const int CSSM_TP_CERTVERIFY_REVOKED = 3;

const int CSSM_TP_CERTVERIFY_SUSPENDED = 4;

const int CSSM_TP_CERTVERIFY_EXPIRED = 5;

const int CSSM_TP_CERTVERIFY_NOT_VALID_YET = 6;

const int CSSM_TP_CERTVERIFY_INVALID_AUTHORITY = 7;

const int CSSM_TP_CERTVERIFY_INVALID_SIGNATURE = 8;

const int CSSM_TP_CERTVERIFY_INVALID_CERT_VALUE = 9;

const int CSSM_TP_CERTVERIFY_INVALID_CERTGROUP = 10;

const int CSSM_TP_CERTVERIFY_INVALID_POLICY = 11;

const int CSSM_TP_CERTVERIFY_INVALID_POLICY_IDS = 12;

const int CSSM_TP_CERTVERIFY_INVALID_BASIC_CONSTRAINTS = 13;

const int CSSM_TP_CERTVERIFY_INVALID_CRL_DIST_PT = 14;

const int CSSM_TP_CERTVERIFY_INVALID_NAME_TREE = 15;

const int CSSM_TP_CERTVERIFY_UNKNOWN_CRITICAL_EXT = 16;

const int CSSM_TP_CERTNOTARIZE_STATUS_UNKNOWN = 0;

const int CSSM_TP_CERTNOTARIZE_OK = 1;

const int CSSM_TP_CERTNOTARIZE_OKWITHOUTFIELDS = 2;

const int CSSM_TP_CERTNOTARIZE_OKWITHSERVICEMODS = 3;

const int CSSM_TP_CERTNOTARIZE_REJECTED = 4;

const int CSSM_TP_CERTNOTARIZE_NOT_AUTHORIZED = 5;

const int CSSM_TP_CERTRECLAIM_STATUS_UNKNOWN = 0;

const int CSSM_TP_CERTRECLAIM_OK = 1;

const int CSSM_TP_CERTRECLAIM_NOMATCH = 2;

const int CSSM_TP_CERTRECLAIM_REJECTED = 3;

const int CSSM_TP_CERTRECLAIM_NOT_AUTHORIZED = 4;

const int CSSM_TP_CRLISSUE_STATUS_UNKNOWN = 0;

const int CSSM_TP_CRLISSUE_OK = 1;

const int CSSM_TP_CRLISSUE_NOT_CURRENT = 2;

const int CSSM_TP_CRLISSUE_INVALID_DOMAIN = 3;

const int CSSM_TP_CRLISSUE_UNKNOWN_IDENTIFIER = 4;

const int CSSM_TP_CRLISSUE_REJECTED = 5;

const int CSSM_TP_CRLISSUE_NOT_AUTHORIZED = 6;

const int CSSM_TP_FORM_TYPE_GENERIC = 0;

const int CSSM_TP_FORM_TYPE_REGISTRATION = 1;

const int CSSM_CL_TEMPLATE_INTERMEDIATE_CERT = 1;

const int CSSM_CL_TEMPLATE_PKIX_CERTTEMPLATE = 2;

const int CSSM_CERT_BUNDLE_UNKNOWN = 0;

const int CSSM_CERT_BUNDLE_CUSTOM = 1;

const int CSSM_CERT_BUNDLE_PKCS7_SIGNED_DATA = 2;

const int CSSM_CERT_BUNDLE_PKCS7_SIGNED_ENVELOPED_DATA = 3;

const int CSSM_CERT_BUNDLE_PKCS12 = 4;

const int CSSM_CERT_BUNDLE_PFX = 5;

const int CSSM_CERT_BUNDLE_SPKI_SEQUENCE = 6;

const int CSSM_CERT_BUNDLE_PGP_KEYRING = 7;

const int CSSM_CERT_BUNDLE_LAST = 32767;

const int CSSM_CL_CUSTOM_CERT_BUNDLE_TYPE = 32768;

const int CSSM_CERT_BUNDLE_ENCODING_UNKNOWN = 0;

const int CSSM_CERT_BUNDLE_ENCODING_CUSTOM = 1;

const int CSSM_CERT_BUNDLE_ENCODING_BER = 2;

const int CSSM_CERT_BUNDLE_ENCODING_DER = 3;

const int CSSM_CERT_BUNDLE_ENCODING_SEXPR = 4;

const int CSSM_CERT_BUNDLE_ENCODING_PGP = 5;

const int CSSM_FIELDVALUE_COMPLEX_DATA_TYPE = -1;

const int CSSM_DB_ATTRIBUTE_NAME_AS_STRING = 0;

const int CSSM_DB_ATTRIBUTE_NAME_AS_OID = 1;

const int CSSM_DB_ATTRIBUTE_NAME_AS_INTEGER = 2;

const int CSSM_DB_ATTRIBUTE_FORMAT_STRING = 0;

const int CSSM_DB_ATTRIBUTE_FORMAT_SINT32 = 1;

const int CSSM_DB_ATTRIBUTE_FORMAT_UINT32 = 2;

const int CSSM_DB_ATTRIBUTE_FORMAT_BIG_NUM = 3;

const int CSSM_DB_ATTRIBUTE_FORMAT_REAL = 4;

const int CSSM_DB_ATTRIBUTE_FORMAT_TIME_DATE = 5;

const int CSSM_DB_ATTRIBUTE_FORMAT_BLOB = 6;

const int CSSM_DB_ATTRIBUTE_FORMAT_MULTI_UINT32 = 7;

const int CSSM_DB_ATTRIBUTE_FORMAT_COMPLEX = 8;

const int CSSM_DB_RECORDTYPE_SCHEMA_START = 0;

const int CSSM_DB_RECORDTYPE_SCHEMA_END = 4;

const int CSSM_DB_RECORDTYPE_OPEN_GROUP_START = 10;

const int CSSM_DB_RECORDTYPE_OPEN_GROUP_END = 18;

const int CSSM_DB_RECORDTYPE_APP_DEFINED_START = -2147483648;

const int CSSM_DB_RECORDTYPE_APP_DEFINED_END = -1;

const int CSSM_DL_DB_SCHEMA_INFO = 0;

const int CSSM_DL_DB_SCHEMA_INDEXES = 1;

const int CSSM_DL_DB_SCHEMA_ATTRIBUTES = 2;

const int CSSM_DL_DB_SCHEMA_PARSING_MODULE = 3;

const int CSSM_DL_DB_RECORD_ANY = 10;

const int CSSM_DL_DB_RECORD_CERT = 11;

const int CSSM_DL_DB_RECORD_CRL = 12;

const int CSSM_DL_DB_RECORD_POLICY = 13;

const int CSSM_DL_DB_RECORD_GENERIC = 14;

const int CSSM_DL_DB_RECORD_PUBLIC_KEY = 15;

const int CSSM_DL_DB_RECORD_PRIVATE_KEY = 16;

const int CSSM_DL_DB_RECORD_SYMMETRIC_KEY = 17;

const int CSSM_DL_DB_RECORD_ALL_KEYS = 18;

const int CSSM_DB_CERT_USE_TRUSTED = 1;

const int CSSM_DB_CERT_USE_SYSTEM = 2;

const int CSSM_DB_CERT_USE_OWNER = 4;

const int CSSM_DB_CERT_USE_REVOKED = 8;

const int CSSM_DB_CERT_USE_SIGNING = 16;

const int CSSM_DB_CERT_USE_PRIVACY = 32;

const int CSSM_DB_INDEX_UNIQUE = 0;

const int CSSM_DB_INDEX_NONUNIQUE = 1;

const int CSSM_DB_INDEX_ON_UNKNOWN = 0;

const int CSSM_DB_INDEX_ON_ATTRIBUTE = 1;

const int CSSM_DB_INDEX_ON_RECORD = 2;

const int CSSM_DB_ACCESS_READ = 1;

const int CSSM_DB_ACCESS_WRITE = 2;

const int CSSM_DB_ACCESS_PRIVILEGED = 4;

const int CSSM_DB_MODIFY_ATTRIBUTE_NONE = 0;

const int CSSM_DB_MODIFY_ATTRIBUTE_ADD = 1;

const int CSSM_DB_MODIFY_ATTRIBUTE_DELETE = 2;

const int CSSM_DB_MODIFY_ATTRIBUTE_REPLACE = 3;

const int CSSM_DB_EQUAL = 0;

const int CSSM_DB_NOT_EQUAL = 1;

const int CSSM_DB_LESS_THAN = 2;

const int CSSM_DB_GREATER_THAN = 3;

const int CSSM_DB_CONTAINS = 4;

const int CSSM_DB_CONTAINS_INITIAL_SUBSTRING = 5;

const int CSSM_DB_CONTAINS_FINAL_SUBSTRING = 6;

const int CSSM_DB_NONE = 0;

const int CSSM_DB_AND = 1;

const int CSSM_DB_OR = 2;

const int CSSM_QUERY_TIMELIMIT_NONE = 0;

const int CSSM_QUERY_SIZELIMIT_NONE = 0;

const int CSSM_QUERY_RETURN_DATA = 1;

const int CSSM_DL_UNKNOWN = 0;

const int CSSM_DL_CUSTOM = 1;

const int CSSM_DL_LDAP = 2;

const int CSSM_DL_ODBC = 3;

const int CSSM_DL_PKCS11 = 4;

const int CSSM_DL_FFS = 5;

const int CSSM_DL_MEMORY = 6;

const int CSSM_DL_REMOTEDIR = 7;

const int CSSM_DB_DATASTORES_UNKNOWN = -1;

const int CSSM_DB_TRANSACTIONAL_MODE = 0;

const int CSSM_DB_FILESYSTEMSCAN_MODE = 1;

const int CSSM_BASE_ERROR = -2147418112;

const int CSSM_ERRORCODE_MODULE_EXTENT = 2048;

const int CSSM_ERRORCODE_CUSTOM_OFFSET = 1024;

const int CSSM_ERRORCODE_COMMON_EXTENT = 256;

const int CSSM_CSSM_BASE_ERROR = -2147418112;

const int CSSM_CSSM_PRIVATE_ERROR = -2147417088;

const int CSSM_CSP_BASE_ERROR = -2147416064;

const int CSSM_CSP_PRIVATE_ERROR = -2147415040;

const int CSSM_DL_BASE_ERROR = -2147414016;

const int CSSM_DL_PRIVATE_ERROR = -2147412992;

const int CSSM_CL_BASE_ERROR = -2147411968;

const int CSSM_CL_PRIVATE_ERROR = -2147410944;

const int CSSM_TP_BASE_ERROR = -2147409920;

const int CSSM_TP_PRIVATE_ERROR = -2147408896;

const int CSSM_KR_BASE_ERROR = -2147407872;

const int CSSM_KR_PRIVATE_ERROR = -2147406848;

const int CSSM_AC_BASE_ERROR = -2147405824;

const int CSSM_AC_PRIVATE_ERROR = -2147404800;

const int CSSM_MDS_BASE_ERROR = -2147414016;

const int CSSM_MDS_PRIVATE_ERROR = -2147412992;

const int CSSMERR_CSSM_INVALID_ADDIN_HANDLE = -2147417855;

const int CSSMERR_CSSM_NOT_INITIALIZED = -2147417854;

const int CSSMERR_CSSM_INVALID_HANDLE_USAGE = -2147417853;

const int CSSMERR_CSSM_PVC_REFERENT_NOT_FOUND = -2147417852;

const int CSSMERR_CSSM_FUNCTION_INTEGRITY_FAIL = -2147417851;

const int CSSM_ERRCODE_INTERNAL_ERROR = 1;

const int CSSM_ERRCODE_MEMORY_ERROR = 2;

const int CSSM_ERRCODE_MDS_ERROR = 3;

const int CSSM_ERRCODE_INVALID_POINTER = 4;

const int CSSM_ERRCODE_INVALID_INPUT_POINTER = 5;

const int CSSM_ERRCODE_INVALID_OUTPUT_POINTER = 6;

const int CSSM_ERRCODE_FUNCTION_NOT_IMPLEMENTED = 7;

const int CSSM_ERRCODE_SELF_CHECK_FAILED = 8;

const int CSSM_ERRCODE_OS_ACCESS_DENIED = 9;

const int CSSM_ERRCODE_FUNCTION_FAILED = 10;

const int CSSM_ERRCODE_MODULE_MANIFEST_VERIFY_FAILED = 11;

const int CSSM_ERRCODE_INVALID_GUID = 12;

const int CSSM_ERRCODE_OPERATION_AUTH_DENIED = 32;

const int CSSM_ERRCODE_OBJECT_USE_AUTH_DENIED = 33;

const int CSSM_ERRCODE_OBJECT_MANIP_AUTH_DENIED = 34;

const int CSSM_ERRCODE_OBJECT_ACL_NOT_SUPPORTED = 35;

const int CSSM_ERRCODE_OBJECT_ACL_REQUIRED = 36;

const int CSSM_ERRCODE_INVALID_ACCESS_CREDENTIALS = 37;

const int CSSM_ERRCODE_INVALID_ACL_BASE_CERTS = 38;

const int CSSM_ERRCODE_ACL_BASE_CERTS_NOT_SUPPORTED = 39;

const int CSSM_ERRCODE_INVALID_SAMPLE_VALUE = 40;

const int CSSM_ERRCODE_SAMPLE_VALUE_NOT_SUPPORTED = 41;

const int CSSM_ERRCODE_INVALID_ACL_SUBJECT_VALUE = 42;

const int CSSM_ERRCODE_ACL_SUBJECT_TYPE_NOT_SUPPORTED = 43;

const int CSSM_ERRCODE_INVALID_ACL_CHALLENGE_CALLBACK = 44;

const int CSSM_ERRCODE_ACL_CHALLENGE_CALLBACK_FAILED = 45;

const int CSSM_ERRCODE_INVALID_ACL_ENTRY_TAG = 46;

const int CSSM_ERRCODE_ACL_ENTRY_TAG_NOT_FOUND = 47;

const int CSSM_ERRCODE_INVALID_ACL_EDIT_MODE = 48;

const int CSSM_ERRCODE_ACL_CHANGE_FAILED = 49;

const int CSSM_ERRCODE_INVALID_NEW_ACL_ENTRY = 50;

const int CSSM_ERRCODE_INVALID_NEW_ACL_OWNER = 51;

const int CSSM_ERRCODE_ACL_DELETE_FAILED = 52;

const int CSSM_ERRCODE_ACL_REPLACE_FAILED = 53;

const int CSSM_ERRCODE_ACL_ADD_FAILED = 54;

const int CSSM_ERRCODE_INVALID_CONTEXT_HANDLE = 64;

const int CSSM_ERRCODE_INCOMPATIBLE_VERSION = 65;

const int CSSM_ERRCODE_INVALID_CERTGROUP_POINTER = 66;

const int CSSM_ERRCODE_INVALID_CERT_POINTER = 67;

const int CSSM_ERRCODE_INVALID_CRL_POINTER = 68;

const int CSSM_ERRCODE_INVALID_FIELD_POINTER = 69;

const int CSSM_ERRCODE_INVALID_DATA = 70;

const int CSSM_ERRCODE_CRL_ALREADY_SIGNED = 71;

const int CSSM_ERRCODE_INVALID_NUMBER_OF_FIELDS = 72;

const int CSSM_ERRCODE_VERIFICATION_FAILURE = 73;

const int CSSM_ERRCODE_INVALID_DB_HANDLE = 74;

const int CSSM_ERRCODE_PRIVILEGE_NOT_GRANTED = 75;

const int CSSM_ERRCODE_INVALID_DB_LIST = 76;

const int CSSM_ERRCODE_INVALID_DB_LIST_POINTER = 77;

const int CSSM_ERRCODE_UNKNOWN_FORMAT = 78;

const int CSSM_ERRCODE_UNKNOWN_TAG = 79;

const int CSSM_ERRCODE_INVALID_CSP_HANDLE = 80;

const int CSSM_ERRCODE_INVALID_DL_HANDLE = 81;

const int CSSM_ERRCODE_INVALID_CL_HANDLE = 82;

const int CSSM_ERRCODE_INVALID_TP_HANDLE = 83;

const int CSSM_ERRCODE_INVALID_KR_HANDLE = 84;

const int CSSM_ERRCODE_INVALID_AC_HANDLE = 85;

const int CSSM_ERRCODE_INVALID_PASSTHROUGH_ID = 86;

const int CSSM_ERRCODE_INVALID_NETWORK_ADDR = 87;

const int CSSM_ERRCODE_INVALID_CRYPTO_DATA = 88;

const int CSSMERR_CSSM_INTERNAL_ERROR = -2147418111;

const int CSSMERR_CSSM_MEMORY_ERROR = -2147418110;

const int CSSMERR_CSSM_MDS_ERROR = -2147418109;

const int CSSMERR_CSSM_INVALID_POINTER = -2147418108;

const int CSSMERR_CSSM_INVALID_INPUT_POINTER = -2147418107;

const int CSSMERR_CSSM_INVALID_OUTPUT_POINTER = -2147418106;

const int CSSMERR_CSSM_FUNCTION_NOT_IMPLEMENTED = -2147418105;

const int CSSMERR_CSSM_SELF_CHECK_FAILED = -2147418104;

const int CSSMERR_CSSM_OS_ACCESS_DENIED = -2147418103;

const int CSSMERR_CSSM_FUNCTION_FAILED = -2147418102;

const int CSSMERR_CSSM_MODULE_MANIFEST_VERIFY_FAILED = -2147418101;

const int CSSMERR_CSSM_INVALID_GUID = -2147418100;

const int CSSMERR_CSSM_INVALID_CONTEXT_HANDLE = -2147418048;

const int CSSMERR_CSSM_INCOMPATIBLE_VERSION = -2147418047;

const int CSSMERR_CSSM_PRIVILEGE_NOT_GRANTED = -2147418037;

const int CSSM_CSSM_BASE_CSSM_ERROR = -2147417840;

const int CSSMERR_CSSM_SCOPE_NOT_SUPPORTED = -2147417839;

const int CSSMERR_CSSM_PVC_ALREADY_CONFIGURED = -2147417838;

const int CSSMERR_CSSM_INVALID_PVC = -2147417837;

const int CSSMERR_CSSM_EMM_LOAD_FAILED = -2147417836;

const int CSSMERR_CSSM_EMM_UNLOAD_FAILED = -2147417835;

const int CSSMERR_CSSM_ADDIN_LOAD_FAILED = -2147417834;

const int CSSMERR_CSSM_INVALID_KEY_HIERARCHY = -2147417833;

const int CSSMERR_CSSM_ADDIN_UNLOAD_FAILED = -2147417832;

const int CSSMERR_CSSM_LIB_REF_NOT_FOUND = -2147417831;

const int CSSMERR_CSSM_INVALID_ADDIN_FUNCTION_TABLE = -2147417830;

const int CSSMERR_CSSM_EMM_AUTHENTICATE_FAILED = -2147417829;

const int CSSMERR_CSSM_ADDIN_AUTHENTICATE_FAILED = -2147417828;

const int CSSMERR_CSSM_INVALID_SERVICE_MASK = -2147417827;

const int CSSMERR_CSSM_MODULE_NOT_LOADED = -2147417826;

const int CSSMERR_CSSM_INVALID_SUBSERVICEID = -2147417825;

const int CSSMERR_CSSM_BUFFER_TOO_SMALL = -2147417824;

const int CSSMERR_CSSM_INVALID_ATTRIBUTE = -2147417823;

const int CSSMERR_CSSM_ATTRIBUTE_NOT_IN_CONTEXT = -2147417822;

const int CSSMERR_CSSM_MODULE_MANAGER_INITIALIZE_FAIL = -2147417821;

const int CSSMERR_CSSM_MODULE_MANAGER_NOT_FOUND = -2147417820;

const int CSSMERR_CSSM_EVENT_NOTIFICATION_CALLBACK_NOT_FOUND = -2147417819;

const int CSSMERR_CSP_INTERNAL_ERROR = -2147416063;

const int CSSMERR_CSP_MEMORY_ERROR = -2147416062;

const int CSSMERR_CSP_MDS_ERROR = -2147416061;

const int CSSMERR_CSP_INVALID_POINTER = -2147416060;

const int CSSMERR_CSP_INVALID_INPUT_POINTER = -2147416059;

const int CSSMERR_CSP_INVALID_OUTPUT_POINTER = -2147416058;

const int CSSMERR_CSP_FUNCTION_NOT_IMPLEMENTED = -2147416057;

const int CSSMERR_CSP_SELF_CHECK_FAILED = -2147416056;

const int CSSMERR_CSP_OS_ACCESS_DENIED = -2147416055;

const int CSSMERR_CSP_FUNCTION_FAILED = -2147416054;

const int CSSMERR_CSP_OPERATION_AUTH_DENIED = -2147416032;

const int CSSMERR_CSP_OBJECT_USE_AUTH_DENIED = -2147416031;

const int CSSMERR_CSP_OBJECT_MANIP_AUTH_DENIED = -2147416030;

const int CSSMERR_CSP_OBJECT_ACL_NOT_SUPPORTED = -2147416029;

const int CSSMERR_CSP_OBJECT_ACL_REQUIRED = -2147416028;

const int CSSMERR_CSP_INVALID_ACCESS_CREDENTIALS = -2147416027;

const int CSSMERR_CSP_INVALID_ACL_BASE_CERTS = -2147416026;

const int CSSMERR_CSP_ACL_BASE_CERTS_NOT_SUPPORTED = -2147416025;

const int CSSMERR_CSP_INVALID_SAMPLE_VALUE = -2147416024;

const int CSSMERR_CSP_SAMPLE_VALUE_NOT_SUPPORTED = -2147416023;

const int CSSMERR_CSP_INVALID_ACL_SUBJECT_VALUE = -2147416022;

const int CSSMERR_CSP_ACL_SUBJECT_TYPE_NOT_SUPPORTED = -2147416021;

const int CSSMERR_CSP_INVALID_ACL_CHALLENGE_CALLBACK = -2147416020;

const int CSSMERR_CSP_ACL_CHALLENGE_CALLBACK_FAILED = -2147416019;

const int CSSMERR_CSP_INVALID_ACL_ENTRY_TAG = -2147416018;

const int CSSMERR_CSP_ACL_ENTRY_TAG_NOT_FOUND = -2147416017;

const int CSSMERR_CSP_INVALID_ACL_EDIT_MODE = -2147416016;

const int CSSMERR_CSP_ACL_CHANGE_FAILED = -2147416015;

const int CSSMERR_CSP_INVALID_NEW_ACL_ENTRY = -2147416014;

const int CSSMERR_CSP_INVALID_NEW_ACL_OWNER = -2147416013;

const int CSSMERR_CSP_ACL_DELETE_FAILED = -2147416012;

const int CSSMERR_CSP_ACL_REPLACE_FAILED = -2147416011;

const int CSSMERR_CSP_ACL_ADD_FAILED = -2147416010;

const int CSSMERR_CSP_INVALID_CONTEXT_HANDLE = -2147416000;

const int CSSMERR_CSP_PRIVILEGE_NOT_GRANTED = -2147415989;

const int CSSMERR_CSP_INVALID_DATA = -2147415994;

const int CSSMERR_CSP_INVALID_PASSTHROUGH_ID = -2147415978;

const int CSSMERR_CSP_INVALID_CRYPTO_DATA = -2147415976;

const int CSSM_CSP_BASE_CSP_ERROR = -2147415808;

const int CSSMERR_CSP_INPUT_LENGTH_ERROR = -2147415807;

const int CSSMERR_CSP_OUTPUT_LENGTH_ERROR = -2147415806;

const int CSSMERR_CSP_PRIVILEGE_NOT_SUPPORTED = -2147415805;

const int CSSMERR_CSP_DEVICE_ERROR = -2147415804;

const int CSSMERR_CSP_DEVICE_MEMORY_ERROR = -2147415803;

const int CSSMERR_CSP_ATTACH_HANDLE_BUSY = -2147415802;

const int CSSMERR_CSP_NOT_LOGGED_IN = -2147415801;

const int CSSMERR_CSP_INVALID_KEY = -2147415792;

const int CSSMERR_CSP_INVALID_KEY_REFERENCE = -2147415791;

const int CSSMERR_CSP_INVALID_KEY_CLASS = -2147415790;

const int CSSMERR_CSP_ALGID_MISMATCH = -2147415789;

const int CSSMERR_CSP_KEY_USAGE_INCORRECT = -2147415788;

const int CSSMERR_CSP_KEY_BLOB_TYPE_INCORRECT = -2147415787;

const int CSSMERR_CSP_KEY_HEADER_INCONSISTENT = -2147415786;

const int CSSMERR_CSP_UNSUPPORTED_KEY_FORMAT = -2147415785;

const int CSSMERR_CSP_UNSUPPORTED_KEY_SIZE = -2147415784;

const int CSSMERR_CSP_INVALID_KEY_POINTER = -2147415783;

const int CSSMERR_CSP_INVALID_KEYUSAGE_MASK = -2147415782;

const int CSSMERR_CSP_UNSUPPORTED_KEYUSAGE_MASK = -2147415781;

const int CSSMERR_CSP_INVALID_KEYATTR_MASK = -2147415780;

const int CSSMERR_CSP_UNSUPPORTED_KEYATTR_MASK = -2147415779;

const int CSSMERR_CSP_INVALID_KEY_LABEL = -2147415778;

const int CSSMERR_CSP_UNSUPPORTED_KEY_LABEL = -2147415777;

const int CSSMERR_CSP_INVALID_KEY_FORMAT = -2147415776;

const int CSSMERR_CSP_INVALID_DATA_COUNT = -2147415768;

const int CSSMERR_CSP_VECTOR_OF_BUFS_UNSUPPORTED = -2147415767;

const int CSSMERR_CSP_INVALID_INPUT_VECTOR = -2147415766;

const int CSSMERR_CSP_INVALID_OUTPUT_VECTOR = -2147415765;

const int CSSMERR_CSP_INVALID_CONTEXT = -2147415760;

const int CSSMERR_CSP_INVALID_ALGORITHM = -2147415759;

const int CSSMERR_CSP_INVALID_ATTR_KEY = -2147415754;

const int CSSMERR_CSP_MISSING_ATTR_KEY = -2147415753;

const int CSSMERR_CSP_INVALID_ATTR_INIT_VECTOR = -2147415752;

const int CSSMERR_CSP_MISSING_ATTR_INIT_VECTOR = -2147415751;

const int CSSMERR_CSP_INVALID_ATTR_SALT = -2147415750;

const int CSSMERR_CSP_MISSING_ATTR_SALT = -2147415749;

const int CSSMERR_CSP_INVALID_ATTR_PADDING = -2147415748;

const int CSSMERR_CSP_MISSING_ATTR_PADDING = -2147415747;

const int CSSMERR_CSP_INVALID_ATTR_RANDOM = -2147415746;

const int CSSMERR_CSP_MISSING_ATTR_RANDOM = -2147415745;

const int CSSMERR_CSP_INVALID_ATTR_SEED = -2147415744;

const int CSSMERR_CSP_MISSING_ATTR_SEED = -2147415743;

const int CSSMERR_CSP_INVALID_ATTR_PASSPHRASE = -2147415742;

const int CSSMERR_CSP_MISSING_ATTR_PASSPHRASE = -2147415741;

const int CSSMERR_CSP_INVALID_ATTR_KEY_LENGTH = -2147415740;

const int CSSMERR_CSP_MISSING_ATTR_KEY_LENGTH = -2147415739;

const int CSSMERR_CSP_INVALID_ATTR_BLOCK_SIZE = -2147415738;

const int CSSMERR_CSP_MISSING_ATTR_BLOCK_SIZE = -2147415737;

const int CSSMERR_CSP_INVALID_ATTR_OUTPUT_SIZE = -2147415708;

const int CSSMERR_CSP_MISSING_ATTR_OUTPUT_SIZE = -2147415707;

const int CSSMERR_CSP_INVALID_ATTR_ROUNDS = -2147415706;

const int CSSMERR_CSP_MISSING_ATTR_ROUNDS = -2147415705;

const int CSSMERR_CSP_INVALID_ATTR_ALG_PARAMS = -2147415704;

const int CSSMERR_CSP_MISSING_ATTR_ALG_PARAMS = -2147415703;

const int CSSMERR_CSP_INVALID_ATTR_LABEL = -2147415702;

const int CSSMERR_CSP_MISSING_ATTR_LABEL = -2147415701;

const int CSSMERR_CSP_INVALID_ATTR_KEY_TYPE = -2147415700;

const int CSSMERR_CSP_MISSING_ATTR_KEY_TYPE = -2147415699;

const int CSSMERR_CSP_INVALID_ATTR_MODE = -2147415698;

const int CSSMERR_CSP_MISSING_ATTR_MODE = -2147415697;

const int CSSMERR_CSP_INVALID_ATTR_EFFECTIVE_BITS = -2147415696;

const int CSSMERR_CSP_MISSING_ATTR_EFFECTIVE_BITS = -2147415695;

const int CSSMERR_CSP_INVALID_ATTR_START_DATE = -2147415694;

const int CSSMERR_CSP_MISSING_ATTR_START_DATE = -2147415693;

const int CSSMERR_CSP_INVALID_ATTR_END_DATE = -2147415692;

const int CSSMERR_CSP_MISSING_ATTR_END_DATE = -2147415691;

const int CSSMERR_CSP_INVALID_ATTR_VERSION = -2147415690;

const int CSSMERR_CSP_MISSING_ATTR_VERSION = -2147415689;

const int CSSMERR_CSP_INVALID_ATTR_PRIME = -2147415688;

const int CSSMERR_CSP_MISSING_ATTR_PRIME = -2147415687;

const int CSSMERR_CSP_INVALID_ATTR_BASE = -2147415686;

const int CSSMERR_CSP_MISSING_ATTR_BASE = -2147415685;

const int CSSMERR_CSP_INVALID_ATTR_SUBPRIME = -2147415684;

const int CSSMERR_CSP_MISSING_ATTR_SUBPRIME = -2147415683;

const int CSSMERR_CSP_INVALID_ATTR_ITERATION_COUNT = -2147415682;

const int CSSMERR_CSP_MISSING_ATTR_ITERATION_COUNT = -2147415681;

const int CSSMERR_CSP_INVALID_ATTR_DL_DB_HANDLE = -2147415680;

const int CSSMERR_CSP_MISSING_ATTR_DL_DB_HANDLE = -2147415679;

const int CSSMERR_CSP_INVALID_ATTR_ACCESS_CREDENTIALS = -2147415678;

const int CSSMERR_CSP_MISSING_ATTR_ACCESS_CREDENTIALS = -2147415677;

const int CSSMERR_CSP_INVALID_ATTR_PUBLIC_KEY_FORMAT = -2147415676;

const int CSSMERR_CSP_MISSING_ATTR_PUBLIC_KEY_FORMAT = -2147415675;

const int CSSMERR_CSP_INVALID_ATTR_PRIVATE_KEY_FORMAT = -2147415674;

const int CSSMERR_CSP_MISSING_ATTR_PRIVATE_KEY_FORMAT = -2147415673;

const int CSSMERR_CSP_INVALID_ATTR_SYMMETRIC_KEY_FORMAT = -2147415672;

const int CSSMERR_CSP_MISSING_ATTR_SYMMETRIC_KEY_FORMAT = -2147415671;

const int CSSMERR_CSP_INVALID_ATTR_WRAPPED_KEY_FORMAT = -2147415670;

const int CSSMERR_CSP_MISSING_ATTR_WRAPPED_KEY_FORMAT = -2147415669;

const int CSSMERR_CSP_STAGED_OPERATION_IN_PROGRESS = -2147415736;

const int CSSMERR_CSP_STAGED_OPERATION_NOT_STARTED = -2147415735;

const int CSSMERR_CSP_VERIFY_FAILED = -2147415734;

const int CSSMERR_CSP_INVALID_SIGNATURE = -2147415733;

const int CSSMERR_CSP_QUERY_SIZE_UNKNOWN = -2147415732;

const int CSSMERR_CSP_BLOCK_SIZE_MISMATCH = -2147415731;

const int CSSMERR_CSP_PRIVATE_KEY_NOT_FOUND = -2147415730;

const int CSSMERR_CSP_PUBLIC_KEY_INCONSISTENT = -2147415729;

const int CSSMERR_CSP_DEVICE_VERIFY_FAILED = -2147415728;

const int CSSMERR_CSP_INVALID_LOGIN_NAME = -2147415727;

const int CSSMERR_CSP_ALREADY_LOGGED_IN = -2147415726;

const int CSSMERR_CSP_PRIVATE_KEY_ALREADY_EXISTS = -2147415725;

const int CSSMERR_CSP_KEY_LABEL_ALREADY_EXISTS = -2147415724;

const int CSSMERR_CSP_INVALID_DIGEST_ALGORITHM = -2147415723;

const int CSSMERR_CSP_CRYPTO_DATA_CALLBACK_FAILED = -2147415722;

const int CSSMERR_TP_INTERNAL_ERROR = -2147409919;

const int CSSMERR_TP_MEMORY_ERROR = -2147409918;

const int CSSMERR_TP_MDS_ERROR = -2147409917;

const int CSSMERR_TP_INVALID_POINTER = -2147409916;

const int CSSMERR_TP_INVALID_INPUT_POINTER = -2147409915;

const int CSSMERR_TP_INVALID_OUTPUT_POINTER = -2147409914;

const int CSSMERR_TP_FUNCTION_NOT_IMPLEMENTED = -2147409913;

const int CSSMERR_TP_SELF_CHECK_FAILED = -2147409912;

const int CSSMERR_TP_OS_ACCESS_DENIED = -2147409911;

const int CSSMERR_TP_FUNCTION_FAILED = -2147409910;

const int CSSMERR_TP_INVALID_CONTEXT_HANDLE = -2147409856;

const int CSSMERR_TP_INVALID_DATA = -2147409850;

const int CSSMERR_TP_INVALID_DB_LIST = -2147409844;

const int CSSMERR_TP_INVALID_CERTGROUP_POINTER = -2147409854;

const int CSSMERR_TP_INVALID_CERT_POINTER = -2147409853;

const int CSSMERR_TP_INVALID_CRL_POINTER = -2147409852;

const int CSSMERR_TP_INVALID_FIELD_POINTER = -2147409851;

const int CSSMERR_TP_INVALID_NETWORK_ADDR = -2147409833;

const int CSSMERR_TP_CRL_ALREADY_SIGNED = -2147409849;

const int CSSMERR_TP_INVALID_NUMBER_OF_FIELDS = -2147409848;

const int CSSMERR_TP_VERIFICATION_FAILURE = -2147409847;

const int CSSMERR_TP_INVALID_DB_HANDLE = -2147409846;

const int CSSMERR_TP_UNKNOWN_FORMAT = -2147409842;

const int CSSMERR_TP_UNKNOWN_TAG = -2147409841;

const int CSSMERR_TP_INVALID_PASSTHROUGH_ID = -2147409834;

const int CSSMERR_TP_INVALID_CSP_HANDLE = -2147409840;

const int CSSMERR_TP_INVALID_DL_HANDLE = -2147409839;

const int CSSMERR_TP_INVALID_CL_HANDLE = -2147409838;

const int CSSMERR_TP_INVALID_DB_LIST_POINTER = -2147409843;

const int CSSM_TP_BASE_TP_ERROR = -2147409664;

const int CSSMERR_TP_INVALID_CALLERAUTH_CONTEXT_POINTER = -2147409663;

const int CSSMERR_TP_INVALID_IDENTIFIER_POINTER = -2147409662;

const int CSSMERR_TP_INVALID_KEYCACHE_HANDLE = -2147409661;

const int CSSMERR_TP_INVALID_CERTGROUP = -2147409660;

const int CSSMERR_TP_INVALID_CRLGROUP = -2147409659;

const int CSSMERR_TP_INVALID_CRLGROUP_POINTER = -2147409658;

const int CSSMERR_TP_AUTHENTICATION_FAILED = -2147409657;

const int CSSMERR_TP_CERTGROUP_INCOMPLETE = -2147409656;

const int CSSMERR_TP_CERTIFICATE_CANT_OPERATE = -2147409655;

const int CSSMERR_TP_CERT_EXPIRED = -2147409654;

const int CSSMERR_TP_CERT_NOT_VALID_YET = -2147409653;

const int CSSMERR_TP_CERT_REVOKED = -2147409652;

const int CSSMERR_TP_CERT_SUSPENDED = -2147409651;

const int CSSMERR_TP_INSUFFICIENT_CREDENTIALS = -2147409650;

const int CSSMERR_TP_INVALID_ACTION = -2147409649;

const int CSSMERR_TP_INVALID_ACTION_DATA = -2147409648;

const int CSSMERR_TP_INVALID_ANCHOR_CERT = -2147409646;

const int CSSMERR_TP_INVALID_AUTHORITY = -2147409645;

const int CSSMERR_TP_VERIFY_ACTION_FAILED = -2147409644;

const int CSSMERR_TP_INVALID_CERTIFICATE = -2147409643;

const int CSSMERR_TP_INVALID_CERT_AUTHORITY = -2147409642;

const int CSSMERR_TP_INVALID_CRL_AUTHORITY = -2147409641;

const int CSSMERR_TP_INVALID_CRL_ENCODING = -2147409640;

const int CSSMERR_TP_INVALID_CRL_TYPE = -2147409639;

const int CSSMERR_TP_INVALID_CRL = -2147409638;

const int CSSMERR_TP_INVALID_FORM_TYPE = -2147409637;

const int CSSMERR_TP_INVALID_ID = -2147409636;

const int CSSMERR_TP_INVALID_IDENTIFIER = -2147409635;

const int CSSMERR_TP_INVALID_INDEX = -2147409634;

const int CSSMERR_TP_INVALID_NAME = -2147409633;

const int CSSMERR_TP_INVALID_POLICY_IDENTIFIERS = -2147409632;

const int CSSMERR_TP_INVALID_TIMESTRING = -2147409631;

const int CSSMERR_TP_INVALID_REASON = -2147409630;

const int CSSMERR_TP_INVALID_REQUEST_INPUTS = -2147409629;

const int CSSMERR_TP_INVALID_RESPONSE_VECTOR = -2147409628;

const int CSSMERR_TP_INVALID_SIGNATURE = -2147409627;

const int CSSMERR_TP_INVALID_STOP_ON_POLICY = -2147409626;

const int CSSMERR_TP_INVALID_CALLBACK = -2147409625;

const int CSSMERR_TP_INVALID_TUPLE = -2147409624;

const int CSSMERR_TP_NOT_SIGNER = -2147409623;

const int CSSMERR_TP_NOT_TRUSTED = -2147409622;

const int CSSMERR_TP_NO_DEFAULT_AUTHORITY = -2147409621;

const int CSSMERR_TP_REJECTED_FORM = -2147409620;

const int CSSMERR_TP_REQUEST_LOST = -2147409619;

const int CSSMERR_TP_REQUEST_REJECTED = -2147409618;

const int CSSMERR_TP_UNSUPPORTED_ADDR_TYPE = -2147409617;

const int CSSMERR_TP_UNSUPPORTED_SERVICE = -2147409616;

const int CSSMERR_TP_INVALID_TUPLEGROUP_POINTER = -2147409615;

const int CSSMERR_TP_INVALID_TUPLEGROUP = -2147409614;

const int CSSMERR_AC_INTERNAL_ERROR = -2147405823;

const int CSSMERR_AC_MEMORY_ERROR = -2147405822;

const int CSSMERR_AC_MDS_ERROR = -2147405821;

const int CSSMERR_AC_INVALID_POINTER = -2147405820;

const int CSSMERR_AC_INVALID_INPUT_POINTER = -2147405819;

const int CSSMERR_AC_INVALID_OUTPUT_POINTER = -2147405818;

const int CSSMERR_AC_FUNCTION_NOT_IMPLEMENTED = -2147405817;

const int CSSMERR_AC_SELF_CHECK_FAILED = -2147405816;

const int CSSMERR_AC_OS_ACCESS_DENIED = -2147405815;

const int CSSMERR_AC_FUNCTION_FAILED = -2147405814;

const int CSSMERR_AC_INVALID_CONTEXT_HANDLE = -2147405760;

const int CSSMERR_AC_INVALID_DATA = -2147405754;

const int CSSMERR_AC_INVALID_DB_LIST = -2147405748;

const int CSSMERR_AC_INVALID_PASSTHROUGH_ID = -2147405738;

const int CSSMERR_AC_INVALID_DL_HANDLE = -2147405743;

const int CSSMERR_AC_INVALID_CL_HANDLE = -2147405742;

const int CSSMERR_AC_INVALID_TP_HANDLE = -2147405741;

const int CSSMERR_AC_INVALID_DB_HANDLE = -2147405750;

const int CSSMERR_AC_INVALID_DB_LIST_POINTER = -2147405747;

const int CSSM_AC_BASE_AC_ERROR = -2147405568;

const int CSSMERR_AC_INVALID_BASE_ACLS = -2147405567;

const int CSSMERR_AC_INVALID_TUPLE_CREDENTIALS = -2147405566;

const int CSSMERR_AC_INVALID_ENCODING = -2147405565;

const int CSSMERR_AC_INVALID_VALIDITY_PERIOD = -2147405564;

const int CSSMERR_AC_INVALID_REQUESTOR = -2147405563;

const int CSSMERR_AC_INVALID_REQUEST_DESCRIPTOR = -2147405562;

const int CSSMERR_CL_INTERNAL_ERROR = -2147411967;

const int CSSMERR_CL_MEMORY_ERROR = -2147411966;

const int CSSMERR_CL_MDS_ERROR = -2147411965;

const int CSSMERR_CL_INVALID_POINTER = -2147411964;

const int CSSMERR_CL_INVALID_INPUT_POINTER = -2147411963;

const int CSSMERR_CL_INVALID_OUTPUT_POINTER = -2147411962;

const int CSSMERR_CL_FUNCTION_NOT_IMPLEMENTED = -2147411961;

const int CSSMERR_CL_SELF_CHECK_FAILED = -2147411960;

const int CSSMERR_CL_OS_ACCESS_DENIED = -2147411959;

const int CSSMERR_CL_FUNCTION_FAILED = -2147411958;

const int CSSMERR_CL_INVALID_CONTEXT_HANDLE = -2147411904;

const int CSSMERR_CL_INVALID_CERTGROUP_POINTER = -2147411902;

const int CSSMERR_CL_INVALID_CERT_POINTER = -2147411901;

const int CSSMERR_CL_INVALID_CRL_POINTER = -2147411900;

const int CSSMERR_CL_INVALID_FIELD_POINTER = -2147411899;

const int CSSMERR_CL_INVALID_DATA = -2147411898;

const int CSSMERR_CL_CRL_ALREADY_SIGNED = -2147411897;

const int CSSMERR_CL_INVALID_NUMBER_OF_FIELDS = -2147411896;

const int CSSMERR_CL_VERIFICATION_FAILURE = -2147411895;

const int CSSMERR_CL_UNKNOWN_FORMAT = -2147411890;

const int CSSMERR_CL_UNKNOWN_TAG = -2147411889;

const int CSSMERR_CL_INVALID_PASSTHROUGH_ID = -2147411882;

const int CSSM_CL_BASE_CL_ERROR = -2147411712;

const int CSSMERR_CL_INVALID_BUNDLE_POINTER = -2147411711;

const int CSSMERR_CL_INVALID_CACHE_HANDLE = -2147411710;

const int CSSMERR_CL_INVALID_RESULTS_HANDLE = -2147411709;

const int CSSMERR_CL_INVALID_BUNDLE_INFO = -2147411708;

const int CSSMERR_CL_INVALID_CRL_INDEX = -2147411707;

const int CSSMERR_CL_INVALID_SCOPE = -2147411706;

const int CSSMERR_CL_NO_FIELD_VALUES = -2147411705;

const int CSSMERR_CL_SCOPE_NOT_SUPPORTED = -2147411704;

const int CSSMERR_DL_INTERNAL_ERROR = -2147414015;

const int CSSMERR_DL_MEMORY_ERROR = -2147414014;

const int CSSMERR_DL_MDS_ERROR = -2147414013;

const int CSSMERR_DL_INVALID_POINTER = -2147414012;

const int CSSMERR_DL_INVALID_INPUT_POINTER = -2147414011;

const int CSSMERR_DL_INVALID_OUTPUT_POINTER = -2147414010;

const int CSSMERR_DL_FUNCTION_NOT_IMPLEMENTED = -2147414009;

const int CSSMERR_DL_SELF_CHECK_FAILED = -2147414008;

const int CSSMERR_DL_OS_ACCESS_DENIED = -2147414007;

const int CSSMERR_DL_FUNCTION_FAILED = -2147414006;

const int CSSMERR_DL_INVALID_CSP_HANDLE = -2147413936;

const int CSSMERR_DL_INVALID_DL_HANDLE = -2147413935;

const int CSSMERR_DL_INVALID_CL_HANDLE = -2147413934;

const int CSSMERR_DL_INVALID_DB_LIST_POINTER = -2147413939;

const int CSSMERR_DL_OPERATION_AUTH_DENIED = -2147413984;

const int CSSMERR_DL_OBJECT_USE_AUTH_DENIED = -2147413983;

const int CSSMERR_DL_OBJECT_MANIP_AUTH_DENIED = -2147413982;

const int CSSMERR_DL_OBJECT_ACL_NOT_SUPPORTED = -2147413981;

const int CSSMERR_DL_OBJECT_ACL_REQUIRED = -2147413980;

const int CSSMERR_DL_INVALID_ACCESS_CREDENTIALS = -2147413979;

const int CSSMERR_DL_INVALID_ACL_BASE_CERTS = -2147413978;

const int CSSMERR_DL_ACL_BASE_CERTS_NOT_SUPPORTED = -2147413977;

const int CSSMERR_DL_INVALID_SAMPLE_VALUE = -2147413976;

const int CSSMERR_DL_SAMPLE_VALUE_NOT_SUPPORTED = -2147413975;

const int CSSMERR_DL_INVALID_ACL_SUBJECT_VALUE = -2147413974;

const int CSSMERR_DL_ACL_SUBJECT_TYPE_NOT_SUPPORTED = -2147413973;

const int CSSMERR_DL_INVALID_ACL_CHALLENGE_CALLBACK = -2147413972;

const int CSSMERR_DL_ACL_CHALLENGE_CALLBACK_FAILED = -2147413971;

const int CSSMERR_DL_INVALID_ACL_ENTRY_TAG = -2147413970;

const int CSSMERR_DL_ACL_ENTRY_TAG_NOT_FOUND = -2147413969;

const int CSSMERR_DL_INVALID_ACL_EDIT_MODE = -2147413968;

const int CSSMERR_DL_ACL_CHANGE_FAILED = -2147413967;

const int CSSMERR_DL_INVALID_NEW_ACL_ENTRY = -2147413966;

const int CSSMERR_DL_INVALID_NEW_ACL_OWNER = -2147413965;

const int CSSMERR_DL_ACL_DELETE_FAILED = -2147413964;

const int CSSMERR_DL_ACL_REPLACE_FAILED = -2147413963;

const int CSSMERR_DL_ACL_ADD_FAILED = -2147413962;

const int CSSMERR_DL_INVALID_DB_HANDLE = -2147413942;

const int CSSMERR_DL_INVALID_PASSTHROUGH_ID = -2147413930;

const int CSSMERR_DL_INVALID_NETWORK_ADDR = -2147413929;

const int CSSM_DL_BASE_DL_ERROR = -2147413760;

const int CSSMERR_DL_DATABASE_CORRUPT = -2147413759;

const int CSSMERR_DL_INVALID_RECORD_INDEX = -2147413752;

const int CSSMERR_DL_INVALID_RECORDTYPE = -2147413751;

const int CSSMERR_DL_INVALID_FIELD_NAME = -2147413750;

const int CSSMERR_DL_UNSUPPORTED_FIELD_FORMAT = -2147413749;

const int CSSMERR_DL_UNSUPPORTED_INDEX_INFO = -2147413748;

const int CSSMERR_DL_UNSUPPORTED_LOCALITY = -2147413747;

const int CSSMERR_DL_UNSUPPORTED_NUM_ATTRIBUTES = -2147413746;

const int CSSMERR_DL_UNSUPPORTED_NUM_INDEXES = -2147413745;

const int CSSMERR_DL_UNSUPPORTED_NUM_RECORDTYPES = -2147413744;

const int CSSMERR_DL_UNSUPPORTED_RECORDTYPE = -2147413743;

const int CSSMERR_DL_FIELD_SPECIFIED_MULTIPLE = -2147413742;

const int CSSMERR_DL_INCOMPATIBLE_FIELD_FORMAT = -2147413741;

const int CSSMERR_DL_INVALID_PARSING_MODULE = -2147413740;

const int CSSMERR_DL_INVALID_DB_NAME = -2147413738;

const int CSSMERR_DL_DATASTORE_DOESNOT_EXIST = -2147413737;

const int CSSMERR_DL_DATASTORE_ALREADY_EXISTS = -2147413736;

const int CSSMERR_DL_DB_LOCKED = -2147413735;

const int CSSMERR_DL_DATASTORE_IS_OPEN = -2147413734;

const int CSSMERR_DL_RECORD_NOT_FOUND = -2147413733;

const int CSSMERR_DL_MISSING_VALUE = -2147413732;

const int CSSMERR_DL_UNSUPPORTED_QUERY = -2147413731;

const int CSSMERR_DL_UNSUPPORTED_QUERY_LIMITS = -2147413730;

const int CSSMERR_DL_UNSUPPORTED_NUM_SELECTION_PREDS = -2147413729;

const int CSSMERR_DL_UNSUPPORTED_OPERATOR = -2147413727;

const int CSSMERR_DL_INVALID_RESULTS_HANDLE = -2147413726;

const int CSSMERR_DL_INVALID_DB_LOCATION = -2147413725;

const int CSSMERR_DL_INVALID_ACCESS_REQUEST = -2147413724;

const int CSSMERR_DL_INVALID_INDEX_INFO = -2147413723;

const int CSSMERR_DL_INVALID_SELECTION_TAG = -2147413722;

const int CSSMERR_DL_INVALID_NEW_OWNER = -2147413721;

const int CSSMERR_DL_INVALID_RECORD_UID = -2147413720;

const int CSSMERR_DL_INVALID_UNIQUE_INDEX_DATA = -2147413719;

const int CSSMERR_DL_INVALID_MODIFY_MODE = -2147413718;

const int CSSMERR_DL_INVALID_OPEN_PARAMETERS = -2147413717;

const int CSSMERR_DL_RECORD_MODIFIED = -2147413716;

const int CSSMERR_DL_ENDOFDATA = -2147413715;

const int CSSMERR_DL_INVALID_QUERY = -2147413714;

const int CSSMERR_DL_INVALID_VALUE = -2147413713;

const int CSSMERR_DL_MULTIPLE_VALUES_UNSUPPORTED = -2147413712;

const int CSSMERR_DL_STALE_UNIQUE_RECORD = -2147413711;

const int CSSM_WORDID_KEYCHAIN_PROMPT = 65536;

const int CSSM_WORDID_KEYCHAIN_LOCK = 65537;

const int CSSM_WORDID_KEYCHAIN_CHANGE_LOCK = 65538;

const int CSSM_WORDID_PROCESS = 65539;

const int CSSM_WORDID__RESERVED_1 = 65540;

const int CSSM_WORDID_SYMMETRIC_KEY = 65541;

const int CSSM_WORDID_SYSTEM = 65542;

const int CSSM_WORDID_KEY = 65543;

const int CSSM_WORDID_PIN = 65544;

const int CSSM_WORDID_PREAUTH = 65545;

const int CSSM_WORDID_PREAUTH_SOURCE = 65546;

const int CSSM_WORDID_ASYMMETRIC_KEY = 65547;

const int CSSM_WORDID_PARTITION = 65548;

const int CSSM_WORDID_KEYBAG_KEY = 65549;

const int CSSM_WORDID__FIRST_UNUSED = 65550;

const int CSSM_ACL_SUBJECT_TYPE_KEYCHAIN_PROMPT = 65536;

const int CSSM_ACL_SUBJECT_TYPE_PROCESS = 65539;

const int CSSM_ACL_SUBJECT_TYPE_CODE_SIGNATURE = 116;

const int CSSM_ACL_SUBJECT_TYPE_COMMENT = 12;

const int CSSM_ACL_SUBJECT_TYPE_SYMMETRIC_KEY = 65541;

const int CSSM_ACL_SUBJECT_TYPE_PREAUTH = 65545;

const int CSSM_ACL_SUBJECT_TYPE_PREAUTH_SOURCE = 65546;

const int CSSM_ACL_SUBJECT_TYPE_ASYMMETRIC_KEY = 65547;

const int CSSM_ACL_SUBJECT_TYPE_PARTITION = 65548;

const int CSSM_SAMPLE_TYPE_KEYCHAIN_PROMPT = 65536;

const int CSSM_SAMPLE_TYPE_KEYCHAIN_LOCK = 65537;

const int CSSM_SAMPLE_TYPE_KEYCHAIN_CHANGE_LOCK = 65538;

const int CSSM_SAMPLE_TYPE_PROCESS = 65539;

const int CSSM_SAMPLE_TYPE_COMMENT = 12;

const int CSSM_SAMPLE_TYPE_RETRY_ID = 85;

const int CSSM_SAMPLE_TYPE_SYMMETRIC_KEY = 65541;

const int CSSM_SAMPLE_TYPE_PREAUTH = 65545;

const int CSSM_SAMPLE_TYPE_ASYMMETRIC_KEY = 65547;

const int CSSM_SAMPLE_TYPE_KEYBAG_KEY = 65549;

const int CSSM_ACL_AUTHORIZATION_CHANGE_ACL = 65536;

const int CSSM_ACL_AUTHORIZATION_CHANGE_OWNER = 65537;

const int CSSM_ACL_AUTHORIZATION_PARTITION_ID = 65538;

const int CSSM_ACL_AUTHORIZATION_INTEGRITY = 65539;

const int CSSM_ACL_AUTHORIZATION_PREAUTH_BASE = 16842752;

const int CSSM_ACL_AUTHORIZATION_PREAUTH_END = 16908288;

const int CSSM_ACL_CODE_SIGNATURE_INVALID = 0;

const int CSSM_ACL_CODE_SIGNATURE_OSX = 1;

const int CSSM_ACL_MATCH_UID = 1;

const int CSSM_ACL_MATCH_GID = 2;

const int CSSM_ACL_MATCH_HONOR_ROOT = 256;

const int CSSM_ACL_MATCH_BITS = 3;

const int CSSM_ACL_PROCESS_SELECTOR_CURRENT_VERSION = 257;

const int CSSM_ACL_KEYCHAIN_PROMPT_CURRENT_VERSION = 257;

const int CSSM_ACL_KEYCHAIN_PROMPT_REQUIRE_PASSPHRASE = 1;

const int CSSM_ACL_KEYCHAIN_PROMPT_UNSIGNED = 16;

const int CSSM_ACL_KEYCHAIN_PROMPT_UNSIGNED_ACT = 32;

const int CSSM_ACL_KEYCHAIN_PROMPT_INVALID = 64;

const int CSSM_ACL_KEYCHAIN_PROMPT_INVALID_ACT = 128;

const int CSSM_ACL_PREAUTH_TRACKING_COUNT_MASK = 255;

const int CSSM_ACL_PREAUTH_TRACKING_BLOCKED = 0;

const int CSSM_ACL_PREAUTH_TRACKING_UNKNOWN = 1073741824;

const int CSSM_ACL_PREAUTH_TRACKING_AUTHORIZED = -2147483648;

const int CSSM_DB_ACCESS_RESET = 65536;

const int CSSM_ALGID_APPLE_YARROW = -2147483648;

const int CSSM_ALGID_AES = -2147483647;

const int CSSM_ALGID_FEE = -2147483646;

const int CSSM_ALGID_FEE_MD5 = -2147483645;

const int CSSM_ALGID_FEE_SHA1 = -2147483644;

const int CSSM_ALGID_FEED = -2147483643;

const int CSSM_ALGID_FEEDEXP = -2147483642;

const int CSSM_ALGID_ASC = -2147483641;

const int CSSM_ALGID_SHA1HMAC_LEGACY = -2147483640;

const int CSSM_ALGID_KEYCHAIN_KEY = -2147483639;

const int CSSM_ALGID_PKCS12_PBE_ENCR = -2147483638;

const int CSSM_ALGID_PKCS12_PBE_MAC = -2147483637;

const int CSSM_ALGID_SECURE_PASSPHRASE = -2147483636;

const int CSSM_ALGID_PBE_OPENSSL_MD5 = -2147483635;

const int CSSM_ALGID_SHA256 = -2147483634;

const int CSSM_ALGID_SHA384 = -2147483633;

const int CSSM_ALGID_SHA512 = -2147483632;

const int CSSM_ALGID_ENTROPY_DEFAULT = -2147483631;

const int CSSM_ALGID_SHA224 = -2147483630;

const int CSSM_ALGID_SHA224WithRSA = -2147483629;

const int CSSM_ALGID_SHA256WithRSA = -2147483628;

const int CSSM_ALGID_SHA384WithRSA = -2147483627;

const int CSSM_ALGID_SHA512WithRSA = -2147483626;

const int CSSM_ALGID_OPENSSH1 = -2147483625;

const int CSSM_ALGID_SHA224WithECDSA = -2147483624;

const int CSSM_ALGID_SHA256WithECDSA = -2147483623;

const int CSSM_ALGID_SHA384WithECDSA = -2147483622;

const int CSSM_ALGID_SHA512WithECDSA = -2147483621;

const int CSSM_ALGID_ECDSA_SPECIFIED = -2147483620;

const int CSSM_ALGID_ECDH_X963_KDF = -2147483619;

const int CSSM_ALGID__FIRST_UNUSED = -2147483618;

const int CSSM_PADDING_APPLE_SSLv2 = -2147483648;

const int CSSM_KEYBLOB_RAW_FORMAT_VENDOR_DEFINED = -2147483648;

const int CSSM_KEYBLOB_RAW_FORMAT_X509 = -2147483648;

const int CSSM_KEYBLOB_RAW_FORMAT_OPENSSH = -2147483647;

const int CSSM_KEYBLOB_RAW_FORMAT_OPENSSL = -2147483646;

const int CSSM_KEYBLOB_RAW_FORMAT_OPENSSH2 = -2147483645;

const int CSSM_CUSTOM_COMMON_ERROR_EXTENT = 224;

const int CSSM_ERRCODE_NO_USER_INTERACTION = 224;

const int CSSM_ERRCODE_USER_CANCELED = 225;

const int CSSM_ERRCODE_SERVICE_NOT_AVAILABLE = 226;

const int CSSM_ERRCODE_INSUFFICIENT_CLIENT_IDENTIFICATION = 227;

const int CSSM_ERRCODE_DEVICE_RESET = 228;

const int CSSM_ERRCODE_DEVICE_FAILED = 229;

const int CSSM_ERRCODE_IN_DARK_WAKE = 230;

const int CSSMERR_CSSM_NO_USER_INTERACTION = -2147417888;

const int CSSMERR_AC_NO_USER_INTERACTION = -2147405600;

const int CSSMERR_CSP_NO_USER_INTERACTION = -2147415840;

const int CSSMERR_CL_NO_USER_INTERACTION = -2147411744;

const int CSSMERR_DL_NO_USER_INTERACTION = -2147413792;

const int CSSMERR_TP_NO_USER_INTERACTION = -2147409696;

const int CSSMERR_CSSM_USER_CANCELED = -2147417887;

const int CSSMERR_AC_USER_CANCELED = -2147405599;

const int CSSMERR_CSP_USER_CANCELED = -2147415839;

const int CSSMERR_CL_USER_CANCELED = -2147411743;

const int CSSMERR_DL_USER_CANCELED = -2147413791;

const int CSSMERR_TP_USER_CANCELED = -2147409695;

const int CSSMERR_CSSM_SERVICE_NOT_AVAILABLE = -2147417886;

const int CSSMERR_AC_SERVICE_NOT_AVAILABLE = -2147405598;

const int CSSMERR_CSP_SERVICE_NOT_AVAILABLE = -2147415838;

const int CSSMERR_CL_SERVICE_NOT_AVAILABLE = -2147411742;

const int CSSMERR_DL_SERVICE_NOT_AVAILABLE = -2147413790;

const int CSSMERR_TP_SERVICE_NOT_AVAILABLE = -2147409694;

const int CSSMERR_CSSM_INSUFFICIENT_CLIENT_IDENTIFICATION = -2147417885;

const int CSSMERR_AC_INSUFFICIENT_CLIENT_IDENTIFICATION = -2147405597;

const int CSSMERR_CSP_INSUFFICIENT_CLIENT_IDENTIFICATION = -2147415837;

const int CSSMERR_CL_INSUFFICIENT_CLIENT_IDENTIFICATION = -2147411741;

const int CSSMERR_DL_INSUFFICIENT_CLIENT_IDENTIFICATION = -2147413789;

const int CSSMERR_TP_INSUFFICIENT_CLIENT_IDENTIFICATION = -2147409693;

const int CSSMERR_CSSM_DEVICE_RESET = -2147417884;

const int CSSMERR_AC_DEVICE_RESET = -2147405596;

const int CSSMERR_CSP_DEVICE_RESET = -2147415836;

const int CSSMERR_CL_DEVICE_RESET = -2147411740;

const int CSSMERR_DL_DEVICE_RESET = -2147413788;

const int CSSMERR_TP_DEVICE_RESET = -2147409692;

const int CSSMERR_CSSM_DEVICE_FAILED = -2147417883;

const int CSSMERR_AC_DEVICE_FAILED = -2147405595;

const int CSSMERR_CSP_DEVICE_FAILED = -2147415835;

const int CSSMERR_CL_DEVICE_FAILED = -2147411739;

const int CSSMERR_DL_DEVICE_FAILED = -2147413787;

const int CSSMERR_TP_DEVICE_FAILED = -2147409691;

const int CSSMERR_CSSM_IN_DARK_WAKE = -2147417882;

const int CSSMERR_AC_IN_DARK_WAKE = -2147405594;

const int CSSMERR_CSP_IN_DARK_WAKE = -2147415834;

const int CSSMERR_CL_IN_DARK_WAKE = -2147411738;

const int CSSMERR_DL_IN_DARK_WAKE = -2147413786;

const int CSSMERR_TP_IN_DARK_WAKE = -2147409690;

const int CSSMERR_CSP_APPLE_ADD_APPLICATION_ACL_SUBJECT = -2147415040;

const int CSSMERR_CSP_APPLE_PUBLIC_KEY_INCOMPLETE = -2147415039;

const int CSSMERR_CSP_APPLE_SIGNATURE_MISMATCH = -2147415038;

const int CSSMERR_CSP_APPLE_INVALID_KEY_START_DATE = -2147415037;

const int CSSMERR_CSP_APPLE_INVALID_KEY_END_DATE = -2147415036;

const int CSSMERR_CSPDL_APPLE_DL_CONVERSION_ERROR = -2147415035;

const int CSSMERR_CSP_APPLE_SSLv2_ROLLBACK = -2147415034;

const int CSSM_DL_DB_RECORD_GENERIC_PASSWORD = -2147483648;

const int CSSM_DL_DB_RECORD_INTERNET_PASSWORD = -2147483647;

const int CSSM_DL_DB_RECORD_APPLESHARE_PASSWORD = -2147483646;

const int CSSM_DL_DB_RECORD_X509_CERTIFICATE = -2147479552;

const int CSSM_DL_DB_RECORD_USER_TRUST = -2147479551;

const int CSSM_DL_DB_RECORD_X509_CRL = -2147479550;

const int CSSM_DL_DB_RECORD_UNLOCK_REFERRAL = -2147479549;

const int CSSM_DL_DB_RECORD_EXTENDED_ATTRIBUTE = -2147479548;

const int CSSM_DL_DB_RECORD_METADATA = -2147450880;

const int CSSM_APPLEFILEDL_TOGGLE_AUTOCOMMIT = 0;

const int CSSM_APPLEFILEDL_COMMIT = 1;

const int CSSM_APPLEFILEDL_ROLLBACK = 2;

const int CSSM_APPLEFILEDL_TAKE_FILE_LOCK = 3;

const int CSSM_APPLEFILEDL_MAKE_BACKUP = 4;

const int CSSM_APPLEFILEDL_MAKE_COPY = 5;

const int CSSM_APPLEFILEDL_DELETE_FILE = 6;

const int CSSM_APPLE_UNLOCK_TYPE_KEY_DIRECT = 1;

const int CSSM_APPLE_UNLOCK_TYPE_WRAPPED_PRIVATE = 2;

const int CSSM_APPLE_UNLOCK_TYPE_KEYBAG = 3;

const int CSSMERR_APPLEDL_INVALID_OPEN_PARAMETERS = -2147412992;

const int CSSMERR_APPLEDL_DISK_FULL = -2147412991;

const int CSSMERR_APPLEDL_QUOTA_EXCEEDED = -2147412990;

const int CSSMERR_APPLEDL_FILE_TOO_BIG = -2147412989;

const int CSSMERR_APPLEDL_INVALID_DATABASE_BLOB = -2147412988;

const int CSSMERR_APPLEDL_INVALID_KEY_BLOB = -2147412987;

const int CSSMERR_APPLEDL_INCOMPATIBLE_DATABASE_BLOB = -2147412986;

const int CSSMERR_APPLEDL_INCOMPATIBLE_KEY_BLOB = -2147412985;

const int CSSMERR_APPLETP_HOSTNAME_MISMATCH = -2147408896;

const int CSSMERR_APPLETP_UNKNOWN_CRITICAL_EXTEN = -2147408895;

const int CSSMERR_APPLETP_NO_BASIC_CONSTRAINTS = -2147408894;

const int CSSMERR_APPLETP_INVALID_CA = -2147408893;

const int CSSMERR_APPLETP_INVALID_AUTHORITY_ID = -2147408892;

const int CSSMERR_APPLETP_INVALID_SUBJECT_ID = -2147408891;

const int CSSMERR_APPLETP_INVALID_KEY_USAGE = -2147408890;

const int CSSMERR_APPLETP_INVALID_EXTENDED_KEY_USAGE = -2147408889;

const int CSSMERR_APPLETP_INVALID_ID_LINKAGE = -2147408888;

const int CSSMERR_APPLETP_PATH_LEN_CONSTRAINT = -2147408887;

const int CSSMERR_APPLETP_INVALID_ROOT = -2147408886;

const int CSSMERR_APPLETP_CRL_EXPIRED = -2147408885;

const int CSSMERR_APPLETP_CRL_NOT_VALID_YET = -2147408884;

const int CSSMERR_APPLETP_CRL_NOT_FOUND = -2147408883;

const int CSSMERR_APPLETP_CRL_SERVER_DOWN = -2147408882;

const int CSSMERR_APPLETP_CRL_BAD_URI = -2147408881;

const int CSSMERR_APPLETP_UNKNOWN_CERT_EXTEN = -2147408880;

const int CSSMERR_APPLETP_UNKNOWN_CRL_EXTEN = -2147408879;

const int CSSMERR_APPLETP_CRL_NOT_TRUSTED = -2147408878;

const int CSSMERR_APPLETP_CRL_INVALID_ANCHOR_CERT = -2147408877;

const int CSSMERR_APPLETP_CRL_POLICY_FAIL = -2147408876;

const int CSSMERR_APPLETP_IDP_FAIL = -2147408875;

const int CSSMERR_APPLETP_CERT_NOT_FOUND_FROM_ISSUER = -2147408874;

const int CSSMERR_APPLETP_BAD_CERT_FROM_ISSUER = -2147408873;

const int CSSMERR_APPLETP_SMIME_EMAIL_ADDRS_NOT_FOUND = -2147408872;

const int CSSMERR_APPLETP_SMIME_BAD_EXT_KEY_USE = -2147408871;

const int CSSMERR_APPLETP_SMIME_BAD_KEY_USE = -2147408870;

const int CSSMERR_APPLETP_SMIME_KEYUSAGE_NOT_CRITICAL = -2147408869;

const int CSSMERR_APPLETP_SMIME_NO_EMAIL_ADDRS = -2147408868;

const int CSSMERR_APPLETP_SMIME_SUBJ_ALT_NAME_NOT_CRIT = -2147408867;

const int CSSMERR_APPLETP_SSL_BAD_EXT_KEY_USE = -2147408866;

const int CSSMERR_APPLETP_OCSP_BAD_RESPONSE = -2147408865;

const int CSSMERR_APPLETP_OCSP_BAD_REQUEST = -2147408864;

const int CSSMERR_APPLETP_OCSP_UNAVAILABLE = -2147408863;

const int CSSMERR_APPLETP_OCSP_STATUS_UNRECOGNIZED = -2147408862;

const int CSSMERR_APPLETP_INCOMPLETE_REVOCATION_CHECK = -2147408861;

const int CSSMERR_APPLETP_NETWORK_FAILURE = -2147408860;

const int CSSMERR_APPLETP_OCSP_NOT_TRUSTED = -2147408859;

const int CSSMERR_APPLETP_OCSP_INVALID_ANCHOR_CERT = -2147408858;

const int CSSMERR_APPLETP_OCSP_SIG_ERROR = -2147408857;

const int CSSMERR_APPLETP_OCSP_NO_SIGNER = -2147408856;

const int CSSMERR_APPLETP_OCSP_RESP_MALFORMED_REQ = -2147408855;

const int CSSMERR_APPLETP_OCSP_RESP_INTERNAL_ERR = -2147408854;

const int CSSMERR_APPLETP_OCSP_RESP_TRY_LATER = -2147408853;

const int CSSMERR_APPLETP_OCSP_RESP_SIG_REQUIRED = -2147408852;

const int CSSMERR_APPLETP_OCSP_RESP_UNAUTHORIZED = -2147408851;

const int CSSMERR_APPLETP_OCSP_NONCE_MISMATCH = -2147408850;

const int CSSMERR_APPLETP_CS_BAD_CERT_CHAIN_LENGTH = -2147408849;

const int CSSMERR_APPLETP_CS_NO_BASIC_CONSTRAINTS = -2147408848;

const int CSSMERR_APPLETP_CS_BAD_PATH_LENGTH = -2147408847;

const int CSSMERR_APPLETP_CS_NO_EXTENDED_KEY_USAGE = -2147408846;

const int CSSMERR_APPLETP_CODE_SIGN_DEVELOPMENT = -2147408845;

const int CSSMERR_APPLETP_RS_BAD_CERT_CHAIN_LENGTH = -2147408844;

const int CSSMERR_APPLETP_RS_BAD_EXTENDED_KEY_USAGE = -2147408843;

const int CSSMERR_APPLETP_TRUST_SETTING_DENY = -2147408842;

const int CSSMERR_APPLETP_INVALID_EMPTY_SUBJECT = -2147408841;

const int CSSMERR_APPLETP_UNKNOWN_QUAL_CERT_STATEMENT = -2147408840;

const int CSSMERR_APPLETP_MISSING_REQUIRED_EXTENSION = -2147408839;

const int CSSMERR_APPLETP_EXT_KEYUSAGE_NOT_CRITICAL = -2147408838;

const int CSSMERR_APPLETP_IDENTIFIER_MISSING = -2147408837;

const int CSSMERR_APPLETP_CA_PIN_MISMATCH = -2147408836;

const int CSSMERR_APPLETP_LEAF_PIN_MISMATCH = -2147408835;

const int CSSMERR_APPLE_DOTMAC_REQ_QUEUED = -2147408796;

const int CSSMERR_APPLE_DOTMAC_REQ_REDIRECT = -2147408795;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_ERR = -2147408794;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_PARAM = -2147408793;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_AUTH = -2147408792;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_UNIMPL = -2147408791;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_NOT_AVAIL = -2147408790;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_ALREADY_EXIST = -2147408789;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_SERVICE_ERROR = -2147408788;

const int CSSMERR_APPLE_DOTMAC_REQ_IS_PENDING = -2147408787;

const int CSSMERR_APPLE_DOTMAC_NO_REQ_PENDING = -2147408786;

const int CSSMERR_APPLE_DOTMAC_CSR_VERIFY_FAIL = -2147408785;

const int CSSMERR_APPLE_DOTMAC_FAILED_CONSISTENCY_CHECK = -2147408784;

const int CSSM_APPLEDL_OPEN_PARAMETERS_VERSION = 1;

const int CSSM_APPLECSPDL_DB_LOCK = 0;

const int CSSM_APPLECSPDL_DB_UNLOCK = 1;

const int CSSM_APPLECSPDL_DB_GET_SETTINGS = 2;

const int CSSM_APPLECSPDL_DB_SET_SETTINGS = 3;

const int CSSM_APPLECSPDL_DB_IS_LOCKED = 4;

const int CSSM_APPLECSPDL_DB_CHANGE_PASSWORD = 5;

const int CSSM_APPLECSPDL_DB_GET_HANDLE = 6;

const int CSSM_APPLESCPDL_CSP_GET_KEYHANDLE = 7;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_8 = 8;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_9 = 9;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_10 = 10;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_11 = 11;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_12 = 12;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_13 = 13;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_14 = 14;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_15 = 15;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_16 = 16;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_17 = 17;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_18 = 18;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_19 = 19;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_20 = 20;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_21 = 21;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_22 = 22;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_23 = 23;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_24 = 24;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_25 = 25;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_26 = 26;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_27 = 27;

const int CSSM_APPLECSP_KEYDIGEST = 256;

const int CSSM_APPLECSP_PUBKEY = 257;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_APPLE_CUSTOM = 100;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_OPENSSL = 101;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_OPENSSH1 = 102;

const int CSSM_ATTRIBUTE_VENDOR_DEFINED = 8388608;

const int CSSM_ATTRIBUTE_PUBLIC_KEY = 1082130432;

const int CSSM_ATTRIBUTE_FEE_PRIME_TYPE = 276824065;

const int CSSM_ATTRIBUTE_FEE_CURVE_TYPE = 276824066;

const int CSSM_ATTRIBUTE_ASC_OPTIMIZATION = 276824067;

const int CSSM_ATTRIBUTE_RSA_BLINDING = 276824068;

const int CSSM_ATTRIBUTE_PARAM_KEY = 1082130437;

const int CSSM_ATTRIBUTE_PROMPT = 545259526;

const int CSSM_ATTRIBUTE_ALERT_TITLE = 545259527;

const int CSSM_ATTRIBUTE_VERIFY_PASSPHRASE = 276824072;

const int CSSM_FEE_PRIME_TYPE_DEFAULT = 0;

const int CSSM_FEE_PRIME_TYPE_MERSENNE = 1;

const int CSSM_FEE_PRIME_TYPE_FEE = 2;

const int CSSM_FEE_PRIME_TYPE_GENERAL = 3;

const int CSSM_FEE_CURVE_TYPE_DEFAULT = 0;

const int CSSM_FEE_CURVE_TYPE_MONTGOMERY = 1;

const int CSSM_FEE_CURVE_TYPE_WEIERSTRASS = 2;

const int CSSM_FEE_CURVE_TYPE_ANSI_X9_62 = 3;

const int CSSM_ASC_OPTIMIZE_DEFAULT = 0;

const int CSSM_ASC_OPTIMIZE_SIZE = 1;

const int CSSM_ASC_OPTIMIZE_SECURITY = 2;

const int CSSM_ASC_OPTIMIZE_TIME = 3;

const int CSSM_ASC_OPTIMIZE_TIME_SIZE = 4;

const int CSSM_ASC_OPTIMIZE_ASCII = 5;

const int CSSM_KEYATTR_PARTIAL = 65536;

const int CSSM_KEYATTR_PUBLIC_KEY_ENCRYPT = 131072;

const int CSSM_TP_ACTION_REQUIRE_CRL_PER_CERT = 1;

const int CSSM_TP_ACTION_FETCH_CRL_FROM_NET = 2;

const int CSSM_TP_ACTION_CRL_SUFFICIENT = 4;

const int CSSM_TP_ACTION_REQUIRE_CRL_IF_PRESENT = 8;

const int CSSM_TP_ACTION_ALLOW_EXPIRED = 1;

const int CSSM_TP_ACTION_LEAF_IS_CA = 2;

const int CSSM_TP_ACTION_FETCH_CERT_FROM_NET = 4;

const int CSSM_TP_ACTION_ALLOW_EXPIRED_ROOT = 8;

const int CSSM_TP_ACTION_REQUIRE_REV_PER_CERT = 16;

const int CSSM_TP_ACTION_TRUST_SETTINGS = 32;

const int CSSM_TP_ACTION_IMPLICIT_ANCHORS = 64;

const int CSSM_CERT_STATUS_EXPIRED = 1;

const int CSSM_CERT_STATUS_NOT_VALID_YET = 2;

const int CSSM_CERT_STATUS_IS_IN_INPUT_CERTS = 4;

const int CSSM_CERT_STATUS_IS_IN_ANCHORS = 8;

const int CSSM_CERT_STATUS_IS_ROOT = 16;

const int CSSM_CERT_STATUS_IS_FROM_NET = 32;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_FOUND_USER = 64;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_FOUND_ADMIN = 128;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_FOUND_SYSTEM = 256;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_TRUST = 512;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_DENY = 1024;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_IGNORED_ERROR = 2048;

const int CSSM_EVIDENCE_FORM_APPLE_HEADER = -2147483648;

const int CSSM_EVIDENCE_FORM_APPLE_CERTGROUP = -2147483647;

const int CSSM_EVIDENCE_FORM_APPLE_CERT_INFO = -2147483646;

const int CSSM_APPLEX509CL_OBTAIN_CSR = 0;

const int CSSM_APPLEX509CL_VERIFY_CSR = 1;

const int kSecSubjectItemAttr = 1937072746;

const int kSecIssuerItemAttr = 1769173877;

const int kSecSerialNumberItemAttr = 1936614002;

const int kSecPublicKeyHashItemAttr = 1752198009;

const int kSecSubjectKeyIdentifierItemAttr = 1936419172;

const int kSecCertTypeItemAttr = 1668577648;

const int kSecCertEncodingItemAttr = 1667591779;

const int SSL_NULL_WITH_NULL_NULL = 0;

const int SSL_RSA_WITH_NULL_MD5 = 1;

const int SSL_RSA_WITH_NULL_SHA = 2;

const int SSL_RSA_EXPORT_WITH_RC4_40_MD5 = 3;

const int SSL_RSA_WITH_RC4_128_MD5 = 4;

const int SSL_RSA_WITH_RC4_128_SHA = 5;

const int SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = 6;

const int SSL_RSA_WITH_IDEA_CBC_SHA = 7;

const int SSL_RSA_EXPORT_WITH_DES40_CBC_SHA = 8;

const int SSL_RSA_WITH_DES_CBC_SHA = 9;

const int SSL_RSA_WITH_3DES_EDE_CBC_SHA = 10;

const int SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = 11;

const int SSL_DH_DSS_WITH_DES_CBC_SHA = 12;

const int SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA = 13;

const int SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = 14;

const int SSL_DH_RSA_WITH_DES_CBC_SHA = 15;

const int SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA = 16;

const int SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = 17;

const int SSL_DHE_DSS_WITH_DES_CBC_SHA = 18;

const int SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 19;

const int SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = 20;

const int SSL_DHE_RSA_WITH_DES_CBC_SHA = 21;

const int SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 22;

const int SSL_DH_anon_EXPORT_WITH_RC4_40_MD5 = 23;

const int SSL_DH_anon_WITH_RC4_128_MD5 = 24;

const int SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA = 25;

const int SSL_DH_anon_WITH_DES_CBC_SHA = 26;

const int SSL_DH_anon_WITH_3DES_EDE_CBC_SHA = 27;

const int SSL_FORTEZZA_DMS_WITH_NULL_SHA = 28;

const int SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA = 29;

const int TLS_RSA_WITH_AES_128_CBC_SHA = 47;

const int TLS_DH_DSS_WITH_AES_128_CBC_SHA = 48;

const int TLS_DH_RSA_WITH_AES_128_CBC_SHA = 49;

const int TLS_DHE_DSS_WITH_AES_128_CBC_SHA = 50;

const int TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 51;

const int TLS_DH_anon_WITH_AES_128_CBC_SHA = 52;

const int TLS_RSA_WITH_AES_256_CBC_SHA = 53;

const int TLS_DH_DSS_WITH_AES_256_CBC_SHA = 54;

const int TLS_DH_RSA_WITH_AES_256_CBC_SHA = 55;

const int TLS_DHE_DSS_WITH_AES_256_CBC_SHA = 56;

const int TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 57;

const int TLS_DH_anon_WITH_AES_256_CBC_SHA = 58;

const int TLS_ECDH_ECDSA_WITH_NULL_SHA = -16383;

const int TLS_ECDH_ECDSA_WITH_RC4_128_SHA = -16382;

const int TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = -16381;

const int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = -16380;

const int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = -16379;

const int TLS_ECDHE_ECDSA_WITH_NULL_SHA = -16378;

const int TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = -16377;

const int TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = -16376;

const int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = -16375;

const int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = -16374;

const int TLS_ECDH_RSA_WITH_NULL_SHA = -16373;

const int TLS_ECDH_RSA_WITH_RC4_128_SHA = -16372;

const int TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = -16371;

const int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = -16370;

const int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = -16369;

const int TLS_ECDHE_RSA_WITH_NULL_SHA = -16368;

const int TLS_ECDHE_RSA_WITH_RC4_128_SHA = -16367;

const int TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = -16366;

const int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = -16365;

const int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = -16364;

const int TLS_ECDH_anon_WITH_NULL_SHA = -16363;

const int TLS_ECDH_anon_WITH_RC4_128_SHA = -16362;

const int TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = -16361;

const int TLS_ECDH_anon_WITH_AES_128_CBC_SHA = -16360;

const int TLS_ECDH_anon_WITH_AES_256_CBC_SHA = -16359;

const int TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA = -16331;

const int TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA = -16330;

const int TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = -13141;

const int TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = -13140;

const int TLS_NULL_WITH_NULL_NULL = 0;

const int TLS_RSA_WITH_NULL_MD5 = 1;

const int TLS_RSA_WITH_NULL_SHA = 2;

const int TLS_RSA_WITH_RC4_128_MD5 = 4;

const int TLS_RSA_WITH_RC4_128_SHA = 5;

const int TLS_RSA_WITH_3DES_EDE_CBC_SHA = 10;

const int TLS_RSA_WITH_NULL_SHA256 = 59;

const int TLS_RSA_WITH_AES_128_CBC_SHA256 = 60;

const int TLS_RSA_WITH_AES_256_CBC_SHA256 = 61;

const int TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = 13;

const int TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = 16;

const int TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = 19;

const int TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = 22;

const int TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = 62;

const int TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = 63;

const int TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = 64;

const int TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 103;

const int TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = 104;

const int TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = 105;

const int TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = 106;

const int TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 107;

const int TLS_DH_anon_WITH_RC4_128_MD5 = 24;

const int TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = 27;

const int TLS_DH_anon_WITH_AES_128_CBC_SHA256 = 108;

const int TLS_DH_anon_WITH_AES_256_CBC_SHA256 = 109;

const int TLS_PSK_WITH_RC4_128_SHA = 138;

const int TLS_PSK_WITH_3DES_EDE_CBC_SHA = 139;

const int TLS_PSK_WITH_AES_128_CBC_SHA = 140;

const int TLS_PSK_WITH_AES_256_CBC_SHA = 141;

const int TLS_DHE_PSK_WITH_RC4_128_SHA = 142;

const int TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA = 143;

const int TLS_DHE_PSK_WITH_AES_128_CBC_SHA = 144;

const int TLS_DHE_PSK_WITH_AES_256_CBC_SHA = 145;

const int TLS_RSA_PSK_WITH_RC4_128_SHA = 146;

const int TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA = 147;

const int TLS_RSA_PSK_WITH_AES_128_CBC_SHA = 148;

const int TLS_RSA_PSK_WITH_AES_256_CBC_SHA = 149;

const int TLS_PSK_WITH_NULL_SHA = 44;

const int TLS_DHE_PSK_WITH_NULL_SHA = 45;

const int TLS_RSA_PSK_WITH_NULL_SHA = 46;

const int TLS_RSA_WITH_AES_128_GCM_SHA256 = 156;

const int TLS_RSA_WITH_AES_256_GCM_SHA384 = 157;

const int TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 158;

const int TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 159;

const int TLS_DH_RSA_WITH_AES_128_GCM_SHA256 = 160;

const int TLS_DH_RSA_WITH_AES_256_GCM_SHA384 = 161;

const int TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 = 162;

const int TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 = 163;

const int TLS_DH_DSS_WITH_AES_128_GCM_SHA256 = 164;

const int TLS_DH_DSS_WITH_AES_256_GCM_SHA384 = 165;

const int TLS_DH_anon_WITH_AES_128_GCM_SHA256 = 166;

const int TLS_DH_anon_WITH_AES_256_GCM_SHA384 = 167;

const int TLS_PSK_WITH_AES_128_GCM_SHA256 = 168;

const int TLS_PSK_WITH_AES_256_GCM_SHA384 = 169;

const int TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 = 170;

const int TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 = 171;

const int TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 = 172;

const int TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 = 173;

const int TLS_PSK_WITH_AES_128_CBC_SHA256 = 174;

const int TLS_PSK_WITH_AES_256_CBC_SHA384 = 175;

const int TLS_PSK_WITH_NULL_SHA256 = 176;

const int TLS_PSK_WITH_NULL_SHA384 = 177;

const int TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 = 178;

const int TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 = 179;

const int TLS_DHE_PSK_WITH_NULL_SHA256 = 180;

const int TLS_DHE_PSK_WITH_NULL_SHA384 = 181;

const int TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 = 182;

const int TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 = 183;

const int TLS_RSA_PSK_WITH_NULL_SHA256 = 184;

const int TLS_RSA_PSK_WITH_NULL_SHA384 = 185;

const int TLS_AES_128_GCM_SHA256 = 4865;

const int TLS_AES_256_GCM_SHA384 = 4866;

const int TLS_CHACHA20_POLY1305_SHA256 = 4867;

const int TLS_AES_128_CCM_SHA256 = 4868;

const int TLS_AES_128_CCM_8_SHA256 = 4869;

const int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = -16349;

const int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = -16348;

const int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 = -16347;

const int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 = -16346;

const int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = -16345;

const int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = -16344;

const int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 = -16343;

const int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 = -16342;

const int TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = -16341;

const int TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = -16340;

const int TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = -16339;

const int TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = -16338;

const int TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = -16337;

const int TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = -16336;

const int TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 = -16335;

const int TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 = -16334;

const int TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = -13144;

const int TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = -13143;

const int TLS_EMPTY_RENEGOTIATION_INFO_SCSV = 255;

const int SSL_RSA_WITH_RC2_CBC_MD5 = -128;

const int SSL_RSA_WITH_IDEA_CBC_MD5 = -127;

const int SSL_RSA_WITH_DES_CBC_MD5 = -126;

const int SSL_RSA_WITH_3DES_EDE_CBC_MD5 = -125;

const int SSL_NO_SUCH_CIPHERSUITE = -1;

const int noErr3 = 0;

const int kNilOptions3 = 0;

const int kVariableLengthArray3 = 1;

const int kUnknownType3 = 1061109567;

const int normal3 = 0;

const int bold3 = 1;

const int italic3 = 2;

const int underline3 = 4;

const int outline3 = 8;

const int shadow3 = 16;

const int condense3 = 32;

const int extend3 = 64;

const int developStage3 = 32;

const int alphaStage3 = 64;

const int betaStage3 = 96;

const int finalStage3 = 128;

const int NSScannedOption3 = 1;

const int NSCollectorDisabledOption3 = 2;

const int NSASCIIStringEncoding = 1;

const int NSNEXTSTEPStringEncoding = 2;

const int NSJapaneseEUCStringEncoding = 3;

const int NSUTF8StringEncoding = 4;

const int NSISOLatin1StringEncoding = 5;

const int NSSymbolStringEncoding = 6;

const int NSNonLossyASCIIStringEncoding = 7;

const int NSShiftJISStringEncoding = 8;

const int NSISOLatin2StringEncoding = 9;

const int NSUnicodeStringEncoding = 10;

const int NSWindowsCP1251StringEncoding = 11;

const int NSWindowsCP1252StringEncoding = 12;

const int NSWindowsCP1253StringEncoding = 13;

const int NSWindowsCP1254StringEncoding = 14;

const int NSWindowsCP1250StringEncoding = 15;

const int NSISO2022JPStringEncoding = 21;

const int NSMacOSRomanStringEncoding = 30;

const int NSUTF16StringEncoding = 10;

const int NSUTF16BigEndianStringEncoding = 2415919360;

const int NSUTF16LittleEndianStringEncoding = 2483028224;

const int NSUTF32StringEncoding = 2348810496;

const int NSUTF32BigEndianStringEncoding = 2550137088;

const int NSUTF32LittleEndianStringEncoding = 2617245952;

const int NSProprietaryStringEncoding = 65536;

const int NSOpenStepUnicodeReservedBase = 62464;

const int noErr4 = 0;

const int kNilOptions4 = 0;

const int kVariableLengthArray4 = 1;

const int kUnknownType4 = 1061109567;

const int normal4 = 0;

const int bold4 = 1;

const int italic4 = 2;

const int underline4 = 4;

const int outline4 = 8;

const int shadow4 = 16;

const int condense4 = 32;

const int extend4 = 64;

const int developStage4 = 32;

const int alphaStage4 = 64;

const int betaStage4 = 96;

const int finalStage4 = 128;

const int NSScannedOption4 = 1;

const int NSCollectorDisabledOption4 = 2;

const int noErr5 = 0;

const int kNilOptions5 = 0;

const int kVariableLengthArray5 = 1;

const int kUnknownType5 = 1061109567;

const int normal5 = 0;

const int bold5 = 1;

const int italic5 = 2;

const int underline5 = 4;

const int outline5 = 8;

const int shadow5 = 16;

const int condense5 = 32;

const int extend5 = 64;

const int developStage5 = 32;

const int alphaStage5 = 64;

const int betaStage5 = 96;

const int finalStage5 = 128;

const int NSScannedOption5 = 1;

const int NSCollectorDisabledOption5 = 2;

const int noErr6 = 0;

const int kNilOptions6 = 0;

const int kVariableLengthArray6 = 1;

const int kUnknownType6 = 1061109567;

const int normal6 = 0;

const int bold6 = 1;

const int italic6 = 2;

const int underline6 = 4;

const int outline6 = 8;

const int shadow6 = 16;

const int condense6 = 32;

const int extend6 = 64;

const int developStage6 = 32;

const int alphaStage6 = 64;

const int betaStage6 = 96;

const int finalStage6 = 128;

const int NSScannedOption6 = 1;

const int NSCollectorDisabledOption6 = 2;

const int noErr7 = 0;

const int kNilOptions7 = 0;

const int kVariableLengthArray7 = 1;

const int kUnknownType7 = 1061109567;

const int normal7 = 0;

const int bold7 = 1;

const int italic7 = 2;

const int underline7 = 4;

const int outline7 = 8;

const int shadow7 = 16;

const int condense7 = 32;

const int extend7 = 64;

const int developStage7 = 32;

const int alphaStage7 = 64;

const int betaStage7 = 96;

const int finalStage7 = 128;

const int NSScannedOption7 = 1;

const int NSCollectorDisabledOption7 = 2;

const int noErr8 = 0;

const int kNilOptions8 = 0;

const int kVariableLengthArray8 = 1;

const int kUnknownType8 = 1061109567;

const int normal8 = 0;

const int bold8 = 1;

const int italic8 = 2;

const int underline8 = 4;

const int outline8 = 8;

const int shadow8 = 16;

const int condense8 = 32;

const int extend8 = 64;

const int developStage8 = 32;

const int alphaStage8 = 64;

const int betaStage8 = 96;

const int finalStage8 = 128;

const int NSScannedOption8 = 1;

const int NSCollectorDisabledOption8 = 2;

const int NSASCIIStringEncoding1 = 1;

const int NSNEXTSTEPStringEncoding1 = 2;

const int NSJapaneseEUCStringEncoding1 = 3;

const int NSUTF8StringEncoding1 = 4;

const int NSISOLatin1StringEncoding1 = 5;

const int NSSymbolStringEncoding1 = 6;

const int NSNonLossyASCIIStringEncoding1 = 7;

const int NSShiftJISStringEncoding1 = 8;

const int NSISOLatin2StringEncoding1 = 9;

const int NSUnicodeStringEncoding1 = 10;

const int NSWindowsCP1251StringEncoding1 = 11;

const int NSWindowsCP1252StringEncoding1 = 12;

const int NSWindowsCP1253StringEncoding1 = 13;

const int NSWindowsCP1254StringEncoding1 = 14;

const int NSWindowsCP1250StringEncoding1 = 15;

const int NSISO2022JPStringEncoding1 = 21;

const int NSMacOSRomanStringEncoding1 = 30;

const int NSUTF16StringEncoding1 = 10;

const int NSUTF16BigEndianStringEncoding1 = 2415919360;

const int NSUTF16LittleEndianStringEncoding1 = 2483028224;

const int NSUTF32StringEncoding1 = 2348810496;

const int NSUTF32BigEndianStringEncoding1 = 2550137088;

const int NSUTF32LittleEndianStringEncoding1 = 2617245952;

const int NSProprietaryStringEncoding1 = 65536;

const int DISPATCH_WALLTIME_NOW1 = -2;

const int noErr9 = 0;

const int kNilOptions9 = 0;

const int kVariableLengthArray9 = 1;

const int kUnknownType9 = 1061109567;

const int normal9 = 0;

const int bold9 = 1;

const int italic9 = 2;

const int underline9 = 4;

const int outline9 = 8;

const int shadow9 = 16;

const int condense9 = 32;

const int extend9 = 64;

const int developStage9 = 32;

const int alphaStage9 = 64;

const int betaStage9 = 96;

const int finalStage9 = 128;

const int NSScannedOption9 = 1;

const int NSCollectorDisabledOption9 = 2;

const int noErr10 = 0;

const int kNilOptions10 = 0;

const int kVariableLengthArray10 = 1;

const int kUnknownType10 = 1061109567;

const int normal10 = 0;

const int bold10 = 1;

const int italic10 = 2;

const int underline10 = 4;

const int outline10 = 8;

const int shadow10 = 16;

const int condense10 = 32;

const int extend10 = 64;

const int developStage10 = 32;

const int alphaStage10 = 64;

const int betaStage10 = 96;

const int finalStage10 = 128;

const int NSScannedOption10 = 1;

const int NSCollectorDisabledOption10 = 2;

const int noErr11 = 0;

const int kNilOptions11 = 0;

const int kVariableLengthArray11 = 1;

const int kUnknownType11 = 1061109567;

const int normal11 = 0;

const int bold11 = 1;

const int italic11 = 2;

const int underline11 = 4;

const int outline11 = 8;

const int shadow11 = 16;

const int condense11 = 32;

const int extend11 = 64;

const int developStage11 = 32;

const int alphaStage11 = 64;

const int betaStage11 = 96;

const int finalStage11 = 128;

const int NSScannedOption11 = 1;

const int NSCollectorDisabledOption11 = 2;

const int NSASCIIStringEncoding2 = 1;

const int NSNEXTSTEPStringEncoding2 = 2;

const int NSJapaneseEUCStringEncoding2 = 3;

const int NSUTF8StringEncoding2 = 4;

const int NSISOLatin1StringEncoding2 = 5;

const int NSSymbolStringEncoding2 = 6;

const int NSNonLossyASCIIStringEncoding2 = 7;

const int NSShiftJISStringEncoding2 = 8;

const int NSISOLatin2StringEncoding2 = 9;

const int NSUnicodeStringEncoding2 = 10;

const int NSWindowsCP1251StringEncoding2 = 11;

const int NSWindowsCP1252StringEncoding2 = 12;

const int NSWindowsCP1253StringEncoding2 = 13;

const int NSWindowsCP1254StringEncoding2 = 14;

const int NSWindowsCP1250StringEncoding2 = 15;

const int NSISO2022JPStringEncoding2 = 21;

const int NSMacOSRomanStringEncoding2 = 30;

const int NSUTF16StringEncoding2 = 10;

const int NSUTF16BigEndianStringEncoding2 = 2415919360;

const int NSUTF16LittleEndianStringEncoding2 = 2483028224;

const int NSUTF32StringEncoding2 = 2348810496;

const int NSUTF32BigEndianStringEncoding2 = 2550137088;

const int NSUTF32LittleEndianStringEncoding2 = 2617245952;

const int NSProprietaryStringEncoding2 = 65536;

const int NSOpenStepUnicodeReservedBase1 = 62464;

const int errSecSuccess1 = 0;

const int errSecUnimplemented1 = -4;

const int errSecDiskFull1 = -34;

const int errSecDskFull1 = -34;

const int errSecIO1 = -36;

const int errSecOpWr1 = -49;

const int errSecParam1 = -50;

const int errSecWrPerm1 = -61;

const int errSecAllocate1 = -108;

const int errSecUserCanceled1 = -128;

const int errSecBadReq1 = -909;

const int errSecInternalComponent1 = -2070;

const int errSecCoreFoundationUnknown1 = -4960;

const int errSecMissingEntitlement1 = -34018;

const int errSecRestrictedAPI1 = -34020;

const int errSecNotAvailable1 = -25291;

const int errSecReadOnly1 = -25292;

const int errSecAuthFailed1 = -25293;

const int errSecNoSuchKeychain1 = -25294;

const int errSecInvalidKeychain1 = -25295;

const int errSecDuplicateKeychain1 = -25296;

const int errSecDuplicateCallback1 = -25297;

const int errSecInvalidCallback1 = -25298;

const int errSecDuplicateItem1 = -25299;

const int errSecItemNotFound1 = -25300;

const int errSecBufferTooSmall1 = -25301;

const int errSecDataTooLarge1 = -25302;

const int errSecNoSuchAttr1 = -25303;

const int errSecInvalidItemRef1 = -25304;

const int errSecInvalidSearchRef1 = -25305;

const int errSecNoSuchClass1 = -25306;

const int errSecNoDefaultKeychain1 = -25307;

const int errSecInteractionNotAllowed1 = -25308;

const int errSecReadOnlyAttr1 = -25309;

const int errSecWrongSecVersion1 = -25310;

const int errSecKeySizeNotAllowed1 = -25311;

const int errSecNoStorageModule1 = -25312;

const int errSecNoCertificateModule1 = -25313;

const int errSecNoPolicyModule1 = -25314;

const int errSecInteractionRequired1 = -25315;

const int errSecDataNotAvailable1 = -25316;

const int errSecDataNotModifiable1 = -25317;

const int errSecCreateChainFailed1 = -25318;

const int errSecInvalidPrefsDomain1 = -25319;

const int errSecInDarkWake1 = -25320;

const int errSecACLNotSimple1 = -25240;

const int errSecPolicyNotFound1 = -25241;

const int errSecInvalidTrustSetting1 = -25242;

const int errSecNoAccessForItem1 = -25243;

const int errSecInvalidOwnerEdit1 = -25244;

const int errSecTrustNotAvailable1 = -25245;

const int errSecUnsupportedFormat1 = -25256;

const int errSecUnknownFormat1 = -25257;

const int errSecKeyIsSensitive1 = -25258;

const int errSecMultiplePrivKeys1 = -25259;

const int errSecPassphraseRequired1 = -25260;

const int errSecInvalidPasswordRef1 = -25261;

const int errSecInvalidTrustSettings1 = -25262;

const int errSecNoTrustSettings1 = -25263;

const int errSecPkcs12VerifyFailure1 = -25264;

const int errSecNotSigner1 = -26267;

const int errSecDecode1 = -26275;

const int errSecServiceNotAvailable1 = -67585;

const int errSecInsufficientClientID1 = -67586;

const int errSecDeviceReset1 = -67587;

const int errSecDeviceFailed1 = -67588;

const int errSecAppleAddAppACLSubject1 = -67589;

const int errSecApplePublicKeyIncomplete1 = -67590;

const int errSecAppleSignatureMismatch1 = -67591;

const int errSecAppleInvalidKeyStartDate1 = -67592;

const int errSecAppleInvalidKeyEndDate1 = -67593;

const int errSecConversionError1 = -67594;

const int errSecAppleSSLv2Rollback1 = -67595;

const int errSecQuotaExceeded1 = -67596;

const int errSecFileTooBig1 = -67597;

const int errSecInvalidDatabaseBlob1 = -67598;

const int errSecInvalidKeyBlob1 = -67599;

const int errSecIncompatibleDatabaseBlob1 = -67600;

const int errSecIncompatibleKeyBlob1 = -67601;

const int errSecHostNameMismatch1 = -67602;

const int errSecUnknownCriticalExtensionFlag1 = -67603;

const int errSecNoBasicConstraints1 = -67604;

const int errSecNoBasicConstraintsCA1 = -67605;

const int errSecInvalidAuthorityKeyID1 = -67606;

const int errSecInvalidSubjectKeyID1 = -67607;

const int errSecInvalidKeyUsageForPolicy1 = -67608;

const int errSecInvalidExtendedKeyUsage1 = -67609;

const int errSecInvalidIDLinkage1 = -67610;

const int errSecPathLengthConstraintExceeded1 = -67611;

const int errSecInvalidRoot1 = -67612;

const int errSecCRLExpired1 = -67613;

const int errSecCRLNotValidYet1 = -67614;

const int errSecCRLNotFound1 = -67615;

const int errSecCRLServerDown1 = -67616;

const int errSecCRLBadURI1 = -67617;

const int errSecUnknownCertExtension1 = -67618;

const int errSecUnknownCRLExtension1 = -67619;

const int errSecCRLNotTrusted1 = -67620;

const int errSecCRLPolicyFailed1 = -67621;

const int errSecIDPFailure1 = -67622;

const int errSecSMIMEEmailAddressesNotFound1 = -67623;

const int errSecSMIMEBadExtendedKeyUsage1 = -67624;

const int errSecSMIMEBadKeyUsage1 = -67625;

const int errSecSMIMEKeyUsageNotCritical1 = -67626;

const int errSecSMIMENoEmailAddress1 = -67627;

const int errSecSMIMESubjAltNameNotCritical1 = -67628;

const int errSecSSLBadExtendedKeyUsage1 = -67629;

const int errSecOCSPBadResponse1 = -67630;

const int errSecOCSPBadRequest1 = -67631;

const int errSecOCSPUnavailable1 = -67632;

const int errSecOCSPStatusUnrecognized1 = -67633;

const int errSecEndOfData1 = -67634;

const int errSecIncompleteCertRevocationCheck1 = -67635;

const int errSecNetworkFailure1 = -67636;

const int errSecOCSPNotTrustedToAnchor1 = -67637;

const int errSecRecordModified1 = -67638;

const int errSecOCSPSignatureError1 = -67639;

const int errSecOCSPNoSigner1 = -67640;

const int errSecOCSPResponderMalformedReq1 = -67641;

const int errSecOCSPResponderInternalError1 = -67642;

const int errSecOCSPResponderTryLater1 = -67643;

const int errSecOCSPResponderSignatureRequired1 = -67644;

const int errSecOCSPResponderUnauthorized1 = -67645;

const int errSecOCSPResponseNonceMismatch1 = -67646;

const int errSecCodeSigningBadCertChainLength1 = -67647;

const int errSecCodeSigningNoBasicConstraints1 = -67648;

const int errSecCodeSigningBadPathLengthConstraint1 = -67649;

const int errSecCodeSigningNoExtendedKeyUsage1 = -67650;

const int errSecCodeSigningDevelopment1 = -67651;

const int errSecResourceSignBadCertChainLength1 = -67652;

const int errSecResourceSignBadExtKeyUsage1 = -67653;

const int errSecTrustSettingDeny1 = -67654;

const int errSecInvalidSubjectName1 = -67655;

const int errSecUnknownQualifiedCertStatement1 = -67656;

const int errSecMobileMeRequestQueued1 = -67657;

const int errSecMobileMeRequestRedirected1 = -67658;

const int errSecMobileMeServerError1 = -67659;

const int errSecMobileMeServerNotAvailable1 = -67660;

const int errSecMobileMeServerAlreadyExists1 = -67661;

const int errSecMobileMeServerServiceErr1 = -67662;

const int errSecMobileMeRequestAlreadyPending1 = -67663;

const int errSecMobileMeNoRequestPending1 = -67664;

const int errSecMobileMeCSRVerifyFailure1 = -67665;

const int errSecMobileMeFailedConsistencyCheck1 = -67666;

const int errSecNotInitialized1 = -67667;

const int errSecInvalidHandleUsage1 = -67668;

const int errSecPVCReferentNotFound1 = -67669;

const int errSecFunctionIntegrityFail1 = -67670;

const int errSecInternalError1 = -67671;

const int errSecMemoryError1 = -67672;

const int errSecInvalidData1 = -67673;

const int errSecMDSError1 = -67674;

const int errSecInvalidPointer1 = -67675;

const int errSecSelfCheckFailed1 = -67676;

const int errSecFunctionFailed1 = -67677;

const int errSecModuleManifestVerifyFailed1 = -67678;

const int errSecInvalidGUID1 = -67679;

const int errSecInvalidHandle1 = -67680;

const int errSecInvalidDBList1 = -67681;

const int errSecInvalidPassthroughID1 = -67682;

const int errSecInvalidNetworkAddress1 = -67683;

const int errSecCRLAlreadySigned1 = -67684;

const int errSecInvalidNumberOfFields1 = -67685;

const int errSecVerificationFailure1 = -67686;

const int errSecUnknownTag1 = -67687;

const int errSecInvalidSignature1 = -67688;

const int errSecInvalidName1 = -67689;

const int errSecInvalidCertificateRef1 = -67690;

const int errSecInvalidCertificateGroup1 = -67691;

const int errSecTagNotFound1 = -67692;

const int errSecInvalidQuery1 = -67693;

const int errSecInvalidValue1 = -67694;

const int errSecCallbackFailed1 = -67695;

const int errSecACLDeleteFailed1 = -67696;

const int errSecACLReplaceFailed1 = -67697;

const int errSecACLAddFailed1 = -67698;

const int errSecACLChangeFailed1 = -67699;

const int errSecInvalidAccessCredentials1 = -67700;

const int errSecInvalidRecord1 = -67701;

const int errSecInvalidACL1 = -67702;

const int errSecInvalidSampleValue1 = -67703;

const int errSecIncompatibleVersion1 = -67704;

const int errSecPrivilegeNotGranted1 = -67705;

const int errSecInvalidScope1 = -67706;

const int errSecPVCAlreadyConfigured1 = -67707;

const int errSecInvalidPVC1 = -67708;

const int errSecEMMLoadFailed1 = -67709;

const int errSecEMMUnloadFailed1 = -67710;

const int errSecAddinLoadFailed1 = -67711;

const int errSecInvalidKeyRef1 = -67712;

const int errSecInvalidKeyHierarchy1 = -67713;

const int errSecAddinUnloadFailed1 = -67714;

const int errSecLibraryReferenceNotFound1 = -67715;

const int errSecInvalidAddinFunctionTable1 = -67716;

const int errSecInvalidServiceMask1 = -67717;

const int errSecModuleNotLoaded1 = -67718;

const int errSecInvalidSubServiceID1 = -67719;

const int errSecAttributeNotInContext1 = -67720;

const int errSecModuleManagerInitializeFailed1 = -67721;

const int errSecModuleManagerNotFound1 = -67722;

const int errSecEventNotificationCallbackNotFound1 = -67723;

const int errSecInputLengthError1 = -67724;

const int errSecOutputLengthError1 = -67725;

const int errSecPrivilegeNotSupported1 = -67726;

const int errSecDeviceError1 = -67727;

const int errSecAttachHandleBusy1 = -67728;

const int errSecNotLoggedIn1 = -67729;

const int errSecAlgorithmMismatch1 = -67730;

const int errSecKeyUsageIncorrect1 = -67731;

const int errSecKeyBlobTypeIncorrect1 = -67732;

const int errSecKeyHeaderInconsistent1 = -67733;

const int errSecUnsupportedKeyFormat1 = -67734;

const int errSecUnsupportedKeySize1 = -67735;

const int errSecInvalidKeyUsageMask1 = -67736;

const int errSecUnsupportedKeyUsageMask1 = -67737;

const int errSecInvalidKeyAttributeMask1 = -67738;

const int errSecUnsupportedKeyAttributeMask1 = -67739;

const int errSecInvalidKeyLabel1 = -67740;

const int errSecUnsupportedKeyLabel1 = -67741;

const int errSecInvalidKeyFormat1 = -67742;

const int errSecUnsupportedVectorOfBuffers1 = -67743;

const int errSecInvalidInputVector1 = -67744;

const int errSecInvalidOutputVector1 = -67745;

const int errSecInvalidContext1 = -67746;

const int errSecInvalidAlgorithm1 = -67747;

const int errSecInvalidAttributeKey1 = -67748;

const int errSecMissingAttributeKey1 = -67749;

const int errSecInvalidAttributeInitVector1 = -67750;

const int errSecMissingAttributeInitVector1 = -67751;

const int errSecInvalidAttributeSalt1 = -67752;

const int errSecMissingAttributeSalt1 = -67753;

const int errSecInvalidAttributePadding1 = -67754;

const int errSecMissingAttributePadding1 = -67755;

const int errSecInvalidAttributeRandom1 = -67756;

const int errSecMissingAttributeRandom1 = -67757;

const int errSecInvalidAttributeSeed1 = -67758;

const int errSecMissingAttributeSeed1 = -67759;

const int errSecInvalidAttributePassphrase1 = -67760;

const int errSecMissingAttributePassphrase1 = -67761;

const int errSecInvalidAttributeKeyLength1 = -67762;

const int errSecMissingAttributeKeyLength1 = -67763;

const int errSecInvalidAttributeBlockSize1 = -67764;

const int errSecMissingAttributeBlockSize1 = -67765;

const int errSecInvalidAttributeOutputSize1 = -67766;

const int errSecMissingAttributeOutputSize1 = -67767;

const int errSecInvalidAttributeRounds1 = -67768;

const int errSecMissingAttributeRounds1 = -67769;

const int errSecInvalidAlgorithmParms1 = -67770;

const int errSecMissingAlgorithmParms1 = -67771;

const int errSecInvalidAttributeLabel1 = -67772;

const int errSecMissingAttributeLabel1 = -67773;

const int errSecInvalidAttributeKeyType1 = -67774;

const int errSecMissingAttributeKeyType1 = -67775;

const int errSecInvalidAttributeMode1 = -67776;

const int errSecMissingAttributeMode1 = -67777;

const int errSecInvalidAttributeEffectiveBits1 = -67778;

const int errSecMissingAttributeEffectiveBits1 = -67779;

const int errSecInvalidAttributeStartDate1 = -67780;

const int errSecMissingAttributeStartDate1 = -67781;

const int errSecInvalidAttributeEndDate1 = -67782;

const int errSecMissingAttributeEndDate1 = -67783;

const int errSecInvalidAttributeVersion1 = -67784;

const int errSecMissingAttributeVersion1 = -67785;

const int errSecInvalidAttributePrime1 = -67786;

const int errSecMissingAttributePrime1 = -67787;

const int errSecInvalidAttributeBase1 = -67788;

const int errSecMissingAttributeBase1 = -67789;

const int errSecInvalidAttributeSubprime1 = -67790;

const int errSecMissingAttributeSubprime1 = -67791;

const int errSecInvalidAttributeIterationCount1 = -67792;

const int errSecMissingAttributeIterationCount1 = -67793;

const int errSecInvalidAttributeDLDBHandle1 = -67794;

const int errSecMissingAttributeDLDBHandle1 = -67795;

const int errSecInvalidAttributeAccessCredentials1 = -67796;

const int errSecMissingAttributeAccessCredentials1 = -67797;

const int errSecInvalidAttributePublicKeyFormat1 = -67798;

const int errSecMissingAttributePublicKeyFormat1 = -67799;

const int errSecInvalidAttributePrivateKeyFormat1 = -67800;

const int errSecMissingAttributePrivateKeyFormat1 = -67801;

const int errSecInvalidAttributeSymmetricKeyFormat1 = -67802;

const int errSecMissingAttributeSymmetricKeyFormat1 = -67803;

const int errSecInvalidAttributeWrappedKeyFormat1 = -67804;

const int errSecMissingAttributeWrappedKeyFormat1 = -67805;

const int errSecStagedOperationInProgress1 = -67806;

const int errSecStagedOperationNotStarted1 = -67807;

const int errSecVerifyFailed1 = -67808;

const int errSecQuerySizeUnknown1 = -67809;

const int errSecBlockSizeMismatch1 = -67810;

const int errSecPublicKeyInconsistent1 = -67811;

const int errSecDeviceVerifyFailed1 = -67812;

const int errSecInvalidLoginName1 = -67813;

const int errSecAlreadyLoggedIn1 = -67814;

const int errSecInvalidDigestAlgorithm1 = -67815;

const int errSecInvalidCRLGroup1 = -67816;

const int errSecCertificateCannotOperate1 = -67817;

const int errSecCertificateExpired1 = -67818;

const int errSecCertificateNotValidYet1 = -67819;

const int errSecCertificateRevoked1 = -67820;

const int errSecCertificateSuspended1 = -67821;

const int errSecInsufficientCredentials1 = -67822;

const int errSecInvalidAction1 = -67823;

const int errSecInvalidAuthority1 = -67824;

const int errSecVerifyActionFailed1 = -67825;

const int errSecInvalidCertAuthority1 = -67826;

const int errSecInvalidCRLAuthority1 = -67827;

const int errSecInvaldCRLAuthority1 = -67827;

const int errSecInvalidCRLEncoding1 = -67828;

const int errSecInvalidCRLType1 = -67829;

const int errSecInvalidCRL1 = -67830;

const int errSecInvalidFormType1 = -67831;

const int errSecInvalidID1 = -67832;

const int errSecInvalidIdentifier1 = -67833;

const int errSecInvalidIndex1 = -67834;

const int errSecInvalidPolicyIdentifiers1 = -67835;

const int errSecInvalidTimeString1 = -67836;

const int errSecInvalidReason1 = -67837;

const int errSecInvalidRequestInputs1 = -67838;

const int errSecInvalidResponseVector1 = -67839;

const int errSecInvalidStopOnPolicy1 = -67840;

const int errSecInvalidTuple1 = -67841;

const int errSecMultipleValuesUnsupported1 = -67842;

const int errSecNotTrusted1 = -67843;

const int errSecNoDefaultAuthority1 = -67844;

const int errSecRejectedForm1 = -67845;

const int errSecRequestLost1 = -67846;

const int errSecRequestRejected1 = -67847;

const int errSecUnsupportedAddressType1 = -67848;

const int errSecUnsupportedService1 = -67849;

const int errSecInvalidTupleGroup1 = -67850;

const int errSecInvalidBaseACLs1 = -67851;

const int errSecInvalidTupleCredentials1 = -67852;

const int errSecInvalidTupleCredendtials1 = -67852;

const int errSecInvalidEncoding1 = -67853;

const int errSecInvalidValidityPeriod1 = -67854;

const int errSecInvalidRequestor1 = -67855;

const int errSecRequestDescriptor1 = -67856;

const int errSecInvalidBundleInfo1 = -67857;

const int errSecInvalidCRLIndex1 = -67858;

const int errSecNoFieldValues1 = -67859;

const int errSecUnsupportedFieldFormat1 = -67860;

const int errSecUnsupportedIndexInfo1 = -67861;

const int errSecUnsupportedLocality1 = -67862;

const int errSecUnsupportedNumAttributes1 = -67863;

const int errSecUnsupportedNumIndexes1 = -67864;

const int errSecUnsupportedNumRecordTypes1 = -67865;

const int errSecFieldSpecifiedMultiple1 = -67866;

const int errSecIncompatibleFieldFormat1 = -67867;

const int errSecInvalidParsingModule1 = -67868;

const int errSecDatabaseLocked1 = -67869;

const int errSecDatastoreIsOpen1 = -67870;

const int errSecMissingValue1 = -67871;

const int errSecUnsupportedQueryLimits1 = -67872;

const int errSecUnsupportedNumSelectionPreds1 = -67873;

const int errSecUnsupportedOperator1 = -67874;

const int errSecInvalidDBLocation1 = -67875;

const int errSecInvalidAccessRequest1 = -67876;

const int errSecInvalidIndexInfo1 = -67877;

const int errSecInvalidNewOwner1 = -67878;

const int errSecInvalidModifyMode1 = -67879;

const int errSecMissingRequiredExtension1 = -67880;

const int errSecExtendedKeyUsageNotCritical1 = -67881;

const int errSecTimestampMissing1 = -67882;

const int errSecTimestampInvalid1 = -67883;

const int errSecTimestampNotTrusted1 = -67884;

const int errSecTimestampServiceNotAvailable1 = -67885;

const int errSecTimestampBadAlg1 = -67886;

const int errSecTimestampBadRequest1 = -67887;

const int errSecTimestampBadDataFormat1 = -67888;

const int errSecTimestampTimeNotAvailable1 = -67889;

const int errSecTimestampUnacceptedPolicy1 = -67890;

const int errSecTimestampUnacceptedExtension1 = -67891;

const int errSecTimestampAddInfoNotAvailable1 = -67892;

const int errSecTimestampSystemFailure1 = -67893;

const int errSecSigningTimeMissing1 = -67894;

const int errSecTimestampRejection1 = -67895;

const int errSecTimestampWaiting1 = -67896;

const int errSecTimestampRevocationWarning1 = -67897;

const int errSecTimestampRevocationNotification1 = -67898;

const int errSecCertificatePolicyNotAllowed1 = -67899;

const int errSecCertificateNameNotAllowed1 = -67900;

const int errSecCertificateValidityPeriodTooLong1 = -67901;

const int errSecCertificateIsCA1 = -67902;

const int errSecCertificateDuplicateExtension1 = -67903;

const int errSSLProtocol1 = -9800;

const int errSSLNegotiation1 = -9801;

const int errSSLFatalAlert1 = -9802;

const int errSSLWouldBlock1 = -9803;

const int errSSLSessionNotFound1 = -9804;

const int errSSLClosedGraceful1 = -9805;

const int errSSLClosedAbort1 = -9806;

const int errSSLXCertChainInvalid1 = -9807;

const int errSSLBadCert1 = -9808;

const int errSSLCrypto1 = -9809;

const int errSSLInternal1 = -9810;

const int errSSLModuleAttach1 = -9811;

const int errSSLUnknownRootCert1 = -9812;

const int errSSLNoRootCert1 = -9813;

const int errSSLCertExpired1 = -9814;

const int errSSLCertNotYetValid1 = -9815;

const int errSSLClosedNoNotify1 = -9816;

const int errSSLBufferOverflow1 = -9817;

const int errSSLBadCipherSuite1 = -9818;

const int errSSLPeerUnexpectedMsg1 = -9819;

const int errSSLPeerBadRecordMac1 = -9820;

const int errSSLPeerDecryptionFail1 = -9821;

const int errSSLPeerRecordOverflow1 = -9822;

const int errSSLPeerDecompressFail1 = -9823;

const int errSSLPeerHandshakeFail1 = -9824;

const int errSSLPeerBadCert1 = -9825;

const int errSSLPeerUnsupportedCert1 = -9826;

const int errSSLPeerCertRevoked1 = -9827;

const int errSSLPeerCertExpired1 = -9828;

const int errSSLPeerCertUnknown1 = -9829;

const int errSSLIllegalParam1 = -9830;

const int errSSLPeerUnknownCA1 = -9831;

const int errSSLPeerAccessDenied1 = -9832;

const int errSSLPeerDecodeError1 = -9833;

const int errSSLPeerDecryptError1 = -9834;

const int errSSLPeerExportRestriction1 = -9835;

const int errSSLPeerProtocolVersion1 = -9836;

const int errSSLPeerInsufficientSecurity1 = -9837;

const int errSSLPeerInternalError1 = -9838;

const int errSSLPeerUserCancelled1 = -9839;

const int errSSLPeerNoRenegotiation1 = -9840;

const int errSSLPeerAuthCompleted1 = -9841;

const int errSSLClientCertRequested1 = -9842;

const int errSSLHostNameMismatch1 = -9843;

const int errSSLConnectionRefused1 = -9844;

const int errSSLDecryptionFail1 = -9845;

const int errSSLBadRecordMac1 = -9846;

const int errSSLRecordOverflow1 = -9847;

const int errSSLBadConfiguration1 = -9848;

const int errSSLUnexpectedRecord1 = -9849;

const int errSSLWeakPeerEphemeralDHKey1 = -9850;

const int errSSLClientHelloReceived1 = -9851;

const int errSSLTransportReset1 = -9852;

const int errSSLNetworkTimeout1 = -9853;

const int errSSLConfigurationFailed1 = -9854;

const int errSSLUnsupportedExtension1 = -9855;

const int errSSLUnexpectedMessage1 = -9856;

const int errSSLDecompressFail1 = -9857;

const int errSSLHandshakeFail1 = -9858;

const int errSSLDecodeError1 = -9859;

const int errSSLInappropriateFallback1 = -9860;

const int errSSLMissingExtension1 = -9861;

const int errSSLBadCertificateStatusResponse1 = -9862;

const int errSSLCertificateRequired1 = -9863;

const int errSSLUnknownPSKIdentity1 = -9864;

const int errSSLUnrecognizedName1 = -9865;

const int errSSLATSViolation1 = -9880;

const int errSSLATSMinimumVersionViolation1 = -9881;

const int errSSLATSCiphersuiteViolation1 = -9882;

const int errSSLATSMinimumKeySizeViolation1 = -9883;

const int errSSLATSLeafCertificateHashAlgorithmViolation1 = -9884;

const int errSSLATSCertificateHashAlgorithmViolation1 = -9885;

const int errSSLATSCertificateTrustViolation1 = -9886;

const int errSSLEarlyDataRejected1 = -9890;

const int OSUnknownByteOrder1 = 0;

const int OSLittleEndian1 = 1;

const int OSBigEndian1 = 2;

const int kCFNotificationDeliverImmediately1 = 1;

const int kCFNotificationPostToAllSessions1 = 2;

const int kCFCalendarComponentsWrap1 = 1;

const int kCFSocketAutomaticallyReenableReadCallBack1 = 1;

const int kCFSocketAutomaticallyReenableAcceptCallBack1 = 2;

const int kCFSocketAutomaticallyReenableDataCallBack1 = 3;

const int kCFSocketAutomaticallyReenableWriteCallBack1 = 8;

const int kCFSocketLeaveErrors1 = 64;

const int kCFSocketCloseOnInvalidate1 = 128;

const int DISPATCH_WALLTIME_NOW2 = -2;

const int kCFPropertyListReadCorruptError1 = 3840;

const int kCFPropertyListReadUnknownVersionError1 = 3841;

const int kCFPropertyListReadStreamError1 = 3842;

const int kCFPropertyListWriteStreamError1 = 3851;

const int kCFBundleExecutableArchitectureI3861 = 7;

const int kCFBundleExecutableArchitecturePPC1 = 18;

const int kCFBundleExecutableArchitectureX86_641 = 16777223;

const int kCFBundleExecutableArchitecturePPC641 = 16777234;

const int kCFBundleExecutableArchitectureARM641 = 16777228;

const int kCFMessagePortSuccess1 = 0;

const int kCFMessagePortSendTimeout1 = -1;

const int kCFMessagePortReceiveTimeout1 = -2;

const int kCFMessagePortIsInvalid1 = -3;

const int kCFMessagePortTransportError1 = -4;

const int kCFMessagePortBecameInvalidError1 = -5;

const int kCFStringTokenizerUnitWord1 = 0;

const int kCFStringTokenizerUnitSentence1 = 1;

const int kCFStringTokenizerUnitParagraph1 = 2;

const int kCFStringTokenizerUnitLineBreak1 = 3;

const int kCFStringTokenizerUnitWordBoundary1 = 4;

const int kCFStringTokenizerAttributeLatinTranscription1 = 65536;

const int kCFStringTokenizerAttributeLanguage1 = 131072;

const int kCFFileDescriptorReadCallBack1 = 1;

const int kCFFileDescriptorWriteCallBack1 = 2;

const int kCFUserNotificationStopAlertLevel1 = 0;

const int kCFUserNotificationNoteAlertLevel1 = 1;

const int kCFUserNotificationCautionAlertLevel1 = 2;

const int kCFUserNotificationPlainAlertLevel1 = 3;

const int kCFUserNotificationDefaultResponse1 = 0;

const int kCFUserNotificationAlternateResponse1 = 1;

const int kCFUserNotificationOtherResponse1 = 2;

const int kCFUserNotificationCancelResponse1 = 3;

const int kCFUserNotificationNoDefaultButtonFlag1 = 32;

const int kCFUserNotificationUseRadioButtonsFlag1 = 64;

const int kCFXMLNodeCurrentVersion1 = 1;

const int CSSM_INVALID_HANDLE1 = 0;

const int CSSM_FALSE1 = 0;

const int CSSM_TRUE1 = 1;

const int CSSM_OK1 = 0;

const int CSSM_MODULE_STRING_SIZE1 = 64;

const int CSSM_KEY_HIERARCHY_NONE1 = 0;

const int CSSM_KEY_HIERARCHY_INTEG1 = 1;

const int CSSM_KEY_HIERARCHY_EXPORT1 = 2;

const int CSSM_PVC_NONE1 = 0;

const int CSSM_PVC_APP1 = 1;

const int CSSM_PVC_SP1 = 2;

const int CSSM_PRIVILEGE_SCOPE_NONE1 = 0;

const int CSSM_PRIVILEGE_SCOPE_PROCESS1 = 1;

const int CSSM_PRIVILEGE_SCOPE_THREAD1 = 2;

const int CSSM_SERVICE_CSSM1 = 1;

const int CSSM_SERVICE_CSP1 = 2;

const int CSSM_SERVICE_DL1 = 4;

const int CSSM_SERVICE_CL1 = 8;

const int CSSM_SERVICE_TP1 = 16;

const int CSSM_SERVICE_AC1 = 32;

const int CSSM_SERVICE_KR1 = 64;

const int CSSM_NOTIFY_INSERT1 = 1;

const int CSSM_NOTIFY_REMOVE1 = 2;

const int CSSM_NOTIFY_FAULT1 = 3;

const int CSSM_ATTACH_READ_ONLY1 = 1;

const int CSSM_USEE_LAST1 = 255;

const int CSSM_USEE_NONE1 = 0;

const int CSSM_USEE_DOMESTIC1 = 1;

const int CSSM_USEE_FINANCIAL1 = 2;

const int CSSM_USEE_KRLE1 = 3;

const int CSSM_USEE_KRENT1 = 4;

const int CSSM_USEE_SSL1 = 5;

const int CSSM_USEE_AUTHENTICATION1 = 6;

const int CSSM_USEE_KEYEXCH1 = 7;

const int CSSM_USEE_MEDICAL1 = 8;

const int CSSM_USEE_INSURANCE1 = 9;

const int CSSM_USEE_WEAK1 = 10;

const int CSSM_ADDR_NONE1 = 0;

const int CSSM_ADDR_CUSTOM1 = 1;

const int CSSM_ADDR_URL1 = 2;

const int CSSM_ADDR_SOCKADDR1 = 3;

const int CSSM_ADDR_NAME1 = 4;

const int CSSM_NET_PROTO_NONE1 = 0;

const int CSSM_NET_PROTO_CUSTOM1 = 1;

const int CSSM_NET_PROTO_UNSPECIFIED1 = 2;

const int CSSM_NET_PROTO_LDAP1 = 3;

const int CSSM_NET_PROTO_LDAPS1 = 4;

const int CSSM_NET_PROTO_LDAPNS1 = 5;

const int CSSM_NET_PROTO_X500DAP1 = 6;

const int CSSM_NET_PROTO_FTP1 = 7;

const int CSSM_NET_PROTO_FTPS1 = 8;

const int CSSM_NET_PROTO_OCSP1 = 9;

const int CSSM_NET_PROTO_CMP1 = 10;

const int CSSM_NET_PROTO_CMPS1 = 11;

const int CSSM_WORDID__UNK_1 = -1;

const int CSSM_WORDID__NLU_1 = 0;

const int CSSM_WORDID__STAR_1 = 1;

const int CSSM_WORDID_A1 = 2;

const int CSSM_WORDID_ACL1 = 3;

const int CSSM_WORDID_ALPHA1 = 4;

const int CSSM_WORDID_B1 = 5;

const int CSSM_WORDID_BER1 = 6;

const int CSSM_WORDID_BINARY1 = 7;

const int CSSM_WORDID_BIOMETRIC1 = 8;

const int CSSM_WORDID_C1 = 9;

const int CSSM_WORDID_CANCELED1 = 10;

const int CSSM_WORDID_CERT1 = 11;

const int CSSM_WORDID_COMMENT1 = 12;

const int CSSM_WORDID_CRL1 = 13;

const int CSSM_WORDID_CUSTOM1 = 14;

const int CSSM_WORDID_D1 = 15;

const int CSSM_WORDID_DATE1 = 16;

const int CSSM_WORDID_DB_DELETE1 = 17;

const int CSSM_WORDID_DB_EXEC_STORED_QUERY1 = 18;

const int CSSM_WORDID_DB_INSERT1 = 19;

const int CSSM_WORDID_DB_MODIFY1 = 20;

const int CSSM_WORDID_DB_READ1 = 21;

const int CSSM_WORDID_DBS_CREATE1 = 22;

const int CSSM_WORDID_DBS_DELETE1 = 23;

const int CSSM_WORDID_DECRYPT1 = 24;

const int CSSM_WORDID_DELETE1 = 25;

const int CSSM_WORDID_DELTA_CRL1 = 26;

const int CSSM_WORDID_DER1 = 27;

const int CSSM_WORDID_DERIVE1 = 28;

const int CSSM_WORDID_DISPLAY1 = 29;

const int CSSM_WORDID_DO1 = 30;

const int CSSM_WORDID_DSA1 = 31;

const int CSSM_WORDID_DSA_SHA11 = 32;

const int CSSM_WORDID_E1 = 33;

const int CSSM_WORDID_ELGAMAL1 = 34;

const int CSSM_WORDID_ENCRYPT1 = 35;

const int CSSM_WORDID_ENTRY1 = 36;

const int CSSM_WORDID_EXPORT_CLEAR1 = 37;

const int CSSM_WORDID_EXPORT_WRAPPED1 = 38;

const int CSSM_WORDID_G1 = 39;

const int CSSM_WORDID_GE1 = 40;

const int CSSM_WORDID_GENKEY1 = 41;

const int CSSM_WORDID_HASH1 = 42;

const int CSSM_WORDID_HASHED_PASSWORD1 = 43;

const int CSSM_WORDID_HASHED_SUBJECT1 = 44;

const int CSSM_WORDID_HAVAL1 = 45;

const int CSSM_WORDID_IBCHASH1 = 46;

const int CSSM_WORDID_IMPORT_CLEAR1 = 47;

const int CSSM_WORDID_IMPORT_WRAPPED1 = 48;

const int CSSM_WORDID_INTEL1 = 49;

const int CSSM_WORDID_ISSUER1 = 50;

const int CSSM_WORDID_ISSUER_INFO1 = 51;

const int CSSM_WORDID_K_OF_N1 = 52;

const int CSSM_WORDID_KEA1 = 53;

const int CSSM_WORDID_KEYHOLDER1 = 54;

const int CSSM_WORDID_L1 = 55;

const int CSSM_WORDID_LE1 = 56;

const int CSSM_WORDID_LOGIN1 = 57;

const int CSSM_WORDID_LOGIN_NAME1 = 58;

const int CSSM_WORDID_MAC1 = 59;

const int CSSM_WORDID_MD21 = 60;

const int CSSM_WORDID_MD2WITHRSA1 = 61;

const int CSSM_WORDID_MD41 = 62;

const int CSSM_WORDID_MD51 = 63;

const int CSSM_WORDID_MD5WITHRSA1 = 64;

const int CSSM_WORDID_N1 = 65;

const int CSSM_WORDID_NAME1 = 66;

const int CSSM_WORDID_NDR1 = 67;

const int CSSM_WORDID_NHASH1 = 68;

const int CSSM_WORDID_NOT_AFTER1 = 69;

const int CSSM_WORDID_NOT_BEFORE1 = 70;

const int CSSM_WORDID_NULL1 = 71;

const int CSSM_WORDID_NUMERIC1 = 72;

const int CSSM_WORDID_OBJECT_HASH1 = 73;

const int CSSM_WORDID_ONE_TIME1 = 74;

const int CSSM_WORDID_ONLINE1 = 75;

const int CSSM_WORDID_OWNER1 = 76;

const int CSSM_WORDID_P1 = 77;

const int CSSM_WORDID_PAM_NAME1 = 78;

const int CSSM_WORDID_PASSWORD1 = 79;

const int CSSM_WORDID_PGP1 = 80;

const int CSSM_WORDID_PREFIX1 = 81;

const int CSSM_WORDID_PRIVATE_KEY1 = 82;

const int CSSM_WORDID_PROMPTED_BIOMETRIC1 = 83;

const int CSSM_WORDID_PROMPTED_PASSWORD1 = 84;

const int CSSM_WORDID_PROPAGATE1 = 85;

const int CSSM_WORDID_PROTECTED_BIOMETRIC1 = 86;

const int CSSM_WORDID_PROTECTED_PASSWORD1 = 87;

const int CSSM_WORDID_PROTECTED_PIN1 = 88;

const int CSSM_WORDID_PUBLIC_KEY1 = 89;

const int CSSM_WORDID_PUBLIC_KEY_FROM_CERT1 = 90;

const int CSSM_WORDID_Q1 = 91;

const int CSSM_WORDID_RANGE1 = 92;

const int CSSM_WORDID_REVAL1 = 93;

const int CSSM_WORDID_RIPEMAC1 = 94;

const int CSSM_WORDID_RIPEMD1 = 95;

const int CSSM_WORDID_RIPEMD1601 = 96;

const int CSSM_WORDID_RSA1 = 97;

const int CSSM_WORDID_RSA_ISO97961 = 98;

const int CSSM_WORDID_RSA_PKCS2 = 99;

const int CSSM_WORDID_RSA_PKCS_MD51 = 100;

const int CSSM_WORDID_RSA_PKCS_SHA11 = 101;

const int CSSM_WORDID_RSA_PKCS11 = 102;

const int CSSM_WORDID_RSA_PKCS1_MD51 = 103;

const int CSSM_WORDID_RSA_PKCS1_SHA11 = 104;

const int CSSM_WORDID_RSA_PKCS1_SIG1 = 105;

const int CSSM_WORDID_RSA_RAW1 = 106;

const int CSSM_WORDID_SDSIV11 = 107;

const int CSSM_WORDID_SEQUENCE1 = 108;

const int CSSM_WORDID_SET1 = 109;

const int CSSM_WORDID_SEXPR1 = 110;

const int CSSM_WORDID_SHA11 = 111;

const int CSSM_WORDID_SHA1WITHDSA1 = 112;

const int CSSM_WORDID_SHA1WITHECDSA1 = 113;

const int CSSM_WORDID_SHA1WITHRSA1 = 114;

const int CSSM_WORDID_SIGN1 = 115;

const int CSSM_WORDID_SIGNATURE1 = 116;

const int CSSM_WORDID_SIGNED_NONCE1 = 117;

const int CSSM_WORDID_SIGNED_SECRET1 = 118;

const int CSSM_WORDID_SPKI1 = 119;

const int CSSM_WORDID_SUBJECT1 = 120;

const int CSSM_WORDID_SUBJECT_INFO1 = 121;

const int CSSM_WORDID_TAG1 = 122;

const int CSSM_WORDID_THRESHOLD1 = 123;

const int CSSM_WORDID_TIME1 = 124;

const int CSSM_WORDID_URI1 = 125;

const int CSSM_WORDID_VERSION1 = 126;

const int CSSM_WORDID_X509_ATTRIBUTE1 = 127;

const int CSSM_WORDID_X509V11 = 128;

const int CSSM_WORDID_X509V21 = 129;

const int CSSM_WORDID_X509V31 = 130;

const int CSSM_WORDID_X9_ATTRIBUTE1 = 131;

const int CSSM_WORDID_VENDOR_START1 = 65536;

const int CSSM_WORDID_VENDOR_END1 = 2147418112;

const int CSSM_LIST_ELEMENT_DATUM1 = 0;

const int CSSM_LIST_ELEMENT_SUBLIST1 = 1;

const int CSSM_LIST_ELEMENT_WORDID1 = 2;

const int CSSM_LIST_TYPE_UNKNOWN1 = 0;

const int CSSM_LIST_TYPE_CUSTOM1 = 1;

const int CSSM_LIST_TYPE_SEXPR1 = 2;

const int CSSM_SAMPLE_TYPE_PASSWORD1 = 79;

const int CSSM_SAMPLE_TYPE_HASHED_PASSWORD1 = 43;

const int CSSM_SAMPLE_TYPE_PROTECTED_PASSWORD1 = 87;

const int CSSM_SAMPLE_TYPE_PROMPTED_PASSWORD1 = 84;

const int CSSM_SAMPLE_TYPE_SIGNED_NONCE1 = 117;

const int CSSM_SAMPLE_TYPE_SIGNED_SECRET1 = 118;

const int CSSM_SAMPLE_TYPE_BIOMETRIC1 = 8;

const int CSSM_SAMPLE_TYPE_PROTECTED_BIOMETRIC1 = 86;

const int CSSM_SAMPLE_TYPE_PROMPTED_BIOMETRIC1 = 83;

const int CSSM_SAMPLE_TYPE_THRESHOLD1 = 123;

const int CSSM_CERT_UNKNOWN1 = 0;

const int CSSM_CERT_X_509v11 = 1;

const int CSSM_CERT_X_509v21 = 2;

const int CSSM_CERT_X_509v31 = 3;

const int CSSM_CERT_PGP1 = 4;

const int CSSM_CERT_SPKI1 = 5;

const int CSSM_CERT_SDSIv11 = 6;

const int CSSM_CERT_Intel1 = 8;

const int CSSM_CERT_X_509_ATTRIBUTE1 = 9;

const int CSSM_CERT_X9_ATTRIBUTE1 = 10;

const int CSSM_CERT_TUPLE1 = 11;

const int CSSM_CERT_ACL_ENTRY1 = 12;

const int CSSM_CERT_MULTIPLE1 = 32766;

const int CSSM_CERT_LAST1 = 32767;

const int CSSM_CL_CUSTOM_CERT_TYPE1 = 32768;

const int CSSM_CERT_ENCODING_UNKNOWN1 = 0;

const int CSSM_CERT_ENCODING_CUSTOM1 = 1;

const int CSSM_CERT_ENCODING_BER1 = 2;

const int CSSM_CERT_ENCODING_DER1 = 3;

const int CSSM_CERT_ENCODING_NDR1 = 4;

const int CSSM_CERT_ENCODING_SEXPR1 = 5;

const int CSSM_CERT_ENCODING_PGP1 = 6;

const int CSSM_CERT_ENCODING_MULTIPLE1 = 32766;

const int CSSM_CERT_ENCODING_LAST1 = 32767;

const int CSSM_CL_CUSTOM_CERT_ENCODING1 = 32768;

const int CSSM_CERT_PARSE_FORMAT_NONE1 = 0;

const int CSSM_CERT_PARSE_FORMAT_CUSTOM1 = 1;

const int CSSM_CERT_PARSE_FORMAT_SEXPR1 = 2;

const int CSSM_CERT_PARSE_FORMAT_COMPLEX1 = 3;

const int CSSM_CERT_PARSE_FORMAT_OID_NAMED1 = 4;

const int CSSM_CERT_PARSE_FORMAT_TUPLE1 = 5;

const int CSSM_CERT_PARSE_FORMAT_MULTIPLE1 = 32766;

const int CSSM_CERT_PARSE_FORMAT_LAST1 = 32767;

const int CSSM_CL_CUSTOM_CERT_PARSE_FORMAT1 = 32768;

const int CSSM_CERTGROUP_DATA1 = 0;

const int CSSM_CERTGROUP_ENCODED_CERT1 = 1;

const int CSSM_CERTGROUP_PARSED_CERT1 = 2;

const int CSSM_CERTGROUP_CERT_PAIR1 = 3;

const int CSSM_ACL_SUBJECT_TYPE_ANY1 = 1;

const int CSSM_ACL_SUBJECT_TYPE_THRESHOLD1 = 123;

const int CSSM_ACL_SUBJECT_TYPE_PASSWORD1 = 79;

const int CSSM_ACL_SUBJECT_TYPE_PROTECTED_PASSWORD1 = 87;

const int CSSM_ACL_SUBJECT_TYPE_PROMPTED_PASSWORD1 = 84;

const int CSSM_ACL_SUBJECT_TYPE_PUBLIC_KEY1 = 89;

const int CSSM_ACL_SUBJECT_TYPE_HASHED_SUBJECT1 = 44;

const int CSSM_ACL_SUBJECT_TYPE_BIOMETRIC1 = 8;

const int CSSM_ACL_SUBJECT_TYPE_PROTECTED_BIOMETRIC1 = 86;

const int CSSM_ACL_SUBJECT_TYPE_PROMPTED_BIOMETRIC1 = 83;

const int CSSM_ACL_SUBJECT_TYPE_LOGIN_NAME1 = 58;

const int CSSM_ACL_SUBJECT_TYPE_EXT_PAM_NAME1 = 78;

const int CSSM_ACL_AUTHORIZATION_TAG_VENDOR_DEFINED_START1 = 65536;

const int CSSM_ACL_AUTHORIZATION_ANY1 = 1;

const int CSSM_ACL_AUTHORIZATION_LOGIN1 = 57;

const int CSSM_ACL_AUTHORIZATION_GENKEY1 = 41;

const int CSSM_ACL_AUTHORIZATION_DELETE1 = 25;

const int CSSM_ACL_AUTHORIZATION_EXPORT_WRAPPED1 = 38;

const int CSSM_ACL_AUTHORIZATION_EXPORT_CLEAR1 = 37;

const int CSSM_ACL_AUTHORIZATION_IMPORT_WRAPPED1 = 48;

const int CSSM_ACL_AUTHORIZATION_IMPORT_CLEAR1 = 47;

const int CSSM_ACL_AUTHORIZATION_SIGN1 = 115;

const int CSSM_ACL_AUTHORIZATION_ENCRYPT1 = 35;

const int CSSM_ACL_AUTHORIZATION_DECRYPT1 = 24;

const int CSSM_ACL_AUTHORIZATION_MAC1 = 59;

const int CSSM_ACL_AUTHORIZATION_DERIVE1 = 28;

const int CSSM_ACL_AUTHORIZATION_DBS_CREATE1 = 22;

const int CSSM_ACL_AUTHORIZATION_DBS_DELETE1 = 23;

const int CSSM_ACL_AUTHORIZATION_DB_READ1 = 21;

const int CSSM_ACL_AUTHORIZATION_DB_INSERT1 = 19;

const int CSSM_ACL_AUTHORIZATION_DB_MODIFY1 = 20;

const int CSSM_ACL_AUTHORIZATION_DB_DELETE1 = 17;

const int CSSM_ACL_EDIT_MODE_ADD1 = 1;

const int CSSM_ACL_EDIT_MODE_DELETE1 = 2;

const int CSSM_ACL_EDIT_MODE_REPLACE1 = 3;

const int CSSM_KEYHEADER_VERSION1 = 2;

const int CSSM_KEYBLOB_RAW1 = 0;

const int CSSM_KEYBLOB_REFERENCE1 = 2;

const int CSSM_KEYBLOB_WRAPPED1 = 3;

const int CSSM_KEYBLOB_OTHER1 = -1;

const int CSSM_KEYBLOB_RAW_FORMAT_NONE1 = 0;

const int CSSM_KEYBLOB_RAW_FORMAT_PKCS11 = 1;

const int CSSM_KEYBLOB_RAW_FORMAT_PKCS31 = 2;

const int CSSM_KEYBLOB_RAW_FORMAT_MSCAPI1 = 3;

const int CSSM_KEYBLOB_RAW_FORMAT_PGP1 = 4;

const int CSSM_KEYBLOB_RAW_FORMAT_FIPS1861 = 5;

const int CSSM_KEYBLOB_RAW_FORMAT_BSAFE1 = 6;

const int CSSM_KEYBLOB_RAW_FORMAT_CCA1 = 9;

const int CSSM_KEYBLOB_RAW_FORMAT_PKCS81 = 10;

const int CSSM_KEYBLOB_RAW_FORMAT_SPKI1 = 11;

const int CSSM_KEYBLOB_RAW_FORMAT_OCTET_STRING1 = 12;

const int CSSM_KEYBLOB_RAW_FORMAT_OTHER1 = -1;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_NONE1 = 0;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_PKCS81 = 1;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_PKCS71 = 2;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_MSCAPI1 = 3;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_OTHER1 = -1;

const int CSSM_KEYBLOB_REF_FORMAT_INTEGER1 = 0;

const int CSSM_KEYBLOB_REF_FORMAT_STRING1 = 1;

const int CSSM_KEYBLOB_REF_FORMAT_SPKI1 = 2;

const int CSSM_KEYBLOB_REF_FORMAT_OTHER1 = -1;

const int CSSM_KEYCLASS_PUBLIC_KEY1 = 0;

const int CSSM_KEYCLASS_PRIVATE_KEY1 = 1;

const int CSSM_KEYCLASS_SESSION_KEY1 = 2;

const int CSSM_KEYCLASS_SECRET_PART1 = 3;

const int CSSM_KEYCLASS_OTHER1 = -1;

const int CSSM_KEYATTR_RETURN_DEFAULT1 = 0;

const int CSSM_KEYATTR_RETURN_DATA1 = 268435456;

const int CSSM_KEYATTR_RETURN_REF1 = 536870912;

const int CSSM_KEYATTR_RETURN_NONE1 = 1073741824;

const int CSSM_KEYATTR_PERMANENT1 = 1;

const int CSSM_KEYATTR_PRIVATE1 = 2;

const int CSSM_KEYATTR_MODIFIABLE1 = 4;

const int CSSM_KEYATTR_SENSITIVE1 = 8;

const int CSSM_KEYATTR_EXTRACTABLE1 = 32;

const int CSSM_KEYATTR_ALWAYS_SENSITIVE1 = 16;

const int CSSM_KEYATTR_NEVER_EXTRACTABLE1 = 64;

const int CSSM_KEYUSE_ANY1 = -2147483648;

const int CSSM_KEYUSE_ENCRYPT1 = 1;

const int CSSM_KEYUSE_DECRYPT1 = 2;

const int CSSM_KEYUSE_SIGN1 = 4;

const int CSSM_KEYUSE_VERIFY1 = 8;

const int CSSM_KEYUSE_SIGN_RECOVER1 = 16;

const int CSSM_KEYUSE_VERIFY_RECOVER1 = 32;

const int CSSM_KEYUSE_WRAP1 = 64;

const int CSSM_KEYUSE_UNWRAP1 = 128;

const int CSSM_KEYUSE_DERIVE1 = 256;

const int CSSM_ALGID_NONE1 = 0;

const int CSSM_ALGID_CUSTOM1 = 1;

const int CSSM_ALGID_DH1 = 2;

const int CSSM_ALGID_PH1 = 3;

const int CSSM_ALGID_KEA1 = 4;

const int CSSM_ALGID_MD21 = 5;

const int CSSM_ALGID_MD41 = 6;

const int CSSM_ALGID_MD51 = 7;

const int CSSM_ALGID_SHA11 = 8;

const int CSSM_ALGID_NHASH1 = 9;

const int CSSM_ALGID_HAVAL1 = 10;

const int CSSM_ALGID_RIPEMD1 = 11;

const int CSSM_ALGID_IBCHASH1 = 12;

const int CSSM_ALGID_RIPEMAC1 = 13;

const int CSSM_ALGID_DES1 = 14;

const int CSSM_ALGID_DESX1 = 15;

const int CSSM_ALGID_RDES1 = 16;

const int CSSM_ALGID_3DES_3KEY_EDE1 = 17;

const int CSSM_ALGID_3DES_2KEY_EDE1 = 18;

const int CSSM_ALGID_3DES_1KEY_EEE1 = 19;

const int CSSM_ALGID_3DES_3KEY1 = 17;

const int CSSM_ALGID_3DES_3KEY_EEE1 = 20;

const int CSSM_ALGID_3DES_2KEY1 = 18;

const int CSSM_ALGID_3DES_2KEY_EEE1 = 21;

const int CSSM_ALGID_3DES_1KEY1 = 20;

const int CSSM_ALGID_IDEA1 = 22;

const int CSSM_ALGID_RC21 = 23;

const int CSSM_ALGID_RC51 = 24;

const int CSSM_ALGID_RC41 = 25;

const int CSSM_ALGID_SEAL1 = 26;

const int CSSM_ALGID_CAST1 = 27;

const int CSSM_ALGID_BLOWFISH1 = 28;

const int CSSM_ALGID_SKIPJACK1 = 29;

const int CSSM_ALGID_LUCIFER1 = 30;

const int CSSM_ALGID_MADRYGA1 = 31;

const int CSSM_ALGID_FEAL1 = 32;

const int CSSM_ALGID_REDOC1 = 33;

const int CSSM_ALGID_REDOC31 = 34;

const int CSSM_ALGID_LOKI1 = 35;

const int CSSM_ALGID_KHUFU1 = 36;

const int CSSM_ALGID_KHAFRE1 = 37;

const int CSSM_ALGID_MMB1 = 38;

const int CSSM_ALGID_GOST1 = 39;

const int CSSM_ALGID_SAFER1 = 40;

const int CSSM_ALGID_CRAB1 = 41;

const int CSSM_ALGID_RSA1 = 42;

const int CSSM_ALGID_DSA1 = 43;

const int CSSM_ALGID_MD5WithRSA1 = 44;

const int CSSM_ALGID_MD2WithRSA1 = 45;

const int CSSM_ALGID_ElGamal1 = 46;

const int CSSM_ALGID_MD2Random1 = 47;

const int CSSM_ALGID_MD5Random1 = 48;

const int CSSM_ALGID_SHARandom1 = 49;

const int CSSM_ALGID_DESRandom1 = 50;

const int CSSM_ALGID_SHA1WithRSA1 = 51;

const int CSSM_ALGID_CDMF1 = 52;

const int CSSM_ALGID_CAST31 = 53;

const int CSSM_ALGID_CAST51 = 54;

const int CSSM_ALGID_GenericSecret1 = 55;

const int CSSM_ALGID_ConcatBaseAndKey1 = 56;

const int CSSM_ALGID_ConcatKeyAndBase1 = 57;

const int CSSM_ALGID_ConcatBaseAndData1 = 58;

const int CSSM_ALGID_ConcatDataAndBase1 = 59;

const int CSSM_ALGID_XORBaseAndData1 = 60;

const int CSSM_ALGID_ExtractFromKey1 = 61;

const int CSSM_ALGID_SSL3PrePrimaryGen1 = 62;

const int CSSM_ALGID_SSL3PreMasterGen1 = 62;

const int CSSM_ALGID_SSL3PrimaryDerive1 = 63;

const int CSSM_ALGID_SSL3MasterDerive1 = 63;

const int CSSM_ALGID_SSL3KeyAndMacDerive1 = 64;

const int CSSM_ALGID_SSL3MD5_MAC1 = 65;

const int CSSM_ALGID_SSL3SHA1_MAC1 = 66;

const int CSSM_ALGID_PKCS5_PBKDF1_MD51 = 67;

const int CSSM_ALGID_PKCS5_PBKDF1_MD21 = 68;

const int CSSM_ALGID_PKCS5_PBKDF1_SHA11 = 69;

const int CSSM_ALGID_WrapLynks1 = 70;

const int CSSM_ALGID_WrapSET_OAEP1 = 71;

const int CSSM_ALGID_BATON1 = 72;

const int CSSM_ALGID_ECDSA1 = 73;

const int CSSM_ALGID_MAYFLY1 = 74;

const int CSSM_ALGID_JUNIPER1 = 75;

const int CSSM_ALGID_FASTHASH1 = 76;

const int CSSM_ALGID_3DES1 = 77;

const int CSSM_ALGID_SSL3MD51 = 78;

const int CSSM_ALGID_SSL3SHA11 = 79;

const int CSSM_ALGID_FortezzaTimestamp1 = 80;

const int CSSM_ALGID_SHA1WithDSA1 = 81;

const int CSSM_ALGID_SHA1WithECDSA1 = 82;

const int CSSM_ALGID_DSA_BSAFE1 = 83;

const int CSSM_ALGID_ECDH1 = 84;

const int CSSM_ALGID_ECMQV1 = 85;

const int CSSM_ALGID_PKCS12_SHA1_PBE1 = 86;

const int CSSM_ALGID_ECNRA1 = 87;

const int CSSM_ALGID_SHA1WithECNRA1 = 88;

const int CSSM_ALGID_ECES1 = 89;

const int CSSM_ALGID_ECAES1 = 90;

const int CSSM_ALGID_SHA1HMAC1 = 91;

const int CSSM_ALGID_FIPS186Random1 = 92;

const int CSSM_ALGID_ECC1 = 93;

const int CSSM_ALGID_MQV1 = 94;

const int CSSM_ALGID_NRA1 = 95;

const int CSSM_ALGID_IntelPlatformRandom1 = 96;

const int CSSM_ALGID_UTC1 = 97;

const int CSSM_ALGID_HAVAL31 = 98;

const int CSSM_ALGID_HAVAL41 = 99;

const int CSSM_ALGID_HAVAL51 = 100;

const int CSSM_ALGID_TIGER1 = 101;

const int CSSM_ALGID_MD5HMAC1 = 102;

const int CSSM_ALGID_PKCS5_PBKDF21 = 103;

const int CSSM_ALGID_RUNNING_COUNTER1 = 104;

const int CSSM_ALGID_LAST1 = 2147483647;

const int CSSM_ALGID_VENDOR_DEFINED1 = -2147483648;

const int CSSM_ALGMODE_NONE1 = 0;

const int CSSM_ALGMODE_CUSTOM1 = 1;

const int CSSM_ALGMODE_ECB1 = 2;

const int CSSM_ALGMODE_ECBPad1 = 3;

const int CSSM_ALGMODE_CBC1 = 4;

const int CSSM_ALGMODE_CBC_IV81 = 5;

const int CSSM_ALGMODE_CBCPadIV81 = 6;

const int CSSM_ALGMODE_CFB1 = 7;

const int CSSM_ALGMODE_CFB_IV81 = 8;

const int CSSM_ALGMODE_CFBPadIV81 = 9;

const int CSSM_ALGMODE_OFB1 = 10;

const int CSSM_ALGMODE_OFB_IV81 = 11;

const int CSSM_ALGMODE_OFBPadIV81 = 12;

const int CSSM_ALGMODE_COUNTER1 = 13;

const int CSSM_ALGMODE_BC1 = 14;

const int CSSM_ALGMODE_PCBC1 = 15;

const int CSSM_ALGMODE_CBCC1 = 16;

const int CSSM_ALGMODE_OFBNLF1 = 17;

const int CSSM_ALGMODE_PBC1 = 18;

const int CSSM_ALGMODE_PFB1 = 19;

const int CSSM_ALGMODE_CBCPD1 = 20;

const int CSSM_ALGMODE_PUBLIC_KEY1 = 21;

const int CSSM_ALGMODE_PRIVATE_KEY1 = 22;

const int CSSM_ALGMODE_SHUFFLE1 = 23;

const int CSSM_ALGMODE_ECB641 = 24;

const int CSSM_ALGMODE_CBC641 = 25;

const int CSSM_ALGMODE_OFB641 = 26;

const int CSSM_ALGMODE_CFB321 = 28;

const int CSSM_ALGMODE_CFB161 = 29;

const int CSSM_ALGMODE_CFB81 = 30;

const int CSSM_ALGMODE_WRAP1 = 31;

const int CSSM_ALGMODE_PRIVATE_WRAP1 = 32;

const int CSSM_ALGMODE_RELAYX1 = 33;

const int CSSM_ALGMODE_ECB1281 = 34;

const int CSSM_ALGMODE_ECB961 = 35;

const int CSSM_ALGMODE_CBC1281 = 36;

const int CSSM_ALGMODE_OAEP_HASH1 = 37;

const int CSSM_ALGMODE_PKCS1_EME_V151 = 38;

const int CSSM_ALGMODE_PKCS1_EME_OAEP1 = 39;

const int CSSM_ALGMODE_PKCS1_EMSA_V151 = 40;

const int CSSM_ALGMODE_ISO_97961 = 41;

const int CSSM_ALGMODE_X9_311 = 42;

const int CSSM_ALGMODE_LAST1 = 2147483647;

const int CSSM_ALGMODE_VENDOR_DEFINED1 = -2147483648;

const int CSSM_CSP_SOFTWARE1 = 1;

const int CSSM_CSP_HARDWARE1 = 2;

const int CSSM_CSP_HYBRID1 = 3;

const int CSSM_ALGCLASS_NONE1 = 0;

const int CSSM_ALGCLASS_CUSTOM1 = 1;

const int CSSM_ALGCLASS_SIGNATURE1 = 2;

const int CSSM_ALGCLASS_SYMMETRIC1 = 3;

const int CSSM_ALGCLASS_DIGEST1 = 4;

const int CSSM_ALGCLASS_RANDOMGEN1 = 5;

const int CSSM_ALGCLASS_UNIQUEGEN1 = 6;

const int CSSM_ALGCLASS_MAC1 = 7;

const int CSSM_ALGCLASS_ASYMMETRIC1 = 8;

const int CSSM_ALGCLASS_KEYGEN1 = 9;

const int CSSM_ALGCLASS_DERIVEKEY1 = 10;

const int CSSM_ATTRIBUTE_DATA_NONE1 = 0;

const int CSSM_ATTRIBUTE_DATA_UINT321 = 268435456;

const int CSSM_ATTRIBUTE_DATA_CSSM_DATA1 = 536870912;

const int CSSM_ATTRIBUTE_DATA_CRYPTO_DATA1 = 805306368;

const int CSSM_ATTRIBUTE_DATA_KEY1 = 1073741824;

const int CSSM_ATTRIBUTE_DATA_STRING1 = 1342177280;

const int CSSM_ATTRIBUTE_DATA_DATE1 = 1610612736;

const int CSSM_ATTRIBUTE_DATA_RANGE1 = 1879048192;

const int CSSM_ATTRIBUTE_DATA_ACCESS_CREDENTIALS1 = -2147483648;

const int CSSM_ATTRIBUTE_DATA_VERSION1 = 16777216;

const int CSSM_ATTRIBUTE_DATA_DL_DB_HANDLE1 = 33554432;

const int CSSM_ATTRIBUTE_DATA_KR_PROFILE1 = 50331648;

const int CSSM_ATTRIBUTE_TYPE_MASK1 = -16777216;

const int CSSM_ATTRIBUTE_NONE1 = 0;

const int CSSM_ATTRIBUTE_CUSTOM1 = 536870913;

const int CSSM_ATTRIBUTE_DESCRIPTION1 = 1342177282;

const int CSSM_ATTRIBUTE_KEY1 = 1073741827;

const int CSSM_ATTRIBUTE_INIT_VECTOR1 = 536870916;

const int CSSM_ATTRIBUTE_SALT1 = 536870917;

const int CSSM_ATTRIBUTE_PADDING1 = 268435462;

const int CSSM_ATTRIBUTE_RANDOM1 = 536870919;

const int CSSM_ATTRIBUTE_SEED1 = 805306376;

const int CSSM_ATTRIBUTE_PASSPHRASE1 = 805306377;

const int CSSM_ATTRIBUTE_KEY_LENGTH1 = 268435466;

const int CSSM_ATTRIBUTE_KEY_LENGTH_RANGE1 = 1879048203;

const int CSSM_ATTRIBUTE_BLOCK_SIZE1 = 268435468;

const int CSSM_ATTRIBUTE_OUTPUT_SIZE1 = 268435469;

const int CSSM_ATTRIBUTE_ROUNDS1 = 268435470;

const int CSSM_ATTRIBUTE_IV_SIZE1 = 268435471;

const int CSSM_ATTRIBUTE_ALG_PARAMS1 = 536870928;

const int CSSM_ATTRIBUTE_LABEL1 = 536870929;

const int CSSM_ATTRIBUTE_KEY_TYPE1 = 268435474;

const int CSSM_ATTRIBUTE_MODE1 = 268435475;

const int CSSM_ATTRIBUTE_EFFECTIVE_BITS1 = 268435476;

const int CSSM_ATTRIBUTE_START_DATE1 = 1610612757;

const int CSSM_ATTRIBUTE_END_DATE1 = 1610612758;

const int CSSM_ATTRIBUTE_KEYUSAGE1 = 268435479;

const int CSSM_ATTRIBUTE_KEYATTR1 = 268435480;

const int CSSM_ATTRIBUTE_VERSION1 = 16777241;

const int CSSM_ATTRIBUTE_PRIME1 = 536870938;

const int CSSM_ATTRIBUTE_BASE1 = 536870939;

const int CSSM_ATTRIBUTE_SUBPRIME1 = 536870940;

const int CSSM_ATTRIBUTE_ALG_ID1 = 268435485;

const int CSSM_ATTRIBUTE_ITERATION_COUNT1 = 268435486;

const int CSSM_ATTRIBUTE_ROUNDS_RANGE1 = 1879048223;

const int CSSM_ATTRIBUTE_KRPROFILE_LOCAL1 = 50331680;

const int CSSM_ATTRIBUTE_KRPROFILE_REMOTE1 = 50331681;

const int CSSM_ATTRIBUTE_CSP_HANDLE1 = 268435490;

const int CSSM_ATTRIBUTE_DL_DB_HANDLE1 = 33554467;

const int CSSM_ATTRIBUTE_ACCESS_CREDENTIALS1 = -2147483612;

const int CSSM_ATTRIBUTE_PUBLIC_KEY_FORMAT1 = 268435493;

const int CSSM_ATTRIBUTE_PRIVATE_KEY_FORMAT1 = 268435494;

const int CSSM_ATTRIBUTE_SYMMETRIC_KEY_FORMAT1 = 268435495;

const int CSSM_ATTRIBUTE_WRAPPED_KEY_FORMAT1 = 268435496;

const int CSSM_PADDING_NONE1 = 0;

const int CSSM_PADDING_CUSTOM1 = 1;

const int CSSM_PADDING_ZERO1 = 2;

const int CSSM_PADDING_ONE1 = 3;

const int CSSM_PADDING_ALTERNATE1 = 4;

const int CSSM_PADDING_FF1 = 5;

const int CSSM_PADDING_PKCS51 = 6;

const int CSSM_PADDING_PKCS71 = 7;

const int CSSM_PADDING_CIPHERSTEALING1 = 8;

const int CSSM_PADDING_RANDOM1 = 9;

const int CSSM_PADDING_PKCS11 = 10;

const int CSSM_PADDING_SIGRAW1 = 11;

const int CSSM_PADDING_VENDOR_DEFINED1 = -2147483648;

const int CSSM_CSP_TOK_RNG1 = 1;

const int CSSM_CSP_TOK_CLOCK_EXISTS1 = 64;

const int CSSM_CSP_RDR_TOKENPRESENT1 = 1;

const int CSSM_CSP_RDR_EXISTS1 = 2;

const int CSSM_CSP_RDR_HW1 = 4;

const int CSSM_CSP_TOK_WRITE_PROTECTED1 = 2;

const int CSSM_CSP_TOK_LOGIN_REQUIRED1 = 4;

const int CSSM_CSP_TOK_USER_PIN_INITIALIZED1 = 8;

const int CSSM_CSP_TOK_PROT_AUTHENTICATION1 = 256;

const int CSSM_CSP_TOK_USER_PIN_EXPIRED1 = 1048576;

const int CSSM_CSP_TOK_SESSION_KEY_PASSWORD1 = 2097152;

const int CSSM_CSP_TOK_PRIVATE_KEY_PASSWORD1 = 4194304;

const int CSSM_CSP_STORES_PRIVATE_KEYS1 = 16777216;

const int CSSM_CSP_STORES_PUBLIC_KEYS1 = 33554432;

const int CSSM_CSP_STORES_SESSION_KEYS1 = 67108864;

const int CSSM_CSP_STORES_CERTIFICATES1 = 134217728;

const int CSSM_CSP_STORES_GENERIC1 = 268435456;

const int CSSM_PKCS_OAEP_MGF_NONE1 = 0;

const int CSSM_PKCS_OAEP_MGF1_SHA11 = 1;

const int CSSM_PKCS_OAEP_MGF1_MD51 = 2;

const int CSSM_PKCS_OAEP_PSOURCE_NONE1 = 0;

const int CSSM_PKCS_OAEP_PSOURCE_Pspecified1 = 1;

const int CSSM_VALUE_NOT_AVAILABLE1 = -1;

const int CSSM_PKCS5_PBKDF2_PRF_HMAC_SHA11 = 0;

const int CSSM_TP_AUTHORITY_REQUEST_CERTISSUE1 = 1;

const int CSSM_TP_AUTHORITY_REQUEST_CERTREVOKE1 = 2;

const int CSSM_TP_AUTHORITY_REQUEST_CERTSUSPEND1 = 3;

const int CSSM_TP_AUTHORITY_REQUEST_CERTRESUME1 = 4;

const int CSSM_TP_AUTHORITY_REQUEST_CERTVERIFY1 = 5;

const int CSSM_TP_AUTHORITY_REQUEST_CERTNOTARIZE1 = 6;

const int CSSM_TP_AUTHORITY_REQUEST_CERTUSERECOVER1 = 7;

const int CSSM_TP_AUTHORITY_REQUEST_CRLISSUE1 = 256;

const int CSSM_TP_KEY_ARCHIVE1 = 1;

const int CSSM_TP_CERT_PUBLISH1 = 2;

const int CSSM_TP_CERT_NOTIFY_RENEW1 = 4;

const int CSSM_TP_CERT_DIR_UPDATE1 = 8;

const int CSSM_TP_CRL_DISTRIBUTE1 = 16;

const int CSSM_TP_ACTION_DEFAULT1 = 0;

const int CSSM_TP_STOP_ON_POLICY1 = 0;

const int CSSM_TP_STOP_ON_NONE1 = 1;

const int CSSM_TP_STOP_ON_FIRST_PASS1 = 2;

const int CSSM_TP_STOP_ON_FIRST_FAIL1 = 3;

const int CSSM_CRL_PARSE_FORMAT_NONE1 = 0;

const int CSSM_CRL_PARSE_FORMAT_CUSTOM1 = 1;

const int CSSM_CRL_PARSE_FORMAT_SEXPR1 = 2;

const int CSSM_CRL_PARSE_FORMAT_COMPLEX1 = 3;

const int CSSM_CRL_PARSE_FORMAT_OID_NAMED1 = 4;

const int CSSM_CRL_PARSE_FORMAT_TUPLE1 = 5;

const int CSSM_CRL_PARSE_FORMAT_MULTIPLE1 = 32766;

const int CSSM_CRL_PARSE_FORMAT_LAST1 = 32767;

const int CSSM_CL_CUSTOM_CRL_PARSE_FORMAT1 = 32768;

const int CSSM_CRL_TYPE_UNKNOWN1 = 0;

const int CSSM_CRL_TYPE_X_509v11 = 1;

const int CSSM_CRL_TYPE_X_509v21 = 2;

const int CSSM_CRL_TYPE_SPKI1 = 3;

const int CSSM_CRL_TYPE_MULTIPLE1 = 32766;

const int CSSM_CRL_ENCODING_UNKNOWN1 = 0;

const int CSSM_CRL_ENCODING_CUSTOM1 = 1;

const int CSSM_CRL_ENCODING_BER1 = 2;

const int CSSM_CRL_ENCODING_DER1 = 3;

const int CSSM_CRL_ENCODING_BLOOM1 = 4;

const int CSSM_CRL_ENCODING_SEXPR1 = 5;

const int CSSM_CRL_ENCODING_MULTIPLE1 = 32766;

const int CSSM_CRLGROUP_DATA1 = 0;

const int CSSM_CRLGROUP_ENCODED_CRL1 = 1;

const int CSSM_CRLGROUP_PARSED_CRL1 = 2;

const int CSSM_CRLGROUP_CRL_PAIR1 = 3;

const int CSSM_EVIDENCE_FORM_UNSPECIFIC1 = 0;

const int CSSM_EVIDENCE_FORM_CERT1 = 1;

const int CSSM_EVIDENCE_FORM_CRL1 = 2;

const int CSSM_EVIDENCE_FORM_CERT_ID1 = 3;

const int CSSM_EVIDENCE_FORM_CRL_ID1 = 4;

const int CSSM_EVIDENCE_FORM_VERIFIER_TIME1 = 5;

const int CSSM_EVIDENCE_FORM_CRL_THISTIME1 = 6;

const int CSSM_EVIDENCE_FORM_CRL_NEXTTIME1 = 7;

const int CSSM_EVIDENCE_FORM_POLICYINFO1 = 8;

const int CSSM_EVIDENCE_FORM_TUPLEGROUP1 = 9;

const int CSSM_TP_CONFIRM_STATUS_UNKNOWN1 = 0;

const int CSSM_TP_CONFIRM_ACCEPT1 = 1;

const int CSSM_TP_CONFIRM_REJECT1 = 2;

const int CSSM_ESTIMATED_TIME_UNKNOWN1 = -1;

const int CSSM_ELAPSED_TIME_UNKNOWN1 = -1;

const int CSSM_ELAPSED_TIME_COMPLETE1 = -2;

const int CSSM_TP_CERTISSUE_STATUS_UNKNOWN1 = 0;

const int CSSM_TP_CERTISSUE_OK1 = 1;

const int CSSM_TP_CERTISSUE_OKWITHCERTMODS1 = 2;

const int CSSM_TP_CERTISSUE_OKWITHSERVICEMODS1 = 3;

const int CSSM_TP_CERTISSUE_REJECTED1 = 4;

const int CSSM_TP_CERTISSUE_NOT_AUTHORIZED1 = 5;

const int CSSM_TP_CERTISSUE_WILL_BE_REVOKED1 = 6;

const int CSSM_TP_CERTCHANGE_NONE1 = 0;

const int CSSM_TP_CERTCHANGE_REVOKE1 = 1;

const int CSSM_TP_CERTCHANGE_HOLD1 = 2;

const int CSSM_TP_CERTCHANGE_RELEASE1 = 3;

const int CSSM_TP_CERTCHANGE_REASON_UNKNOWN1 = 0;

const int CSSM_TP_CERTCHANGE_REASON_KEYCOMPROMISE1 = 1;

const int CSSM_TP_CERTCHANGE_REASON_CACOMPROMISE1 = 2;

const int CSSM_TP_CERTCHANGE_REASON_CEASEOPERATION1 = 3;

const int CSSM_TP_CERTCHANGE_REASON_AFFILIATIONCHANGE1 = 4;

const int CSSM_TP_CERTCHANGE_REASON_SUPERCEDED1 = 5;

const int CSSM_TP_CERTCHANGE_REASON_SUSPECTEDCOMPROMISE1 = 6;

const int CSSM_TP_CERTCHANGE_REASON_HOLDRELEASE1 = 7;

const int CSSM_TP_CERTCHANGE_STATUS_UNKNOWN1 = 0;

const int CSSM_TP_CERTCHANGE_OK1 = 1;

const int CSSM_TP_CERTCHANGE_OKWITHNEWTIME1 = 2;

const int CSSM_TP_CERTCHANGE_WRONGCA1 = 3;

const int CSSM_TP_CERTCHANGE_REJECTED1 = 4;

const int CSSM_TP_CERTCHANGE_NOT_AUTHORIZED1 = 5;

const int CSSM_TP_CERTVERIFY_UNKNOWN1 = 0;

const int CSSM_TP_CERTVERIFY_VALID1 = 1;

const int CSSM_TP_CERTVERIFY_INVALID1 = 2;

const int CSSM_TP_CERTVERIFY_REVOKED1 = 3;

const int CSSM_TP_CERTVERIFY_SUSPENDED1 = 4;

const int CSSM_TP_CERTVERIFY_EXPIRED1 = 5;

const int CSSM_TP_CERTVERIFY_NOT_VALID_YET1 = 6;

const int CSSM_TP_CERTVERIFY_INVALID_AUTHORITY1 = 7;

const int CSSM_TP_CERTVERIFY_INVALID_SIGNATURE1 = 8;

const int CSSM_TP_CERTVERIFY_INVALID_CERT_VALUE1 = 9;

const int CSSM_TP_CERTVERIFY_INVALID_CERTGROUP1 = 10;

const int CSSM_TP_CERTVERIFY_INVALID_POLICY1 = 11;

const int CSSM_TP_CERTVERIFY_INVALID_POLICY_IDS1 = 12;

const int CSSM_TP_CERTVERIFY_INVALID_BASIC_CONSTRAINTS1 = 13;

const int CSSM_TP_CERTVERIFY_INVALID_CRL_DIST_PT1 = 14;

const int CSSM_TP_CERTVERIFY_INVALID_NAME_TREE1 = 15;

const int CSSM_TP_CERTVERIFY_UNKNOWN_CRITICAL_EXT1 = 16;

const int CSSM_TP_CERTNOTARIZE_STATUS_UNKNOWN1 = 0;

const int CSSM_TP_CERTNOTARIZE_OK1 = 1;

const int CSSM_TP_CERTNOTARIZE_OKWITHOUTFIELDS1 = 2;

const int CSSM_TP_CERTNOTARIZE_OKWITHSERVICEMODS1 = 3;

const int CSSM_TP_CERTNOTARIZE_REJECTED1 = 4;

const int CSSM_TP_CERTNOTARIZE_NOT_AUTHORIZED1 = 5;

const int CSSM_TP_CERTRECLAIM_STATUS_UNKNOWN1 = 0;

const int CSSM_TP_CERTRECLAIM_OK1 = 1;

const int CSSM_TP_CERTRECLAIM_NOMATCH1 = 2;

const int CSSM_TP_CERTRECLAIM_REJECTED1 = 3;

const int CSSM_TP_CERTRECLAIM_NOT_AUTHORIZED1 = 4;

const int CSSM_TP_CRLISSUE_STATUS_UNKNOWN1 = 0;

const int CSSM_TP_CRLISSUE_OK1 = 1;

const int CSSM_TP_CRLISSUE_NOT_CURRENT1 = 2;

const int CSSM_TP_CRLISSUE_INVALID_DOMAIN1 = 3;

const int CSSM_TP_CRLISSUE_UNKNOWN_IDENTIFIER1 = 4;

const int CSSM_TP_CRLISSUE_REJECTED1 = 5;

const int CSSM_TP_CRLISSUE_NOT_AUTHORIZED1 = 6;

const int CSSM_TP_FORM_TYPE_GENERIC1 = 0;

const int CSSM_TP_FORM_TYPE_REGISTRATION1 = 1;

const int CSSM_CL_TEMPLATE_INTERMEDIATE_CERT1 = 1;

const int CSSM_CL_TEMPLATE_PKIX_CERTTEMPLATE1 = 2;

const int CSSM_CERT_BUNDLE_UNKNOWN1 = 0;

const int CSSM_CERT_BUNDLE_CUSTOM1 = 1;

const int CSSM_CERT_BUNDLE_PKCS7_SIGNED_DATA1 = 2;

const int CSSM_CERT_BUNDLE_PKCS7_SIGNED_ENVELOPED_DATA1 = 3;

const int CSSM_CERT_BUNDLE_PKCS121 = 4;

const int CSSM_CERT_BUNDLE_PFX1 = 5;

const int CSSM_CERT_BUNDLE_SPKI_SEQUENCE1 = 6;

const int CSSM_CERT_BUNDLE_PGP_KEYRING1 = 7;

const int CSSM_CERT_BUNDLE_LAST1 = 32767;

const int CSSM_CL_CUSTOM_CERT_BUNDLE_TYPE1 = 32768;

const int CSSM_CERT_BUNDLE_ENCODING_UNKNOWN1 = 0;

const int CSSM_CERT_BUNDLE_ENCODING_CUSTOM1 = 1;

const int CSSM_CERT_BUNDLE_ENCODING_BER1 = 2;

const int CSSM_CERT_BUNDLE_ENCODING_DER1 = 3;

const int CSSM_CERT_BUNDLE_ENCODING_SEXPR1 = 4;

const int CSSM_CERT_BUNDLE_ENCODING_PGP1 = 5;

const int CSSM_FIELDVALUE_COMPLEX_DATA_TYPE1 = -1;

const int CSSM_DB_ATTRIBUTE_NAME_AS_STRING1 = 0;

const int CSSM_DB_ATTRIBUTE_NAME_AS_OID1 = 1;

const int CSSM_DB_ATTRIBUTE_NAME_AS_INTEGER1 = 2;

const int CSSM_DB_ATTRIBUTE_FORMAT_STRING1 = 0;

const int CSSM_DB_ATTRIBUTE_FORMAT_SINT321 = 1;

const int CSSM_DB_ATTRIBUTE_FORMAT_UINT321 = 2;

const int CSSM_DB_ATTRIBUTE_FORMAT_BIG_NUM1 = 3;

const int CSSM_DB_ATTRIBUTE_FORMAT_REAL1 = 4;

const int CSSM_DB_ATTRIBUTE_FORMAT_TIME_DATE1 = 5;

const int CSSM_DB_ATTRIBUTE_FORMAT_BLOB1 = 6;

const int CSSM_DB_ATTRIBUTE_FORMAT_MULTI_UINT321 = 7;

const int CSSM_DB_ATTRIBUTE_FORMAT_COMPLEX1 = 8;

const int CSSM_DB_RECORDTYPE_SCHEMA_START1 = 0;

const int CSSM_DB_RECORDTYPE_SCHEMA_END1 = 4;

const int CSSM_DB_RECORDTYPE_OPEN_GROUP_START1 = 10;

const int CSSM_DB_RECORDTYPE_OPEN_GROUP_END1 = 18;

const int CSSM_DB_RECORDTYPE_APP_DEFINED_START1 = -2147483648;

const int CSSM_DB_RECORDTYPE_APP_DEFINED_END1 = -1;

const int CSSM_DL_DB_SCHEMA_INFO1 = 0;

const int CSSM_DL_DB_SCHEMA_INDEXES1 = 1;

const int CSSM_DL_DB_SCHEMA_ATTRIBUTES1 = 2;

const int CSSM_DL_DB_SCHEMA_PARSING_MODULE1 = 3;

const int CSSM_DL_DB_RECORD_ANY1 = 10;

const int CSSM_DL_DB_RECORD_CERT1 = 11;

const int CSSM_DL_DB_RECORD_CRL1 = 12;

const int CSSM_DL_DB_RECORD_POLICY1 = 13;

const int CSSM_DL_DB_RECORD_GENERIC1 = 14;

const int CSSM_DL_DB_RECORD_PUBLIC_KEY1 = 15;

const int CSSM_DL_DB_RECORD_PRIVATE_KEY1 = 16;

const int CSSM_DL_DB_RECORD_SYMMETRIC_KEY1 = 17;

const int CSSM_DL_DB_RECORD_ALL_KEYS1 = 18;

const int CSSM_DB_CERT_USE_TRUSTED1 = 1;

const int CSSM_DB_CERT_USE_SYSTEM1 = 2;

const int CSSM_DB_CERT_USE_OWNER1 = 4;

const int CSSM_DB_CERT_USE_REVOKED1 = 8;

const int CSSM_DB_CERT_USE_SIGNING1 = 16;

const int CSSM_DB_CERT_USE_PRIVACY1 = 32;

const int CSSM_DB_INDEX_UNIQUE1 = 0;

const int CSSM_DB_INDEX_NONUNIQUE1 = 1;

const int CSSM_DB_INDEX_ON_UNKNOWN1 = 0;

const int CSSM_DB_INDEX_ON_ATTRIBUTE1 = 1;

const int CSSM_DB_INDEX_ON_RECORD1 = 2;

const int CSSM_DB_ACCESS_READ1 = 1;

const int CSSM_DB_ACCESS_WRITE1 = 2;

const int CSSM_DB_ACCESS_PRIVILEGED1 = 4;

const int CSSM_DB_MODIFY_ATTRIBUTE_NONE1 = 0;

const int CSSM_DB_MODIFY_ATTRIBUTE_ADD1 = 1;

const int CSSM_DB_MODIFY_ATTRIBUTE_DELETE1 = 2;

const int CSSM_DB_MODIFY_ATTRIBUTE_REPLACE1 = 3;

const int CSSM_DB_EQUAL1 = 0;

const int CSSM_DB_NOT_EQUAL1 = 1;

const int CSSM_DB_LESS_THAN1 = 2;

const int CSSM_DB_GREATER_THAN1 = 3;

const int CSSM_DB_CONTAINS1 = 4;

const int CSSM_DB_CONTAINS_INITIAL_SUBSTRING1 = 5;

const int CSSM_DB_CONTAINS_FINAL_SUBSTRING1 = 6;

const int CSSM_DB_NONE1 = 0;

const int CSSM_DB_AND1 = 1;

const int CSSM_DB_OR1 = 2;

const int CSSM_QUERY_TIMELIMIT_NONE1 = 0;

const int CSSM_QUERY_SIZELIMIT_NONE1 = 0;

const int CSSM_QUERY_RETURN_DATA1 = 1;

const int CSSM_DL_UNKNOWN1 = 0;

const int CSSM_DL_CUSTOM1 = 1;

const int CSSM_DL_LDAP1 = 2;

const int CSSM_DL_ODBC1 = 3;

const int CSSM_DL_PKCS111 = 4;

const int CSSM_DL_FFS1 = 5;

const int CSSM_DL_MEMORY1 = 6;

const int CSSM_DL_REMOTEDIR1 = 7;

const int CSSM_DB_DATASTORES_UNKNOWN1 = -1;

const int CSSM_DB_TRANSACTIONAL_MODE1 = 0;

const int CSSM_DB_FILESYSTEMSCAN_MODE1 = 1;

const int CSSM_BASE_ERROR1 = -2147418112;

const int CSSM_ERRORCODE_MODULE_EXTENT1 = 2048;

const int CSSM_ERRORCODE_CUSTOM_OFFSET1 = 1024;

const int CSSM_ERRORCODE_COMMON_EXTENT1 = 256;

const int CSSM_CSSM_BASE_ERROR1 = -2147418112;

const int CSSM_CSSM_PRIVATE_ERROR1 = -2147417088;

const int CSSM_CSP_BASE_ERROR1 = -2147416064;

const int CSSM_CSP_PRIVATE_ERROR1 = -2147415040;

const int CSSM_DL_BASE_ERROR1 = -2147414016;

const int CSSM_DL_PRIVATE_ERROR1 = -2147412992;

const int CSSM_CL_BASE_ERROR1 = -2147411968;

const int CSSM_CL_PRIVATE_ERROR1 = -2147410944;

const int CSSM_TP_BASE_ERROR1 = -2147409920;

const int CSSM_TP_PRIVATE_ERROR1 = -2147408896;

const int CSSM_KR_BASE_ERROR1 = -2147407872;

const int CSSM_KR_PRIVATE_ERROR1 = -2147406848;

const int CSSM_AC_BASE_ERROR1 = -2147405824;

const int CSSM_AC_PRIVATE_ERROR1 = -2147404800;

const int CSSM_MDS_BASE_ERROR1 = -2147414016;

const int CSSM_MDS_PRIVATE_ERROR1 = -2147412992;

const int CSSMERR_CSSM_INVALID_ADDIN_HANDLE1 = -2147417855;

const int CSSMERR_CSSM_NOT_INITIALIZED1 = -2147417854;

const int CSSMERR_CSSM_INVALID_HANDLE_USAGE1 = -2147417853;

const int CSSMERR_CSSM_PVC_REFERENT_NOT_FOUND1 = -2147417852;

const int CSSMERR_CSSM_FUNCTION_INTEGRITY_FAIL1 = -2147417851;

const int CSSM_ERRCODE_INTERNAL_ERROR1 = 1;

const int CSSM_ERRCODE_MEMORY_ERROR1 = 2;

const int CSSM_ERRCODE_MDS_ERROR1 = 3;

const int CSSM_ERRCODE_INVALID_POINTER1 = 4;

const int CSSM_ERRCODE_INVALID_INPUT_POINTER1 = 5;

const int CSSM_ERRCODE_INVALID_OUTPUT_POINTER1 = 6;

const int CSSM_ERRCODE_FUNCTION_NOT_IMPLEMENTED1 = 7;

const int CSSM_ERRCODE_SELF_CHECK_FAILED1 = 8;

const int CSSM_ERRCODE_OS_ACCESS_DENIED1 = 9;

const int CSSM_ERRCODE_FUNCTION_FAILED1 = 10;

const int CSSM_ERRCODE_MODULE_MANIFEST_VERIFY_FAILED1 = 11;

const int CSSM_ERRCODE_INVALID_GUID1 = 12;

const int CSSM_ERRCODE_OPERATION_AUTH_DENIED1 = 32;

const int CSSM_ERRCODE_OBJECT_USE_AUTH_DENIED1 = 33;

const int CSSM_ERRCODE_OBJECT_MANIP_AUTH_DENIED1 = 34;

const int CSSM_ERRCODE_OBJECT_ACL_NOT_SUPPORTED1 = 35;

const int CSSM_ERRCODE_OBJECT_ACL_REQUIRED1 = 36;

const int CSSM_ERRCODE_INVALID_ACCESS_CREDENTIALS1 = 37;

const int CSSM_ERRCODE_INVALID_ACL_BASE_CERTS1 = 38;

const int CSSM_ERRCODE_ACL_BASE_CERTS_NOT_SUPPORTED1 = 39;

const int CSSM_ERRCODE_INVALID_SAMPLE_VALUE1 = 40;

const int CSSM_ERRCODE_SAMPLE_VALUE_NOT_SUPPORTED1 = 41;

const int CSSM_ERRCODE_INVALID_ACL_SUBJECT_VALUE1 = 42;

const int CSSM_ERRCODE_ACL_SUBJECT_TYPE_NOT_SUPPORTED1 = 43;

const int CSSM_ERRCODE_INVALID_ACL_CHALLENGE_CALLBACK1 = 44;

const int CSSM_ERRCODE_ACL_CHALLENGE_CALLBACK_FAILED1 = 45;

const int CSSM_ERRCODE_INVALID_ACL_ENTRY_TAG1 = 46;

const int CSSM_ERRCODE_ACL_ENTRY_TAG_NOT_FOUND1 = 47;

const int CSSM_ERRCODE_INVALID_ACL_EDIT_MODE1 = 48;

const int CSSM_ERRCODE_ACL_CHANGE_FAILED1 = 49;

const int CSSM_ERRCODE_INVALID_NEW_ACL_ENTRY1 = 50;

const int CSSM_ERRCODE_INVALID_NEW_ACL_OWNER1 = 51;

const int CSSM_ERRCODE_ACL_DELETE_FAILED1 = 52;

const int CSSM_ERRCODE_ACL_REPLACE_FAILED1 = 53;

const int CSSM_ERRCODE_ACL_ADD_FAILED1 = 54;

const int CSSM_ERRCODE_INVALID_CONTEXT_HANDLE1 = 64;

const int CSSM_ERRCODE_INCOMPATIBLE_VERSION1 = 65;

const int CSSM_ERRCODE_INVALID_CERTGROUP_POINTER1 = 66;

const int CSSM_ERRCODE_INVALID_CERT_POINTER1 = 67;

const int CSSM_ERRCODE_INVALID_CRL_POINTER1 = 68;

const int CSSM_ERRCODE_INVALID_FIELD_POINTER1 = 69;

const int CSSM_ERRCODE_INVALID_DATA1 = 70;

const int CSSM_ERRCODE_CRL_ALREADY_SIGNED1 = 71;

const int CSSM_ERRCODE_INVALID_NUMBER_OF_FIELDS1 = 72;

const int CSSM_ERRCODE_VERIFICATION_FAILURE1 = 73;

const int CSSM_ERRCODE_INVALID_DB_HANDLE1 = 74;

const int CSSM_ERRCODE_PRIVILEGE_NOT_GRANTED1 = 75;

const int CSSM_ERRCODE_INVALID_DB_LIST1 = 76;

const int CSSM_ERRCODE_INVALID_DB_LIST_POINTER1 = 77;

const int CSSM_ERRCODE_UNKNOWN_FORMAT1 = 78;

const int CSSM_ERRCODE_UNKNOWN_TAG1 = 79;

const int CSSM_ERRCODE_INVALID_CSP_HANDLE1 = 80;

const int CSSM_ERRCODE_INVALID_DL_HANDLE1 = 81;

const int CSSM_ERRCODE_INVALID_CL_HANDLE1 = 82;

const int CSSM_ERRCODE_INVALID_TP_HANDLE1 = 83;

const int CSSM_ERRCODE_INVALID_KR_HANDLE1 = 84;

const int CSSM_ERRCODE_INVALID_AC_HANDLE1 = 85;

const int CSSM_ERRCODE_INVALID_PASSTHROUGH_ID1 = 86;

const int CSSM_ERRCODE_INVALID_NETWORK_ADDR1 = 87;

const int CSSM_ERRCODE_INVALID_CRYPTO_DATA1 = 88;

const int CSSMERR_CSSM_INTERNAL_ERROR1 = -2147418111;

const int CSSMERR_CSSM_MEMORY_ERROR1 = -2147418110;

const int CSSMERR_CSSM_MDS_ERROR1 = -2147418109;

const int CSSMERR_CSSM_INVALID_POINTER1 = -2147418108;

const int CSSMERR_CSSM_INVALID_INPUT_POINTER1 = -2147418107;

const int CSSMERR_CSSM_INVALID_OUTPUT_POINTER1 = -2147418106;

const int CSSMERR_CSSM_FUNCTION_NOT_IMPLEMENTED1 = -2147418105;

const int CSSMERR_CSSM_SELF_CHECK_FAILED1 = -2147418104;

const int CSSMERR_CSSM_OS_ACCESS_DENIED1 = -2147418103;

const int CSSMERR_CSSM_FUNCTION_FAILED1 = -2147418102;

const int CSSMERR_CSSM_MODULE_MANIFEST_VERIFY_FAILED1 = -2147418101;

const int CSSMERR_CSSM_INVALID_GUID1 = -2147418100;

const int CSSMERR_CSSM_INVALID_CONTEXT_HANDLE1 = -2147418048;

const int CSSMERR_CSSM_INCOMPATIBLE_VERSION1 = -2147418047;

const int CSSMERR_CSSM_PRIVILEGE_NOT_GRANTED1 = -2147418037;

const int CSSM_CSSM_BASE_CSSM_ERROR1 = -2147417840;

const int CSSMERR_CSSM_SCOPE_NOT_SUPPORTED1 = -2147417839;

const int CSSMERR_CSSM_PVC_ALREADY_CONFIGURED1 = -2147417838;

const int CSSMERR_CSSM_INVALID_PVC1 = -2147417837;

const int CSSMERR_CSSM_EMM_LOAD_FAILED1 = -2147417836;

const int CSSMERR_CSSM_EMM_UNLOAD_FAILED1 = -2147417835;

const int CSSMERR_CSSM_ADDIN_LOAD_FAILED1 = -2147417834;

const int CSSMERR_CSSM_INVALID_KEY_HIERARCHY1 = -2147417833;

const int CSSMERR_CSSM_ADDIN_UNLOAD_FAILED1 = -2147417832;

const int CSSMERR_CSSM_LIB_REF_NOT_FOUND1 = -2147417831;

const int CSSMERR_CSSM_INVALID_ADDIN_FUNCTION_TABLE1 = -2147417830;

const int CSSMERR_CSSM_EMM_AUTHENTICATE_FAILED1 = -2147417829;

const int CSSMERR_CSSM_ADDIN_AUTHENTICATE_FAILED1 = -2147417828;

const int CSSMERR_CSSM_INVALID_SERVICE_MASK1 = -2147417827;

const int CSSMERR_CSSM_MODULE_NOT_LOADED1 = -2147417826;

const int CSSMERR_CSSM_INVALID_SUBSERVICEID1 = -2147417825;

const int CSSMERR_CSSM_BUFFER_TOO_SMALL1 = -2147417824;

const int CSSMERR_CSSM_INVALID_ATTRIBUTE1 = -2147417823;

const int CSSMERR_CSSM_ATTRIBUTE_NOT_IN_CONTEXT1 = -2147417822;

const int CSSMERR_CSSM_MODULE_MANAGER_INITIALIZE_FAIL1 = -2147417821;

const int CSSMERR_CSSM_MODULE_MANAGER_NOT_FOUND1 = -2147417820;

const int CSSMERR_CSSM_EVENT_NOTIFICATION_CALLBACK_NOT_FOUND1 = -2147417819;

const int CSSMERR_CSP_INTERNAL_ERROR1 = -2147416063;

const int CSSMERR_CSP_MEMORY_ERROR1 = -2147416062;

const int CSSMERR_CSP_MDS_ERROR1 = -2147416061;

const int CSSMERR_CSP_INVALID_POINTER1 = -2147416060;

const int CSSMERR_CSP_INVALID_INPUT_POINTER1 = -2147416059;

const int CSSMERR_CSP_INVALID_OUTPUT_POINTER1 = -2147416058;

const int CSSMERR_CSP_FUNCTION_NOT_IMPLEMENTED1 = -2147416057;

const int CSSMERR_CSP_SELF_CHECK_FAILED1 = -2147416056;

const int CSSMERR_CSP_OS_ACCESS_DENIED1 = -2147416055;

const int CSSMERR_CSP_FUNCTION_FAILED1 = -2147416054;

const int CSSMERR_CSP_OPERATION_AUTH_DENIED1 = -2147416032;

const int CSSMERR_CSP_OBJECT_USE_AUTH_DENIED1 = -2147416031;

const int CSSMERR_CSP_OBJECT_MANIP_AUTH_DENIED1 = -2147416030;

const int CSSMERR_CSP_OBJECT_ACL_NOT_SUPPORTED1 = -2147416029;

const int CSSMERR_CSP_OBJECT_ACL_REQUIRED1 = -2147416028;

const int CSSMERR_CSP_INVALID_ACCESS_CREDENTIALS1 = -2147416027;

const int CSSMERR_CSP_INVALID_ACL_BASE_CERTS1 = -2147416026;

const int CSSMERR_CSP_ACL_BASE_CERTS_NOT_SUPPORTED1 = -2147416025;

const int CSSMERR_CSP_INVALID_SAMPLE_VALUE1 = -2147416024;

const int CSSMERR_CSP_SAMPLE_VALUE_NOT_SUPPORTED1 = -2147416023;

const int CSSMERR_CSP_INVALID_ACL_SUBJECT_VALUE1 = -2147416022;

const int CSSMERR_CSP_ACL_SUBJECT_TYPE_NOT_SUPPORTED1 = -2147416021;

const int CSSMERR_CSP_INVALID_ACL_CHALLENGE_CALLBACK1 = -2147416020;

const int CSSMERR_CSP_ACL_CHALLENGE_CALLBACK_FAILED1 = -2147416019;

const int CSSMERR_CSP_INVALID_ACL_ENTRY_TAG1 = -2147416018;

const int CSSMERR_CSP_ACL_ENTRY_TAG_NOT_FOUND1 = -2147416017;

const int CSSMERR_CSP_INVALID_ACL_EDIT_MODE1 = -2147416016;

const int CSSMERR_CSP_ACL_CHANGE_FAILED1 = -2147416015;

const int CSSMERR_CSP_INVALID_NEW_ACL_ENTRY1 = -2147416014;

const int CSSMERR_CSP_INVALID_NEW_ACL_OWNER1 = -2147416013;

const int CSSMERR_CSP_ACL_DELETE_FAILED1 = -2147416012;

const int CSSMERR_CSP_ACL_REPLACE_FAILED1 = -2147416011;

const int CSSMERR_CSP_ACL_ADD_FAILED1 = -2147416010;

const int CSSMERR_CSP_INVALID_CONTEXT_HANDLE1 = -2147416000;

const int CSSMERR_CSP_PRIVILEGE_NOT_GRANTED1 = -2147415989;

const int CSSMERR_CSP_INVALID_DATA1 = -2147415994;

const int CSSMERR_CSP_INVALID_PASSTHROUGH_ID1 = -2147415978;

const int CSSMERR_CSP_INVALID_CRYPTO_DATA1 = -2147415976;

const int CSSM_CSP_BASE_CSP_ERROR1 = -2147415808;

const int CSSMERR_CSP_INPUT_LENGTH_ERROR1 = -2147415807;

const int CSSMERR_CSP_OUTPUT_LENGTH_ERROR1 = -2147415806;

const int CSSMERR_CSP_PRIVILEGE_NOT_SUPPORTED1 = -2147415805;

const int CSSMERR_CSP_DEVICE_ERROR1 = -2147415804;

const int CSSMERR_CSP_DEVICE_MEMORY_ERROR1 = -2147415803;

const int CSSMERR_CSP_ATTACH_HANDLE_BUSY1 = -2147415802;

const int CSSMERR_CSP_NOT_LOGGED_IN1 = -2147415801;

const int CSSMERR_CSP_INVALID_KEY1 = -2147415792;

const int CSSMERR_CSP_INVALID_KEY_REFERENCE1 = -2147415791;

const int CSSMERR_CSP_INVALID_KEY_CLASS1 = -2147415790;

const int CSSMERR_CSP_ALGID_MISMATCH1 = -2147415789;

const int CSSMERR_CSP_KEY_USAGE_INCORRECT1 = -2147415788;

const int CSSMERR_CSP_KEY_BLOB_TYPE_INCORRECT1 = -2147415787;

const int CSSMERR_CSP_KEY_HEADER_INCONSISTENT1 = -2147415786;

const int CSSMERR_CSP_UNSUPPORTED_KEY_FORMAT1 = -2147415785;

const int CSSMERR_CSP_UNSUPPORTED_KEY_SIZE1 = -2147415784;

const int CSSMERR_CSP_INVALID_KEY_POINTER1 = -2147415783;

const int CSSMERR_CSP_INVALID_KEYUSAGE_MASK1 = -2147415782;

const int CSSMERR_CSP_UNSUPPORTED_KEYUSAGE_MASK1 = -2147415781;

const int CSSMERR_CSP_INVALID_KEYATTR_MASK1 = -2147415780;

const int CSSMERR_CSP_UNSUPPORTED_KEYATTR_MASK1 = -2147415779;

const int CSSMERR_CSP_INVALID_KEY_LABEL1 = -2147415778;

const int CSSMERR_CSP_UNSUPPORTED_KEY_LABEL1 = -2147415777;

const int CSSMERR_CSP_INVALID_KEY_FORMAT1 = -2147415776;

const int CSSMERR_CSP_INVALID_DATA_COUNT1 = -2147415768;

const int CSSMERR_CSP_VECTOR_OF_BUFS_UNSUPPORTED1 = -2147415767;

const int CSSMERR_CSP_INVALID_INPUT_VECTOR1 = -2147415766;

const int CSSMERR_CSP_INVALID_OUTPUT_VECTOR1 = -2147415765;

const int CSSMERR_CSP_INVALID_CONTEXT1 = -2147415760;

const int CSSMERR_CSP_INVALID_ALGORITHM1 = -2147415759;

const int CSSMERR_CSP_INVALID_ATTR_KEY1 = -2147415754;

const int CSSMERR_CSP_MISSING_ATTR_KEY1 = -2147415753;

const int CSSMERR_CSP_INVALID_ATTR_INIT_VECTOR1 = -2147415752;

const int CSSMERR_CSP_MISSING_ATTR_INIT_VECTOR1 = -2147415751;

const int CSSMERR_CSP_INVALID_ATTR_SALT1 = -2147415750;

const int CSSMERR_CSP_MISSING_ATTR_SALT1 = -2147415749;

const int CSSMERR_CSP_INVALID_ATTR_PADDING1 = -2147415748;

const int CSSMERR_CSP_MISSING_ATTR_PADDING1 = -2147415747;

const int CSSMERR_CSP_INVALID_ATTR_RANDOM1 = -2147415746;

const int CSSMERR_CSP_MISSING_ATTR_RANDOM1 = -2147415745;

const int CSSMERR_CSP_INVALID_ATTR_SEED1 = -2147415744;

const int CSSMERR_CSP_MISSING_ATTR_SEED1 = -2147415743;

const int CSSMERR_CSP_INVALID_ATTR_PASSPHRASE1 = -2147415742;

const int CSSMERR_CSP_MISSING_ATTR_PASSPHRASE1 = -2147415741;

const int CSSMERR_CSP_INVALID_ATTR_KEY_LENGTH1 = -2147415740;

const int CSSMERR_CSP_MISSING_ATTR_KEY_LENGTH1 = -2147415739;

const int CSSMERR_CSP_INVALID_ATTR_BLOCK_SIZE1 = -2147415738;

const int CSSMERR_CSP_MISSING_ATTR_BLOCK_SIZE1 = -2147415737;

const int CSSMERR_CSP_INVALID_ATTR_OUTPUT_SIZE1 = -2147415708;

const int CSSMERR_CSP_MISSING_ATTR_OUTPUT_SIZE1 = -2147415707;

const int CSSMERR_CSP_INVALID_ATTR_ROUNDS1 = -2147415706;

const int CSSMERR_CSP_MISSING_ATTR_ROUNDS1 = -2147415705;

const int CSSMERR_CSP_INVALID_ATTR_ALG_PARAMS1 = -2147415704;

const int CSSMERR_CSP_MISSING_ATTR_ALG_PARAMS1 = -2147415703;

const int CSSMERR_CSP_INVALID_ATTR_LABEL1 = -2147415702;

const int CSSMERR_CSP_MISSING_ATTR_LABEL1 = -2147415701;

const int CSSMERR_CSP_INVALID_ATTR_KEY_TYPE1 = -2147415700;

const int CSSMERR_CSP_MISSING_ATTR_KEY_TYPE1 = -2147415699;

const int CSSMERR_CSP_INVALID_ATTR_MODE1 = -2147415698;

const int CSSMERR_CSP_MISSING_ATTR_MODE1 = -2147415697;

const int CSSMERR_CSP_INVALID_ATTR_EFFECTIVE_BITS1 = -2147415696;

const int CSSMERR_CSP_MISSING_ATTR_EFFECTIVE_BITS1 = -2147415695;

const int CSSMERR_CSP_INVALID_ATTR_START_DATE1 = -2147415694;

const int CSSMERR_CSP_MISSING_ATTR_START_DATE1 = -2147415693;

const int CSSMERR_CSP_INVALID_ATTR_END_DATE1 = -2147415692;

const int CSSMERR_CSP_MISSING_ATTR_END_DATE1 = -2147415691;

const int CSSMERR_CSP_INVALID_ATTR_VERSION1 = -2147415690;

const int CSSMERR_CSP_MISSING_ATTR_VERSION1 = -2147415689;

const int CSSMERR_CSP_INVALID_ATTR_PRIME1 = -2147415688;

const int CSSMERR_CSP_MISSING_ATTR_PRIME1 = -2147415687;

const int CSSMERR_CSP_INVALID_ATTR_BASE1 = -2147415686;

const int CSSMERR_CSP_MISSING_ATTR_BASE1 = -2147415685;

const int CSSMERR_CSP_INVALID_ATTR_SUBPRIME1 = -2147415684;

const int CSSMERR_CSP_MISSING_ATTR_SUBPRIME1 = -2147415683;

const int CSSMERR_CSP_INVALID_ATTR_ITERATION_COUNT1 = -2147415682;

const int CSSMERR_CSP_MISSING_ATTR_ITERATION_COUNT1 = -2147415681;

const int CSSMERR_CSP_INVALID_ATTR_DL_DB_HANDLE1 = -2147415680;

const int CSSMERR_CSP_MISSING_ATTR_DL_DB_HANDLE1 = -2147415679;

const int CSSMERR_CSP_INVALID_ATTR_ACCESS_CREDENTIALS1 = -2147415678;

const int CSSMERR_CSP_MISSING_ATTR_ACCESS_CREDENTIALS1 = -2147415677;

const int CSSMERR_CSP_INVALID_ATTR_PUBLIC_KEY_FORMAT1 = -2147415676;

const int CSSMERR_CSP_MISSING_ATTR_PUBLIC_KEY_FORMAT1 = -2147415675;

const int CSSMERR_CSP_INVALID_ATTR_PRIVATE_KEY_FORMAT1 = -2147415674;

const int CSSMERR_CSP_MISSING_ATTR_PRIVATE_KEY_FORMAT1 = -2147415673;

const int CSSMERR_CSP_INVALID_ATTR_SYMMETRIC_KEY_FORMAT1 = -2147415672;

const int CSSMERR_CSP_MISSING_ATTR_SYMMETRIC_KEY_FORMAT1 = -2147415671;

const int CSSMERR_CSP_INVALID_ATTR_WRAPPED_KEY_FORMAT1 = -2147415670;

const int CSSMERR_CSP_MISSING_ATTR_WRAPPED_KEY_FORMAT1 = -2147415669;

const int CSSMERR_CSP_STAGED_OPERATION_IN_PROGRESS1 = -2147415736;

const int CSSMERR_CSP_STAGED_OPERATION_NOT_STARTED1 = -2147415735;

const int CSSMERR_CSP_VERIFY_FAILED1 = -2147415734;

const int CSSMERR_CSP_INVALID_SIGNATURE1 = -2147415733;

const int CSSMERR_CSP_QUERY_SIZE_UNKNOWN1 = -2147415732;

const int CSSMERR_CSP_BLOCK_SIZE_MISMATCH1 = -2147415731;

const int CSSMERR_CSP_PRIVATE_KEY_NOT_FOUND1 = -2147415730;

const int CSSMERR_CSP_PUBLIC_KEY_INCONSISTENT1 = -2147415729;

const int CSSMERR_CSP_DEVICE_VERIFY_FAILED1 = -2147415728;

const int CSSMERR_CSP_INVALID_LOGIN_NAME1 = -2147415727;

const int CSSMERR_CSP_ALREADY_LOGGED_IN1 = -2147415726;

const int CSSMERR_CSP_PRIVATE_KEY_ALREADY_EXISTS1 = -2147415725;

const int CSSMERR_CSP_KEY_LABEL_ALREADY_EXISTS1 = -2147415724;

const int CSSMERR_CSP_INVALID_DIGEST_ALGORITHM1 = -2147415723;

const int CSSMERR_CSP_CRYPTO_DATA_CALLBACK_FAILED1 = -2147415722;

const int CSSMERR_TP_INTERNAL_ERROR1 = -2147409919;

const int CSSMERR_TP_MEMORY_ERROR1 = -2147409918;

const int CSSMERR_TP_MDS_ERROR1 = -2147409917;

const int CSSMERR_TP_INVALID_POINTER1 = -2147409916;

const int CSSMERR_TP_INVALID_INPUT_POINTER1 = -2147409915;

const int CSSMERR_TP_INVALID_OUTPUT_POINTER1 = -2147409914;

const int CSSMERR_TP_FUNCTION_NOT_IMPLEMENTED1 = -2147409913;

const int CSSMERR_TP_SELF_CHECK_FAILED1 = -2147409912;

const int CSSMERR_TP_OS_ACCESS_DENIED1 = -2147409911;

const int CSSMERR_TP_FUNCTION_FAILED1 = -2147409910;

const int CSSMERR_TP_INVALID_CONTEXT_HANDLE1 = -2147409856;

const int CSSMERR_TP_INVALID_DATA1 = -2147409850;

const int CSSMERR_TP_INVALID_DB_LIST1 = -2147409844;

const int CSSMERR_TP_INVALID_CERTGROUP_POINTER1 = -2147409854;

const int CSSMERR_TP_INVALID_CERT_POINTER1 = -2147409853;

const int CSSMERR_TP_INVALID_CRL_POINTER1 = -2147409852;

const int CSSMERR_TP_INVALID_FIELD_POINTER1 = -2147409851;

const int CSSMERR_TP_INVALID_NETWORK_ADDR1 = -2147409833;

const int CSSMERR_TP_CRL_ALREADY_SIGNED1 = -2147409849;

const int CSSMERR_TP_INVALID_NUMBER_OF_FIELDS1 = -2147409848;

const int CSSMERR_TP_VERIFICATION_FAILURE1 = -2147409847;

const int CSSMERR_TP_INVALID_DB_HANDLE1 = -2147409846;

const int CSSMERR_TP_UNKNOWN_FORMAT1 = -2147409842;

const int CSSMERR_TP_UNKNOWN_TAG1 = -2147409841;

const int CSSMERR_TP_INVALID_PASSTHROUGH_ID1 = -2147409834;

const int CSSMERR_TP_INVALID_CSP_HANDLE1 = -2147409840;

const int CSSMERR_TP_INVALID_DL_HANDLE1 = -2147409839;

const int CSSMERR_TP_INVALID_CL_HANDLE1 = -2147409838;

const int CSSMERR_TP_INVALID_DB_LIST_POINTER1 = -2147409843;

const int CSSM_TP_BASE_TP_ERROR1 = -2147409664;

const int CSSMERR_TP_INVALID_CALLERAUTH_CONTEXT_POINTER1 = -2147409663;

const int CSSMERR_TP_INVALID_IDENTIFIER_POINTER1 = -2147409662;

const int CSSMERR_TP_INVALID_KEYCACHE_HANDLE1 = -2147409661;

const int CSSMERR_TP_INVALID_CERTGROUP1 = -2147409660;

const int CSSMERR_TP_INVALID_CRLGROUP1 = -2147409659;

const int CSSMERR_TP_INVALID_CRLGROUP_POINTER1 = -2147409658;

const int CSSMERR_TP_AUTHENTICATION_FAILED1 = -2147409657;

const int CSSMERR_TP_CERTGROUP_INCOMPLETE1 = -2147409656;

const int CSSMERR_TP_CERTIFICATE_CANT_OPERATE1 = -2147409655;

const int CSSMERR_TP_CERT_EXPIRED1 = -2147409654;

const int CSSMERR_TP_CERT_NOT_VALID_YET1 = -2147409653;

const int CSSMERR_TP_CERT_REVOKED1 = -2147409652;

const int CSSMERR_TP_CERT_SUSPENDED1 = -2147409651;

const int CSSMERR_TP_INSUFFICIENT_CREDENTIALS1 = -2147409650;

const int CSSMERR_TP_INVALID_ACTION1 = -2147409649;

const int CSSMERR_TP_INVALID_ACTION_DATA1 = -2147409648;

const int CSSMERR_TP_INVALID_ANCHOR_CERT1 = -2147409646;

const int CSSMERR_TP_INVALID_AUTHORITY1 = -2147409645;

const int CSSMERR_TP_VERIFY_ACTION_FAILED1 = -2147409644;

const int CSSMERR_TP_INVALID_CERTIFICATE1 = -2147409643;

const int CSSMERR_TP_INVALID_CERT_AUTHORITY1 = -2147409642;

const int CSSMERR_TP_INVALID_CRL_AUTHORITY1 = -2147409641;

const int CSSMERR_TP_INVALID_CRL_ENCODING1 = -2147409640;

const int CSSMERR_TP_INVALID_CRL_TYPE1 = -2147409639;

const int CSSMERR_TP_INVALID_CRL1 = -2147409638;

const int CSSMERR_TP_INVALID_FORM_TYPE1 = -2147409637;

const int CSSMERR_TP_INVALID_ID1 = -2147409636;

const int CSSMERR_TP_INVALID_IDENTIFIER1 = -2147409635;

const int CSSMERR_TP_INVALID_INDEX1 = -2147409634;

const int CSSMERR_TP_INVALID_NAME1 = -2147409633;

const int CSSMERR_TP_INVALID_POLICY_IDENTIFIERS1 = -2147409632;

const int CSSMERR_TP_INVALID_TIMESTRING1 = -2147409631;

const int CSSMERR_TP_INVALID_REASON1 = -2147409630;

const int CSSMERR_TP_INVALID_REQUEST_INPUTS1 = -2147409629;

const int CSSMERR_TP_INVALID_RESPONSE_VECTOR1 = -2147409628;

const int CSSMERR_TP_INVALID_SIGNATURE1 = -2147409627;

const int CSSMERR_TP_INVALID_STOP_ON_POLICY1 = -2147409626;

const int CSSMERR_TP_INVALID_CALLBACK1 = -2147409625;

const int CSSMERR_TP_INVALID_TUPLE1 = -2147409624;

const int CSSMERR_TP_NOT_SIGNER1 = -2147409623;

const int CSSMERR_TP_NOT_TRUSTED1 = -2147409622;

const int CSSMERR_TP_NO_DEFAULT_AUTHORITY1 = -2147409621;

const int CSSMERR_TP_REJECTED_FORM1 = -2147409620;

const int CSSMERR_TP_REQUEST_LOST1 = -2147409619;

const int CSSMERR_TP_REQUEST_REJECTED1 = -2147409618;

const int CSSMERR_TP_UNSUPPORTED_ADDR_TYPE1 = -2147409617;

const int CSSMERR_TP_UNSUPPORTED_SERVICE1 = -2147409616;

const int CSSMERR_TP_INVALID_TUPLEGROUP_POINTER1 = -2147409615;

const int CSSMERR_TP_INVALID_TUPLEGROUP1 = -2147409614;

const int CSSMERR_AC_INTERNAL_ERROR1 = -2147405823;

const int CSSMERR_AC_MEMORY_ERROR1 = -2147405822;

const int CSSMERR_AC_MDS_ERROR1 = -2147405821;

const int CSSMERR_AC_INVALID_POINTER1 = -2147405820;

const int CSSMERR_AC_INVALID_INPUT_POINTER1 = -2147405819;

const int CSSMERR_AC_INVALID_OUTPUT_POINTER1 = -2147405818;

const int CSSMERR_AC_FUNCTION_NOT_IMPLEMENTED1 = -2147405817;

const int CSSMERR_AC_SELF_CHECK_FAILED1 = -2147405816;

const int CSSMERR_AC_OS_ACCESS_DENIED1 = -2147405815;

const int CSSMERR_AC_FUNCTION_FAILED1 = -2147405814;

const int CSSMERR_AC_INVALID_CONTEXT_HANDLE1 = -2147405760;

const int CSSMERR_AC_INVALID_DATA1 = -2147405754;

const int CSSMERR_AC_INVALID_DB_LIST1 = -2147405748;

const int CSSMERR_AC_INVALID_PASSTHROUGH_ID1 = -2147405738;

const int CSSMERR_AC_INVALID_DL_HANDLE1 = -2147405743;

const int CSSMERR_AC_INVALID_CL_HANDLE1 = -2147405742;

const int CSSMERR_AC_INVALID_TP_HANDLE1 = -2147405741;

const int CSSMERR_AC_INVALID_DB_HANDLE1 = -2147405750;

const int CSSMERR_AC_INVALID_DB_LIST_POINTER1 = -2147405747;

const int CSSM_AC_BASE_AC_ERROR1 = -2147405568;

const int CSSMERR_AC_INVALID_BASE_ACLS1 = -2147405567;

const int CSSMERR_AC_INVALID_TUPLE_CREDENTIALS1 = -2147405566;

const int CSSMERR_AC_INVALID_ENCODING1 = -2147405565;

const int CSSMERR_AC_INVALID_VALIDITY_PERIOD1 = -2147405564;

const int CSSMERR_AC_INVALID_REQUESTOR1 = -2147405563;

const int CSSMERR_AC_INVALID_REQUEST_DESCRIPTOR1 = -2147405562;

const int CSSMERR_CL_INTERNAL_ERROR1 = -2147411967;

const int CSSMERR_CL_MEMORY_ERROR1 = -2147411966;

const int CSSMERR_CL_MDS_ERROR1 = -2147411965;

const int CSSMERR_CL_INVALID_POINTER1 = -2147411964;

const int CSSMERR_CL_INVALID_INPUT_POINTER1 = -2147411963;

const int CSSMERR_CL_INVALID_OUTPUT_POINTER1 = -2147411962;

const int CSSMERR_CL_FUNCTION_NOT_IMPLEMENTED1 = -2147411961;

const int CSSMERR_CL_SELF_CHECK_FAILED1 = -2147411960;

const int CSSMERR_CL_OS_ACCESS_DENIED1 = -2147411959;

const int CSSMERR_CL_FUNCTION_FAILED1 = -2147411958;

const int CSSMERR_CL_INVALID_CONTEXT_HANDLE1 = -2147411904;

const int CSSMERR_CL_INVALID_CERTGROUP_POINTER1 = -2147411902;

const int CSSMERR_CL_INVALID_CERT_POINTER1 = -2147411901;

const int CSSMERR_CL_INVALID_CRL_POINTER1 = -2147411900;

const int CSSMERR_CL_INVALID_FIELD_POINTER1 = -2147411899;

const int CSSMERR_CL_INVALID_DATA1 = -2147411898;

const int CSSMERR_CL_CRL_ALREADY_SIGNED1 = -2147411897;

const int CSSMERR_CL_INVALID_NUMBER_OF_FIELDS1 = -2147411896;

const int CSSMERR_CL_VERIFICATION_FAILURE1 = -2147411895;

const int CSSMERR_CL_UNKNOWN_FORMAT1 = -2147411890;

const int CSSMERR_CL_UNKNOWN_TAG1 = -2147411889;

const int CSSMERR_CL_INVALID_PASSTHROUGH_ID1 = -2147411882;

const int CSSM_CL_BASE_CL_ERROR1 = -2147411712;

const int CSSMERR_CL_INVALID_BUNDLE_POINTER1 = -2147411711;

const int CSSMERR_CL_INVALID_CACHE_HANDLE1 = -2147411710;

const int CSSMERR_CL_INVALID_RESULTS_HANDLE1 = -2147411709;

const int CSSMERR_CL_INVALID_BUNDLE_INFO1 = -2147411708;

const int CSSMERR_CL_INVALID_CRL_INDEX1 = -2147411707;

const int CSSMERR_CL_INVALID_SCOPE1 = -2147411706;

const int CSSMERR_CL_NO_FIELD_VALUES1 = -2147411705;

const int CSSMERR_CL_SCOPE_NOT_SUPPORTED1 = -2147411704;

const int CSSMERR_DL_INTERNAL_ERROR1 = -2147414015;

const int CSSMERR_DL_MEMORY_ERROR1 = -2147414014;

const int CSSMERR_DL_MDS_ERROR1 = -2147414013;

const int CSSMERR_DL_INVALID_POINTER1 = -2147414012;

const int CSSMERR_DL_INVALID_INPUT_POINTER1 = -2147414011;

const int CSSMERR_DL_INVALID_OUTPUT_POINTER1 = -2147414010;

const int CSSMERR_DL_FUNCTION_NOT_IMPLEMENTED1 = -2147414009;

const int CSSMERR_DL_SELF_CHECK_FAILED1 = -2147414008;

const int CSSMERR_DL_OS_ACCESS_DENIED1 = -2147414007;

const int CSSMERR_DL_FUNCTION_FAILED1 = -2147414006;

const int CSSMERR_DL_INVALID_CSP_HANDLE1 = -2147413936;

const int CSSMERR_DL_INVALID_DL_HANDLE1 = -2147413935;

const int CSSMERR_DL_INVALID_CL_HANDLE1 = -2147413934;

const int CSSMERR_DL_INVALID_DB_LIST_POINTER1 = -2147413939;

const int CSSMERR_DL_OPERATION_AUTH_DENIED1 = -2147413984;

const int CSSMERR_DL_OBJECT_USE_AUTH_DENIED1 = -2147413983;

const int CSSMERR_DL_OBJECT_MANIP_AUTH_DENIED1 = -2147413982;

const int CSSMERR_DL_OBJECT_ACL_NOT_SUPPORTED1 = -2147413981;

const int CSSMERR_DL_OBJECT_ACL_REQUIRED1 = -2147413980;

const int CSSMERR_DL_INVALID_ACCESS_CREDENTIALS1 = -2147413979;

const int CSSMERR_DL_INVALID_ACL_BASE_CERTS1 = -2147413978;

const int CSSMERR_DL_ACL_BASE_CERTS_NOT_SUPPORTED1 = -2147413977;

const int CSSMERR_DL_INVALID_SAMPLE_VALUE1 = -2147413976;

const int CSSMERR_DL_SAMPLE_VALUE_NOT_SUPPORTED1 = -2147413975;

const int CSSMERR_DL_INVALID_ACL_SUBJECT_VALUE1 = -2147413974;

const int CSSMERR_DL_ACL_SUBJECT_TYPE_NOT_SUPPORTED1 = -2147413973;

const int CSSMERR_DL_INVALID_ACL_CHALLENGE_CALLBACK1 = -2147413972;

const int CSSMERR_DL_ACL_CHALLENGE_CALLBACK_FAILED1 = -2147413971;

const int CSSMERR_DL_INVALID_ACL_ENTRY_TAG1 = -2147413970;

const int CSSMERR_DL_ACL_ENTRY_TAG_NOT_FOUND1 = -2147413969;

const int CSSMERR_DL_INVALID_ACL_EDIT_MODE1 = -2147413968;

const int CSSMERR_DL_ACL_CHANGE_FAILED1 = -2147413967;

const int CSSMERR_DL_INVALID_NEW_ACL_ENTRY1 = -2147413966;

const int CSSMERR_DL_INVALID_NEW_ACL_OWNER1 = -2147413965;

const int CSSMERR_DL_ACL_DELETE_FAILED1 = -2147413964;

const int CSSMERR_DL_ACL_REPLACE_FAILED1 = -2147413963;

const int CSSMERR_DL_ACL_ADD_FAILED1 = -2147413962;

const int CSSMERR_DL_INVALID_DB_HANDLE1 = -2147413942;

const int CSSMERR_DL_INVALID_PASSTHROUGH_ID1 = -2147413930;

const int CSSMERR_DL_INVALID_NETWORK_ADDR1 = -2147413929;

const int CSSM_DL_BASE_DL_ERROR1 = -2147413760;

const int CSSMERR_DL_DATABASE_CORRUPT1 = -2147413759;

const int CSSMERR_DL_INVALID_RECORD_INDEX1 = -2147413752;

const int CSSMERR_DL_INVALID_RECORDTYPE1 = -2147413751;

const int CSSMERR_DL_INVALID_FIELD_NAME1 = -2147413750;

const int CSSMERR_DL_UNSUPPORTED_FIELD_FORMAT1 = -2147413749;

const int CSSMERR_DL_UNSUPPORTED_INDEX_INFO1 = -2147413748;

const int CSSMERR_DL_UNSUPPORTED_LOCALITY1 = -2147413747;

const int CSSMERR_DL_UNSUPPORTED_NUM_ATTRIBUTES1 = -2147413746;

const int CSSMERR_DL_UNSUPPORTED_NUM_INDEXES1 = -2147413745;

const int CSSMERR_DL_UNSUPPORTED_NUM_RECORDTYPES1 = -2147413744;

const int CSSMERR_DL_UNSUPPORTED_RECORDTYPE1 = -2147413743;

const int CSSMERR_DL_FIELD_SPECIFIED_MULTIPLE1 = -2147413742;

const int CSSMERR_DL_INCOMPATIBLE_FIELD_FORMAT1 = -2147413741;

const int CSSMERR_DL_INVALID_PARSING_MODULE1 = -2147413740;

const int CSSMERR_DL_INVALID_DB_NAME1 = -2147413738;

const int CSSMERR_DL_DATASTORE_DOESNOT_EXIST1 = -2147413737;

const int CSSMERR_DL_DATASTORE_ALREADY_EXISTS1 = -2147413736;

const int CSSMERR_DL_DB_LOCKED1 = -2147413735;

const int CSSMERR_DL_DATASTORE_IS_OPEN1 = -2147413734;

const int CSSMERR_DL_RECORD_NOT_FOUND1 = -2147413733;

const int CSSMERR_DL_MISSING_VALUE1 = -2147413732;

const int CSSMERR_DL_UNSUPPORTED_QUERY1 = -2147413731;

const int CSSMERR_DL_UNSUPPORTED_QUERY_LIMITS1 = -2147413730;

const int CSSMERR_DL_UNSUPPORTED_NUM_SELECTION_PREDS1 = -2147413729;

const int CSSMERR_DL_UNSUPPORTED_OPERATOR1 = -2147413727;

const int CSSMERR_DL_INVALID_RESULTS_HANDLE1 = -2147413726;

const int CSSMERR_DL_INVALID_DB_LOCATION1 = -2147413725;

const int CSSMERR_DL_INVALID_ACCESS_REQUEST1 = -2147413724;

const int CSSMERR_DL_INVALID_INDEX_INFO1 = -2147413723;

const int CSSMERR_DL_INVALID_SELECTION_TAG1 = -2147413722;

const int CSSMERR_DL_INVALID_NEW_OWNER1 = -2147413721;

const int CSSMERR_DL_INVALID_RECORD_UID1 = -2147413720;

const int CSSMERR_DL_INVALID_UNIQUE_INDEX_DATA1 = -2147413719;

const int CSSMERR_DL_INVALID_MODIFY_MODE1 = -2147413718;

const int CSSMERR_DL_INVALID_OPEN_PARAMETERS1 = -2147413717;

const int CSSMERR_DL_RECORD_MODIFIED1 = -2147413716;

const int CSSMERR_DL_ENDOFDATA1 = -2147413715;

const int CSSMERR_DL_INVALID_QUERY1 = -2147413714;

const int CSSMERR_DL_INVALID_VALUE1 = -2147413713;

const int CSSMERR_DL_MULTIPLE_VALUES_UNSUPPORTED1 = -2147413712;

const int CSSMERR_DL_STALE_UNIQUE_RECORD1 = -2147413711;

const int CSSM_WORDID_KEYCHAIN_PROMPT1 = 65536;

const int CSSM_WORDID_KEYCHAIN_LOCK1 = 65537;

const int CSSM_WORDID_KEYCHAIN_CHANGE_LOCK1 = 65538;

const int CSSM_WORDID_PROCESS1 = 65539;

const int CSSM_WORDID__RESERVED_11 = 65540;

const int CSSM_WORDID_SYMMETRIC_KEY1 = 65541;

const int CSSM_WORDID_SYSTEM1 = 65542;

const int CSSM_WORDID_KEY1 = 65543;

const int CSSM_WORDID_PIN1 = 65544;

const int CSSM_WORDID_PREAUTH1 = 65545;

const int CSSM_WORDID_PREAUTH_SOURCE1 = 65546;

const int CSSM_WORDID_ASYMMETRIC_KEY1 = 65547;

const int CSSM_WORDID_PARTITION1 = 65548;

const int CSSM_WORDID_KEYBAG_KEY1 = 65549;

const int CSSM_WORDID__FIRST_UNUSED1 = 65550;

const int CSSM_ACL_SUBJECT_TYPE_KEYCHAIN_PROMPT1 = 65536;

const int CSSM_ACL_SUBJECT_TYPE_PROCESS1 = 65539;

const int CSSM_ACL_SUBJECT_TYPE_CODE_SIGNATURE1 = 116;

const int CSSM_ACL_SUBJECT_TYPE_COMMENT1 = 12;

const int CSSM_ACL_SUBJECT_TYPE_SYMMETRIC_KEY1 = 65541;

const int CSSM_ACL_SUBJECT_TYPE_PREAUTH1 = 65545;

const int CSSM_ACL_SUBJECT_TYPE_PREAUTH_SOURCE1 = 65546;

const int CSSM_ACL_SUBJECT_TYPE_ASYMMETRIC_KEY1 = 65547;

const int CSSM_ACL_SUBJECT_TYPE_PARTITION1 = 65548;

const int CSSM_SAMPLE_TYPE_KEYCHAIN_PROMPT1 = 65536;

const int CSSM_SAMPLE_TYPE_KEYCHAIN_LOCK1 = 65537;

const int CSSM_SAMPLE_TYPE_KEYCHAIN_CHANGE_LOCK1 = 65538;

const int CSSM_SAMPLE_TYPE_PROCESS1 = 65539;

const int CSSM_SAMPLE_TYPE_COMMENT1 = 12;

const int CSSM_SAMPLE_TYPE_RETRY_ID1 = 85;

const int CSSM_SAMPLE_TYPE_SYMMETRIC_KEY1 = 65541;

const int CSSM_SAMPLE_TYPE_PREAUTH1 = 65545;

const int CSSM_SAMPLE_TYPE_ASYMMETRIC_KEY1 = 65547;

const int CSSM_SAMPLE_TYPE_KEYBAG_KEY1 = 65549;

const int CSSM_ACL_AUTHORIZATION_CHANGE_ACL1 = 65536;

const int CSSM_ACL_AUTHORIZATION_CHANGE_OWNER1 = 65537;

const int CSSM_ACL_AUTHORIZATION_PARTITION_ID1 = 65538;

const int CSSM_ACL_AUTHORIZATION_INTEGRITY1 = 65539;

const int CSSM_ACL_AUTHORIZATION_PREAUTH_BASE1 = 16842752;

const int CSSM_ACL_AUTHORIZATION_PREAUTH_END1 = 16908288;

const int CSSM_ACL_CODE_SIGNATURE_INVALID1 = 0;

const int CSSM_ACL_CODE_SIGNATURE_OSX1 = 1;

const int CSSM_ACL_MATCH_UID1 = 1;

const int CSSM_ACL_MATCH_GID1 = 2;

const int CSSM_ACL_MATCH_HONOR_ROOT1 = 256;

const int CSSM_ACL_MATCH_BITS1 = 3;

const int CSSM_ACL_PROCESS_SELECTOR_CURRENT_VERSION1 = 257;

const int CSSM_ACL_KEYCHAIN_PROMPT_CURRENT_VERSION1 = 257;

const int CSSM_ACL_KEYCHAIN_PROMPT_REQUIRE_PASSPHRASE1 = 1;

const int CSSM_ACL_KEYCHAIN_PROMPT_UNSIGNED1 = 16;

const int CSSM_ACL_KEYCHAIN_PROMPT_UNSIGNED_ACT1 = 32;

const int CSSM_ACL_KEYCHAIN_PROMPT_INVALID1 = 64;

const int CSSM_ACL_KEYCHAIN_PROMPT_INVALID_ACT1 = 128;

const int CSSM_ACL_PREAUTH_TRACKING_COUNT_MASK1 = 255;

const int CSSM_ACL_PREAUTH_TRACKING_BLOCKED1 = 0;

const int CSSM_ACL_PREAUTH_TRACKING_UNKNOWN1 = 1073741824;

const int CSSM_ACL_PREAUTH_TRACKING_AUTHORIZED1 = -2147483648;

const int CSSM_DB_ACCESS_RESET1 = 65536;

const int CSSM_ALGID_APPLE_YARROW1 = -2147483648;

const int CSSM_ALGID_AES1 = -2147483647;

const int CSSM_ALGID_FEE1 = -2147483646;

const int CSSM_ALGID_FEE_MD51 = -2147483645;

const int CSSM_ALGID_FEE_SHA11 = -2147483644;

const int CSSM_ALGID_FEED1 = -2147483643;

const int CSSM_ALGID_FEEDEXP1 = -2147483642;

const int CSSM_ALGID_ASC1 = -2147483641;

const int CSSM_ALGID_SHA1HMAC_LEGACY1 = -2147483640;

const int CSSM_ALGID_KEYCHAIN_KEY1 = -2147483639;

const int CSSM_ALGID_PKCS12_PBE_ENCR1 = -2147483638;

const int CSSM_ALGID_PKCS12_PBE_MAC1 = -2147483637;

const int CSSM_ALGID_SECURE_PASSPHRASE1 = -2147483636;

const int CSSM_ALGID_PBE_OPENSSL_MD51 = -2147483635;

const int CSSM_ALGID_SHA2561 = -2147483634;

const int CSSM_ALGID_SHA3841 = -2147483633;

const int CSSM_ALGID_SHA5121 = -2147483632;

const int CSSM_ALGID_ENTROPY_DEFAULT1 = -2147483631;

const int CSSM_ALGID_SHA2241 = -2147483630;

const int CSSM_ALGID_SHA224WithRSA1 = -2147483629;

const int CSSM_ALGID_SHA256WithRSA1 = -2147483628;

const int CSSM_ALGID_SHA384WithRSA1 = -2147483627;

const int CSSM_ALGID_SHA512WithRSA1 = -2147483626;

const int CSSM_ALGID_OPENSSH11 = -2147483625;

const int CSSM_ALGID_SHA224WithECDSA1 = -2147483624;

const int CSSM_ALGID_SHA256WithECDSA1 = -2147483623;

const int CSSM_ALGID_SHA384WithECDSA1 = -2147483622;

const int CSSM_ALGID_SHA512WithECDSA1 = -2147483621;

const int CSSM_ALGID_ECDSA_SPECIFIED1 = -2147483620;

const int CSSM_ALGID_ECDH_X963_KDF1 = -2147483619;

const int CSSM_ALGID__FIRST_UNUSED1 = -2147483618;

const int CSSM_PADDING_APPLE_SSLv21 = -2147483648;

const int CSSM_KEYBLOB_RAW_FORMAT_VENDOR_DEFINED1 = -2147483648;

const int CSSM_KEYBLOB_RAW_FORMAT_X5091 = -2147483648;

const int CSSM_KEYBLOB_RAW_FORMAT_OPENSSH1 = -2147483647;

const int CSSM_KEYBLOB_RAW_FORMAT_OPENSSL1 = -2147483646;

const int CSSM_KEYBLOB_RAW_FORMAT_OPENSSH21 = -2147483645;

const int CSSM_CUSTOM_COMMON_ERROR_EXTENT1 = 224;

const int CSSM_ERRCODE_NO_USER_INTERACTION1 = 224;

const int CSSM_ERRCODE_USER_CANCELED1 = 225;

const int CSSM_ERRCODE_SERVICE_NOT_AVAILABLE1 = 226;

const int CSSM_ERRCODE_INSUFFICIENT_CLIENT_IDENTIFICATION1 = 227;

const int CSSM_ERRCODE_DEVICE_RESET1 = 228;

const int CSSM_ERRCODE_DEVICE_FAILED1 = 229;

const int CSSM_ERRCODE_IN_DARK_WAKE1 = 230;

const int CSSMERR_CSSM_NO_USER_INTERACTION1 = -2147417888;

const int CSSMERR_AC_NO_USER_INTERACTION1 = -2147405600;

const int CSSMERR_CSP_NO_USER_INTERACTION1 = -2147415840;

const int CSSMERR_CL_NO_USER_INTERACTION1 = -2147411744;

const int CSSMERR_DL_NO_USER_INTERACTION1 = -2147413792;

const int CSSMERR_TP_NO_USER_INTERACTION1 = -2147409696;

const int CSSMERR_CSSM_USER_CANCELED1 = -2147417887;

const int CSSMERR_AC_USER_CANCELED1 = -2147405599;

const int CSSMERR_CSP_USER_CANCELED1 = -2147415839;

const int CSSMERR_CL_USER_CANCELED1 = -2147411743;

const int CSSMERR_DL_USER_CANCELED1 = -2147413791;

const int CSSMERR_TP_USER_CANCELED1 = -2147409695;

const int CSSMERR_CSSM_SERVICE_NOT_AVAILABLE1 = -2147417886;

const int CSSMERR_AC_SERVICE_NOT_AVAILABLE1 = -2147405598;

const int CSSMERR_CSP_SERVICE_NOT_AVAILABLE1 = -2147415838;

const int CSSMERR_CL_SERVICE_NOT_AVAILABLE1 = -2147411742;

const int CSSMERR_DL_SERVICE_NOT_AVAILABLE1 = -2147413790;

const int CSSMERR_TP_SERVICE_NOT_AVAILABLE1 = -2147409694;

const int CSSMERR_CSSM_INSUFFICIENT_CLIENT_IDENTIFICATION1 = -2147417885;

const int CSSMERR_AC_INSUFFICIENT_CLIENT_IDENTIFICATION1 = -2147405597;

const int CSSMERR_CSP_INSUFFICIENT_CLIENT_IDENTIFICATION1 = -2147415837;

const int CSSMERR_CL_INSUFFICIENT_CLIENT_IDENTIFICATION1 = -2147411741;

const int CSSMERR_DL_INSUFFICIENT_CLIENT_IDENTIFICATION1 = -2147413789;

const int CSSMERR_TP_INSUFFICIENT_CLIENT_IDENTIFICATION1 = -2147409693;

const int CSSMERR_CSSM_DEVICE_RESET1 = -2147417884;

const int CSSMERR_AC_DEVICE_RESET1 = -2147405596;

const int CSSMERR_CSP_DEVICE_RESET1 = -2147415836;

const int CSSMERR_CL_DEVICE_RESET1 = -2147411740;

const int CSSMERR_DL_DEVICE_RESET1 = -2147413788;

const int CSSMERR_TP_DEVICE_RESET1 = -2147409692;

const int CSSMERR_CSSM_DEVICE_FAILED1 = -2147417883;

const int CSSMERR_AC_DEVICE_FAILED1 = -2147405595;

const int CSSMERR_CSP_DEVICE_FAILED1 = -2147415835;

const int CSSMERR_CL_DEVICE_FAILED1 = -2147411739;

const int CSSMERR_DL_DEVICE_FAILED1 = -2147413787;

const int CSSMERR_TP_DEVICE_FAILED1 = -2147409691;

const int CSSMERR_CSSM_IN_DARK_WAKE1 = -2147417882;

const int CSSMERR_AC_IN_DARK_WAKE1 = -2147405594;

const int CSSMERR_CSP_IN_DARK_WAKE1 = -2147415834;

const int CSSMERR_CL_IN_DARK_WAKE1 = -2147411738;

const int CSSMERR_DL_IN_DARK_WAKE1 = -2147413786;

const int CSSMERR_TP_IN_DARK_WAKE1 = -2147409690;

const int CSSMERR_CSP_APPLE_ADD_APPLICATION_ACL_SUBJECT1 = -2147415040;

const int CSSMERR_CSP_APPLE_PUBLIC_KEY_INCOMPLETE1 = -2147415039;

const int CSSMERR_CSP_APPLE_SIGNATURE_MISMATCH1 = -2147415038;

const int CSSMERR_CSP_APPLE_INVALID_KEY_START_DATE1 = -2147415037;

const int CSSMERR_CSP_APPLE_INVALID_KEY_END_DATE1 = -2147415036;

const int CSSMERR_CSPDL_APPLE_DL_CONVERSION_ERROR1 = -2147415035;

const int CSSMERR_CSP_APPLE_SSLv2_ROLLBACK1 = -2147415034;

const int CSSM_DL_DB_RECORD_GENERIC_PASSWORD1 = -2147483648;

const int CSSM_DL_DB_RECORD_INTERNET_PASSWORD1 = -2147483647;

const int CSSM_DL_DB_RECORD_APPLESHARE_PASSWORD1 = -2147483646;

const int CSSM_DL_DB_RECORD_X509_CERTIFICATE1 = -2147479552;

const int CSSM_DL_DB_RECORD_USER_TRUST1 = -2147479551;

const int CSSM_DL_DB_RECORD_X509_CRL1 = -2147479550;

const int CSSM_DL_DB_RECORD_UNLOCK_REFERRAL1 = -2147479549;

const int CSSM_DL_DB_RECORD_EXTENDED_ATTRIBUTE1 = -2147479548;

const int CSSM_DL_DB_RECORD_METADATA1 = -2147450880;

const int CSSM_APPLEFILEDL_TOGGLE_AUTOCOMMIT1 = 0;

const int CSSM_APPLEFILEDL_COMMIT1 = 1;

const int CSSM_APPLEFILEDL_ROLLBACK1 = 2;

const int CSSM_APPLEFILEDL_TAKE_FILE_LOCK1 = 3;

const int CSSM_APPLEFILEDL_MAKE_BACKUP1 = 4;

const int CSSM_APPLEFILEDL_MAKE_COPY1 = 5;

const int CSSM_APPLEFILEDL_DELETE_FILE1 = 6;

const int CSSM_APPLE_UNLOCK_TYPE_KEY_DIRECT1 = 1;

const int CSSM_APPLE_UNLOCK_TYPE_WRAPPED_PRIVATE1 = 2;

const int CSSM_APPLE_UNLOCK_TYPE_KEYBAG1 = 3;

const int CSSMERR_APPLEDL_INVALID_OPEN_PARAMETERS1 = -2147412992;

const int CSSMERR_APPLEDL_DISK_FULL1 = -2147412991;

const int CSSMERR_APPLEDL_QUOTA_EXCEEDED1 = -2147412990;

const int CSSMERR_APPLEDL_FILE_TOO_BIG1 = -2147412989;

const int CSSMERR_APPLEDL_INVALID_DATABASE_BLOB1 = -2147412988;

const int CSSMERR_APPLEDL_INVALID_KEY_BLOB1 = -2147412987;

const int CSSMERR_APPLEDL_INCOMPATIBLE_DATABASE_BLOB1 = -2147412986;

const int CSSMERR_APPLEDL_INCOMPATIBLE_KEY_BLOB1 = -2147412985;

const int CSSMERR_APPLETP_HOSTNAME_MISMATCH1 = -2147408896;

const int CSSMERR_APPLETP_UNKNOWN_CRITICAL_EXTEN1 = -2147408895;

const int CSSMERR_APPLETP_NO_BASIC_CONSTRAINTS1 = -2147408894;

const int CSSMERR_APPLETP_INVALID_CA1 = -2147408893;

const int CSSMERR_APPLETP_INVALID_AUTHORITY_ID1 = -2147408892;

const int CSSMERR_APPLETP_INVALID_SUBJECT_ID1 = -2147408891;

const int CSSMERR_APPLETP_INVALID_KEY_USAGE1 = -2147408890;

const int CSSMERR_APPLETP_INVALID_EXTENDED_KEY_USAGE1 = -2147408889;

const int CSSMERR_APPLETP_INVALID_ID_LINKAGE1 = -2147408888;

const int CSSMERR_APPLETP_PATH_LEN_CONSTRAINT1 = -2147408887;

const int CSSMERR_APPLETP_INVALID_ROOT1 = -2147408886;

const int CSSMERR_APPLETP_CRL_EXPIRED1 = -2147408885;

const int CSSMERR_APPLETP_CRL_NOT_VALID_YET1 = -2147408884;

const int CSSMERR_APPLETP_CRL_NOT_FOUND1 = -2147408883;

const int CSSMERR_APPLETP_CRL_SERVER_DOWN1 = -2147408882;

const int CSSMERR_APPLETP_CRL_BAD_URI1 = -2147408881;

const int CSSMERR_APPLETP_UNKNOWN_CERT_EXTEN1 = -2147408880;

const int CSSMERR_APPLETP_UNKNOWN_CRL_EXTEN1 = -2147408879;

const int CSSMERR_APPLETP_CRL_NOT_TRUSTED1 = -2147408878;

const int CSSMERR_APPLETP_CRL_INVALID_ANCHOR_CERT1 = -2147408877;

const int CSSMERR_APPLETP_CRL_POLICY_FAIL1 = -2147408876;

const int CSSMERR_APPLETP_IDP_FAIL1 = -2147408875;

const int CSSMERR_APPLETP_CERT_NOT_FOUND_FROM_ISSUER1 = -2147408874;

const int CSSMERR_APPLETP_BAD_CERT_FROM_ISSUER1 = -2147408873;

const int CSSMERR_APPLETP_SMIME_EMAIL_ADDRS_NOT_FOUND1 = -2147408872;

const int CSSMERR_APPLETP_SMIME_BAD_EXT_KEY_USE1 = -2147408871;

const int CSSMERR_APPLETP_SMIME_BAD_KEY_USE1 = -2147408870;

const int CSSMERR_APPLETP_SMIME_KEYUSAGE_NOT_CRITICAL1 = -2147408869;

const int CSSMERR_APPLETP_SMIME_NO_EMAIL_ADDRS1 = -2147408868;

const int CSSMERR_APPLETP_SMIME_SUBJ_ALT_NAME_NOT_CRIT1 = -2147408867;

const int CSSMERR_APPLETP_SSL_BAD_EXT_KEY_USE1 = -2147408866;

const int CSSMERR_APPLETP_OCSP_BAD_RESPONSE1 = -2147408865;

const int CSSMERR_APPLETP_OCSP_BAD_REQUEST1 = -2147408864;

const int CSSMERR_APPLETP_OCSP_UNAVAILABLE1 = -2147408863;

const int CSSMERR_APPLETP_OCSP_STATUS_UNRECOGNIZED1 = -2147408862;

const int CSSMERR_APPLETP_INCOMPLETE_REVOCATION_CHECK1 = -2147408861;

const int CSSMERR_APPLETP_NETWORK_FAILURE1 = -2147408860;

const int CSSMERR_APPLETP_OCSP_NOT_TRUSTED1 = -2147408859;

const int CSSMERR_APPLETP_OCSP_INVALID_ANCHOR_CERT1 = -2147408858;

const int CSSMERR_APPLETP_OCSP_SIG_ERROR1 = -2147408857;

const int CSSMERR_APPLETP_OCSP_NO_SIGNER1 = -2147408856;

const int CSSMERR_APPLETP_OCSP_RESP_MALFORMED_REQ1 = -2147408855;

const int CSSMERR_APPLETP_OCSP_RESP_INTERNAL_ERR1 = -2147408854;

const int CSSMERR_APPLETP_OCSP_RESP_TRY_LATER1 = -2147408853;

const int CSSMERR_APPLETP_OCSP_RESP_SIG_REQUIRED1 = -2147408852;

const int CSSMERR_APPLETP_OCSP_RESP_UNAUTHORIZED1 = -2147408851;

const int CSSMERR_APPLETP_OCSP_NONCE_MISMATCH1 = -2147408850;

const int CSSMERR_APPLETP_CS_BAD_CERT_CHAIN_LENGTH1 = -2147408849;

const int CSSMERR_APPLETP_CS_NO_BASIC_CONSTRAINTS1 = -2147408848;

const int CSSMERR_APPLETP_CS_BAD_PATH_LENGTH1 = -2147408847;

const int CSSMERR_APPLETP_CS_NO_EXTENDED_KEY_USAGE1 = -2147408846;

const int CSSMERR_APPLETP_CODE_SIGN_DEVELOPMENT1 = -2147408845;

const int CSSMERR_APPLETP_RS_BAD_CERT_CHAIN_LENGTH1 = -2147408844;

const int CSSMERR_APPLETP_RS_BAD_EXTENDED_KEY_USAGE1 = -2147408843;

const int CSSMERR_APPLETP_TRUST_SETTING_DENY1 = -2147408842;

const int CSSMERR_APPLETP_INVALID_EMPTY_SUBJECT1 = -2147408841;

const int CSSMERR_APPLETP_UNKNOWN_QUAL_CERT_STATEMENT1 = -2147408840;

const int CSSMERR_APPLETP_MISSING_REQUIRED_EXTENSION1 = -2147408839;

const int CSSMERR_APPLETP_EXT_KEYUSAGE_NOT_CRITICAL1 = -2147408838;

const int CSSMERR_APPLETP_IDENTIFIER_MISSING1 = -2147408837;

const int CSSMERR_APPLETP_CA_PIN_MISMATCH1 = -2147408836;

const int CSSMERR_APPLETP_LEAF_PIN_MISMATCH1 = -2147408835;

const int CSSMERR_APPLE_DOTMAC_REQ_QUEUED1 = -2147408796;

const int CSSMERR_APPLE_DOTMAC_REQ_REDIRECT1 = -2147408795;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_ERR1 = -2147408794;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_PARAM1 = -2147408793;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_AUTH1 = -2147408792;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_UNIMPL1 = -2147408791;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_NOT_AVAIL1 = -2147408790;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_ALREADY_EXIST1 = -2147408789;

const int CSSMERR_APPLE_DOTMAC_REQ_SERVER_SERVICE_ERROR1 = -2147408788;

const int CSSMERR_APPLE_DOTMAC_REQ_IS_PENDING1 = -2147408787;

const int CSSMERR_APPLE_DOTMAC_NO_REQ_PENDING1 = -2147408786;

const int CSSMERR_APPLE_DOTMAC_CSR_VERIFY_FAIL1 = -2147408785;

const int CSSMERR_APPLE_DOTMAC_FAILED_CONSISTENCY_CHECK1 = -2147408784;

const int CSSM_APPLEDL_OPEN_PARAMETERS_VERSION1 = 1;

const int CSSM_APPLECSPDL_DB_LOCK1 = 0;

const int CSSM_APPLECSPDL_DB_UNLOCK1 = 1;

const int CSSM_APPLECSPDL_DB_GET_SETTINGS1 = 2;

const int CSSM_APPLECSPDL_DB_SET_SETTINGS1 = 3;

const int CSSM_APPLECSPDL_DB_IS_LOCKED1 = 4;

const int CSSM_APPLECSPDL_DB_CHANGE_PASSWORD1 = 5;

const int CSSM_APPLECSPDL_DB_GET_HANDLE1 = 6;

const int CSSM_APPLESCPDL_CSP_GET_KEYHANDLE1 = 7;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_81 = 8;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_91 = 9;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_101 = 10;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_111 = 11;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_121 = 12;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_131 = 13;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_141 = 14;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_151 = 15;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_161 = 16;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_171 = 17;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_181 = 18;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_191 = 19;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_201 = 20;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_211 = 21;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_221 = 22;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_231 = 23;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_241 = 24;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_251 = 25;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_261 = 26;

const int CSSM_APPLE_PRIVATE_CSPDL_CODE_271 = 27;

const int CSSM_APPLECSP_KEYDIGEST1 = 256;

const int CSSM_APPLECSP_PUBKEY1 = 257;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_APPLE_CUSTOM1 = 100;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_OPENSSL1 = 101;

const int CSSM_KEYBLOB_WRAPPED_FORMAT_OPENSSH11 = 102;

const int CSSM_ATTRIBUTE_VENDOR_DEFINED1 = 8388608;

const int CSSM_ATTRIBUTE_PUBLIC_KEY1 = 1082130432;

const int CSSM_ATTRIBUTE_FEE_PRIME_TYPE1 = 276824065;

const int CSSM_ATTRIBUTE_FEE_CURVE_TYPE1 = 276824066;

const int CSSM_ATTRIBUTE_ASC_OPTIMIZATION1 = 276824067;

const int CSSM_ATTRIBUTE_RSA_BLINDING1 = 276824068;

const int CSSM_ATTRIBUTE_PARAM_KEY1 = 1082130437;

const int CSSM_ATTRIBUTE_PROMPT1 = 545259526;

const int CSSM_ATTRIBUTE_ALERT_TITLE1 = 545259527;

const int CSSM_ATTRIBUTE_VERIFY_PASSPHRASE1 = 276824072;

const int CSSM_FEE_PRIME_TYPE_DEFAULT1 = 0;

const int CSSM_FEE_PRIME_TYPE_MERSENNE1 = 1;

const int CSSM_FEE_PRIME_TYPE_FEE1 = 2;

const int CSSM_FEE_PRIME_TYPE_GENERAL1 = 3;

const int CSSM_FEE_CURVE_TYPE_DEFAULT1 = 0;

const int CSSM_FEE_CURVE_TYPE_MONTGOMERY1 = 1;

const int CSSM_FEE_CURVE_TYPE_WEIERSTRASS1 = 2;

const int CSSM_FEE_CURVE_TYPE_ANSI_X9_621 = 3;

const int CSSM_ASC_OPTIMIZE_DEFAULT1 = 0;

const int CSSM_ASC_OPTIMIZE_SIZE1 = 1;

const int CSSM_ASC_OPTIMIZE_SECURITY1 = 2;

const int CSSM_ASC_OPTIMIZE_TIME1 = 3;

const int CSSM_ASC_OPTIMIZE_TIME_SIZE1 = 4;

const int CSSM_ASC_OPTIMIZE_ASCII1 = 5;

const int CSSM_KEYATTR_PARTIAL1 = 65536;

const int CSSM_KEYATTR_PUBLIC_KEY_ENCRYPT1 = 131072;

const int CSSM_TP_ACTION_REQUIRE_CRL_PER_CERT1 = 1;

const int CSSM_TP_ACTION_FETCH_CRL_FROM_NET1 = 2;

const int CSSM_TP_ACTION_CRL_SUFFICIENT1 = 4;

const int CSSM_TP_ACTION_REQUIRE_CRL_IF_PRESENT1 = 8;

const int CSSM_TP_ACTION_ALLOW_EXPIRED1 = 1;

const int CSSM_TP_ACTION_LEAF_IS_CA1 = 2;

const int CSSM_TP_ACTION_FETCH_CERT_FROM_NET1 = 4;

const int CSSM_TP_ACTION_ALLOW_EXPIRED_ROOT1 = 8;

const int CSSM_TP_ACTION_REQUIRE_REV_PER_CERT1 = 16;

const int CSSM_TP_ACTION_TRUST_SETTINGS1 = 32;

const int CSSM_TP_ACTION_IMPLICIT_ANCHORS1 = 64;

const int CSSM_CERT_STATUS_EXPIRED1 = 1;

const int CSSM_CERT_STATUS_NOT_VALID_YET1 = 2;

const int CSSM_CERT_STATUS_IS_IN_INPUT_CERTS1 = 4;

const int CSSM_CERT_STATUS_IS_IN_ANCHORS1 = 8;

const int CSSM_CERT_STATUS_IS_ROOT1 = 16;

const int CSSM_CERT_STATUS_IS_FROM_NET1 = 32;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_FOUND_USER1 = 64;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_FOUND_ADMIN1 = 128;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_FOUND_SYSTEM1 = 256;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_TRUST1 = 512;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_DENY1 = 1024;

const int CSSM_CERT_STATUS_TRUST_SETTINGS_IGNORED_ERROR1 = 2048;

const int CSSM_EVIDENCE_FORM_APPLE_HEADER1 = -2147483648;

const int CSSM_EVIDENCE_FORM_APPLE_CERTGROUP1 = -2147483647;

const int CSSM_EVIDENCE_FORM_APPLE_CERT_INFO1 = -2147483646;

const int CSSM_APPLEX509CL_OBTAIN_CSR1 = 0;

const int CSSM_APPLEX509CL_VERIFY_CSR1 = 1;

const int kSecSubjectItemAttr1 = 1937072746;

const int kSecIssuerItemAttr1 = 1769173877;

const int kSecSerialNumberItemAttr1 = 1936614002;

const int kSecPublicKeyHashItemAttr1 = 1752198009;

const int kSecSubjectKeyIdentifierItemAttr1 = 1936419172;

const int kSecCertTypeItemAttr1 = 1668577648;

const int kSecCertEncodingItemAttr1 = 1667591779;

const int SSL_NULL_WITH_NULL_NULL1 = 0;

const int SSL_RSA_WITH_NULL_MD51 = 1;

const int SSL_RSA_WITH_NULL_SHA1 = 2;

const int SSL_RSA_EXPORT_WITH_RC4_40_MD51 = 3;

const int SSL_RSA_WITH_RC4_128_MD51 = 4;

const int SSL_RSA_WITH_RC4_128_SHA1 = 5;

const int SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD51 = 6;

const int SSL_RSA_WITH_IDEA_CBC_SHA1 = 7;

const int SSL_RSA_EXPORT_WITH_DES40_CBC_SHA1 = 8;

const int SSL_RSA_WITH_DES_CBC_SHA1 = 9;

const int SSL_RSA_WITH_3DES_EDE_CBC_SHA1 = 10;

const int SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA1 = 11;

const int SSL_DH_DSS_WITH_DES_CBC_SHA1 = 12;

const int SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA1 = 13;

const int SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA1 = 14;

const int SSL_DH_RSA_WITH_DES_CBC_SHA1 = 15;

const int SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA1 = 16;

const int SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA1 = 17;

const int SSL_DHE_DSS_WITH_DES_CBC_SHA1 = 18;

const int SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA1 = 19;

const int SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA1 = 20;

const int SSL_DHE_RSA_WITH_DES_CBC_SHA1 = 21;

const int SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA1 = 22;

const int SSL_DH_anon_EXPORT_WITH_RC4_40_MD51 = 23;

const int SSL_DH_anon_WITH_RC4_128_MD51 = 24;

const int SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA1 = 25;

const int SSL_DH_anon_WITH_DES_CBC_SHA1 = 26;

const int SSL_DH_anon_WITH_3DES_EDE_CBC_SHA1 = 27;

const int SSL_FORTEZZA_DMS_WITH_NULL_SHA1 = 28;

const int SSL_FORTEZZA_DMS_WITH_FORTEZZA_CBC_SHA1 = 29;

const int TLS_RSA_WITH_AES_128_CBC_SHA1 = 47;

const int TLS_DH_DSS_WITH_AES_128_CBC_SHA1 = 48;

const int TLS_DH_RSA_WITH_AES_128_CBC_SHA1 = 49;

const int TLS_DHE_DSS_WITH_AES_128_CBC_SHA1 = 50;

const int TLS_DHE_RSA_WITH_AES_128_CBC_SHA1 = 51;

const int TLS_DH_anon_WITH_AES_128_CBC_SHA1 = 52;

const int TLS_RSA_WITH_AES_256_CBC_SHA1 = 53;

const int TLS_DH_DSS_WITH_AES_256_CBC_SHA1 = 54;

const int TLS_DH_RSA_WITH_AES_256_CBC_SHA1 = 55;

const int TLS_DHE_DSS_WITH_AES_256_CBC_SHA1 = 56;

const int TLS_DHE_RSA_WITH_AES_256_CBC_SHA1 = 57;

const int TLS_DH_anon_WITH_AES_256_CBC_SHA1 = 58;

const int TLS_ECDH_ECDSA_WITH_NULL_SHA1 = -16383;

const int TLS_ECDH_ECDSA_WITH_RC4_128_SHA1 = -16382;

const int TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA1 = -16381;

const int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA1 = -16380;

const int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA1 = -16379;

const int TLS_ECDHE_ECDSA_WITH_NULL_SHA1 = -16378;

const int TLS_ECDHE_ECDSA_WITH_RC4_128_SHA1 = -16377;

const int TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA1 = -16376;

const int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA1 = -16375;

const int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA1 = -16374;

const int TLS_ECDH_RSA_WITH_NULL_SHA1 = -16373;

const int TLS_ECDH_RSA_WITH_RC4_128_SHA1 = -16372;

const int TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA1 = -16371;

const int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA1 = -16370;

const int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA1 = -16369;

const int TLS_ECDHE_RSA_WITH_NULL_SHA1 = -16368;

const int TLS_ECDHE_RSA_WITH_RC4_128_SHA1 = -16367;

const int TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA1 = -16366;

const int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA1 = -16365;

const int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA1 = -16364;

const int TLS_ECDH_anon_WITH_NULL_SHA1 = -16363;

const int TLS_ECDH_anon_WITH_RC4_128_SHA1 = -16362;

const int TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA1 = -16361;

const int TLS_ECDH_anon_WITH_AES_128_CBC_SHA1 = -16360;

const int TLS_ECDH_anon_WITH_AES_256_CBC_SHA1 = -16359;

const int TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA1 = -16331;

const int TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA1 = -16330;

const int TLS_PSK_WITH_CHACHA20_POLY1305_SHA2561 = -13141;

const int TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA2561 = -13140;

const int TLS_NULL_WITH_NULL_NULL1 = 0;

const int TLS_RSA_WITH_NULL_MD51 = 1;

const int TLS_RSA_WITH_NULL_SHA1 = 2;

const int TLS_RSA_WITH_RC4_128_MD51 = 4;

const int TLS_RSA_WITH_RC4_128_SHA1 = 5;

const int TLS_RSA_WITH_3DES_EDE_CBC_SHA1 = 10;

const int TLS_RSA_WITH_NULL_SHA2561 = 59;

const int TLS_RSA_WITH_AES_128_CBC_SHA2561 = 60;

const int TLS_RSA_WITH_AES_256_CBC_SHA2561 = 61;

const int TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA1 = 13;

const int TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA1 = 16;

const int TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA1 = 19;

const int TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA1 = 22;

const int TLS_DH_DSS_WITH_AES_128_CBC_SHA2561 = 62;

const int TLS_DH_RSA_WITH_AES_128_CBC_SHA2561 = 63;

const int TLS_DHE_DSS_WITH_AES_128_CBC_SHA2561 = 64;

const int TLS_DHE_RSA_WITH_AES_128_CBC_SHA2561 = 103;

const int TLS_DH_DSS_WITH_AES_256_CBC_SHA2561 = 104;

const int TLS_DH_RSA_WITH_AES_256_CBC_SHA2561 = 105;

const int TLS_DHE_DSS_WITH_AES_256_CBC_SHA2561 = 106;

const int TLS_DHE_RSA_WITH_AES_256_CBC_SHA2561 = 107;

const int TLS_DH_anon_WITH_RC4_128_MD51 = 24;

const int TLS_DH_anon_WITH_3DES_EDE_CBC_SHA1 = 27;

const int TLS_DH_anon_WITH_AES_128_CBC_SHA2561 = 108;

const int TLS_DH_anon_WITH_AES_256_CBC_SHA2561 = 109;

const int TLS_PSK_WITH_RC4_128_SHA1 = 138;

const int TLS_PSK_WITH_3DES_EDE_CBC_SHA1 = 139;

const int TLS_PSK_WITH_AES_128_CBC_SHA1 = 140;

const int TLS_PSK_WITH_AES_256_CBC_SHA1 = 141;

const int TLS_DHE_PSK_WITH_RC4_128_SHA1 = 142;

const int TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA1 = 143;

const int TLS_DHE_PSK_WITH_AES_128_CBC_SHA1 = 144;

const int TLS_DHE_PSK_WITH_AES_256_CBC_SHA1 = 145;

const int TLS_RSA_PSK_WITH_RC4_128_SHA1 = 146;

const int TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA1 = 147;

const int TLS_RSA_PSK_WITH_AES_128_CBC_SHA1 = 148;

const int TLS_RSA_PSK_WITH_AES_256_CBC_SHA1 = 149;

const int TLS_PSK_WITH_NULL_SHA1 = 44;

const int TLS_DHE_PSK_WITH_NULL_SHA1 = 45;

const int TLS_RSA_PSK_WITH_NULL_SHA1 = 46;

const int TLS_RSA_WITH_AES_128_GCM_SHA2561 = 156;

const int TLS_RSA_WITH_AES_256_GCM_SHA3841 = 157;

const int TLS_DHE_RSA_WITH_AES_128_GCM_SHA2561 = 158;

const int TLS_DHE_RSA_WITH_AES_256_GCM_SHA3841 = 159;

const int TLS_DH_RSA_WITH_AES_128_GCM_SHA2561 = 160;

const int TLS_DH_RSA_WITH_AES_256_GCM_SHA3841 = 161;

const int TLS_DHE_DSS_WITH_AES_128_GCM_SHA2561 = 162;

const int TLS_DHE_DSS_WITH_AES_256_GCM_SHA3841 = 163;

const int TLS_DH_DSS_WITH_AES_128_GCM_SHA2561 = 164;

const int TLS_DH_DSS_WITH_AES_256_GCM_SHA3841 = 165;

const int TLS_DH_anon_WITH_AES_128_GCM_SHA2561 = 166;

const int TLS_DH_anon_WITH_AES_256_GCM_SHA3841 = 167;

const int TLS_PSK_WITH_AES_128_GCM_SHA2561 = 168;

const int TLS_PSK_WITH_AES_256_GCM_SHA3841 = 169;

const int TLS_DHE_PSK_WITH_AES_128_GCM_SHA2561 = 170;

const int TLS_DHE_PSK_WITH_AES_256_GCM_SHA3841 = 171;

const int TLS_RSA_PSK_WITH_AES_128_GCM_SHA2561 = 172;

const int TLS_RSA_PSK_WITH_AES_256_GCM_SHA3841 = 173;

const int TLS_PSK_WITH_AES_128_CBC_SHA2561 = 174;

const int TLS_PSK_WITH_AES_256_CBC_SHA3841 = 175;

const int TLS_PSK_WITH_NULL_SHA2561 = 176;

const int TLS_PSK_WITH_NULL_SHA3841 = 177;

const int TLS_DHE_PSK_WITH_AES_128_CBC_SHA2561 = 178;

const int TLS_DHE_PSK_WITH_AES_256_CBC_SHA3841 = 179;

const int TLS_DHE_PSK_WITH_NULL_SHA2561 = 180;

const int TLS_DHE_PSK_WITH_NULL_SHA3841 = 181;

const int TLS_RSA_PSK_WITH_AES_128_CBC_SHA2561 = 182;

const int TLS_RSA_PSK_WITH_AES_256_CBC_SHA3841 = 183;

const int TLS_RSA_PSK_WITH_NULL_SHA2561 = 184;

const int TLS_RSA_PSK_WITH_NULL_SHA3841 = 185;

const int TLS_AES_128_GCM_SHA2561 = 4865;

const int TLS_AES_256_GCM_SHA3841 = 4866;

const int TLS_CHACHA20_POLY1305_SHA2561 = 4867;

const int TLS_AES_128_CCM_SHA2561 = 4868;

const int TLS_AES_128_CCM_8_SHA2561 = 4869;

const int TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA2561 = -16349;

const int TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA3841 = -16348;

const int TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA2561 = -16347;

const int TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA3841 = -16346;

const int TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA2561 = -16345;

const int TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA3841 = -16344;

const int TLS_ECDH_RSA_WITH_AES_128_CBC_SHA2561 = -16343;

const int TLS_ECDH_RSA_WITH_AES_256_CBC_SHA3841 = -16342;

const int TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA2561 = -16341;

const int TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA3841 = -16340;

const int TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA2561 = -16339;

const int TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA3841 = -16338;

const int TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA2561 = -16337;

const int TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA3841 = -16336;

const int TLS_ECDH_RSA_WITH_AES_128_GCM_SHA2561 = -16335;

const int TLS_ECDH_RSA_WITH_AES_256_GCM_SHA3841 = -16334;

const int TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA2561 = -13144;

const int TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA2561 = -13143;

const int TLS_EMPTY_RENEGOTIATION_INFO_SCSV1 = 255;

const int SSL_RSA_WITH_RC2_CBC_MD51 = -128;

const int SSL_RSA_WITH_IDEA_CBC_MD51 = -127;

const int SSL_RSA_WITH_DES_CBC_MD51 = -126;

const int SSL_RSA_WITH_3DES_EDE_CBC_MD51 = -125;

const int SSL_NO_SUCH_CIPHERSUITE1 = -1;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOS = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_12_6 = 120600;

const int __MAC_12_7 = 120700;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_13_5 = 130500;

const int __MAC_13_6 = 130600;

const int __MAC_14_0 = 140000;

const int __MAC_14_1 = 140100;

const int __MAC_14_2 = 140200;

const int __MAC_14_3 = 140300;

const int __MAC_14_4 = 140400;

const int __MAC_14_5 = 140500;

const int __MAC_15_0 = 150000;

const int __MAC_15_1 = 150100;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_4 = 140400;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_15_7 = 150700;

const int __IPHONE_15_8 = 150800;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_16_6 = 160600;

const int __IPHONE_16_7 = 160700;

const int __IPHONE_17_0 = 170000;

const int __IPHONE_17_1 = 170100;

const int __IPHONE_17_2 = 170200;

const int __IPHONE_17_3 = 170300;

const int __IPHONE_17_4 = 170400;

const int __IPHONE_17_5 = 170500;

const int __IPHONE_18_0 = 180000;

const int __IPHONE_18_1 = 180100;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_8_8 = 80800;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_9_6 = 90600;

const int __WATCHOS_10_0 = 100000;

const int __WATCHOS_10_1 = 100100;

const int __WATCHOS_10_2 = 100200;

const int __WATCHOS_10_3 = 100300;

const int __WATCHOS_10_4 = 100400;

const int __WATCHOS_10_5 = 100500;

const int __WATCHOS_11_0 = 110000;

const int __WATCHOS_11_1 = 110100;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_16_6 = 160600;

const int __TVOS_17_0 = 170000;

const int __TVOS_17_1 = 170100;

const int __TVOS_17_2 = 170200;

const int __TVOS_17_3 = 170300;

const int __TVOS_17_4 = 170400;

const int __TVOS_17_5 = 170500;

const int __TVOS_18_0 = 180000;

const int __TVOS_18_1 = 180100;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_7_6 = 70600;

const int __BRIDGEOS_8_0 = 80000;

const int __BRIDGEOS_8_1 = 80100;

const int __BRIDGEOS_8_2 = 80200;

const int __BRIDGEOS_8_3 = 80300;

const int __BRIDGEOS_8_4 = 80400;

const int __BRIDGEOS_8_5 = 80500;

const int __BRIDGEOS_9_0 = 90000;

const int __BRIDGEOS_9_1 = 90100;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_22_6 = 220600;

const int __DRIVERKIT_23_0 = 230000;

const int __DRIVERKIT_23_1 = 230100;

const int __DRIVERKIT_23_2 = 230200;

const int __DRIVERKIT_23_3 = 230300;

const int __DRIVERKIT_23_4 = 230400;

const int __DRIVERKIT_23_5 = 230500;

const int __DRIVERKIT_24_0 = 240000;

const int __DRIVERKIT_24_1 = 240100;

const int __VISIONOS_1_0 = 10000;

const int __VISIONOS_1_1 = 10100;

const int __VISIONOS_1_2 = 10200;

const int __VISIONOS_2_0 = 20000;

const int __VISIONOS_2_1 = 20100;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_12_6 = 120600;

const int MAC_OS_VERSION_12_7 = 120700;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_13_5 = 130500;

const int MAC_OS_VERSION_13_6 = 130600;

const int MAC_OS_VERSION_14_0 = 140000;

const int MAC_OS_VERSION_14_1 = 140100;

const int MAC_OS_VERSION_14_2 = 140200;

const int MAC_OS_VERSION_14_3 = 140300;

const int MAC_OS_VERSION_14_4 = 140400;

const int MAC_OS_VERSION_14_5 = 140500;

const int MAC_OS_VERSION_15_0 = 150000;

const int MAC_OS_VERSION_15_1 = 150100;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 150000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 150100;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __has_safe_buffers = 1;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int __DARWIN_NSIG = 32;

const int NSIG = 32;

const int _ARM_SIGNAL_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGIOT = 6;

const int SIGEMT = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGIO = 23;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGWINCH = 28;

const int SIGINFO = 29;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int USER_ADDR_NULL = 0;

const int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = 0;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int ILL_NOOP = 0;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_NOOP = 0;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_NOOP = 0;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_NOOP = 0;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_NOOP = 0;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERTRAMP = 256;

const int SA_64REGSET = 512;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int SV_ONSTACK = 1;

const int SV_INTERRUPT = 2;

const int SV_RESETHAND = 4;

const int SV_NODEFER = 16;

const int SV_NOCLDSTOP = 8;

const int SV_SIGINFO = 64;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WCOREFLAG = 128;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int WAIT_ANY = -1;

const int WAIT_MYPGRP = 0;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int BYTE_ORDER = 1234;

const int NULL = 0;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;

const int TARGET_OS_RTKIT = 0;

const int TARGET_RT_LITTLE_ENDIAN = 1;

const int TARGET_RT_BIG_ENDIAN = 0;

const int TARGET_RT_64_BIT = 1;

const int TARGET_RT_MAC_CFM = 0;

const int TARGET_RT_MAC_MACHO = 1;

const int TARGET_CPU_ARM64 = 1;

const int TARGET_CPU_PPC = 0;

const int TARGET_CPU_PPC64 = 0;

const int TARGET_CPU_68K = 0;

const int TARGET_CPU_X86 = 0;

const int TARGET_CPU_X86_64 = 0;

const int TARGET_CPU_ARM = 0;

const int TARGET_CPU_MIPS = 0;

const int TARGET_CPU_SPARC = 0;

const int TARGET_CPU_ALPHA = 0;

const int TARGET_ABI_USES_IOS_VALUES = 1;

const int __DARWIN_FD_SETSIZE = 1024;

const int __DARWIN_NBBY = 8;

const int __DARWIN_NFDBITS = 32;

const int NBBY = 8;

const int NFDBITS = 32;

const int FD_SETSIZE = 1024;

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;

const int __DARWIN_CLK_TCK = 100;

const int MB_LEN_MAX = 6;

const int CLK_TCK = 100;

const int CHAR_BIT = 8;

const int SCHAR_MAX = 127;

const int SCHAR_MIN = -128;

const int UCHAR_MAX = 255;

const int CHAR_MAX = 127;

const int CHAR_MIN = -128;

const int USHRT_MAX = 65535;

const int SHRT_MAX = 32767;

const int SHRT_MIN = -32768;

const int UINT_MAX = 4294967295;

const int INT_MAX = 2147483647;

const int INT_MIN = -2147483648;

const int ULONG_MAX = -1;

const int LONG_MAX = 9223372036854775807;

const int LONG_MIN = -9223372036854775808;

const int ULLONG_MAX = -1;

const int LLONG_MAX = 9223372036854775807;

const int LLONG_MIN = -9223372036854775808;

const int LONG_BIT = 64;

const int SSIZE_MAX = 9223372036854775807;

const int WORD_BIT = 32;

const int SIZE_T_MAX = -1;

const int UQUAD_MAX = -1;

const int QUAD_MAX = 9223372036854775807;

const int QUAD_MIN = -9223372036854775808;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int API_TO_BE_DEPRECATED = 100000;

const int API_TO_BE_DEPRECATED_MACOS = 100000;

const int API_TO_BE_DEPRECATED_IOS = 100000;

const int API_TO_BE_DEPRECATED_TVOS = 100000;

const int API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int API_TO_BE_DEPRECATED_VISIONOS = 100000;

const int TRUE = 1;

const int FALSE = 0;

const int OS_OBJECT_HAVE_OBJC_SUPPORT = 0;

const int OS_OBJECT_USE_OBJC = 0;

const int OS_OBJECT_SWIFT3 = 0;

const int OS_OBJECT_USE_OBJC_RETAIN_RELEASE = 0;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int SEEK_HOLE = 3;

const int SEEK_DATA = 4;

const int MACH_PORT_NULL = 0;

const int MACH_PORT_DEAD = 4294967295;

const int MACH_PORT_RIGHT_SEND = 0;

const int MACH_PORT_RIGHT_RECEIVE = 1;

const int MACH_PORT_RIGHT_SEND_ONCE = 2;

const int MACH_PORT_RIGHT_PORT_SET = 3;

const int MACH_PORT_RIGHT_DEAD_NAME = 4;

const int MACH_PORT_RIGHT_LABELH = 5;

const int MACH_PORT_RIGHT_NUMBER = 6;

const int MACH_PORT_TYPE_NONE = 0;

const int MACH_PORT_TYPE_SEND = 65536;

const int MACH_PORT_TYPE_RECEIVE = 131072;

const int MACH_PORT_TYPE_SEND_ONCE = 262144;

const int MACH_PORT_TYPE_PORT_SET = 524288;

const int MACH_PORT_TYPE_DEAD_NAME = 1048576;

const int MACH_PORT_TYPE_LABELH = 2097152;

const int MACH_PORT_TYPE_DNREQUEST = 2147483648;

const int MACH_PORT_TYPE_SPREQUEST = 1073741824;

const int MACH_PORT_TYPE_SPREQUEST_DELAYED = 536870912;

const int MACH_PORT_TYPE_SEND_RECEIVE = 196608;

const int MACH_PORT_TYPE_SEND_RIGHTS = 327680;

const int MACH_PORT_TYPE_PORT_RIGHTS = 458752;

const int MACH_PORT_TYPE_PORT_OR_DEAD = 1507328;

const int MACH_PORT_TYPE_ALL_RIGHTS = 2031616;

const int MACH_PORT_SRIGHTS_NONE = 0;

const int MACH_PORT_SRIGHTS_PRESENT = 1;

const int MACH_PORT_QLIMIT_ZERO = 0;

const int MACH_PORT_QLIMIT_BASIC = 5;

const int MACH_PORT_QLIMIT_SMALL = 16;

const int MACH_PORT_QLIMIT_LARGE = 1024;

const int MACH_PORT_QLIMIT_KERNEL = 65534;

const int MACH_PORT_QLIMIT_MIN = 0;

const int MACH_PORT_QLIMIT_DEFAULT = 5;

const int MACH_PORT_QLIMIT_MAX = 1024;

const int MACH_PORT_STATUS_FLAG_TEMPOWNER = 1;

const int MACH_PORT_STATUS_FLAG_GUARDED = 2;

const int MACH_PORT_STATUS_FLAG_STRICT_GUARD = 4;

const int MACH_PORT_STATUS_FLAG_IMP_DONATION = 8;

const int MACH_PORT_STATUS_FLAG_REVIVE = 16;

const int MACH_PORT_STATUS_FLAG_TASKPTR = 32;

const int MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE = 64;

const int MACH_PORT_STATUS_FLAG_NO_GRANT = 128;

const int MACH_PORT_LIMITS_INFO = 1;

const int MACH_PORT_RECEIVE_STATUS = 2;

const int MACH_PORT_DNREQUESTS_SIZE = 3;

const int MACH_PORT_TEMPOWNER = 4;

const int MACH_PORT_IMPORTANCE_RECEIVER = 5;

const int MACH_PORT_DENAP_RECEIVER = 6;

const int MACH_PORT_INFO_EXT = 7;

const int MACH_PORT_GUARD_INFO = 8;

const int MACH_PORT_SERVICE_THROTTLED = 9;

const int MACH_PORT_LIMITS_INFO_COUNT = 1;

const int MACH_PORT_RECEIVE_STATUS_COUNT = 10;

const int MACH_PORT_DNREQUESTS_SIZE_COUNT = 1;

const int MACH_PORT_INFO_EXT_COUNT = 17;

const int MACH_PORT_GUARD_INFO_COUNT = 2;

const int MACH_PORT_SERVICE_THROTTLED_COUNT = 1;

const int MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN = 255;

const int MACH_SERVICE_PORT_INFO_COUNT = 0;

const int MPO_CONTEXT_AS_GUARD = 1;

const int MPO_QLIMIT = 2;

const int MPO_TEMPOWNER = 4;

const int MPO_IMPORTANCE_RECEIVER = 8;

const int MPO_INSERT_SEND_RIGHT = 16;

const int MPO_STRICT = 32;

const int MPO_DENAP_RECEIVER = 64;

const int MPO_IMMOVABLE_RECEIVE = 128;

const int MPO_FILTER_MSG = 256;

const int MPO_TG_BLOCK_TRACKING = 512;

const int MPO_SERVICE_PORT = 1024;

const int MPO_CONNECTION_PORT = 2048;

const int MPO_REPLY_PORT = 4096;

const int MPO_ENFORCE_REPLY_PORT_SEMANTICS = 8192;

const int MPO_PROVISIONAL_REPLY_PORT = 16384;

const int MPO_EXCEPTION_PORT = 32768;

const int GUARD_TYPE_MACH_PORT = 1;

const int MAX_FATAL_kGUARD_EXC_CODE = 128;

const int MPG_FLAGS_NONE = 0;

const int MAX_OPTIONAL_kGUARD_EXC_CODE = 524288;

const int MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP = 72057594037927936;

const int MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT = 144115188075855872;

const int MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER = 288230376151711744;

const int MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR = 576460752303423488;

const int MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA = 1152921504606846976;

const int MPG_FLAGS_STRICT_REPLY_MASK = -72057594037927936;

const int MPG_FLAGS_MOD_REFS_PINNED_DEALLOC = 72057594037927936;

const int MPG_FLAGS_MOD_REFS_PINNED_DESTROY = 144115188075855872;

const int MPG_FLAGS_MOD_REFS_PINNED_COPYIN = 288230376151711744;

const int MPG_FLAGS_IMMOVABLE_PINNED = 72057594037927936;

const int MPG_STRICT = 1;

const int MPG_IMMOVABLE_RECEIVE = 2;

const int _POSIX_VERSION = 200112;

const int _POSIX2_VERSION = 200112;

const int _POSIX_VDISABLE = 255;

const int F_OK = 0;

const int X_OK = 1;

const int W_OK = 2;

const int R_OK = 4;

const int _READ_OK = 512;

const int _WRITE_OK = 1024;

const int _EXECUTE_OK = 2048;

const int _DELETE_OK = 4096;

const int _APPEND_OK = 8192;

const int _RMFILE_OK = 16384;

const int _RATTR_OK = 32768;

const int _WATTR_OK = 65536;

const int _REXT_OK = 131072;

const int _WEXT_OK = 262144;

const int _RPERM_OK = 524288;

const int _WPERM_OK = 1048576;

const int _CHOWN_OK = 2097152;

const int _ACCESS_EXTENDED_MASK = 4193792;

const int L_SET = 0;

const int L_INCR = 1;

const int L_XTND = 2;

const int ACCESSX_MAX_DESCRIPTORS = 100;

const int ACCESSX_MAX_TABLESIZE = 16384;

const int _PC_LINK_MAX = 1;

const int _PC_MAX_CANON = 2;

const int _PC_MAX_INPUT = 3;

const int _PC_NAME_MAX = 4;

const int _PC_PATH_MAX = 5;

const int _PC_PIPE_BUF = 6;

const int _PC_CHOWN_RESTRICTED = 7;

const int _PC_NO_TRUNC = 8;

const int _PC_VDISABLE = 9;

const int _PC_NAME_CHARS_MAX = 10;

const int _PC_CASE_SENSITIVE = 11;

const int _PC_CASE_PRESERVING = 12;

const int _PC_EXTENDED_SECURITY_NP = 13;

const int _PC_AUTH_OPAQUE_NP = 14;

const int _PC_2_SYMLINKS = 15;

const int _PC_ALLOC_SIZE_MIN = 16;

const int _PC_ASYNC_IO = 17;

const int _PC_FILESIZEBITS = 18;

const int _PC_PRIO_IO = 19;

const int _PC_REC_INCR_XFER_SIZE = 20;

const int _PC_REC_MAX_XFER_SIZE = 21;

const int _PC_REC_MIN_XFER_SIZE = 22;

const int _PC_REC_XFER_ALIGN = 23;

const int _PC_SYMLINK_MAX = 24;

const int _PC_SYNC_IO = 25;

const int _PC_XATTR_SIZE_BITS = 26;

const int _PC_MIN_HOLE_SIZE = 27;

const int _CS_PATH = 1;

const int STDIN_FILENO = 0;

const int STDOUT_FILENO = 1;

const int STDERR_FILENO = 2;

const int _XOPEN_VERSION = 600;

const int _XOPEN_XCU_VERSION = 4;

const int _POSIX_ADVISORY_INFO = -1;

const int _POSIX_ASYNCHRONOUS_IO = -1;

const int _POSIX_BARRIERS = -1;

const int _POSIX_CHOWN_RESTRICTED = 200112;

const int _POSIX_CLOCK_SELECTION = -1;

const int _POSIX_CPUTIME = -1;

const int _POSIX_FSYNC = 200112;

const int _POSIX_IPV6 = 200112;

const int _POSIX_JOB_CONTROL = 200112;

const int _POSIX_MAPPED_FILES = 200112;

const int _POSIX_MEMLOCK = -1;

const int _POSIX_MEMLOCK_RANGE = -1;

const int _POSIX_MEMORY_PROTECTION = 200112;

const int _POSIX_MESSAGE_PASSING = -1;

const int _POSIX_MONOTONIC_CLOCK = -1;

const int _POSIX_NO_TRUNC = 200112;

const int _POSIX_PRIORITIZED_IO = -1;

const int _POSIX_PRIORITY_SCHEDULING = -1;

const int _POSIX_RAW_SOCKETS = -1;

const int _POSIX_READER_WRITER_LOCKS = 200112;

const int _POSIX_REALTIME_SIGNALS = -1;

const int _POSIX_REGEXP = 200112;

const int _POSIX_SAVED_IDS = 200112;

const int _POSIX_SEMAPHORES = -1;

const int _POSIX_SHARED_MEMORY_OBJECTS = -1;

const int _POSIX_SHELL = 200112;

const int _POSIX_SPAWN = 200112;

const int _POSIX_SPIN_LOCKS = -1;

const int _POSIX_SPORADIC_SERVER = -1;

const int _POSIX_SYNCHRONIZED_IO = -1;

const int _POSIX_THREAD_ATTR_STACKADDR = 200112;

const int _POSIX_THREAD_ATTR_STACKSIZE = 200112;

const int _POSIX_THREAD_CPUTIME = -1;

const int _POSIX_THREAD_PRIO_INHERIT = -1;

const int _POSIX_THREAD_PRIO_PROTECT = -1;

const int _POSIX_THREAD_PRIORITY_SCHEDULING = -1;

const int _POSIX_THREAD_PROCESS_SHARED = 200112;

const int _POSIX_THREAD_SAFE_FUNCTIONS = 200112;

const int _POSIX_THREAD_SPORADIC_SERVER = -1;

const int _POSIX_THREADS = 200112;

const int _POSIX_TIMEOUTS = -1;

const int _POSIX_TIMERS = -1;

const int _POSIX_TRACE = -1;

const int _POSIX_TRACE_EVENT_FILTER = -1;

const int _POSIX_TRACE_INHERIT = -1;

const int _POSIX_TRACE_LOG = -1;

const int _POSIX_TYPED_MEMORY_OBJECTS = -1;

const int _POSIX2_C_BIND = 200112;

const int _POSIX2_C_DEV = 200112;

const int _POSIX2_CHAR_TERM = 200112;

const int _POSIX2_FORT_DEV = -1;

const int _POSIX2_FORT_RUN = 200112;

const int _POSIX2_LOCALEDEF = 200112;

const int _POSIX2_PBS = -1;

const int _POSIX2_PBS_ACCOUNTING = -1;

const int _POSIX2_PBS_CHECKPOINT = -1;

const int _POSIX2_PBS_LOCATE = -1;

const int _POSIX2_PBS_MESSAGE = -1;

const int _POSIX2_PBS_TRACK = -1;

const int _POSIX2_SW_DEV = 200112;

const int _POSIX2_UPE = 200112;

const int __ILP32_OFF32 = -1;

const int __ILP32_OFFBIG = -1;

const int __LP64_OFF64 = 1;

const int __LPBIG_OFFBIG = 1;

const int _POSIX_V6_ILP32_OFF32 = -1;

const int _POSIX_V6_ILP32_OFFBIG = -1;

const int _POSIX_V6_LP64_OFF64 = 1;

const int _POSIX_V6_LPBIG_OFFBIG = 1;

const int _POSIX_V7_ILP32_OFF32 = -1;

const int _POSIX_V7_ILP32_OFFBIG = -1;

const int _POSIX_V7_LP64_OFF64 = 1;

const int _POSIX_V7_LPBIG_OFFBIG = 1;

const int _V6_ILP32_OFF32 = -1;

const int _V6_ILP32_OFFBIG = -1;

const int _V6_LP64_OFF64 = 1;

const int _V6_LPBIG_OFFBIG = 1;

const int _XBS5_ILP32_OFF32 = -1;

const int _XBS5_ILP32_OFFBIG = -1;

const int _XBS5_LP64_OFF64 = 1;

const int _XBS5_LPBIG_OFFBIG = 1;

const int _XOPEN_CRYPT = 1;

const int _XOPEN_ENH_I18N = 1;

const int _XOPEN_LEGACY = -1;

const int _XOPEN_REALTIME = -1;

const int _XOPEN_REALTIME_THREADS = -1;

const int _XOPEN_SHM = 1;

const int _XOPEN_STREAMS = -1;

const int _XOPEN_UNIX = 1;

const int _SC_ARG_MAX = 1;

const int _SC_CHILD_MAX = 2;

const int _SC_CLK_TCK = 3;

const int _SC_NGROUPS_MAX = 4;

const int _SC_OPEN_MAX = 5;

const int _SC_JOB_CONTROL = 6;

const int _SC_SAVED_IDS = 7;

const int _SC_VERSION = 8;

const int _SC_BC_BASE_MAX = 9;

const int _SC_BC_DIM_MAX = 10;

const int _SC_BC_SCALE_MAX = 11;

const int _SC_BC_STRING_MAX = 12;

const int _SC_COLL_WEIGHTS_MAX = 13;

const int _SC_EXPR_NEST_MAX = 14;

const int _SC_LINE_MAX = 15;

const int _SC_RE_DUP_MAX = 16;

const int _SC_2_VERSION = 17;

const int _SC_2_C_BIND = 18;

const int _SC_2_C_DEV = 19;

const int _SC_2_CHAR_TERM = 20;

const int _SC_2_FORT_DEV = 21;

const int _SC_2_FORT_RUN = 22;

const int _SC_2_LOCALEDEF = 23;

const int _SC_2_SW_DEV = 24;

const int _SC_2_UPE = 25;

const int _SC_STREAM_MAX = 26;

const int _SC_TZNAME_MAX = 27;

const int _SC_ASYNCHRONOUS_IO = 28;

const int _SC_PAGESIZE = 29;

const int _SC_MEMLOCK = 30;

const int _SC_MEMLOCK_RANGE = 31;

const int _SC_MEMORY_PROTECTION = 32;

const int _SC_MESSAGE_PASSING = 33;

const int _SC_PRIORITIZED_IO = 34;

const int _SC_PRIORITY_SCHEDULING = 35;

const int _SC_REALTIME_SIGNALS = 36;

const int _SC_SEMAPHORES = 37;

const int _SC_FSYNC = 38;

const int _SC_SHARED_MEMORY_OBJECTS = 39;

const int _SC_SYNCHRONIZED_IO = 40;

const int _SC_TIMERS = 41;

const int _SC_AIO_LISTIO_MAX = 42;

const int _SC_AIO_MAX = 43;

const int _SC_AIO_PRIO_DELTA_MAX = 44;

const int _SC_DELAYTIMER_MAX = 45;

const int _SC_MQ_OPEN_MAX = 46;

const int _SC_MAPPED_FILES = 47;

const int _SC_RTSIG_MAX = 48;

const int _SC_SEM_NSEMS_MAX = 49;

const int _SC_SEM_VALUE_MAX = 50;

const int _SC_SIGQUEUE_MAX = 51;

const int _SC_TIMER_MAX = 52;

const int _SC_NPROCESSORS_CONF = 57;

const int _SC_NPROCESSORS_ONLN = 58;

const int _SC_2_PBS = 59;

const int _SC_2_PBS_ACCOUNTING = 60;

const int _SC_2_PBS_CHECKPOINT = 61;

const int _SC_2_PBS_LOCATE = 62;

const int _SC_2_PBS_MESSAGE = 63;

const int _SC_2_PBS_TRACK = 64;

const int _SC_ADVISORY_INFO = 65;

const int _SC_BARRIERS = 66;

const int _SC_CLOCK_SELECTION = 67;

const int _SC_CPUTIME = 68;

const int _SC_FILE_LOCKING = 69;

const int _SC_GETGR_R_SIZE_MAX = 70;

const int _SC_GETPW_R_SIZE_MAX = 71;

const int _SC_HOST_NAME_MAX = 72;

const int _SC_LOGIN_NAME_MAX = 73;

const int _SC_MONOTONIC_CLOCK = 74;

const int _SC_MQ_PRIO_MAX = 75;

const int _SC_READER_WRITER_LOCKS = 76;

const int _SC_REGEXP = 77;

const int _SC_SHELL = 78;

const int _SC_SPAWN = 79;

const int _SC_SPIN_LOCKS = 80;

const int _SC_SPORADIC_SERVER = 81;

const int _SC_THREAD_ATTR_STACKADDR = 82;

const int _SC_THREAD_ATTR_STACKSIZE = 83;

const int _SC_THREAD_CPUTIME = 84;

const int _SC_THREAD_DESTRUCTOR_ITERATIONS = 85;

const int _SC_THREAD_KEYS_MAX = 86;

const int _SC_THREAD_PRIO_INHERIT = 87;

const int _SC_THREAD_PRIO_PROTECT = 88;

const int _SC_THREAD_PRIORITY_SCHEDULING = 89;

const int _SC_THREAD_PROCESS_SHARED = 90;

const int _SC_THREAD_SAFE_FUNCTIONS = 91;

const int _SC_THREAD_SPORADIC_SERVER = 92;

const int _SC_THREAD_STACK_MIN = 93;

const int _SC_THREAD_THREADS_MAX = 94;

const int _SC_TIMEOUTS = 95;

const int _SC_THREADS = 96;

const int _SC_TRACE = 97;

const int _SC_TRACE_EVENT_FILTER = 98;

const int _SC_TRACE_INHERIT = 99;

const int _SC_TRACE_LOG = 100;

const int _SC_TTY_NAME_MAX = 101;

const int _SC_TYPED_MEMORY_OBJECTS = 102;

const int _SC_V6_ILP32_OFF32 = 103;

const int _SC_V6_ILP32_OFFBIG = 104;

const int _SC_V6_LP64_OFF64 = 105;

const int _SC_V6_LPBIG_OFFBIG = 106;

const int _SC_IPV6 = 118;

const int _SC_RAW_SOCKETS = 119;

const int _SC_SYMLOOP_MAX = 120;

const int _SC_ATEXIT_MAX = 107;

const int _SC_IOV_MAX = 56;

const int _SC_PAGE_SIZE = 29;

const int _SC_XOPEN_CRYPT = 108;

const int _SC_XOPEN_ENH_I18N = 109;

const int _SC_XOPEN_LEGACY = 110;

const int _SC_XOPEN_REALTIME = 111;

const int _SC_XOPEN_REALTIME_THREADS = 112;

const int _SC_XOPEN_SHM = 113;

const int _SC_XOPEN_STREAMS = 114;

const int _SC_XOPEN_UNIX = 115;

const int _SC_XOPEN_VERSION = 116;

const int _SC_XOPEN_XCU_VERSION = 121;

const int _SC_XBS5_ILP32_OFF32 = 122;

const int _SC_XBS5_ILP32_OFFBIG = 123;

const int _SC_XBS5_LP64_OFF64 = 124;

const int _SC_XBS5_LPBIG_OFFBIG = 125;

const int _SC_SS_REPL_MAX = 126;

const int _SC_TRACE_EVENT_NAME_MAX = 127;

const int _SC_TRACE_NAME_MAX = 128;

const int _SC_TRACE_SYS_MAX = 129;

const int _SC_TRACE_USER_EVENT_MAX = 130;

const int _SC_PASS_MAX = 131;

const int _SC_PHYS_PAGES = 200;

const int _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 2;

const int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 3;

const int _CS_POSIX_V6_ILP32_OFF32_LIBS = 4;

const int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 5;

const int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 6;

const int _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 7;

const int _CS_POSIX_V6_LP64_OFF64_CFLAGS = 8;

const int _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 9;

const int _CS_POSIX_V6_LP64_OFF64_LIBS = 10;

const int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 11;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 12;

const int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 13;

const int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = 14;

const int _CS_XBS5_ILP32_OFF32_CFLAGS = 20;

const int _CS_XBS5_ILP32_OFF32_LDFLAGS = 21;

const int _CS_XBS5_ILP32_OFF32_LIBS = 22;

const int _CS_XBS5_ILP32_OFF32_LINTFLAGS = 23;

const int _CS_XBS5_ILP32_OFFBIG_CFLAGS = 24;

const int _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 25;

const int _CS_XBS5_ILP32_OFFBIG_LIBS = 26;

const int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 27;

const int _CS_XBS5_LP64_OFF64_CFLAGS = 28;

const int _CS_XBS5_LP64_OFF64_LDFLAGS = 29;

const int _CS_XBS5_LP64_OFF64_LIBS = 30;

const int _CS_XBS5_LP64_OFF64_LINTFLAGS = 31;

const int _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 32;

const int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 33;

const int _CS_XBS5_LPBIG_OFFBIG_LIBS = 34;

const int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 35;

const int _CS_DARWIN_USER_DIR = 65536;

const int _CS_DARWIN_USER_TEMP_DIR = 65537;

const int _CS_DARWIN_USER_CACHE_DIR = 65538;

const int F_ULOCK = 0;

const int F_LOCK = 1;

const int F_TLOCK = 2;

const int F_TEST = 3;

const int SYNC_VOLUME_FULLSYNC = 1;

const int SYNC_VOLUME_WAIT = 2;

const int O_RDONLY = 0;

const int O_WRONLY = 1;

const int O_RDWR = 2;

const int O_ACCMODE = 3;

const int FREAD = 1;

const int FWRITE = 2;

const int O_NONBLOCK = 4;

const int O_APPEND = 8;

const int O_SYNC = 128;

const int O_SHLOCK = 16;

const int O_EXLOCK = 32;

const int O_ASYNC = 64;

const int O_FSYNC = 128;

const int O_NOFOLLOW = 256;

const int O_CREAT = 512;

const int O_TRUNC = 1024;

const int O_EXCL = 2048;

const int O_EVTONLY = 32768;

const int O_NOCTTY = 131072;

const int O_DIRECTORY = 1048576;

const int O_SYMLINK = 2097152;

const int O_DSYNC = 4194304;

const int O_CLOEXEC = 16777216;

const int O_NOFOLLOW_ANY = 536870912;

const int O_EXEC = 1073741824;

const int O_SEARCH = 1074790400;

const int AT_FDCWD = -2;

const int AT_EACCESS = 16;

const int AT_SYMLINK_NOFOLLOW = 32;

const int AT_SYMLINK_FOLLOW = 64;

const int AT_REMOVEDIR = 128;

const int AT_REALDEV = 512;

const int AT_FDONLY = 1024;

const int AT_SYMLINK_NOFOLLOW_ANY = 2048;

const int O_DP_GETRAWENCRYPTED = 1;

const int O_DP_GETRAWUNENCRYPTED = 2;

const int O_DP_AUTHENTICATE = 4;

const int AUTH_OPEN_NOAUTHFD = -1;

const int FAPPEND = 8;

const int FASYNC = 64;

const int FFSYNC = 128;

const int FFDSYNC = 4194304;

const int FNONBLOCK = 4;

const int FNDELAY = 4;

const int O_NDELAY = 4;

const int CPF_OVERWRITE = 1;

const int CPF_IGNORE_MODE = 2;

const int CPF_MASK = 3;

const int F_DUPFD = 0;

const int F_GETFD = 1;

const int F_SETFD = 2;

const int F_GETFL = 3;

const int F_SETFL = 4;

const int F_GETOWN = 5;

const int F_SETOWN = 6;

const int F_GETLK = 7;

const int F_SETLK = 8;

const int F_SETLKW = 9;

const int F_SETLKWTIMEOUT = 10;

const int F_FLUSH_DATA = 40;

const int F_CHKCLEAN = 41;

const int F_PREALLOCATE = 42;

const int F_SETSIZE = 43;

const int F_RDADVISE = 44;

const int F_RDAHEAD = 45;

const int F_NOCACHE = 48;

const int F_LOG2PHYS = 49;

const int F_GETPATH = 50;

const int F_FULLFSYNC = 51;

const int F_PATHPKG_CHECK = 52;

const int F_FREEZE_FS = 53;

const int F_THAW_FS = 54;

const int F_GLOBAL_NOCACHE = 55;

const int F_ADDSIGS = 59;

const int F_ADDFILESIGS = 61;

const int F_NODIRECT = 62;

const int F_GETPROTECTIONCLASS = 63;

const int F_SETPROTECTIONCLASS = 64;

const int F_LOG2PHYS_EXT = 65;

const int F_GETLKPID = 66;

const int F_SETBACKINGSTORE = 70;

const int F_GETPATH_MTMINFO = 71;

const int F_GETCODEDIR = 72;

const int F_SETNOSIGPIPE = 73;

const int F_GETNOSIGPIPE = 74;

const int F_TRANSCODEKEY = 75;

const int F_SINGLE_WRITER = 76;

const int F_GETPROTECTIONLEVEL = 77;

const int F_FINDSIGS = 78;

const int F_ADDFILESIGS_FOR_DYLD_SIM = 83;

const int F_BARRIERFSYNC = 85;

const int F_OFD_SETLK = 90;

const int F_OFD_SETLKW = 91;

const int F_OFD_GETLK = 92;

const int F_OFD_SETLKWTIMEOUT = 93;

const int F_ADDFILESIGS_RETURN = 97;

const int F_CHECK_LV = 98;

const int F_PUNCHHOLE = 99;

const int F_TRIM_ACTIVE_FILE = 100;

const int F_SPECULATIVE_READ = 101;

const int F_GETPATH_NOFIRMLINK = 102;

const int F_ADDFILESIGS_INFO = 103;

const int F_ADDFILESUPPL = 104;

const int F_GETSIGSINFO = 105;

const int F_SETLEASE = 106;

const int F_GETLEASE = 107;

const int F_TRANSFEREXTENTS = 110;

const int F_ATTRIBUTION_TAG = 111;

const int F_ADDSIGS_MAIN_BINARY = 113;

const int FCNTL_FS_SPECIFIC_BASE = 65536;

const int F_DUPFD_CLOEXEC = 67;

const int FD_CLOEXEC = 1;

const int F_RDLCK = 1;

const int F_UNLCK = 2;

const int F_WRLCK = 3;

const int S_IFMT = 61440;

const int S_IFIFO = 4096;

const int S_IFCHR = 8192;

const int S_IFDIR = 16384;

const int S_IFBLK = 24576;

const int S_IFREG = 32768;

const int S_IFLNK = 40960;

const int S_IFSOCK = 49152;

const int S_IFWHT = 57344;

const int S_IRWXU = 448;

const int S_IRUSR = 256;

const int S_IWUSR = 128;

const int S_IXUSR = 64;

const int S_IRWXG = 56;

const int S_IRGRP = 32;

const int S_IWGRP = 16;

const int S_IXGRP = 8;

const int S_IRWXO = 7;

const int S_IROTH = 4;

const int S_IWOTH = 2;

const int S_IXOTH = 1;

const int S_ISUID = 2048;

const int S_ISGID = 1024;

const int S_ISVTX = 512;

const int S_ISTXT = 512;

const int S_IREAD = 256;

const int S_IWRITE = 128;

const int S_IEXEC = 64;

const int F_ALLOCATECONTIG = 2;

const int F_ALLOCATEALL = 4;

const int F_ALLOCATEPERSIST = 8;

const int F_PEOFPOSMODE = 3;

const int F_VOLPOSMODE = 4;

const int USER_FSIGNATURES_CDHASH_LEN = 20;

const int GETSIGSINFO_PLATFORM_BINARY = 1;

const int LOCK_SH = 1;

const int LOCK_EX = 2;

const int LOCK_NB = 4;

const int LOCK_UN = 8;

const int ATTRIBUTION_NAME_MAX = 255;

const int F_CREATE_TAG = 1;

const int F_DELETE_TAG = 2;

const int F_QUERY_TAG = 4;

const int O_POPUP = 2147483648;

const int O_ALERT = 536870912;

const int FILESEC_GUID = 3;

const int DISPATCH_API_VERSION = 20181008;

const int __OS_WORKGROUP_ATTR_SIZE__ = 60;

const int __OS_WORKGROUP_INTERVAL_DATA_SIZE__ = 56;

const int __OS_WORKGROUP_JOIN_TOKEN_SIZE__ = 36;

const int _OS_WORKGROUP_ATTR_SIG_DEFAULT_INIT = 799564724;

const int _OS_WORKGROUP_ATTR_SIG_EMPTY_INIT = 799564740;

const int _OS_WORKGROUP_INTERVAL_DATA_SIG_INIT = 1386695757;

const int DISPATCH_SWIFT3_OVERLAY = 0;

const int TIME_MICROS_MAX = 1000000;

const int SYSTEM_CLOCK = 0;

const int CALENDAR_CLOCK = 1;

const int REALTIME_CLOCK = 0;

const int CLOCK_GET_TIME_RES = 1;

const int CLOCK_ALARM_CURRES = 3;

const int CLOCK_ALARM_MINRES = 4;

const int CLOCK_ALARM_MAXRES = 5;

const int NSEC_PER_USEC = 1000;

const int USEC_PER_SEC = 1000000;

const int NSEC_PER_SEC = 1000000000;

const int NSEC_PER_MSEC = 1000000;

const int ALRMTYPE = 255;

const int TIME_ABSOLUTE = 0;

const int TIME_RELATIVE = 1;

const int MSEC_PER_SEC = 1000;

const int DISPATCH_TIME_NOW = 0;

const int DISPATCH_TIME_FOREVER = -1;

const int QOS_MIN_RELATIVE_PRIORITY = -15;

const int DISPATCH_APPLY_AUTO_AVAILABLE = 1;

const int DISPATCH_QUEUE_PRIORITY_HIGH = 2;

const int DISPATCH_QUEUE_PRIORITY_DEFAULT = 0;

const int DISPATCH_QUEUE_PRIORITY_LOW = -2;

const int DISPATCH_QUEUE_PRIORITY_BACKGROUND = -32768;

const int DISPATCH_QUEUE_SERIAL = 0;

const int DISPATCH_TARGET_QUEUE_DEFAULT = 0;

const int DISPATCH_CURRENT_QUEUE_LABEL = 0;

const int KERN_SUCCESS = 0;

const int KERN_INVALID_ADDRESS = 1;

const int KERN_PROTECTION_FAILURE = 2;

const int KERN_NO_SPACE = 3;

const int KERN_INVALID_ARGUMENT = 4;

const int KERN_FAILURE = 5;

const int KERN_RESOURCE_SHORTAGE = 6;

const int KERN_NOT_RECEIVER = 7;

const int KERN_NO_ACCESS = 8;

const int KERN_MEMORY_FAILURE = 9;

const int KERN_MEMORY_ERROR = 10;

const int KERN_ALREADY_IN_SET = 11;

const int KERN_NOT_IN_SET = 12;

const int KERN_NAME_EXISTS = 13;

const int KERN_ABORTED = 14;

const int KERN_INVALID_NAME = 15;

const int KERN_INVALID_TASK = 16;

const int KERN_INVALID_RIGHT = 17;

const int KERN_INVALID_VALUE = 18;

const int KERN_UREFS_OVERFLOW = 19;

const int KERN_INVALID_CAPABILITY = 20;

const int KERN_RIGHT_EXISTS = 21;

const int KERN_INVALID_HOST = 22;

const int KERN_MEMORY_PRESENT = 23;

const int KERN_MEMORY_DATA_MOVED = 24;

const int KERN_MEMORY_RESTART_COPY = 25;

const int KERN_INVALID_PROCESSOR_SET = 26;

const int KERN_POLICY_LIMIT = 27;

const int KERN_INVALID_POLICY = 28;

const int KERN_INVALID_OBJECT = 29;

const int KERN_ALREADY_WAITING = 30;

const int KERN_DEFAULT_SET = 31;

const int KERN_EXCEPTION_PROTECTED = 32;

const int KERN_INVALID_LEDGER = 33;

const int KERN_INVALID_MEMORY_CONTROL = 34;

const int KERN_INVALID_SECURITY = 35;

const int KERN_NOT_DEPRESSED = 36;

const int KERN_TERMINATED = 37;

const int KERN_LOCK_SET_DESTROYED = 38;

const int KERN_LOCK_UNSTABLE = 39;

const int KERN_LOCK_OWNED = 40;

const int KERN_LOCK_OWNED_SELF = 41;

const int KERN_SEMAPHORE_DESTROYED = 42;

const int KERN_RPC_SERVER_TERMINATED = 43;

const int KERN_RPC_TERMINATE_ORPHAN = 44;

const int KERN_RPC_CONTINUE_ORPHAN = 45;

const int KERN_NOT_SUPPORTED = 46;

const int KERN_NODE_DOWN = 47;

const int KERN_NOT_WAITING = 48;

const int KERN_OPERATION_TIMED_OUT = 49;

const int KERN_CODESIGN_ERROR = 50;

const int KERN_POLICY_STATIC = 51;

const int KERN_INSUFFICIENT_BUFFER_SIZE = 52;

const int KERN_DENIED = 53;

const int KERN_MISSING_KC = 54;

const int KERN_INVALID_KC = 55;

const int KERN_NOT_FOUND = 56;

const int KERN_RETURN_MAX = 256;

const int MACH_MSG_TIMEOUT_NONE = 0;

const int MACH_MSGH_BITS_ZERO = 0;

const int MACH_MSGH_BITS_REMOTE_MASK = 31;

const int MACH_MSGH_BITS_LOCAL_MASK = 7936;

const int MACH_MSGH_BITS_VOUCHER_MASK = 2031616;

const int MACH_MSGH_BITS_PORTS_MASK = 2039583;

const int MACH_MSGH_BITS_COMPLEX = 2147483648;

const int MACH_MSGH_BITS_USER = 2149523231;

const int MACH_MSGH_BITS_RAISEIMP = 536870912;

const int MACH_MSGH_BITS_DENAP = 536870912;

const int MACH_MSGH_BITS_IMPHOLDASRT = 268435456;

const int MACH_MSGH_BITS_DENAPHOLDASRT = 268435456;

const int MACH_MSGH_BITS_CIRCULAR = 268435456;

const int MACH_MSGH_BITS_USED = 2954829599;

const int MACH_MSG_PRIORITY_UNSPECIFIED = 0;

const int MACH_MSG_TYPE_MOVE_RECEIVE = 16;

const int MACH_MSG_TYPE_MOVE_SEND = 17;

const int MACH_MSG_TYPE_MOVE_SEND_ONCE = 18;

const int MACH_MSG_TYPE_COPY_SEND = 19;

const int MACH_MSG_TYPE_MAKE_SEND = 20;

const int MACH_MSG_TYPE_MAKE_SEND_ONCE = 21;

const int MACH_MSG_TYPE_COPY_RECEIVE = 22;

const int MACH_MSG_TYPE_DISPOSE_RECEIVE = 24;

const int MACH_MSG_TYPE_DISPOSE_SEND = 25;

const int MACH_MSG_TYPE_DISPOSE_SEND_ONCE = 26;

const int MACH_MSG_PHYSICAL_COPY = 0;

const int MACH_MSG_VIRTUAL_COPY = 1;

const int MACH_MSG_ALLOCATE = 2;

const int MACH_MSG_OVERWRITE = 3;

const int MACH_MSG_GUARD_FLAGS_NONE = 0;

const int MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE = 1;

const int MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND = 2;

const int MACH_MSG_GUARD_FLAGS_MASK = 3;

const int MACH_MSG_PORT_DESCRIPTOR = 0;

const int MACH_MSG_OOL_DESCRIPTOR = 1;

const int MACH_MSG_OOL_PORTS_DESCRIPTOR = 2;

const int MACH_MSG_OOL_VOLATILE_DESCRIPTOR = 3;

const int MACH_MSG_GUARDED_PORT_DESCRIPTOR = 4;

const int MACH_MSG_DESCRIPTOR_MAX = 4;

const int MACH_MSG_TRAILER_FORMAT_0 = 0;

const int MACH_MSG_FILTER_POLICY_ALLOW = 0;

const int MACH_MSG_TRAILER_MINIMUM_SIZE = 8;

const int MAX_TRAILER_SIZE = 68;

const int MACH_MSG_TRAILER_FORMAT_0_SIZE = 20;

const int MACH_MSG_SIZE_MAX = 4294967295;

const int MACH_MSG_SIZE_RELIABLE = 262144;

const int MACH_MSGH_KIND_NORMAL = 0;

const int MACH_MSGH_KIND_NOTIFICATION = 1;

const int MACH_MSG_TYPE_PORT_NONE = 0;

const int MACH_MSG_TYPE_PORT_NAME = 15;

const int MACH_MSG_TYPE_PORT_RECEIVE = 16;

const int MACH_MSG_TYPE_PORT_SEND = 17;

const int MACH_MSG_TYPE_PORT_SEND_ONCE = 18;

const int MACH_MSG_TYPE_LAST = 22;

const int MACH_MSG_TYPE_POLYMORPHIC = 4294967295;

const int MACH_MSG_OPTION_NONE = 0;

const int MACH_SEND_MSG = 1;

const int MACH_RCV_MSG = 2;

const int MACH_RCV_LARGE = 4;

const int MACH_RCV_LARGE_IDENTITY = 8;

const int MACH_SEND_TIMEOUT = 16;

const int MACH_SEND_OVERRIDE = 32;

const int MACH_SEND_INTERRUPT = 64;

const int MACH_SEND_NOTIFY = 128;

const int MACH_SEND_ALWAYS = 65536;

const int MACH_SEND_FILTER_NONFATAL = 65536;

const int MACH_SEND_TRAILER = 131072;

const int MACH_SEND_NOIMPORTANCE = 262144;

const int MACH_SEND_NODENAP = 262144;

const int MACH_SEND_IMPORTANCE = 524288;

const int MACH_SEND_SYNC_OVERRIDE = 1048576;

const int MACH_SEND_PROPAGATE_QOS = 2097152;

const int MACH_SEND_SYNC_USE_THRPRI = 2097152;

const int MACH_SEND_KERNEL = 4194304;

const int MACH_SEND_SYNC_BOOTSTRAP_CHECKIN = 8388608;

const int MACH_RCV_TIMEOUT = 256;

const int MACH_RCV_NOTIFY = 0;

const int MACH_RCV_INTERRUPT = 1024;

const int MACH_RCV_VOUCHER = 2048;

const int MACH_RCV_OVERWRITE = 0;

const int MACH_RCV_GUARDED_DESC = 4096;

const int MACH_RCV_SYNC_WAIT = 16384;

const int MACH_RCV_SYNC_PEEK = 32768;

const int MACH_MSG_STRICT_REPLY = 512;

const int MACH_RCV_TRAILER_NULL = 0;

const int MACH_RCV_TRAILER_SEQNO = 1;

const int MACH_RCV_TRAILER_SENDER = 2;

const int MACH_RCV_TRAILER_AUDIT = 3;

const int MACH_RCV_TRAILER_CTX = 4;

const int MACH_RCV_TRAILER_AV = 7;

const int MACH_RCV_TRAILER_LABELS = 8;

const int MACH_RCV_TRAILER_MASK = 251658240;

const int MACH_MSG_SUCCESS = 0;

const int MACH_MSG_MASK = 15872;

const int MACH_MSG_IPC_SPACE = 8192;

const int MACH_MSG_VM_SPACE = 4096;

const int MACH_MSG_IPC_KERNEL = 2048;

const int MACH_MSG_VM_KERNEL = 1024;

const int MACH_SEND_IN_PROGRESS = 268435457;

const int MACH_SEND_INVALID_DATA = 268435458;

const int MACH_SEND_INVALID_DEST = 268435459;

const int MACH_SEND_TIMED_OUT = 268435460;

const int MACH_SEND_INVALID_VOUCHER = 268435461;

const int MACH_SEND_INTERRUPTED = 268435463;

const int MACH_SEND_MSG_TOO_SMALL = 268435464;

const int MACH_SEND_INVALID_REPLY = 268435465;

const int MACH_SEND_INVALID_RIGHT = 268435466;

const int MACH_SEND_INVALID_NOTIFY = 268435467;

const int MACH_SEND_INVALID_MEMORY = 268435468;

const int MACH_SEND_NO_BUFFER = 268435469;

const int MACH_SEND_TOO_LARGE = 268435470;

const int MACH_SEND_INVALID_TYPE = 268435471;

const int MACH_SEND_INVALID_HEADER = 268435472;

const int MACH_SEND_INVALID_TRAILER = 268435473;

const int MACH_SEND_INVALID_CONTEXT = 268435474;

const int MACH_SEND_INVALID_OPTIONS = 268435475;

const int MACH_SEND_INVALID_RT_OOL_SIZE = 268435477;

const int MACH_SEND_NO_GRANT_DEST = 268435478;

const int MACH_SEND_MSG_FILTERED = 268435479;

const int MACH_SEND_AUX_TOO_SMALL = 268435480;

const int MACH_SEND_AUX_TOO_LARGE = 268435481;

const int MACH_RCV_IN_PROGRESS = 268451841;

const int MACH_RCV_INVALID_NAME = 268451842;

const int MACH_RCV_TIMED_OUT = 268451843;

const int MACH_RCV_TOO_LARGE = 268451844;

const int MACH_RCV_INTERRUPTED = 268451845;

const int MACH_RCV_PORT_CHANGED = 268451846;

const int MACH_RCV_INVALID_NOTIFY = 268451847;

const int MACH_RCV_INVALID_DATA = 268451848;

const int MACH_RCV_PORT_DIED = 268451849;

const int MACH_RCV_IN_SET = 268451850;

const int MACH_RCV_HEADER_ERROR = 268451851;

const int MACH_RCV_BODY_ERROR = 268451852;

const int MACH_RCV_INVALID_TYPE = 268451853;

const int MACH_RCV_SCATTER_SMALL = 268451854;

const int MACH_RCV_INVALID_TRAILER = 268451855;

const int MACH_RCV_IN_PROGRESS_TIMED = 268451857;

const int MACH_RCV_INVALID_REPLY = 268451858;

const int MACH_RCV_INVALID_ARGUMENTS = 268451859;

const int DISPATCH_MACH_SEND_DEAD = 1;

const int DISPATCH_MEMORYPRESSURE_NORMAL = 1;

const int DISPATCH_MEMORYPRESSURE_WARN = 2;

const int DISPATCH_MEMORYPRESSURE_CRITICAL = 4;

const int DISPATCH_PROC_EXIT = 2147483648;

const int DISPATCH_PROC_FORK = 1073741824;

const int DISPATCH_PROC_EXEC = 536870912;

const int DISPATCH_PROC_SIGNAL = 134217728;

const int DISPATCH_VNODE_DELETE = 1;

const int DISPATCH_VNODE_WRITE = 2;

const int DISPATCH_VNODE_EXTEND = 4;

const int DISPATCH_VNODE_ATTRIB = 8;

const int DISPATCH_VNODE_LINK = 16;

const int DISPATCH_VNODE_RENAME = 32;

const int DISPATCH_VNODE_REVOKE = 64;

const int DISPATCH_VNODE_FUNLOCK = 256;

const int DISPATCH_TIMER_STRICT = 1;

const int DISPATCH_ONCE_INLINE_FASTPATH = 1;

const int DISPATCH_DATA_DESTRUCTOR_DEFAULT = 0;

const int DISPATCH_IO_STREAM = 0;

const int DISPATCH_IO_RANDOM = 1;

const int DISPATCH_IO_STOP = 1;

const int DISPATCH_IO_STRICT_INTERVAL = 1;

const int NSURLResponseUnknownLength = -1;
